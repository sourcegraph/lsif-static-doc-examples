{
  "pathID": "/cmd/gitserver/server",
  "documentation": {
    "identifier": "server",
    "newPage": true,
    "searchKey": "cmd/gitserver/server",
    "tags": [
      "package"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package server"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package server implements the gitserver service. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/cmd/gitserver/server#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/cmd/gitserver/server#gitConfigMaybeCorrupt",
              "documentation": {
                "identifier": "gitConfigMaybeCorrupt",
                "newPage": false,
                "searchKey": "server.gitConfigMaybeCorrupt",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const gitConfigMaybeCorrupt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gitConfigMaybeCorrupt = \"sourcegraph.maybeCorruptRepo\"\n```\n\ngitConfigMaybeCorrupt is a key we add to git config to signal that a repo may be corrupt on disk. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#headFileRefPrefix",
              "documentation": {
                "identifier": "headFileRefPrefix",
                "newPage": false,
                "searchKey": "server.headFileRefPrefix",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const headFileRefPrefix"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst headFileRefPrefix = \"ref: \"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#repoTTL",
              "documentation": {
                "identifier": "repoTTL",
                "newPage": false,
                "searchKey": "server.repoTTL",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const repoTTL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst repoTTL = time.Hour * 24 * 45\n```\n\nrepoTTL is how often we should re-clone a repository. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#repoTTLGC",
              "documentation": {
                "identifier": "repoTTLGC",
                "newPage": false,
                "searchKey": "server.repoTTLGC",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const repoTTLGC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst repoTTLGC = time.Hour * 24 * 2\n```\n\nrepoTTLGC is how often we should re-clone a repository once it is reporting git gc issues. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#reposStatsName",
              "documentation": {
                "identifier": "reposStatsName",
                "newPage": false,
                "searchKey": "server.reposStatsName",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const reposStatsName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst reposStatsName = \"repos-stats.json\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#tempDirName",
              "documentation": {
                "identifier": "tempDirName",
                "newPage": false,
                "searchKey": "server.tempDirName",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const tempDirName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tempDirName = \".tmp\"\n```\n\ntempDirName is the name used for the temporary directory under ReposDir. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#testRepoA",
              "documentation": {
                "identifier": "testRepoA",
                "newPage": false,
                "searchKey": "server.testRepoA",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const testRepoA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst testRepoA = \"testrepo-A\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#testRepoC",
              "documentation": {
                "identifier": "testRepoC",
                "newPage": false,
                "searchKey": "server.testRepoC",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const testRepoC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst testRepoC = \"testrepo-C\"\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/cmd/gitserver/server#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/cmd/gitserver/server#badRefs",
              "documentation": {
                "identifier": "badRefs",
                "newPage": false,
                "searchKey": "server.badRefs",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var badRefs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badRefs []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#badRefsOnce",
              "documentation": {
                "identifier": "badRefsOnce",
                "newPage": false,
                "searchKey": "server.badRefsOnce",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var badRefsOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badRefsOnce sync.Once\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#callSignPattern",
              "documentation": {
                "identifier": "callSignPattern",
                "newPage": false,
                "searchKey": "server.callSignPattern",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var callSignPattern"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar callSignPattern = lazyregexp.New(\"^[A-Z]+$\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#cloneQueue",
              "documentation": {
                "identifier": "cloneQueue",
                "newPage": false,
                "searchKey": "server.cloneQueue",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var cloneQueue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cloneQueue = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#customGitFetch",
              "documentation": {
                "identifier": "customGitFetch",
                "newPage": false,
                "searchKey": "server.customGitFetch",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var customGitFetch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar customGitFetch = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#defaultGitolite",
              "documentation": {
                "identifier": "defaultGitolite",
                "newPage": false,
                "searchKey": "server.defaultGitolite",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var defaultGitolite"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar defaultGitolite = gitoliteFetcher{client: gitoliteClient{}}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#doBackgroundRepoUpdateMock",
              "documentation": {
                "identifier": "doBackgroundRepoUpdateMock",
                "newPage": false,
                "searchKey": "server.doBackgroundRepoUpdateMock",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var doBackgroundRepoUpdateMock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar doBackgroundRepoUpdateMock func(api.RepoName) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#enableGCAuto",
              "documentation": {
                "identifier": "enableGCAuto",
                "newPage": false,
                "searchKey": "server.enableGCAuto",
                "tags": [
                  "variable",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var enableGCAuto"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar enableGCAuto, _ = ...\n```\n\nEnableGCAuto is a temporary flag that allows us to control whether or not `git gc --auto` is invoked during janitorial activities. This flag will likely evolve into some form of site config value in the future. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#execDuration",
              "documentation": {
                "identifier": "execDuration",
                "newPage": false,
                "searchKey": "server.execDuration",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var execDuration"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar execDuration = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#execRunning",
              "documentation": {
                "identifier": "execRunning",
                "newPage": false,
                "searchKey": "server.execRunning",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var execRunning"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar execRunning = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#headBranchPattern",
              "documentation": {
                "identifier": "headBranchPattern",
                "newPage": false,
                "searchKey": "server.headBranchPattern",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var headBranchPattern"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar headBranchPattern = lazyregexp.New(`HEAD branch: (.+?)\\n`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#janitorRunning",
              "documentation": {
                "identifier": "janitorRunning",
                "newPage": false,
                "searchKey": "server.janitorRunning",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var janitorRunning"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar janitorRunning = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#jobTimer",
              "documentation": {
                "identifier": "jobTimer",
                "newPage": false,
                "searchKey": "server.jobTimer",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var jobTimer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jobTimer = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#lastCheckAt",
              "documentation": {
                "identifier": "lastCheckAt",
                "newPage": false,
                "searchKey": "server.lastCheckAt",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var lastCheckAt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lastCheckAt = make(map[api.RepoName]time.Time)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#lastCheckMutex",
              "documentation": {
                "identifier": "lastCheckMutex",
                "newPage": false,
                "searchKey": "server.lastCheckMutex",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var lastCheckMutex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lastCheckMutex sync.Mutex\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#logUnflushableResponseWriterOnce",
              "documentation": {
                "identifier": "logUnflushableResponseWriterOnce",
                "newPage": false,
                "searchKey": "server.logUnflushableResponseWriterOnce",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var logUnflushableResponseWriterOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar logUnflushableResponseWriterOnce sync.Once\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#longGitCommandTimeout",
              "documentation": {
                "identifier": "longGitCommandTimeout",
                "newPage": false,
                "searchKey": "server.longGitCommandTimeout",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var longGitCommandTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar longGitCommandTimeout = time.Hour\n```\n\nThis is a timeout for long git commands like clone or remote update. that may take a while for large repos. These types of commands should be run in the background. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#lsRemoteQueue",
              "documentation": {
                "identifier": "lsRemoteQueue",
                "newPage": false,
                "searchKey": "server.lsRemoteQueue",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var lsRemoteQueue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lsRemoteQueue = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#maybeCorruptStderrRe",
              "documentation": {
                "identifier": "maybeCorruptStderrRe",
                "newPage": false,
                "searchKey": "server.maybeCorruptStderrRe",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var maybeCorruptStderrRe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar maybeCorruptStderrRe = lazyregexp.NewPOSIX(`^error: (Could not read|packfile) `)\n```\n\nmaybeCorruptStderrRe matches stderr lines from git which indicate there might be repository corruption. \n\nSee [https://github.com/sourcegraph/sourcegraph/issues/6676](https://github.com/sourcegraph/sourcegraph/issues/6676) for more context. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#metricServiceDuration",
              "documentation": {
                "identifier": "metricServiceDuration",
                "newPage": false,
                "searchKey": "server.metricServiceDuration",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var metricServiceDuration"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar metricServiceDuration = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#metricServiceRunning",
              "documentation": {
                "identifier": "metricServiceRunning",
                "newPage": false,
                "searchKey": "server.metricServiceRunning",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var metricServiceRunning"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar metricServiceRunning = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#patchID",
              "documentation": {
                "identifier": "patchID",
                "newPage": false,
                "searchKey": "server.patchID",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var patchID"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar patchID uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#refspecOverrides",
              "documentation": {
                "identifier": "refspecOverrides",
                "newPage": false,
                "searchKey": "server.refspecOverrides",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var refspecOverrides"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar refspecOverrides = ...\n```\n\nHACK(keegancsmith) workaround to experiment with cloning less in a large monorepo. [https://github.com/sourcegraph/customer/issues/19](https://github.com/sourcegraph/customer/issues/19) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#repoCloned",
              "documentation": {
                "identifier": "repoCloned",
                "newPage": false,
                "searchKey": "server.repoCloned",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var repoCloned"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar repoCloned = ...\n```\n\nrepoCloned checks if dir or `${dir}/.git` is a valid GIT_DIR. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#repoClonedCounter",
              "documentation": {
                "identifier": "repoClonedCounter",
                "newPage": false,
                "searchKey": "server.repoClonedCounter",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var repoClonedCounter"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar repoClonedCounter = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#repoLastChanged",
              "documentation": {
                "identifier": "repoLastChanged",
                "newPage": false,
                "searchKey": "server.repoLastChanged",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var repoLastChanged"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar repoLastChanged = ...\n```\n\nrepoLastChanged returns the mtime of the repo's sg_refhash, which is the cached timestamp of the most recent commit we could find in the tree. As a special case when sg_refhash is missing we return repoLastFetched(dir). \n\nThis breaks on file systems that do not record mtime. This is a Sourcegraph extension to track last time a repo changed. The file is updated by setLastChanged via doBackgroundRepoUpdate. \n\nAs a special case, tries both the directory given, and the .git subdirectory, because we're a bit inconsistent about which name to use. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#repoLastFetched",
              "documentation": {
                "identifier": "repoLastFetched",
                "newPage": false,
                "searchKey": "server.repoLastFetched",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var repoLastFetched"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar repoLastFetched = ...\n```\n\nrepoLastFetched returns the mtime of the repo's FETCH_HEAD, which is the date of the last successful `git remote update` or `git fetch` (even if nothing new was fetched). As a special case when the repo has been cloned but none of those other two operations have been run (and so FETCH_HEAD does not exist), it will return the mtime of HEAD. \n\nThis breaks on file systems that do not record mtime and if Git ever changes this undocumented behavior. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#repoRemoteRefs",
              "documentation": {
                "identifier": "repoRemoteRefs",
                "newPage": false,
                "searchKey": "server.repoRemoteRefs",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var repoRemoteRefs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar repoRemoteRefs = ...\n```\n\nrepoRemoteRefs returns a map containing ref + commit pairs from the remote Git repository starting with the specified prefix. \n\nThe ref prefix `ref/<ref type>/` is stripped away from the returned refs. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#repoStateUpsertCounter",
              "documentation": {
                "identifier": "repoStateUpsertCounter",
                "newPage": false,
                "searchKey": "server.repoStateUpsertCounter",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var repoStateUpsertCounter"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar repoStateUpsertCounter = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#repoSyncStateCounter",
              "documentation": {
                "identifier": "repoSyncStateCounter",
                "newPage": false,
                "searchKey": "server.repoSyncStateCounter",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var repoSyncStateCounter"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar repoSyncStateCounter = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#repoSyncStatePercentComplete",
              "documentation": {
                "identifier": "repoSyncStatePercentComplete",
                "newPage": false,
                "searchKey": "server.repoSyncStatePercentComplete",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var repoSyncStatePercentComplete"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar repoSyncStatePercentComplete = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#reposRecloned",
              "documentation": {
                "identifier": "reposRecloned",
                "newPage": false,
                "searchKey": "server.reposRecloned",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var reposRecloned"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar reposRecloned = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#reposRemoved",
              "documentation": {
                "identifier": "reposRemoved",
                "newPage": false,
                "searchKey": "server.reposRemoved",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var reposRemoved"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar reposRemoved = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#reposRemovedDiskPressure",
              "documentation": {
                "identifier": "reposRemovedDiskPressure",
                "newPage": false,
                "searchKey": "server.reposRemovedDiskPressure",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var reposRemovedDiskPressure"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar reposRemovedDiskPressure = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#runCommandMock",
              "documentation": {
                "identifier": "runCommandMock",
                "newPage": false,
                "searchKey": "server.runCommandMock",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var runCommandMock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar runCommandMock func(context.Context, *exec.Cmd) (int, error)\n```\n\nrunCommandMock is set by tests. When non-nil it is run instead of runCommand \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#sshAgentSockID",
              "documentation": {
                "identifier": "sshAgentSockID",
                "newPage": false,
                "searchKey": "server.sshAgentSockID",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var sshAgentSockID"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sshAgentSockID int64 = 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#testGitRepoExists",
              "documentation": {
                "identifier": "testGitRepoExists",
                "newPage": false,
                "searchKey": "server.testGitRepoExists",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testGitRepoExists"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testGitRepoExists func(ctx context.Context, remoteURL *vcs.URL) error\n```\n\ntestGitRepoExists is a test fixture that overrides the return value for GitRepoSyncer.IsCloneable when it is set. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#testRepoCorrupter",
              "documentation": {
                "identifier": "testRepoCorrupter",
                "newPage": false,
                "searchKey": "server.testRepoCorrupter",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testRepoCorrupter"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testRepoCorrupter func(ctx context.Context, tmpDir GitDir)\n```\n\ntestRepoCorrupter is used by tests to disrupt a cloned repository (e.g. deleting HEAD, zeroing it out, etc.) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#tlsExternal",
              "documentation": {
                "identifier": "tlsExternal",
                "newPage": false,
                "searchKey": "server.tlsExternal",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var tlsExternal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tlsExternal = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#traceLogs",
              "documentation": {
                "identifier": "traceLogs",
                "newPage": false,
                "searchKey": "server.traceLogs",
                "tags": [
                  "variable",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var traceLogs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar traceLogs bool\n```\n\ntraceLogs is controlled via the env SRC_GITSERVER_TRACE. If true we trace logs to stderr \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/cmd/gitserver/server#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/cmd/gitserver/server#DiskSizer",
              "documentation": {
                "identifier": "DiskSizer",
                "newPage": false,
                "searchKey": "server.DiskSizer",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type DiskSizer interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype DiskSizer interface {\n\tBytesFreeOnDisk(mountPoint string) (uint64, error)\n\tDiskSizeBytes(mountPoint string) (uint64, error)\n}\n```\n\nDiskSizer gets information about disk size and free space. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#GitDir",
              "documentation": {
                "identifier": "GitDir",
                "newPage": false,
                "searchKey": "server.GitDir",
                "tags": [
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type GitDir string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype GitDir string\n```\n\nGitDir is an absolute path to a GIT_DIR. They will all follow the form: \n\n```\n${s.ReposDir}/${name}/.git\n\n```\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#GitDir.Path",
                    "documentation": {
                      "identifier": "GitDir.Path",
                      "newPage": false,
                      "searchKey": "server.GitDir.Path",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dir GitDir) Path(elem ...string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dir GitDir) Path(elem ...string) string\n```\n\nPath is a helper which returns filepath.Join(dir, elem...) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#GitDir.Set",
                    "documentation": {
                      "identifier": "GitDir.Set",
                      "newPage": false,
                      "searchKey": "server.GitDir.Set",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dir GitDir) Set(cmd *exec.Cmd)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dir GitDir) Set(cmd *exec.Cmd)\n```\n\nSet updates cmd so that it will run in dir. \n\nNote: GitDir is always a valid GIT_DIR, so we additionally set the environment variable GIT_DIR. This is to avoid git doing discovery in case of a bad repo, leading to hard to diagnose error messages. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#GitRepoSyncer",
              "documentation": {
                "identifier": "GitRepoSyncer",
                "newPage": false,
                "searchKey": "server.GitRepoSyncer",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type GitRepoSyncer struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype GitRepoSyncer struct{}\n```\n\nGitRepoSyncer is a syncer for Git repositories. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#GitRepoSyncer.CloneCommand",
                    "documentation": {
                      "identifier": "GitRepoSyncer.CloneCommand",
                      "newPage": false,
                      "searchKey": "server.GitRepoSyncer.CloneCommand",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *GitRepoSyncer) CloneCommand(ctx context.Context, remoteURL *vcs.URL, tmpPath string) (cmd *exec.Cmd, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *GitRepoSyncer) CloneCommand(ctx context.Context, remoteURL *vcs.URL, tmpPath string) (cmd *exec.Cmd, err error)\n```\n\nCloneCommand returns the command to be executed for cloning a Git repository. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#GitRepoSyncer.Fetch",
                    "documentation": {
                      "identifier": "GitRepoSyncer.Fetch",
                      "newPage": false,
                      "searchKey": "server.GitRepoSyncer.Fetch",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *GitRepoSyncer) Fetch(ctx context.Context, remoteURL *vcs.URL, dir GitDir) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *GitRepoSyncer) Fetch(ctx context.Context, remoteURL *vcs.URL, dir GitDir) error\n```\n\nFetch tries to fetch updates of a Git repository. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#GitRepoSyncer.IsCloneable",
                    "documentation": {
                      "identifier": "GitRepoSyncer.IsCloneable",
                      "newPage": false,
                      "searchKey": "server.GitRepoSyncer.IsCloneable",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *GitRepoSyncer) IsCloneable(ctx context.Context, remoteURL *vcs.URL) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *GitRepoSyncer) IsCloneable(ctx context.Context, remoteURL *vcs.URL) error\n```\n\nIsCloneable checks to see if the Git remote URL is cloneable. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#GitRepoSyncer.RemoteShowCommand",
                    "documentation": {
                      "identifier": "GitRepoSyncer.RemoteShowCommand",
                      "newPage": false,
                      "searchKey": "server.GitRepoSyncer.RemoteShowCommand",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *GitRepoSyncer) RemoteShowCommand(ctx context.Context, remoteURL *vcs.URL) (cmd *exec.Cmd, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *GitRepoSyncer) RemoteShowCommand(ctx context.Context, remoteURL *vcs.URL) (cmd *exec.Cmd, err error)\n```\n\nRemoteShowCommand returns the command to be executed for showing remote of a Git repository. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#GitRepoSyncer.Type",
                    "documentation": {
                      "identifier": "GitRepoSyncer.Type",
                      "newPage": false,
                      "searchKey": "server.GitRepoSyncer.Type",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *GitRepoSyncer) Type() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *GitRepoSyncer) Type() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#GitRepoSyncer.fetchCommand",
                    "documentation": {
                      "identifier": "GitRepoSyncer.fetchCommand",
                      "newPage": false,
                      "searchKey": "server.GitRepoSyncer.fetchCommand",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *GitRepoSyncer) fetchCommand(ctx context.Context, remoteURL *vcs.URL) (cmd *exec.Cmd, configRemoteOpts bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *GitRepoSyncer) fetchCommand(ctx context.Context, remoteURL *vcs.URL) (cmd *exec.Cmd, configRemoteOpts bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#PerforceDepotSyncer",
              "documentation": {
                "identifier": "PerforceDepotSyncer",
                "newPage": false,
                "searchKey": "server.PerforceDepotSyncer",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type PerforceDepotSyncer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PerforceDepotSyncer struct {\n\t// MaxChanges indicates to only import at most n changes when possible.\n\tMaxChanges int\n}\n```\n\nPerforceDepotSyncer is a syncer for Perforce depots. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#PerforceDepotSyncer.CloneCommand",
                    "documentation": {
                      "identifier": "PerforceDepotSyncer.CloneCommand",
                      "newPage": false,
                      "searchKey": "server.PerforceDepotSyncer.CloneCommand",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *PerforceDepotSyncer) CloneCommand(ctx context.Context, remoteURL *vcs.URL, tmpPath string) (*exec.Cmd, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *PerforceDepotSyncer) CloneCommand(ctx context.Context, remoteURL *vcs.URL, tmpPath string) (*exec.Cmd, error)\n```\n\nCloneCommand returns the command to be executed for cloning a Perforce depot as a Git repository. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#PerforceDepotSyncer.Fetch",
                    "documentation": {
                      "identifier": "PerforceDepotSyncer.Fetch",
                      "newPage": false,
                      "searchKey": "server.PerforceDepotSyncer.Fetch",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *PerforceDepotSyncer) Fetch(ctx context.Context, remoteURL *vcs.URL, dir GitDir) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *PerforceDepotSyncer) Fetch(ctx context.Context, remoteURL *vcs.URL, dir GitDir) error\n```\n\nFetch tries to fetch updates of a Perforce depot as a Git repository. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#PerforceDepotSyncer.IsCloneable",
                    "documentation": {
                      "identifier": "PerforceDepotSyncer.IsCloneable",
                      "newPage": false,
                      "searchKey": "server.PerforceDepotSyncer.IsCloneable",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *PerforceDepotSyncer) IsCloneable(ctx context.Context, remoteURL *vcs.URL) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *PerforceDepotSyncer) IsCloneable(ctx context.Context, remoteURL *vcs.URL) error\n```\n\nIsCloneable checks to see if the Perforce remote URL is cloneable. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#PerforceDepotSyncer.RemoteShowCommand",
                    "documentation": {
                      "identifier": "PerforceDepotSyncer.RemoteShowCommand",
                      "newPage": false,
                      "searchKey": "server.PerforceDepotSyncer.RemoteShowCommand",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *PerforceDepotSyncer) RemoteShowCommand(ctx context.Context, remoteURL *vcs.URL) (cmd *exec.Cmd, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *PerforceDepotSyncer) RemoteShowCommand(ctx context.Context, remoteURL *vcs.URL) (cmd *exec.Cmd, err error)\n```\n\nRemoteShowCommand returns the command to be executed for showing Git remote of a Perforce depot. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#PerforceDepotSyncer.Type",
                    "documentation": {
                      "identifier": "PerforceDepotSyncer.Type",
                      "newPage": false,
                      "searchKey": "server.PerforceDepotSyncer.Type",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *PerforceDepotSyncer) Type() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *PerforceDepotSyncer) Type() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#RepositoryLock",
              "documentation": {
                "identifier": "RepositoryLock",
                "newPage": false,
                "searchKey": "server.RepositoryLock",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RepositoryLock struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RepositoryLock struct {\n\tlocker *RepositoryLocker\n\tdir    GitDir\n\n\t// done is protected by locker.mu\n\tdone bool\n}\n```\n\nRepositoryLock is returned by RepositoryLocker.TryAcquire. It allows updating the status of a directory lock, as well as releasing the lock. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#RepositoryLock.Release",
                    "documentation": {
                      "identifier": "RepositoryLock.Release",
                      "newPage": false,
                      "searchKey": "server.RepositoryLock.Release",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *RepositoryLock) Release()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *RepositoryLock) Release()\n```\n\nRelease releases the lock. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#RepositoryLock.SetStatus",
                    "documentation": {
                      "identifier": "RepositoryLock.SetStatus",
                      "newPage": false,
                      "searchKey": "server.RepositoryLock.SetStatus",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *RepositoryLock) SetStatus(status string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *RepositoryLock) SetStatus(status string)\n```\n\nSetStatus updates the status for the lock. If the lock has been released, this is a noop. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#RepositoryLocker",
              "documentation": {
                "identifier": "RepositoryLocker",
                "newPage": false,
                "searchKey": "server.RepositoryLocker",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RepositoryLocker struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RepositoryLocker struct {\n\t// mu protects status\n\tmu sync.RWMutex\n\t// status tracks directories that are locked. The value is the status. If\n\t// a directory is in status, the directory is locked.\n\tstatus map[GitDir]string\n}\n```\n\nRepositoryLocker provides locks for doing operations to a repository directory. When a repository is locked, only the owner of the lock is allowed to run commands against it. \n\nRepositories are identified by the absolute path to their $GIT_DIR. \n\nThe directory's $GIT_DIR does not have to exist when locked. The owner of the lock may remove the directory's $GIT_DIR while holding the lock. \n\nThe main use of RepositoryLocker is to prevent concurrent clones. However, it is also used during maintenance tasks such as recloning/migrating/etc. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#RepositoryLocker.Status",
                    "documentation": {
                      "identifier": "RepositoryLocker.Status",
                      "newPage": false,
                      "searchKey": "server.RepositoryLocker.Status",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *RepositoryLocker) Status(dir GitDir) (status string, locked bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *RepositoryLocker) Status(dir GitDir) (status string, locked bool)\n```\n\nStatus returns the status of the locked directory dir. If dir is not locked, then locked is false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#RepositoryLocker.TryAcquire",
                    "documentation": {
                      "identifier": "RepositoryLocker.TryAcquire",
                      "newPage": false,
                      "searchKey": "server.RepositoryLocker.TryAcquire",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *RepositoryLocker) TryAcquire(dir GitDir, initialStatus string) (lock *RepositoryLock, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *RepositoryLocker) TryAcquire(dir GitDir, initialStatus string) (lock *RepositoryLock, ok bool)\n```\n\nTryAcquire acquires the lock for dir. If it is already held, ok is false and lock is nil. Otherwise a non-nil lock is returned and true. When finished with the lock you must call lock.Release. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#Server",
              "documentation": {
                "identifier": "Server",
                "newPage": false,
                "searchKey": "server.Server",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Server struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Server struct {\n\t// ReposDir is the path to the base directory for gitserver storage.\n\tReposDir string\n\n\t// DesiredPercentFree is the desired percentage of disk space to keep free.\n\tDesiredPercentFree int\n\n\t// DiskSizer tells how much disk is free and how large the disk is.\n\tDiskSizer DiskSizer\n\n\t// GetRemoteURLFunc is a function which returns the remote URL for a\n\t// repository. This is used when cloning or fetching a repository. In\n\t// production this will speak to the database to look up the clone URL. In\n\t// tests this is usually set to clone a local repository or intentionally\n\t// error.\n\t//\n\t// Note: internal uses should call getRemoteURL which will handle\n\t// GetRemoteURLFunc being nil.\n\tGetRemoteURLFunc func(context.Context, api.RepoName) (string, error)\n\n\t// GetVCSSyncer is a function which returns the VCS syncer for a repository.\n\t// This is used when cloning or fetching a repository. In production this will\n\t// speak to the database to determine the code host type. In tests this is\n\t// usually set to return a GitRepoSyncer.\n\tGetVCSSyncer func(context.Context, api.RepoName) (VCSSyncer, error)\n\n\t// Hostname is how we identify this instance of gitserver. Generally it is the\n\t// actual hostname but can also be overridden by the HOSTNAME environment variable.\n\tHostname string\n\n\t// shared db handle\n\tDB dbutil.DB\n\n\t// skipCloneForTests is set by tests to avoid clones.\n\tskipCloneForTests bool\n\n\t// ctx is the context we use for all background jobs. It is done when the\n\t// server is stopped. Do not directly call this, rather call\n\t// Server.context()\n\tctx      context.Context\n\tcancel   context.CancelFunc // used to shutdown background jobs\n\tcancelMu sync.Mutex         // protects canceled\n\tcanceled bool\n\twg       sync.WaitGroup // tracks running background jobs\n\n\tlocker *RepositoryLocker\n\n\t// cloneLimiter and cloneableLimiter limits the number of concurrent\n\t// clones and ls-remotes respectively. Use s.acquireCloneLimiter() and\n\t// s.acquireClonableLimiter() instead of using these directly.\n\tcloneLimiter     *mutablelimiter.Limiter\n\tcloneableLimiter *mutablelimiter.Limiter\n\n\t// rpsLimiter limits the remote code host git operations done per second\n\t// per gitserver instance\n\trpsLimiter *rate.Limiter\n\n\trepoUpdateLocksMu sync.Mutex // protects the map below and also updates to locks.once\n\trepoUpdateLocks   map[api.RepoName]*locks\n}\n```\n\nServer is a gitserver server. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#makeTestServer",
                    "documentation": {
                      "identifier": "makeTestServer",
                      "newPage": false,
                      "searchKey": "server.makeTestServer",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeTestServer(ctx context.Context, repoDir, remote string, db dbutil.DB) *Server"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeTestServer(ctx context.Context, repoDir, remote string, db dbutil.DB) *Server\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.Handler",
                    "documentation": {
                      "identifier": "Server.Handler",
                      "newPage": false,
                      "searchKey": "server.Server.Handler",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) Handler() http.Handler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) Handler() http.Handler\n```\n\nHandler returns the http.Handler that should be used to serve requests. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.Janitor",
                    "documentation": {
                      "identifier": "Server.Janitor",
                      "newPage": false,
                      "searchKey": "server.Server.Janitor",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) Janitor(interval time.Duration)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) Janitor(interval time.Duration)\n```\n\nJanitor does clean up tasks over s.ReposDir and is expected to run in a background goroutine. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.RegisterMetrics",
                    "documentation": {
                      "identifier": "Server.RegisterMetrics",
                      "newPage": false,
                      "searchKey": "server.Server.RegisterMetrics",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) RegisterMetrics()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) RegisterMetrics()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.SetupAndClearTmp",
                    "documentation": {
                      "identifier": "Server.SetupAndClearTmp",
                      "newPage": false,
                      "searchKey": "server.Server.SetupAndClearTmp",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) SetupAndClearTmp() (string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) SetupAndClearTmp() (string, error)\n```\n\nSetupAndClearTmp sets up the the tempdir for ReposDir as well as clearing it out. It returns the temporary directory location. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.Stop",
                    "documentation": {
                      "identifier": "Server.Stop",
                      "newPage": false,
                      "searchKey": "server.Server.Stop",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) Stop()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) Stop()\n```\n\nStop cancels the running background jobs and returns when done. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.SyncRepoState",
                    "documentation": {
                      "identifier": "Server.SyncRepoState",
                      "newPage": false,
                      "searchKey": "server.Server.SyncRepoState",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) SyncRepoState(interval time.Duration, batchSize, perSecond int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) SyncRepoState(interval time.Duration, batchSize, perSecond int)\n```\n\nSyncRepoState syncs state on disk to the database for all repos and is expected to run in a background goroutine. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.acquireCloneLimiter",
                    "documentation": {
                      "identifier": "Server.acquireCloneLimiter",
                      "newPage": false,
                      "searchKey": "server.Server.acquireCloneLimiter",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) acquireCloneLimiter(ctx context.Context) (context.Context, context.CancelFunc, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) acquireCloneLimiter(ctx context.Context) (context.Context, context.CancelFunc, error)\n```\n\nacquireCloneLimiter() acquires a cancellable context associated with the clone limiter. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.acquireCloneableLimiter",
                    "documentation": {
                      "identifier": "Server.acquireCloneableLimiter",
                      "newPage": false,
                      "searchKey": "server.Server.acquireCloneableLimiter",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) acquireCloneableLimiter(ctx context.Context) (context.Context, context.CancelFunc, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) acquireCloneableLimiter(ctx context.Context) (context.Context, context.CancelFunc, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.cleanTmpFiles",
                    "documentation": {
                      "identifier": "Server.cleanTmpFiles",
                      "newPage": false,
                      "searchKey": "server.Server.cleanTmpFiles",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) cleanTmpFiles(dir GitDir)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) cleanTmpFiles(dir GitDir)\n```\n\ncleanTmpFiles tries to remove tmp_pack_* files from .git/objects/pack. These files can be created by an interrupted fetch operation, and would be purged by `git gc --prune=now`, but `git gc` is very slow. Removing these files while they're in use will cause an operation to fail, but not damage the repository. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.cleanupRepos",
                    "documentation": {
                      "identifier": "Server.cleanupRepos",
                      "newPage": false,
                      "searchKey": "server.Server.cleanupRepos",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) cleanupRepos()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) cleanupRepos()\n```\n\ncleanupRepos walks the repos directory and performs maintenance tasks: \n\n1. Compute the amount of space used by the repo 2. Remove corrupt repos. 3. Remove stale lock files. 4. Ensure correct git attributes 5. Scrub remote URLs 6. Perform garbage collection 7. Re-clone repos after a while. (simulate git gc) 8. Remove repos based on disk pressure. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.cloneRepo",
                    "documentation": {
                      "identifier": "Server.cloneRepo",
                      "newPage": false,
                      "searchKey": "server.Server.cloneRepo",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) cloneRepo(ctx context.Context, repo api.RepoName, opts *cloneOptions) (string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) cloneRepo(ctx context.Context, repo api.RepoName, opts *cloneOptions) (string, error)\n```\n\ncloneRepo performs a clone operation for the given repository. It is non-blocking by default. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.createCommitFromPatch",
                    "documentation": {
                      "identifier": "Server.createCommitFromPatch",
                      "newPage": false,
                      "searchKey": "server.Server.createCommitFromPatch",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) createCommitFromPatch(ctx context.Context, req protocol.CreateCommitFromPatchRequest) (int, protocol.CreateCommitFromPatchResponse)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) createCommitFromPatch(ctx context.Context, req protocol.CreateCommitFromPatchRequest) (int, protocol.CreateCommitFromPatchResponse)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.deleteRepo",
                    "documentation": {
                      "identifier": "Server.deleteRepo",
                      "newPage": false,
                      "searchKey": "server.Server.deleteRepo",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) deleteRepo(repo api.RepoName) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) deleteRepo(repo api.RepoName) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.dir",
                    "documentation": {
                      "identifier": "Server.dir",
                      "newPage": false,
                      "searchKey": "server.Server.dir",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) dir(name api.RepoName) GitDir"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) dir(name api.RepoName) GitDir\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.doBackgroundRepoUpdate",
                    "documentation": {
                      "identifier": "Server.doBackgroundRepoUpdate",
                      "newPage": false,
                      "searchKey": "server.Server.doBackgroundRepoUpdate",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) doBackgroundRepoUpdate(repo api.RepoName) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) doBackgroundRepoUpdate(repo api.RepoName) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.doRepoUpdate",
                    "documentation": {
                      "identifier": "Server.doRepoUpdate",
                      "newPage": false,
                      "searchKey": "server.Server.doRepoUpdate",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) doRepoUpdate(ctx context.Context, repo api.RepoName) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) doRepoUpdate(ctx context.Context, repo api.RepoName) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.ensureRevision",
                    "documentation": {
                      "identifier": "Server.ensureRevision",
                      "newPage": false,
                      "searchKey": "server.Server.ensureRevision",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) ensureRevision(ctx context.Context, repo api.RepoName, rev string, repoDir GitDir) (didUpdate bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) ensureRevision(ctx context.Context, repo api.RepoName, rev string, repoDir GitDir) (didUpdate bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.exec",
                    "documentation": {
                      "identifier": "Server.exec",
                      "newPage": false,
                      "searchKey": "server.Server.exec",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) exec(w http.ResponseWriter, r *http.Request, req *protocol.ExecRequest)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) exec(w http.ResponseWriter, r *http.Request, req *protocol.ExecRequest)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.findGitDirs",
                    "documentation": {
                      "identifier": "Server.findGitDirs",
                      "newPage": false,
                      "searchKey": "server.Server.findGitDirs",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) findGitDirs() ([]GitDir, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) findGitDirs() ([]GitDir, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.freeUpSpace",
                    "documentation": {
                      "identifier": "Server.freeUpSpace",
                      "newPage": false,
                      "searchKey": "server.Server.freeUpSpace",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) freeUpSpace(howManyBytesToFree int64) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) freeUpSpace(howManyBytesToFree int64) error\n```\n\nfreeUpSpace removes git directories under ReposDir, in order from least recently to most recently used, until it has freed howManyBytesToFree. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.getRemoteURL",
                    "documentation": {
                      "identifier": "Server.getRemoteURL",
                      "newPage": false,
                      "searchKey": "server.Server.getRemoteURL",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) getRemoteURL(ctx context.Context, name api.RepoName) (*vcs.URL, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) getRemoteURL(ctx context.Context, name api.RepoName) (*vcs.URL, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.gitServiceHandler",
                    "documentation": {
                      "identifier": "Server.gitServiceHandler",
                      "newPage": false,
                      "searchKey": "server.Server.gitServiceHandler",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) gitServiceHandler() *gitservice.Handler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) gitServiceHandler() *gitservice.Handler\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleArchive",
                    "documentation": {
                      "identifier": "Server.handleArchive",
                      "newPage": false,
                      "searchKey": "server.Server.handleArchive",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleArchive(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleArchive(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleCreateCommitFromPatch",
                    "documentation": {
                      "identifier": "Server.handleCreateCommitFromPatch",
                      "newPage": false,
                      "searchKey": "server.Server.handleCreateCommitFromPatch",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleCreateCommitFromPatch(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleCreateCommitFromPatch(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleExec",
                    "documentation": {
                      "identifier": "Server.handleExec",
                      "newPage": false,
                      "searchKey": "server.Server.handleExec",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleExec(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleExec(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleGetGitolitePhabricatorMetadata",
                    "documentation": {
                      "identifier": "Server.handleGetGitolitePhabricatorMetadata",
                      "newPage": false,
                      "searchKey": "server.Server.handleGetGitolitePhabricatorMetadata",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleGetGitolitePhabricatorMetadata(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleGetGitolitePhabricatorMetadata(w http.ResponseWriter, r *http.Request)\n```\n\nhandleGetGitolitePhabricatorMetadata serves the Gitolite Phabricator metadata endpoint, which returns the Phabricator metadata for a given repository by running a user-provided command. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleIsRepoCloneable",
                    "documentation": {
                      "identifier": "Server.handleIsRepoCloneable",
                      "newPage": false,
                      "searchKey": "server.Server.handleIsRepoCloneable",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleIsRepoCloneable(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleIsRepoCloneable(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleIsRepoCloned",
                    "documentation": {
                      "identifier": "Server.handleIsRepoCloned",
                      "newPage": false,
                      "searchKey": "server.Server.handleIsRepoCloned",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleIsRepoCloned(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleIsRepoCloned(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleList",
                    "documentation": {
                      "identifier": "Server.handleList",
                      "newPage": false,
                      "searchKey": "server.Server.handleList",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleList(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleList(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleListGitolite",
                    "documentation": {
                      "identifier": "Server.handleListGitolite",
                      "newPage": false,
                      "searchKey": "server.Server.handleListGitolite",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleListGitolite(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleListGitolite(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleP4Exec",
                    "documentation": {
                      "identifier": "Server.handleP4Exec",
                      "newPage": false,
                      "searchKey": "server.Server.handleP4Exec",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleP4Exec(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleP4Exec(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleRepoCloneProgress",
                    "documentation": {
                      "identifier": "Server.handleRepoCloneProgress",
                      "newPage": false,
                      "searchKey": "server.Server.handleRepoCloneProgress",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleRepoCloneProgress(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleRepoCloneProgress(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleRepoDelete",
                    "documentation": {
                      "identifier": "Server.handleRepoDelete",
                      "newPage": false,
                      "searchKey": "server.Server.handleRepoDelete",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleRepoDelete(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleRepoDelete(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleRepoInfo",
                    "documentation": {
                      "identifier": "Server.handleRepoInfo",
                      "newPage": false,
                      "searchKey": "server.Server.handleRepoInfo",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleRepoInfo(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleRepoInfo(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleRepoUpdate",
                    "documentation": {
                      "identifier": "Server.handleRepoUpdate",
                      "newPage": false,
                      "searchKey": "server.Server.handleRepoUpdate",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleRepoUpdate(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleRepoUpdate(w http.ResponseWriter, r *http.Request)\n```\n\nhandleRepoUpdate is a synchronous (waits for update to complete or time out) method so it can yield errors. Updates are not unconditional; we debounce them based on the provided interval, to avoid spam. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.handleReposStats",
                    "documentation": {
                      "identifier": "Server.handleReposStats",
                      "newPage": false,
                      "searchKey": "server.Server.handleReposStats",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) handleReposStats(w http.ResponseWriter, r *http.Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) handleReposStats(w http.ResponseWriter, r *http.Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.hostnameMatch",
                    "documentation": {
                      "identifier": "Server.hostnameMatch",
                      "newPage": false,
                      "searchKey": "server.Server.hostnameMatch",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) hostnameMatch(addr string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) hostnameMatch(addr string) bool\n```\n\nhostnameMatch checks whether the hostname matches the given address. If we don't find an exact match, we look at the initial prefix. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.howManyBytesToFree",
                    "documentation": {
                      "identifier": "Server.howManyBytesToFree",
                      "newPage": false,
                      "searchKey": "server.Server.howManyBytesToFree",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) howManyBytesToFree() (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) howManyBytesToFree() (int64, error)\n```\n\nhowManyBytesToFree returns the number of bytes that should be freed to make sure there is sufficient disk space free to satisfy s.DesiredPercentFree. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.ignorePath",
                    "documentation": {
                      "identifier": "Server.ignorePath",
                      "newPage": false,
                      "searchKey": "server.Server.ignorePath",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) ignorePath(path string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) ignorePath(path string) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.name",
                    "documentation": {
                      "identifier": "Server.name",
                      "newPage": false,
                      "searchKey": "server.Server.name",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) name(dir GitDir) api.RepoName"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) name(dir GitDir) api.RepoName\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.p4exec",
                    "documentation": {
                      "identifier": "Server.p4exec",
                      "newPage": false,
                      "searchKey": "server.Server.p4exec",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) p4exec(w http.ResponseWriter, r *http.Request, req *protocol.P4ExecRequest)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) p4exec(w http.ResponseWriter, r *http.Request, req *protocol.P4ExecRequest)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.queryCloneLimiter",
                    "documentation": {
                      "identifier": "Server.queryCloneLimiter",
                      "newPage": false,
                      "searchKey": "server.Server.queryCloneLimiter",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) queryCloneLimiter() (cap, len int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) queryCloneLimiter() (cap, len int)\n```\n\nqueryCloneLimiter reports the capacity and length of the clone limiter's queue \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.removeRepoDirectory",
                    "documentation": {
                      "identifier": "Server.removeRepoDirectory",
                      "newPage": false,
                      "searchKey": "server.Server.removeRepoDirectory",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) removeRepoDirectory(gitDir GitDir) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) removeRepoDirectory(gitDir GitDir) error\n```\n\nremoveRepoDirectory atomically removes a directory from s.ReposDir. \n\nIt first moves the directory to a temporary location to avoid leaving partial state in the event of server restart or concurrent modifications to the directory. \n\nAdditionally it removes parent empty directories up until s.ReposDir. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.repoCloneProgress",
                    "documentation": {
                      "identifier": "Server.repoCloneProgress",
                      "newPage": false,
                      "searchKey": "server.Server.repoCloneProgress",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) repoCloneProgress(repo api.RepoName) (*protocol.RepoCloneProgress, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) repoCloneProgress(repo api.RepoName) (*protocol.RepoCloneProgress, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.repoInfo",
                    "documentation": {
                      "identifier": "Server.repoInfo",
                      "newPage": false,
                      "searchKey": "server.Server.repoInfo",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) repoInfo(ctx context.Context, repo api.RepoName) (*protocol.RepoInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) repoInfo(ctx context.Context, repo api.RepoName) (*protocol.RepoInfo, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.serverContext",
                    "documentation": {
                      "identifier": "Server.serverContext",
                      "newPage": false,
                      "searchKey": "server.Server.serverContext",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) serverContext() (context.Context, context.CancelFunc)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) serverContext() (context.Context, context.CancelFunc)\n```\n\nserverContext returns a child context tied to the lifecycle of server. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.setCloneStatus",
                    "documentation": {
                      "identifier": "Server.setCloneStatus",
                      "newPage": false,
                      "searchKey": "server.Server.setCloneStatus",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) setCloneStatus(ctx context.Context, name api.RepoName, status types.CloneStatus) (err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) setCloneStatus(ctx context.Context, name api.RepoName, status types.CloneStatus) (err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.setCloneStatusNonFatal",
                    "documentation": {
                      "identifier": "Server.setCloneStatusNonFatal",
                      "newPage": false,
                      "searchKey": "server.Server.setCloneStatusNonFatal",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) setCloneStatusNonFatal(ctx context.Context, name api.RepoName, status types.CloneStatus)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) setCloneStatusNonFatal(ctx context.Context, name api.RepoName, status types.CloneStatus)\n```\n\nsetCloneStatusNonFatal is the same as setCloneStatus but only logs errors \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.setLastError",
                    "documentation": {
                      "identifier": "Server.setLastError",
                      "newPage": false,
                      "searchKey": "server.Server.setLastError",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) setLastError(ctx context.Context, name api.RepoName, error string) (err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) setLastError(ctx context.Context, name api.RepoName, error string) (err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.setLastErrorNonFatal",
                    "documentation": {
                      "identifier": "Server.setLastErrorNonFatal",
                      "newPage": false,
                      "searchKey": "server.Server.setLastErrorNonFatal",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) setLastErrorNonFatal(ctx context.Context, name api.RepoName, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) setLastErrorNonFatal(ctx context.Context, name api.RepoName, err error)\n```\n\nsetLastErrorNonFatal is the same as setLastError but only logs errors \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.syncRepoState",
                    "documentation": {
                      "identifier": "Server.syncRepoState",
                      "newPage": false,
                      "searchKey": "server.Server.syncRepoState",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) syncRepoState(addrs []string, batchSize, perSecond int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) syncRepoState(addrs []string, batchSize, perSecond int) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#Server.tempDir",
                    "documentation": {
                      "identifier": "Server.tempDir",
                      "newPage": false,
                      "searchKey": "server.Server.tempDir",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) tempDir(prefix string) (name string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) tempDir(prefix string) (name string, err error)\n```\n\ntempDir is a wrapper around os.MkdirTemp, but using the server's temporary directory filepath.Join(s.ReposDir, tempDirName). \n\nThis directory is cleaned up by gitserver and will be ignored by repository listing operations. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#StatDiskSizer",
              "documentation": {
                "identifier": "StatDiskSizer",
                "newPage": false,
                "searchKey": "server.StatDiskSizer",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type StatDiskSizer struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype StatDiskSizer struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#StatDiskSizer.BytesFreeOnDisk",
                    "documentation": {
                      "identifier": "StatDiskSizer.BytesFreeOnDisk",
                      "newPage": false,
                      "searchKey": "server.StatDiskSizer.BytesFreeOnDisk",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *StatDiskSizer) BytesFreeOnDisk(mountPoint string) (uint64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *StatDiskSizer) BytesFreeOnDisk(mountPoint string) (uint64, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#StatDiskSizer.DiskSizeBytes",
                    "documentation": {
                      "identifier": "StatDiskSizer.DiskSizeBytes",
                      "newPage": false,
                      "searchKey": "server.StatDiskSizer.DiskSizeBytes",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *StatDiskSizer) DiskSizeBytes(mountPoint string) (uint64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *StatDiskSizer) DiskSizeBytes(mountPoint string) (uint64, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#Test",
              "documentation": {
                "identifier": "Test",
                "newPage": false,
                "searchKey": "server.Test",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Test struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Test struct {\n\tName             string\n\tRequest          *http.Request\n\tExpectedCode     int\n\tExpectedBody     string\n\tExpectedTrailers http.Header\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#VCSSyncer",
              "documentation": {
                "identifier": "VCSSyncer",
                "newPage": false,
                "searchKey": "server.VCSSyncer",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type VCSSyncer interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype VCSSyncer interface {\n\t// Type returns the type of the syncer.\n\tType() string\n\t// IsCloneable checks to see if the VCS remote URL is cloneable. Any non-nil\n\t// error indicates there is a problem.\n\tIsCloneable(ctx context.Context, remoteURL *vcs.URL) error\n\t// CloneCommand returns the command to be executed for cloning from remote.\n\tCloneCommand(ctx context.Context, remoteURL *vcs.URL, tmpPath string) (cmd *exec.Cmd, err error)\n\t// Fetch tries to fetch updates from the remote to given directory.\n\tFetch(ctx context.Context, remoteURL *vcs.URL, dir GitDir) error\n\t// RemoteShowCommand returns the command to be executed for showing remote.\n\tRemoteShowCommand(ctx context.Context, remoteURL *vcs.URL) (cmd *exec.Cmd, err error)\n}\n```\n\nVCSSyncer describes whether and how to sync content from a VCS remote to local disk. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#cloneOptions",
              "documentation": {
                "identifier": "cloneOptions",
                "newPage": false,
                "searchKey": "server.cloneOptions",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type cloneOptions struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cloneOptions struct {\n\t// Block will wait for the clone to finish before returning. If the clone\n\t// fails, the error will be returned. The passed in context is\n\t// respected. When not blocking the clone is done with a server background\n\t// context.\n\tBlock bool\n\n\t// Overwrite will overwrite the existing clone.\n\tOverwrite bool\n}\n```\n\ncloneOptions specify optional behaviour for the cloneRepo function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#fakeDiskSizer",
              "documentation": {
                "identifier": "fakeDiskSizer",
                "newPage": false,
                "searchKey": "server.fakeDiskSizer",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type fakeDiskSizer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fakeDiskSizer struct {\n\tbytesFree uint64\n\tdiskSize  uint64\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#fakeDiskSizer.BytesFreeOnDisk",
                    "documentation": {
                      "identifier": "fakeDiskSizer.BytesFreeOnDisk",
                      "newPage": false,
                      "searchKey": "server.fakeDiskSizer.BytesFreeOnDisk",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fakeDiskSizer) BytesFreeOnDisk(mountPoint string) (uint64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fakeDiskSizer) BytesFreeOnDisk(mountPoint string) (uint64, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#fakeDiskSizer.DiskSizeBytes",
                    "documentation": {
                      "identifier": "fakeDiskSizer.DiskSizeBytes",
                      "newPage": false,
                      "searchKey": "server.fakeDiskSizer.DiskSizeBytes",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fakeDiskSizer) DiskSizeBytes(mountPoint string) (uint64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fakeDiskSizer) DiskSizeBytes(mountPoint string) (uint64, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#flushFunc",
              "documentation": {
                "identifier": "flushFunc",
                "newPage": false,
                "searchKey": "server.flushFunc",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type flushFunc func()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype flushFunc func()\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#flushFunc.Flush",
                    "documentation": {
                      "identifier": "flushFunc.Flush",
                      "newPage": false,
                      "searchKey": "server.flushFunc.Flush",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f flushFunc) Flush()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f flushFunc) Flush()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#flushingResponseWriter",
              "documentation": {
                "identifier": "flushingResponseWriter",
                "newPage": false,
                "searchKey": "server.flushingResponseWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type flushingResponseWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype flushingResponseWriter struct {\n\t// mu ensures we don't concurrently call Flush and Write. It also protects\n\t// state.\n\tmu      sync.Mutex\n\tw       http.ResponseWriter\n\tflusher http.Flusher\n\tclosed  bool\n\tdoFlush bool\n}\n```\n\nflushingResponseWriter is a http.ResponseWriter that flushes all writes to the underlying connection within a certain time period after Write is called (instead of buffering them indefinitely). \n\nThis lets, e.g., clients with a context deadline see as much partial response body as possible. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#newFlushingResponseWriter",
                    "documentation": {
                      "identifier": "newFlushingResponseWriter",
                      "newPage": false,
                      "searchKey": "server.newFlushingResponseWriter",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newFlushingResponseWriter(w http.ResponseWriter) *flushingResponseWriter"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newFlushingResponseWriter(w http.ResponseWriter) *flushingResponseWriter\n```\n\nnewFlushingResponseWriter creates a new flushing response writer. Callers must call Close to free the resources created by the writer. \n\nIf w does not support flushing, it returns nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#flushingResponseWriter.Close",
                    "documentation": {
                      "identifier": "flushingResponseWriter.Close",
                      "newPage": false,
                      "searchKey": "server.flushingResponseWriter.Close",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *flushingResponseWriter) Close()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *flushingResponseWriter) Close()\n```\n\nClose signals to the flush goroutine to stop. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#flushingResponseWriter.Header",
                    "documentation": {
                      "identifier": "flushingResponseWriter.Header",
                      "newPage": false,
                      "searchKey": "server.flushingResponseWriter.Header",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *flushingResponseWriter) Header() http.Header"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *flushingResponseWriter) Header() http.Header\n```\n\nHeader implements http.ResponseWriter. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#flushingResponseWriter.Write",
                    "documentation": {
                      "identifier": "flushingResponseWriter.Write",
                      "newPage": false,
                      "searchKey": "server.flushingResponseWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *flushingResponseWriter) Write(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *flushingResponseWriter) Write(p []byte) (int, error)\n```\n\nWrite implements http.ResponseWriter. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#flushingResponseWriter.WriteHeader",
                    "documentation": {
                      "identifier": "flushingResponseWriter.WriteHeader",
                      "newPage": false,
                      "searchKey": "server.flushingResponseWriter.WriteHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *flushingResponseWriter) WriteHeader(code int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *flushingResponseWriter) WriteHeader(code int)\n```\n\nWriteHeader implements http.ResponseWriter. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#flushingResponseWriter.periodicFlush",
                    "documentation": {
                      "identifier": "flushingResponseWriter.periodicFlush",
                      "newPage": false,
                      "searchKey": "server.flushingResponseWriter.periodicFlush",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *flushingResponseWriter) periodicFlush()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *flushingResponseWriter) periodicFlush()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#gitoliteClient",
              "documentation": {
                "identifier": "gitoliteClient",
                "newPage": false,
                "searchKey": "server.gitoliteClient",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type gitoliteClient struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gitoliteClient struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#gitoliteClient.ListRepos",
                    "documentation": {
                      "identifier": "gitoliteClient.ListRepos",
                      "newPage": false,
                      "searchKey": "server.gitoliteClient.ListRepos",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c gitoliteClient) ListRepos(ctx context.Context, host string) ([]*gitolite.Repo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c gitoliteClient) ListRepos(ctx context.Context, host string) ([]*gitolite.Repo, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#gitoliteFetcher",
              "documentation": {
                "identifier": "gitoliteFetcher",
                "newPage": false,
                "searchKey": "server.gitoliteFetcher",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type gitoliteFetcher struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gitoliteFetcher struct {\n\tclient iGitoliteClient\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#gitoliteFetcher.listRepos",
                    "documentation": {
                      "identifier": "gitoliteFetcher.listRepos",
                      "newPage": false,
                      "searchKey": "server.gitoliteFetcher.listRepos",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (g gitoliteFetcher) listRepos(ctx context.Context, gitoliteHost string, w http.ResponseWriter)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (g gitoliteFetcher) listRepos(ctx context.Context, gitoliteHost string, w http.ResponseWriter)\n```\n\nlistRepos lists the repos of a Gitolite server reachable at the address in gitoliteHost \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#iGitoliteClient",
              "documentation": {
                "identifier": "iGitoliteClient",
                "newPage": false,
                "searchKey": "server.iGitoliteClient",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type iGitoliteClient interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype iGitoliteClient interface {\n\tListRepos(ctx context.Context, host string) ([]*gitolite.Repo, error)\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#limitWriter",
              "documentation": {
                "identifier": "limitWriter",
                "newPage": false,
                "searchKey": "server.limitWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type limitWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype limitWriter struct {\n\tW io.Writer // underling writer\n\tN int       // max bytes remaining\n}\n```\n\nlimitWriter is a io.Writer that writes to an W but discards after N bytes. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#limitWriter.Write",
                    "documentation": {
                      "identifier": "limitWriter.Write",
                      "newPage": false,
                      "searchKey": "server.limitWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *limitWriter) Write(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *limitWriter) Write(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#locks",
              "documentation": {
                "identifier": "locks",
                "newPage": false,
                "searchKey": "server.locks",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type locks struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype locks struct {\n\tonce *sync.Once  // consolidates multiple waiting updates\n\tmu   *sync.Mutex // prevents updates running in parallel\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#progressWriter",
              "documentation": {
                "identifier": "progressWriter",
                "newPage": false,
                "searchKey": "server.progressWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type progressWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype progressWriter struct {\n\t// writeOffset is the offset in buf where the next write should begin.\n\twriteOffset int\n\n\t// afterLastNewline is the index after the last '\\n' in buf\n\t// or 0 if there is no '\\n' in buf.\n\tafterLastNewline int\n\n\tbuf []byte\n}\n```\n\nprogressWriter is an io.Writer that writes to a buffer. '\\r' resets the write offset to the index after last '\\n' in the buffer, or the beginning of the buffer if a '\\n' has not been written yet. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#progressWriter.Bytes",
                    "documentation": {
                      "identifier": "progressWriter.Bytes",
                      "newPage": false,
                      "searchKey": "server.progressWriter.Bytes",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *progressWriter) Bytes() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *progressWriter) Bytes() []byte\n```\n\nBytes returns the contents of the buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#progressWriter.String",
                    "documentation": {
                      "identifier": "progressWriter.String",
                      "newPage": false,
                      "searchKey": "server.progressWriter.String",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *progressWriter) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *progressWriter) String() string\n```\n\nString returns the contents of the buffer as a string. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#progressWriter.Write",
                    "documentation": {
                      "identifier": "progressWriter.Write",
                      "newPage": false,
                      "searchKey": "server.progressWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *progressWriter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *progressWriter) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#sshAgent",
              "documentation": {
                "identifier": "sshAgent",
                "newPage": false,
                "searchKey": "server.sshAgent",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type sshAgent struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sshAgent struct {\n\tl       net.Listener\n\tsock    string\n\tkeyring agent.Agent\n\tdone    chan struct{}\n}\n```\n\nsshAgent speaks the ssh-agent protocol and can be used by gitserver to provide a private key to ssh when talking to the code host. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#newSSHAgent",
                    "documentation": {
                      "identifier": "newSSHAgent",
                      "newPage": false,
                      "searchKey": "server.newSSHAgent",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newSSHAgent(raw, passphrase []byte) (*sshAgent, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newSSHAgent(raw, passphrase []byte) (*sshAgent, error)\n```\n\nnewSSHAgent takes a private key and it's passphrase and returns an `sshAgent`. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#sshAgent.Close",
                    "documentation": {
                      "identifier": "sshAgent.Close",
                      "newPage": false,
                      "searchKey": "server.sshAgent.Close",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *sshAgent) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *sshAgent) Close() error\n```\n\nClose closes the server. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#sshAgent.Listen",
                    "documentation": {
                      "identifier": "sshAgent.Listen",
                      "newPage": false,
                      "searchKey": "server.sshAgent.Listen",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *sshAgent) Listen()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *sshAgent) Listen()\n```\n\nListen starts accepting connections of the ssh agent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#sshAgent.Socket",
                    "documentation": {
                      "identifier": "sshAgent.Socket",
                      "newPage": false,
                      "searchKey": "server.sshAgent.Socket",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *sshAgent) Socket() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *sshAgent) Socket() string\n```\n\nSocket returns the path to the unix socket the ssh-agent server is listening on. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#stubGitoliteClient",
              "documentation": {
                "identifier": "stubGitoliteClient",
                "newPage": false,
                "searchKey": "server.stubGitoliteClient",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type stubGitoliteClient struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stubGitoliteClient struct {\n\tListRepos_ func(ctx context.Context, host string) ([]*gitolite.Repo, error)\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#stubGitoliteClient.ListRepos",
                    "documentation": {
                      "identifier": "stubGitoliteClient.ListRepos",
                      "newPage": false,
                      "searchKey": "server.stubGitoliteClient.ListRepos",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c stubGitoliteClient) ListRepos(ctx context.Context, host string) ([]*gitolite.Repo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c stubGitoliteClient) ListRepos(ctx context.Context, host string) ([]*gitolite.Repo, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#tlsConfig",
              "documentation": {
                "identifier": "tlsConfig",
                "newPage": false,
                "searchKey": "server.tlsConfig",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type tlsConfig struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype tlsConfig struct {\n\t// Whether to not verify the SSL certificate when fetching or pushing over\n\t// HTTPS.\n\t//\n\t// https://git-scm.com/docs/git-config#Documentation/git-config.txt-httpsslVerify\n\tSSLNoVerify bool\n\n\t// File containing the certificates to verify the peer with when fetching\n\t// or pushing over HTTPS.\n\t//\n\t// https://git-scm.com/docs/git-config#Documentation/git-config.txt-httpsslCAInfo\n\tSSLCAInfo string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#urlRedactor",
              "documentation": {
                "identifier": "urlRedactor",
                "newPage": false,
                "searchKey": "server.urlRedactor",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type urlRedactor struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype urlRedactor struct {\n\t// sensitive are sensitive strings to be redacted.\n\t// The strings should not be empty.\n\tsensitive []string\n}\n```\n\nurlRedactor redacts all sensitive strings from a message. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#newURLRedactor",
                    "documentation": {
                      "identifier": "newURLRedactor",
                      "newPage": false,
                      "searchKey": "server.newURLRedactor",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newURLRedactor(parsedURL *vcs.URL) *urlRedactor"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newURLRedactor(parsedURL *vcs.URL) *urlRedactor\n```\n\nnewURLRedactor returns a new urlRedactor that redacts credentials found in rawurl, and the rawurl itself. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#urlRedactor.redact",
                    "documentation": {
                      "identifier": "urlRedactor.redact",
                      "newPage": false,
                      "searchKey": "server.urlRedactor.redact",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *urlRedactor) redact(message string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *urlRedactor) redact(message string) string\n```\n\nredact returns a redacted version of message. Sensitive strings are replaced with \"<redacted>\". \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#writeCounter",
              "documentation": {
                "identifier": "writeCounter",
                "newPage": false,
                "searchKey": "server.writeCounter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type writeCounter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype writeCounter struct {\n\tw io.Writer\n\t// n is the number of bytes written to w\n\tn int64\n}\n```\n\nwriteCounter wraps an io.Writer and keeps track of bytes written. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/cmd/gitserver/server#writeCounter.Write",
                    "documentation": {
                      "identifier": "writeCounter.Write",
                      "newPage": false,
                      "searchKey": "server.writeCounter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *writeCounter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *writeCounter) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/cmd/gitserver/server#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/cmd/gitserver/server#BenchmarkQuickRevParseHeadQuickSymbolicRefHead_packed_refs",
              "documentation": {
                "identifier": "BenchmarkQuickRevParseHeadQuickSymbolicRefHead_packed_refs",
                "newPage": false,
                "searchKey": "server.BenchmarkQuickRevParseHeadQuickSymbolicRefHead_packed_refs",
                "tags": [
                  "function",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkQuickRevParseHeadQuickSymbolicRefHead_packed_refs(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkQuickRevParseHeadQuickSymbolicRefHead_packed_refs(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#BenchmarkQuickRevParseHeadQuickSymbolicRefHead_unpacked_refs",
              "documentation": {
                "identifier": "BenchmarkQuickRevParseHeadQuickSymbolicRefHead_unpacked_refs",
                "newPage": false,
                "searchKey": "server.BenchmarkQuickRevParseHeadQuickSymbolicRefHead_unpacked_refs",
                "tags": [
                  "function",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkQuickRevParseHeadQuickSymbolicRefHead_unpacked_refs(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkQuickRevParseHeadQuickSymbolicRefHead_unpacked_refs(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestCleanupExpired",
              "documentation": {
                "identifier": "TestCleanupExpired",
                "newPage": false,
                "searchKey": "server.TestCleanupExpired",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCleanupExpired(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCleanupExpired(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestCleanupInactive",
              "documentation": {
                "identifier": "TestCleanupInactive",
                "newPage": false,
                "searchKey": "server.TestCleanupInactive",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCleanupInactive(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCleanupInactive(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestCleanupOldLocks",
              "documentation": {
                "identifier": "TestCleanupOldLocks",
                "newPage": false,
                "searchKey": "server.TestCleanupOldLocks",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCleanupOldLocks(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCleanupOldLocks(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestCleanup_computeStats",
              "documentation": {
                "identifier": "TestCleanup_computeStats",
                "newPage": false,
                "searchKey": "server.TestCleanup_computeStats",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCleanup_computeStats(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCleanup_computeStats(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestCloneRepo",
              "documentation": {
                "identifier": "TestCloneRepo",
                "newPage": false,
                "searchKey": "server.TestCloneRepo",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloneRepo(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloneRepo(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestCloneRepo_EnsureValidity",
              "documentation": {
                "identifier": "TestCloneRepo_EnsureValidity",
                "newPage": false,
                "searchKey": "server.TestCloneRepo_EnsureValidity",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloneRepo_EnsureValidity(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloneRepo_EnsureValidity(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestConfigureRemoteGitCommand",
              "documentation": {
                "identifier": "TestConfigureRemoteGitCommand",
                "newPage": false,
                "searchKey": "server.TestConfigureRemoteGitCommand",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConfigureRemoteGitCommand(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConfigureRemoteGitCommand(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestConfigureRemoteGitCommand_tls",
              "documentation": {
                "identifier": "TestConfigureRemoteGitCommand_tls",
                "newPage": false,
                "searchKey": "server.TestConfigureRemoteGitCommand_tls",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConfigureRemoteGitCommand_tls(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConfigureRemoteGitCommand_tls(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestCustomGitFetch",
              "documentation": {
                "identifier": "TestCustomGitFetch",
                "newPage": false,
                "searchKey": "server.TestCustomGitFetch",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCustomGitFetch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCustomGitFetch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestDecomposePerforceRemoteURL",
              "documentation": {
                "identifier": "TestDecomposePerforceRemoteURL",
                "newPage": false,
                "searchKey": "server.TestDecomposePerforceRemoteURL",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDecomposePerforceRemoteURL(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDecomposePerforceRemoteURL(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestEmptyCustomGitFetch",
              "documentation": {
                "identifier": "TestEmptyCustomGitFetch",
                "newPage": false,
                "searchKey": "server.TestEmptyCustomGitFetch",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEmptyCustomGitFetch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEmptyCustomGitFetch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestFlushingResponseWriter",
              "documentation": {
                "identifier": "TestFlushingResponseWriter",
                "newPage": false,
                "searchKey": "server.TestFlushingResponseWriter",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFlushingResponseWriter(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFlushingResponseWriter(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestFreeUpSpace",
              "documentation": {
                "identifier": "TestFreeUpSpace",
                "newPage": false,
                "searchKey": "server.TestFreeUpSpace",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFreeUpSpace(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFreeUpSpace(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestGitGCAuto",
              "documentation": {
                "identifier": "TestGitGCAuto",
                "newPage": false,
                "searchKey": "server.TestGitGCAuto",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGitGCAuto(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGitGCAuto(t *testing.T)\n```\n\nNote that the exact values (e.g. 50 commits) below are related to git's internal heuristics regarding whether or not to invoke `git gc --auto`. \n\nThey are stable today, but may become flaky in the future if/when the relevant internal magic numbers and transformations change. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestHandleRepoUpdate",
              "documentation": {
                "identifier": "TestHandleRepoUpdate",
                "newPage": false,
                "searchKey": "server.TestHandleRepoUpdate",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandleRepoUpdate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandleRepoUpdate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestHostnameMatch",
              "documentation": {
                "identifier": "TestHostnameMatch",
                "newPage": false,
                "searchKey": "server.TestHostnameMatch",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHostnameMatch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHostnameMatch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestHowManyBytesToFree",
              "documentation": {
                "identifier": "TestHowManyBytesToFree",
                "newPage": false,
                "searchKey": "server.TestHowManyBytesToFree",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHowManyBytesToFree(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHowManyBytesToFree(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestJitterDuration",
              "documentation": {
                "identifier": "TestJitterDuration",
                "newPage": false,
                "searchKey": "server.TestJitterDuration",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestJitterDuration(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestJitterDuration(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestMain",
              "documentation": {
                "identifier": "TestMain",
                "newPage": false,
                "searchKey": "server.TestMain",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMain(m *testing.M)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMain(m *testing.M)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestMaybeCorruptStderrRe",
              "documentation": {
                "identifier": "TestMaybeCorruptStderrRe",
                "newPage": false,
                "searchKey": "server.TestMaybeCorruptStderrRe",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMaybeCorruptStderrRe(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMaybeCorruptStderrRe(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestProgressWriter",
              "documentation": {
                "identifier": "TestProgressWriter",
                "newPage": false,
                "searchKey": "server.TestProgressWriter",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestProgressWriter(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestProgressWriter(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestRemoveBadRefs",
              "documentation": {
                "identifier": "TestRemoveBadRefs",
                "newPage": false,
                "searchKey": "server.TestRemoveBadRefs",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRemoveBadRefs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRemoveBadRefs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestRemoveRepoDirectory",
              "documentation": {
                "identifier": "TestRemoveRepoDirectory",
                "newPage": false,
                "searchKey": "server.TestRemoveRepoDirectory",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRemoveRepoDirectory(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRemoveRepoDirectory(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestRemoveRepoDirectory_Empty",
              "documentation": {
                "identifier": "TestRemoveRepoDirectory_Empty",
                "newPage": false,
                "searchKey": "server.TestRemoveRepoDirectory_Empty",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRemoveRepoDirectory_Empty(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRemoveRepoDirectory_Empty(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestRequest",
              "documentation": {
                "identifier": "TestRequest",
                "newPage": false,
                "searchKey": "server.TestRequest",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRequest(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRequest(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestSSHAgent",
              "documentation": {
                "identifier": "TestSSHAgent",
                "newPage": false,
                "searchKey": "server.TestSSHAgent",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSSHAgent(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSSHAgent(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestServer_handleGet",
              "documentation": {
                "identifier": "TestServer_handleGet",
                "newPage": false,
                "searchKey": "server.TestServer_handleGet",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestServer_handleGet(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestServer_handleGet(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestServer_handleGet_invalid",
              "documentation": {
                "identifier": "TestServer_handleGet_invalid",
                "newPage": false,
                "searchKey": "server.TestServer_handleGet_invalid",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestServer_handleGet_invalid(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestServer_handleGet_invalid(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestServer_handleList",
              "documentation": {
                "identifier": "TestServer_handleList",
                "newPage": false,
                "searchKey": "server.TestServer_handleList",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestServer_handleList(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestServer_handleList(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestServer_handleP4Exec",
              "documentation": {
                "identifier": "TestServer_handleP4Exec",
                "newPage": false,
                "searchKey": "server.TestServer_handleP4Exec",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestServer_handleP4Exec(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestServer_handleP4Exec(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestServer_handleRepoInfo",
              "documentation": {
                "identifier": "TestServer_handleRepoInfo",
                "newPage": false,
                "searchKey": "server.TestServer_handleRepoInfo",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestServer_handleRepoInfo(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestServer_handleRepoInfo(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestSetupAndClearTmp",
              "documentation": {
                "identifier": "TestSetupAndClearTmp",
                "newPage": false,
                "searchKey": "server.TestSetupAndClearTmp",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSetupAndClearTmp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSetupAndClearTmp(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestSetupAndClearTmp_Empty",
              "documentation": {
                "identifier": "TestSetupAndClearTmp_Empty",
                "newPage": false,
                "searchKey": "server.TestSetupAndClearTmp_Empty",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSetupAndClearTmp_Empty(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSetupAndClearTmp_Empty(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestSyncRepoState",
              "documentation": {
                "identifier": "TestSyncRepoState",
                "newPage": false,
                "searchKey": "server.TestSyncRepoState",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSyncRepoState(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSyncRepoState(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestUpdateFileIfDifferent",
              "documentation": {
                "identifier": "TestUpdateFileIfDifferent",
                "newPage": false,
                "searchKey": "server.TestUpdateFileIfDifferent",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUpdateFileIfDifferent(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUpdateFileIfDifferent(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#TestUrlRedactor",
              "documentation": {
                "identifier": "TestUrlRedactor",
                "newPage": false,
                "searchKey": "server.TestUrlRedactor",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUrlRedactor(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUrlRedactor(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#Test_Gitolite_listRepos",
              "documentation": {
                "identifier": "Test_Gitolite_listRepos",
                "newPage": false,
                "searchKey": "server.Test_Gitolite_listRepos",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Test_Gitolite_listRepos(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Test_Gitolite_listRepos(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#assertPaths",
              "documentation": {
                "identifier": "assertPaths",
                "newPage": false,
                "searchKey": "server.assertPaths",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func assertPaths(t *testing.T, root string, want ...string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc assertPaths(t *testing.T, root string, want ...string)\n```\n\nassertPaths checks that all paths under want exist. It excludes non-empty directories \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#bestEffortWalk",
              "documentation": {
                "identifier": "bestEffortWalk",
                "newPage": false,
                "searchKey": "server.bestEffortWalk",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func bestEffortWalk(root string, walkFn func(path string, info fs.FileInfo) error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bestEffortWalk(root string, walkFn func(path string, info fs.FileInfo) error) error\n```\n\nbestEffortWalk is a filepath.Walk which ignores errors that can be passed to walkFn. This is a common pattern used in gitserver for best effort work. \n\nNote: We still respect errors returned by walkFn. \n\nfilepath.Walk can return errors if we run into permission errors or a file disappears between readdir and the stat of the file. In either case this error can be ignored for best effort code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#buildCustomFetchMappings",
              "documentation": {
                "identifier": "buildCustomFetchMappings",
                "newPage": false,
                "searchKey": "server.buildCustomFetchMappings",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func buildCustomFetchMappings(c []*schema.CustomGitFetchMapping) map[string][]string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc buildCustomFetchMappings(c []*schema.CustomGitFetchMapping) map[string][]string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#checkMaybeCorruptRepo",
              "documentation": {
                "identifier": "checkMaybeCorruptRepo",
                "newPage": false,
                "searchKey": "server.checkMaybeCorruptRepo",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkMaybeCorruptRepo(repo api.RepoName, dir GitDir, stderr string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkMaybeCorruptRepo(repo api.RepoName, dir GitDir, stderr string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#checkSpecArgSafety",
              "documentation": {
                "identifier": "checkSpecArgSafety",
                "newPage": false,
                "searchKey": "server.checkSpecArgSafety",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkSpecArgSafety(spec string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkSpecArgSafety(spec string) error\n```\n\ncheckSpecArgSafety returns a non-nil err if spec begins with a \"-\", which could cause it to be interpreted as a git command line argument. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#cleanUpTmpRepo",
              "documentation": {
                "identifier": "cleanUpTmpRepo",
                "newPage": false,
                "searchKey": "server.cleanUpTmpRepo",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func cleanUpTmpRepo(path string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cleanUpTmpRepo(path string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#cloneStatus",
              "documentation": {
                "identifier": "cloneStatus",
                "newPage": false,
                "searchKey": "server.cloneStatus",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func cloneStatus(cloned, cloning bool) types.CloneStatus"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cloneStatus(cloned, cloning bool) types.CloneStatus\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#computeLatestCommitTimestamp",
              "documentation": {
                "identifier": "computeLatestCommitTimestamp",
                "newPage": false,
                "searchKey": "server.computeLatestCommitTimestamp",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func computeLatestCommitTimestamp(dir GitDir) time.Time"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc computeLatestCommitTimestamp(dir GitDir) time.Time\n```\n\ncomputeLatestCommitTimestamp returns the timestamp of the most recent commit if any. If there are no commits or the latest commit is in the future, or there is any error, time.Now is returned. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#computeRefHash",
              "documentation": {
                "identifier": "computeRefHash",
                "newPage": false,
                "searchKey": "server.computeRefHash",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func computeRefHash(dir GitDir) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc computeRefHash(dir GitDir) ([]byte, error)\n```\n\ncomputeRefHash returns a hash of the refs for dir. The hash should only change if the set of refs and the commits they point to change. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#configureRemoteGitCommand",
              "documentation": {
                "identifier": "configureRemoteGitCommand",
                "newPage": false,
                "searchKey": "server.configureRemoteGitCommand",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func configureRemoteGitCommand(cmd *exec.Cmd, tlsConf *tlsConfig)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc configureRemoteGitCommand(cmd *exec.Cmd, tlsConf *tlsConfig)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#customFetchCmd",
              "documentation": {
                "identifier": "customFetchCmd",
                "newPage": false,
                "searchKey": "server.customFetchCmd",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func customFetchCmd(ctx context.Context, remoteURL *vcs.URL) *exec.Cmd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc customFetchCmd(ctx context.Context, remoteURL *vcs.URL) *exec.Cmd\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#debounce",
              "documentation": {
                "identifier": "debounce",
                "newPage": false,
                "searchKey": "server.debounce",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func debounce(name api.RepoName, since time.Duration) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc debounce(name api.RepoName, since time.Duration) bool\n```\n\ndebounce() provides some filtering to prevent spammy requests for the same repository. If the last fetch of the repository was within the given duration, returns false, otherwise returns true and updates the last fetch stamp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#decomposePerforceRemoteURL",
              "documentation": {
                "identifier": "decomposePerforceRemoteURL",
                "newPage": false,
                "searchKey": "server.decomposePerforceRemoteURL",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func decomposePerforceRemoteURL(remoteURL *vcs.URL) (username, password, host, depot string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc decomposePerforceRemoteURL(remoteURL *vcs.URL) (username, password, host, depot string, err error)\n```\n\ndecomposePerforceRemoteURL decomposes information back from a clone URL for a Perforce depot. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#dirSize",
              "documentation": {
                "identifier": "dirSize",
                "newPage": false,
                "searchKey": "server.dirSize",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func dirSize(d string) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dirSize(d string) int64\n```\n\ndirSize returns the total size in bytes of all the files under d. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#ensureHEAD",
              "documentation": {
                "identifier": "ensureHEAD",
                "newPage": false,
                "searchKey": "server.ensureHEAD",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ensureHEAD(dir GitDir)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ensureHEAD(dir GitDir)\n```\n\nensureHEAD verifies that there is a HEAD file within the repo, and that it is of non-zero length. If either condition is met, we configure a best-effort default. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#ensureRefPrefix",
              "documentation": {
                "identifier": "ensureRefPrefix",
                "newPage": false,
                "searchKey": "server.ensureRefPrefix",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ensureRefPrefix(ref string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ensureRefPrefix(ref string) string\n```\n\nensureRefPrefix checks whether the ref is a full ref and contains the \"refs/heads\" prefix (i.e. \"refs/heads/master\") or just an abbreviated ref (i.e. \"master\") and adds the \"refs/heads/\" prefix if the latter is the case. \n\nCopied from git package to avoid cycle import when testing git package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#errorString",
              "documentation": {
                "identifier": "errorString",
                "newPage": false,
                "searchKey": "server.errorString",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func errorString(err error) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc errorString(err error) string\n```\n\nerrorString returns the error string. If err is nil it returns the empty string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#flowrateWriter",
              "documentation": {
                "identifier": "flowrateWriter",
                "newPage": false,
                "searchKey": "server.flowrateWriter",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func flowrateWriter(w io.Writer) io.Writer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc flowrateWriter(w io.Writer) io.Writer\n```\n\nflowrateWriter limits the write rate of w to 1 Gbps. \n\nWe are cloning repositories from within the same network from another Sourcegraph service (zoekt-indexserver). This can end up being so fast that we harm our own network connectivity. In the case of zoekt-indexserver and gitserver running on the same host machine, we can even reach up to ~100 Gbps and effectively DoS the Docker network, temporarily disrupting other containers running on the host. \n\nGoogle Compute Engine has a network bandwidth of about 1.64 Gbps between nodes, and AWS varies widely depending on instance type. We play it safe and default to 1 Gbps here (~119 MiB/s), which means we can fetch a 1 GiB archive in ~8.5 seconds. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#fsync",
              "documentation": {
                "identifier": "fsync",
                "newPage": false,
                "searchKey": "server.fsync",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fsync(path string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fsync(path string) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#generateSocketFilename",
              "documentation": {
                "identifier": "generateSocketFilename",
                "newPage": false,
                "searchKey": "server.generateSocketFilename",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func generateSocketFilename() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc generateSocketFilename() string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#getGitolitePhabCallsign",
              "documentation": {
                "identifier": "getGitolitePhabCallsign",
                "newPage": false,
                "searchKey": "server.getGitolitePhabCallsign",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func getGitolitePhabCallsign(ctx context.Context, gconf *schema.GitoliteConnection, repo, command string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getGitolitePhabCallsign(ctx context.Context, gconf *schema.GitoliteConnection, repo, command string) (string, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#getRecloneTime",
              "documentation": {
                "identifier": "getRecloneTime",
                "newPage": false,
                "searchKey": "server.getRecloneTime",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func getRecloneTime(dir GitDir) (time.Time, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getRecloneTime(dir GitDir) (time.Time, error)\n```\n\ngetRecloneTime returns an approximate time a repository is cloned. If the value is not stored in the repository, the re-clone time for the repository is set to now. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#getRepositoryType",
              "documentation": {
                "identifier": "getRepositoryType",
                "newPage": false,
                "searchKey": "server.getRepositoryType",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func getRepositoryType(dir GitDir) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getRepositoryType(dir GitDir) (string, error)\n```\n\ngetRepositoryType returns the type of the repository. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#gitConfigGet",
              "documentation": {
                "identifier": "gitConfigGet",
                "newPage": false,
                "searchKey": "server.gitConfigGet",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func gitConfigGet(dir GitDir, key string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gitConfigGet(dir GitDir, key string) (string, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#gitConfigSet",
              "documentation": {
                "identifier": "gitConfigSet",
                "newPage": false,
                "searchKey": "server.gitConfigSet",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func gitConfigSet(dir GitDir, key, value string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gitConfigSet(dir GitDir, key, value string) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#gitConfigUnset",
              "documentation": {
                "identifier": "gitConfigUnset",
                "newPage": false,
                "searchKey": "server.gitConfigUnset",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func gitConfigUnset(dir GitDir, key string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gitConfigUnset(dir GitDir, key string) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#gitDirModTime",
              "documentation": {
                "identifier": "gitDirModTime",
                "newPage": false,
                "searchKey": "server.gitDirModTime",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func gitDirModTime(d GitDir) (time.Time, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gitDirModTime(d GitDir) (time.Time, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#gitGC",
              "documentation": {
                "identifier": "gitGC",
                "newPage": false,
                "searchKey": "server.gitGC",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func gitGC(dir GitDir) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gitGC(dir GitDir) error\n```\n\ngitGC will invoke `git-gc` to clean up any garbage in the repo. It will operate synchronously and be aggressive with its internal heurisitcs when deciding to act (meaning it will act now at lower thresholds). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#hackilyGetHTTPFlusher",
              "documentation": {
                "identifier": "hackilyGetHTTPFlusher",
                "newPage": false,
                "searchKey": "server.hackilyGetHTTPFlusher",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func hackilyGetHTTPFlusher(w http.ResponseWriter) http.Flusher"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hackilyGetHTTPFlusher(w http.ResponseWriter) http.Flusher\n```\n\nhackilyGetHTTPFlusher attempts to get an http.Flusher from w. It (hackily) handles the case where w is a nethttp.statusCodeTracker (which wraps http.ResponseWriter and does not implement http.Flusher). See [https://github.com/opentracing-contrib/go-stdlib/pull/11#discussion_r164295773](https://github.com/opentracing-contrib/go-stdlib/pull/11#discussion_r164295773) and [https://github.com/sourcegraph/sourcegraph/issues/9045](https://github.com/sourcegraph/sourcegraph/issues/9045). \n\nI (@sqs) wrote this hack instead of fixing it upstream immediately because seems to be some reluctance to merge a fix (because it'd make the http.ResponseWriter falsely appear to implement many interfaces that it doesn't actually implement, so it would break the correctness of Go type-assertion impl checks). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#honeySampleRate",
              "documentation": {
                "identifier": "honeySampleRate",
                "newPage": false,
                "searchKey": "server.honeySampleRate",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func honeySampleRate(cmd string) uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc honeySampleRate(cmd string) uint\n```\n\nSend 1 in 16 events to honeycomb. This is hardcoded since we only use this for Sourcegraph.com. \n\n2020-05-29 1 in 4. We are currently at the top tier for honeycomb (before enterprise) and using double our quota. This gives us room to grow. If you find we keep bumping this / missing data we care about we can look into more dynamic ways to sample in our application code. \n\n2020-07-20 1 in 16. Again hitting very high usage. Likely due to recent scaling up of the indexed search cluster. Will require more investigation, but we should probably segment user request path traffic vs internal batch traffic. \n\n2020-11-02 Dynamically sample. Again hitting very high usage. Same root cause as before, scaling out indexed search cluster. We update our sampling to isntead be dynamic, since \"rev-parse\" is 12 times more likely than the next most common command. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#init.server.go",
              "documentation": {
                "identifier": "init.server.go",
                "newPage": false,
                "searchKey": "server.init",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#isAbsoluteRevision",
              "documentation": {
                "identifier": "isAbsoluteRevision",
                "newPage": false,
                "searchKey": "server.isAbsoluteRevision",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isAbsoluteRevision(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isAbsoluteRevision(s string) bool\n```\n\nIsAbsoluteRevision checks if the revision is a git OID SHA string. \n\nNote: This doesn't mean the SHA exists in a repository, nor does it mean it isn't a ref. Git allows 40-char hexadecimal strings to be references. \n\ncopied from internal/vcs/git to avoid cyclic import \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#isAlwaysCloningTest",
              "documentation": {
                "identifier": "isAlwaysCloningTest",
                "newPage": false,
                "searchKey": "server.isAlwaysCloningTest",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isAlwaysCloningTest(name api.RepoName) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isAlwaysCloningTest(name api.RepoName) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#isEmptyDir",
              "documentation": {
                "identifier": "isEmptyDir",
                "newPage": false,
                "searchKey": "server.isEmptyDir",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isEmptyDir(path string) (bool, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isEmptyDir(path string) (bool, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#jitterDuration",
              "documentation": {
                "identifier": "jitterDuration",
                "newPage": false,
                "searchKey": "server.jitterDuration",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func jitterDuration(key string, d time.Duration) time.Duration"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc jitterDuration(key string, d time.Duration) time.Duration\n```\n\njitterDuration returns a duration between [0, d) based on key. This is like a random duration, but instead of a random source it is computed via a hash on key. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#makeFakeRepo",
              "documentation": {
                "identifier": "makeFakeRepo",
                "newPage": false,
                "searchKey": "server.makeFakeRepo",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func makeFakeRepo(d string, sizeBytes int) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makeFakeRepo(d string, sizeBytes int) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#makeSingleCommitRepo",
              "documentation": {
                "identifier": "makeSingleCommitRepo",
                "newPage": false,
                "searchKey": "server.makeSingleCommitRepo",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func makeSingleCommitRepo(cmd func(string, ...string) string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makeSingleCommitRepo(cmd func(string, ...string) string) string\n```\n\nmakeSingleCommitRepo make create a new repo with a single commit and returns the HEAD SHA \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#mapToLog15Ctx",
              "documentation": {
                "identifier": "mapToLog15Ctx",
                "newPage": false,
                "searchKey": "server.mapToLog15Ctx",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapToLog15Ctx(m map[string]interface{}) []interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapToLog15Ctx(m map[string]interface{}) []interface{}\n```\n\nmapToLog15Ctx translates a map to log15 context fields. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#mkFiles",
              "documentation": {
                "identifier": "mkFiles",
                "newPage": false,
                "searchKey": "server.mkFiles",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func mkFiles(t *testing.T, root string, paths ...string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mkFiles(t *testing.T, root string, paths ...string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#p4ping",
              "documentation": {
                "identifier": "p4ping",
                "newPage": false,
                "searchKey": "server.p4ping",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func p4ping(ctx context.Context, host, username, password string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc p4ping(ctx context.Context, host, username, password string) error\n```\n\np4ping sends one message to the Perforce server to check connectivity. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#p4pingWithTrust",
              "documentation": {
                "identifier": "p4pingWithTrust",
                "newPage": false,
                "searchKey": "server.p4pingWithTrust",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func p4pingWithTrust(ctx context.Context, host, username, password string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc p4pingWithTrust(ctx context.Context, host, username, password string) error\n```\n\np4pingWithTrust attempts to ping the Perforce server and performs a trust operation when needed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#p4trust",
              "documentation": {
                "identifier": "p4trust",
                "newPage": false,
                "searchKey": "server.p4trust",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func p4trust(ctx context.Context, host string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc p4trust(ctx context.Context, host string) error\n```\n\np4trust blindly accepts fingerprint of the Perforce server. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#quickRevParseHead",
              "documentation": {
                "identifier": "quickRevParseHead",
                "newPage": false,
                "searchKey": "server.quickRevParseHead",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func quickRevParseHead(dir GitDir) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc quickRevParseHead(dir GitDir) (string, error)\n```\n\nquickRevParseHead best-effort mimics the execution of `git rev-parse HEAD`, but doesn't exec a child process. It just reads the relevant files from the bare git repository directory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#quickSymbolicRefHead",
              "documentation": {
                "identifier": "quickSymbolicRefHead",
                "newPage": false,
                "searchKey": "server.quickSymbolicRefHead",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func quickSymbolicRefHead(dir GitDir) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc quickSymbolicRefHead(dir GitDir) (string, error)\n```\n\nquickSymbolicRefHead best-effort mimics the execution of `git symbolic-ref HEAD`, but doesn't exec a child process. It just reads the .git/HEAD file from the bare git repository directory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#readCloneProgress",
              "documentation": {
                "identifier": "readCloneProgress",
                "newPage": false,
                "searchKey": "server.readCloneProgress",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func readCloneProgress(redactor *urlRedactor, lock *RepositoryLock, pr io.Reader)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readCloneProgress(redactor *urlRedactor, lock *RepositoryLock, pr io.Reader)\n```\n\nreadCloneProgress scans the reader and saves the most recent line of output as the lock status. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#refspecOverridesFetchCmd",
              "documentation": {
                "identifier": "refspecOverridesFetchCmd",
                "newPage": false,
                "searchKey": "server.refspecOverridesFetchCmd",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func refspecOverridesFetchCmd(ctx context.Context, remoteURL *vcs.URL) *exec.Cmd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc refspecOverridesFetchCmd(ctx context.Context, remoteURL *vcs.URL) *exec.Cmd\n```\n\nHACK(keegancsmith) workaround to experiment with cloning less in a large monorepo. [https://github.com/sourcegraph/customer/issues/19](https://github.com/sourcegraph/customer/issues/19) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#removeBadRefs",
              "documentation": {
                "identifier": "removeBadRefs",
                "newPage": false,
                "searchKey": "server.removeBadRefs",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func removeBadRefs(ctx context.Context, dir GitDir)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc removeBadRefs(ctx context.Context, dir GitDir)\n```\n\nremoveBadRefs removes bad refs and tags from the git repo at dir. This should be run after a clone or fetch. If your repository contains a ref or tag called HEAD (case insensitive), most commands will output a warning from git: \n\n```\nwarning: refname 'HEAD' is ambiguous.\n\n```\nInstead we just remove this ref. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#removeFileOlderThan",
              "documentation": {
                "identifier": "removeFileOlderThan",
                "newPage": false,
                "searchKey": "server.removeFileOlderThan",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func removeFileOlderThan(path string, maxAge time.Duration) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc removeFileOlderThan(path string, maxAge time.Duration) error\n```\n\nremoveFileOlderThan removes path if its mtime is older than maxAge. If the file is missing, no error is returned. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#renameAndSync",
              "documentation": {
                "identifier": "renameAndSync",
                "newPage": false,
                "searchKey": "server.renameAndSync",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func renameAndSync(oldpath, newpath string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc renameAndSync(oldpath, newpath string) error\n```\n\nrenameAndSync will do an os.Rename followed by fsync to ensure the rename is recorded \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#runCmd",
              "documentation": {
                "identifier": "runCmd",
                "newPage": false,
                "searchKey": "server.runCmd",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func runCmd(t *testing.T, dir string, cmd string, arg ...string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runCmd(t *testing.T, dir string, cmd string, arg ...string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#runCommand",
              "documentation": {
                "identifier": "runCommand",
                "newPage": false,
                "searchKey": "server.runCommand",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func runCommand(ctx context.Context, cmd *exec.Cmd) (exitCode int, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runCommand(ctx context.Context, cmd *exec.Cmd) (exitCode int, err error)\n```\n\nrunCommand runs the command and returns the exit status. All clients of this function should set the context in cmd themselves, but we have to pass the context separately here for the sake of tracing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#runWith",
              "documentation": {
                "identifier": "runWith",
                "newPage": false,
                "searchKey": "server.runWith",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func runWith(ctx context.Context, cmd *exec.Cmd, configRemoteOpts bool, progress io.Writer) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runWith(ctx context.Context, cmd *exec.Cmd, configRemoteOpts bool, progress io.Writer) ([]byte, error)\n```\n\nrunWithRemoteOpts runs the command after applying the remote options. If progress is not nil, all output is written to it in a separate goroutine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#runWithRemoteOpts",
              "documentation": {
                "identifier": "runWithRemoteOpts",
                "newPage": false,
                "searchKey": "server.runWithRemoteOpts",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func runWithRemoteOpts(ctx context.Context, cmd *exec.Cmd, progress io.Writer) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runWithRemoteOpts(ctx context.Context, cmd *exec.Cmd, progress io.Writer) ([]byte, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#scanCRLF",
              "documentation": {
                "identifier": "scanCRLF",
                "newPage": false,
                "searchKey": "server.scanCRLF",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func scanCRLF(data []byte, atEOF bool) (advance int, token []byte, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc scanCRLF(data []byte, atEOF bool) (advance int, token []byte, err error)\n```\n\nscanCRLF is similar to bufio.ScanLines except it splits on both '\\r' and '\\n' and it does not return tokens that contain only whitespace. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#setGitAttributes",
              "documentation": {
                "identifier": "setGitAttributes",
                "newPage": false,
                "searchKey": "server.setGitAttributes",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func setGitAttributes(dir GitDir) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setGitAttributes(dir GitDir) error\n```\n\nsetGitAttributes writes our global gitattributes to gitDir/info/attributes. This will override .gitattributes inside of repositories. It is used to unset attributes such as export-ignore. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#setHEAD",
              "documentation": {
                "identifier": "setHEAD",
                "newPage": false,
                "searchKey": "server.setHEAD",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func setHEAD(ctx context.Context, dir GitDir, syncer VCSSyncer, repo api.RepoName, remoteURL *vcs.URL) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setHEAD(ctx context.Context, dir GitDir, syncer VCSSyncer, repo api.RepoName, remoteURL *vcs.URL) error\n```\n\nsetHEAD configures git repo defaults (such as what HEAD is) which are needed for git commands to work. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#setLastChanged",
              "documentation": {
                "identifier": "setLastChanged",
                "newPage": false,
                "searchKey": "server.setLastChanged",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func setLastChanged(dir GitDir) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setLastChanged(dir GitDir) error\n```\n\nsetLastChanged discerns an approximate last-changed timestamp for a repository. This can be approximate; it's used to determine how often we should run `git fetch`, but is not relied on strongly. The basic plan is as follows: If a repository has never had a timestamp before, we guess that the right stamp is *probably* the timestamp of the most chronologically-recent commit. If there are no commits, we just use the current time because that's probably usually a temporary state. \n\nIf a timestamp already exists, we want to update it if and only if the set of references (as determined by `git show-ref`) has changed. \n\nTo accomplish this, we assert that the file `sg_refhash` in the git directory should, if it exists, contain a hash of the output of `git show-ref`, and have a timestamp of \"the last time this changed\", except that if we're creating that file for the first time, we set it to the timestamp of the top commit. We then compute the hash of the show-ref output, and store it in the file if and only if it's different from the current contents. \n\nIf show-ref fails, we use rev-list to determine whether that's just an empty repository (not an error) or some kind of actual error that is possibly causing our data to be incorrect, which should be reported. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#setRecloneTime",
              "documentation": {
                "identifier": "setRecloneTime",
                "newPage": false,
                "searchKey": "server.setRecloneTime",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func setRecloneTime(dir GitDir, now time.Time) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setRecloneTime(dir GitDir, now time.Time) error\n```\n\nsetRecloneTime sets the time a repository is cloned. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#setRepositoryType",
              "documentation": {
                "identifier": "setRepositoryType",
                "newPage": false,
                "searchKey": "server.setRepositoryType",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func setRepositoryType(dir GitDir, typ string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setRepositoryType(dir GitDir, typ string) error\n```\n\nsetRepositoryType sets the type of the repository. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#shortGitCommandSlow",
              "documentation": {
                "identifier": "shortGitCommandSlow",
                "newPage": false,
                "searchKey": "server.shortGitCommandSlow",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func shortGitCommandSlow(args []string) time.Duration"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc shortGitCommandSlow(args []string) time.Duration\n```\n\nshortGitCommandSlow returns the threshold for regarding an git command as slow. Some commands such as \"git archive\" are inherently slower than \"git rev-parse\", so this will return an appropriate threshold given the command. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#shortGitCommandTimeout",
              "documentation": {
                "identifier": "shortGitCommandTimeout",
                "newPage": false,
                "searchKey": "server.shortGitCommandTimeout",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func shortGitCommandTimeout(args []string) time.Duration"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc shortGitCommandTimeout(args []string) time.Duration\n```\n\nshortGitCommandTimeout returns the timeout for git commands that should not take a long time. Some commands such as \"git archive\" are allowed more time than \"git rev-parse\", so this will return an appropriate timeout given the command. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#staticGetRemoteURL",
              "documentation": {
                "identifier": "staticGetRemoteURL",
                "newPage": false,
                "searchKey": "server.staticGetRemoteURL",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func staticGetRemoteURL(remote string) func(context.Context, api.RepoName) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc staticGetRemoteURL(remote string) func(context.Context, api.RepoName) (string, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#updateFileIfDifferent",
              "documentation": {
                "identifier": "updateFileIfDifferent",
                "newPage": false,
                "searchKey": "server.updateFileIfDifferent",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func updateFileIfDifferent(path string, content []byte) (bool, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc updateFileIfDifferent(path string, content []byte) (bool, error)\n```\n\nupdateFileIfDifferent will atomically update the file if the contents are different. If it does an update ok is true. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#useRefspecOverrides",
              "documentation": {
                "identifier": "useRefspecOverrides",
                "newPage": false,
                "searchKey": "server.useRefspecOverrides",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func useRefspecOverrides() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc useRefspecOverrides() bool\n```\n\nHACK(keegancsmith) workaround to experiment with cloning less in a large monorepo. [https://github.com/sourcegraph/customer/issues/19](https://github.com/sourcegraph/customer/issues/19) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#wrapCmdError",
              "documentation": {
                "identifier": "wrapCmdError",
                "newPage": false,
                "searchKey": "server.wrapCmdError",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func wrapCmdError(cmd *exec.Cmd, err error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc wrapCmdError(cmd *exec.Cmd, err error) error\n```\n\nwrapCmdError will wrap errors for cmd to include the arguments. If the error is an exec.ExitError and cmd was invoked with Output(), it will also include the captured stderr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#writeFile",
              "documentation": {
                "identifier": "writeFile",
                "newPage": false,
                "searchKey": "server.writeFile",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeFile(t *testing.T, path string, content []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeFile(t *testing.T, path string, content []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/cmd/gitserver/server#writeTempFile",
              "documentation": {
                "identifier": "writeTempFile",
                "newPage": false,
                "searchKey": "server.writeTempFile",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeTempFile(pattern string, data []byte) (path string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeTempFile(pattern string, data []byte) (path string, err error)\n```\n\nwriteTempFile writes data to the TempFile with pattern. Returns the path of the tempfile. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
