{
  "pathID": "/internal/search/query",
  "documentation": {
    "identifier": "query",
    "newPage": true,
    "searchKey": "internal/search/query",
    "tags": [
      "package",
      "private"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package query"
  },
  "detail": {
    "kind": "markdown",
    "value": ""
  },
  "children": [
    {
      "node": {
        "pathID": "/internal/search/query#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package",
            "private"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/internal/search/query#AND",
              "documentation": {
                "identifier": "AND",
                "newPage": false,
                "searchKey": "query.AND",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const AND"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst AND keyword = \"and\"\n```\n\nReserved keyword syntax. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#And",
              "documentation": {
                "identifier": "And",
                "newPage": false,
                "searchKey": "query.And",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const And"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst And\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Any",
              "documentation": {
                "identifier": "Any",
                "newPage": false,
                "searchKey": "query.Any",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Any"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Any repoVisibility = \"any\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#BoolType",
              "documentation": {
                "identifier": "BoolType",
                "newPage": false,
                "searchKey": "query.BoolType",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const BoolType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst BoolType\n```\n\nAll ValueType values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Concat",
              "documentation": {
                "identifier": "Concat",
                "newPage": false,
                "searchKey": "query.Concat",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Concat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Concat\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#DQUOTE",
              "documentation": {
                "identifier": "DQUOTE",
                "newPage": false,
                "searchKey": "query.DQUOTE",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const DQUOTE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst DQUOTE keyword = \"\\\"\"\n```\n\nReserved keyword syntax. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldAfter",
              "documentation": {
                "identifier": "FieldAfter",
                "newPage": false,
                "searchKey": "query.FieldAfter",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldAfter"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldAfter = \"after\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldArchived",
              "documentation": {
                "identifier": "FieldArchived",
                "newPage": false,
                "searchKey": "query.FieldArchived",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldArchived"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldArchived = \"archived\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldAuthor",
              "documentation": {
                "identifier": "FieldAuthor",
                "newPage": false,
                "searchKey": "query.FieldAuthor",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldAuthor"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldAuthor = \"author\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldBefore",
              "documentation": {
                "identifier": "FieldBefore",
                "newPage": false,
                "searchKey": "query.FieldBefore",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldBefore"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldBefore = \"before\"\n```\n\nAll field names. \n\nFor diff and commit search only: \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldCase",
              "documentation": {
                "identifier": "FieldCase",
                "newPage": false,
                "searchKey": "query.FieldCase",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldCase"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldCase = \"case\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldCombyRule",
              "documentation": {
                "identifier": "FieldCombyRule",
                "newPage": false,
                "searchKey": "query.FieldCombyRule",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldCombyRule"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldCombyRule = \"rule\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldCommitter",
              "documentation": {
                "identifier": "FieldCommitter",
                "newPage": false,
                "searchKey": "query.FieldCommitter",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldCommitter"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldCommitter = \"committer\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldContent",
              "documentation": {
                "identifier": "FieldContent",
                "newPage": false,
                "searchKey": "query.FieldContent",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldContent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldContent = \"content\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldContext",
              "documentation": {
                "identifier": "FieldContext",
                "newPage": false,
                "searchKey": "query.FieldContext",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldContext"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldContext = \"context\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldCount",
              "documentation": {
                "identifier": "FieldCount",
                "newPage": false,
                "searchKey": "query.FieldCount",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldCount // Searches that specify `count:` will fetch at least that number of results, or the full result set\n = ...\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldDefault",
              "documentation": {
                "identifier": "FieldDefault",
                "newPage": false,
                "searchKey": "query.FieldDefault",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldDefault"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldDefault = \"\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldFile",
              "documentation": {
                "identifier": "FieldFile",
                "newPage": false,
                "searchKey": "query.FieldFile",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldFile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldFile = \"file\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldFork",
              "documentation": {
                "identifier": "FieldFork",
                "newPage": false,
                "searchKey": "query.FieldFork",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldFork"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldFork = \"fork\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldIndex",
              "documentation": {
                "identifier": "FieldIndex",
                "newPage": false,
                "searchKey": "query.FieldIndex",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldIndex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldIndex = \"index\"\n```\n\nAll field names. \n\nTemporary experimental fields: \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldLang",
              "documentation": {
                "identifier": "FieldLang",
                "newPage": false,
                "searchKey": "query.FieldLang",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldLang"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldLang = \"lang\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldMessage",
              "documentation": {
                "identifier": "FieldMessage",
                "newPage": false,
                "searchKey": "query.FieldMessage",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldMessage"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldMessage = \"message\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldPatternType",
              "documentation": {
                "identifier": "FieldPatternType",
                "newPage": false,
                "searchKey": "query.FieldPatternType",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldPatternType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldPatternType = \"patterntype\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldRepo",
              "documentation": {
                "identifier": "FieldRepo",
                "newPage": false,
                "searchKey": "query.FieldRepo",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldRepo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldRepo = \"repo\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldRepoGroup",
              "documentation": {
                "identifier": "FieldRepoGroup",
                "newPage": false,
                "searchKey": "query.FieldRepoGroup",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldRepoGroup"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldRepoGroup = \"repogroup\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldRepoHasCommitAfter",
              "documentation": {
                "identifier": "FieldRepoHasCommitAfter",
                "newPage": false,
                "searchKey": "query.FieldRepoHasCommitAfter",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldRepoHasCommitAfter"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldRepoHasCommitAfter = \"repohascommitafter\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldRepoHasFile",
              "documentation": {
                "identifier": "FieldRepoHasFile",
                "newPage": false,
                "searchKey": "query.FieldRepoHasFile",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldRepoHasFile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldRepoHasFile = \"repohasfile\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldRev",
              "documentation": {
                "identifier": "FieldRev",
                "newPage": false,
                "searchKey": "query.FieldRev",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldRev"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldRev = \"rev\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldSelect",
              "documentation": {
                "identifier": "FieldSelect",
                "newPage": false,
                "searchKey": "query.FieldSelect",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldSelect"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldSelect = \"select\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldStable",
              "documentation": {
                "identifier": "FieldStable",
                "newPage": false,
                "searchKey": "query.FieldStable",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldStable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldStable // Forces search to return a stable result ordering (currently limited to file content matches).\n = ...\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldTimeout",
              "documentation": {
                "identifier": "FieldTimeout",
                "newPage": false,
                "searchKey": "query.FieldTimeout",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldTimeout = \"timeout\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldType",
              "documentation": {
                "identifier": "FieldType",
                "newPage": false,
                "searchKey": "query.FieldType",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldType = \"type\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldVisibility",
              "documentation": {
                "identifier": "FieldVisibility",
                "newPage": false,
                "searchKey": "query.FieldVisibility",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldVisibility"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldVisibility = \"visibility\"\n```\n\nAll field names. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#HeuristicDanglingParens",
              "documentation": {
                "identifier": "HeuristicDanglingParens",
                "newPage": false,
                "searchKey": "query.HeuristicDanglingParens",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const HeuristicDanglingParens"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst HeuristicDanglingParens\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#HeuristicHoisted",
              "documentation": {
                "identifier": "HeuristicHoisted",
                "newPage": false,
                "searchKey": "query.HeuristicHoisted",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const HeuristicHoisted"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst HeuristicHoisted\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#HeuristicParensAsPatterns",
              "documentation": {
                "identifier": "HeuristicParensAsPatterns",
                "newPage": false,
                "searchKey": "query.HeuristicParensAsPatterns",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const HeuristicParensAsPatterns"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst HeuristicParensAsPatterns\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Invalid",
              "documentation": {
                "identifier": "Invalid",
                "newPage": false,
                "searchKey": "query.Invalid",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Invalid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Invalid YesNoOnly = \"invalid\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#IsPredicate",
              "documentation": {
                "identifier": "IsPredicate",
                "newPage": false,
                "searchKey": "query.IsPredicate",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const IsPredicate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IsPredicate\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#LPAREN",
              "documentation": {
                "identifier": "LPAREN",
                "newPage": false,
                "searchKey": "query.LPAREN",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const LPAREN"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst LPAREN keyword = \"(\"\n```\n\nReserved keyword syntax. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Literal",
              "documentation": {
                "identifier": "Literal",
                "newPage": false,
                "searchKey": "query.Literal",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Literal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Literal = 1 << iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#NOT",
              "documentation": {
                "identifier": "NOT",
                "newPage": false,
                "searchKey": "query.NOT",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const NOT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst NOT keyword = \"not\"\n```\n\nReserved keyword syntax. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#No",
              "documentation": {
                "identifier": "No",
                "newPage": false,
                "searchKey": "query.No",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const No"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst No YesNoOnly = \"no\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#None",
              "documentation": {
                "identifier": "None",
                "newPage": false,
                "searchKey": "query.None",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const None"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst None labels = 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#OR",
              "documentation": {
                "identifier": "OR",
                "newPage": false,
                "searchKey": "query.OR",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OR keyword = \"or\"\n```\n\nReserved keyword syntax. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Only",
              "documentation": {
                "identifier": "Only",
                "newPage": false,
                "searchKey": "query.Only",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Only"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Only YesNoOnly = \"only\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Or",
              "documentation": {
                "identifier": "Or",
                "newPage": false,
                "searchKey": "query.Or",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Or"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Or operatorKind = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Private",
              "documentation": {
                "identifier": "Private",
                "newPage": false,
                "searchKey": "query.Private",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Private"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Private repoVisibility = \"private\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Public",
              "documentation": {
                "identifier": "Public",
                "newPage": false,
                "searchKey": "query.Public",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Public"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Public repoVisibility = \"public\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Quoted",
              "documentation": {
                "identifier": "Quoted",
                "newPage": false,
                "searchKey": "query.Quoted",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Quoted"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Quoted\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#RPAREN",
              "documentation": {
                "identifier": "RPAREN",
                "newPage": false,
                "searchKey": "query.RPAREN",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RPAREN"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RPAREN keyword = \")\"\n```\n\nReserved keyword syntax. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Regexp",
              "documentation": {
                "identifier": "Regexp",
                "newPage": false,
                "searchKey": "query.Regexp",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Regexp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Regexp\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#RegexpType",
              "documentation": {
                "identifier": "RegexpType",
                "newPage": false,
                "searchKey": "query.RegexpType",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RegexpType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RegexpType\n```\n\nAll ValueType values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#SLASH",
              "documentation": {
                "identifier": "SLASH",
                "newPage": false,
                "searchKey": "query.SLASH",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SLASH"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SLASH keyword = \"/\"\n```\n\nReserved keyword syntax. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#SQUOTE",
              "documentation": {
                "identifier": "SQUOTE",
                "newPage": false,
                "searchKey": "query.SQUOTE",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SQUOTE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SQUOTE keyword = \"'\"\n```\n\nReserved keyword syntax. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#SearchTypeLiteral",
              "documentation": {
                "identifier": "SearchTypeLiteral",
                "newPage": false,
                "searchKey": "query.SearchTypeLiteral",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SearchTypeLiteral"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SearchTypeLiteral\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#SearchTypeRegex",
              "documentation": {
                "identifier": "SearchTypeRegex",
                "newPage": false,
                "searchKey": "query.SearchTypeRegex",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SearchTypeRegex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SearchTypeRegex SearchType = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#SearchTypeStructural",
              "documentation": {
                "identifier": "SearchTypeStructural",
                "newPage": false,
                "searchKey": "query.SearchTypeStructural",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SearchTypeStructural"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SearchTypeStructural\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#StringType",
              "documentation": {
                "identifier": "StringType",
                "newPage": false,
                "searchKey": "query.StringType",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StringType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StringType ValueType = 1 << iota\n```\n\nAll ValueType values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Structural",
              "documentation": {
                "identifier": "Structural",
                "newPage": false,
                "searchKey": "query.Structural",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Structural"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Structural\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Yes",
              "documentation": {
                "identifier": "Yes",
                "newPage": false,
                "searchKey": "query.Yes",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Yes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Yes YesNoOnly = \"yes\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#allowDanglingParens",
              "documentation": {
                "identifier": "allowDanglingParens",
                "newPage": false,
                "searchKey": "query.allowDanglingParens",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const allowDanglingParens"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst allowDanglingParens\n```\n\nIf set, all parentheses, whether balanced or unbalanced, are parsed as literal search patterns (i.e., interpreting parentheses as expression groups is completely disabled). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#disambiguated",
              "documentation": {
                "identifier": "disambiguated",
                "newPage": false,
                "searchKey": "query.disambiguated",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const disambiguated"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst disambiguated\n```\n\nIf set, implies that at least one expression was disambiguated by explicit parentheses. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#parensAsPatterns",
              "documentation": {
                "identifier": "parensAsPatterns",
                "newPage": false,
                "searchKey": "query.parensAsPatterns",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const parensAsPatterns"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst parensAsPatterns heuristics = 1 << iota\n```\n\nIf set, balanced parentheses, which would normally be treated as delimiting expression groups, may in select cases be parsed as literal search patterns instead. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/internal/search/query#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package",
            "private"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/internal/search/query#DefaultPredicateRegistry",
              "documentation": {
                "identifier": "DefaultPredicateRegistry",
                "newPage": false,
                "searchKey": "query.DefaultPredicateRegistry",
                "tags": [
                  "variable",
                  "object"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var DefaultPredicateRegistry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar DefaultPredicateRegistry = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ErrBadGlobPattern",
              "documentation": {
                "identifier": "ErrBadGlobPattern",
                "newPage": false,
                "searchKey": "query.ErrBadGlobPattern",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrBadGlobPattern"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrBadGlobPattern = errors.New(\"syntax error in glob pattern\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#aliases",
              "documentation": {
                "identifier": "aliases",
                "newPage": false,
                "searchKey": "query.aliases",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var aliases"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar aliases = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#allFields",
              "documentation": {
                "identifier": "allFields",
                "newPage": false,
                "searchKey": "query.allFields",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var allFields"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allFields = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#allLabels",
              "documentation": {
                "identifier": "allLabels",
                "newPage": false,
                "searchKey": "query.allLabels",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var allLabels"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allLabels = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#empty",
              "documentation": {
                "identifier": "empty",
                "newPage": false,
                "searchKey": "query.empty",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var empty"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar empty = struct{}{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#gitHubRepoPath",
              "documentation": {
                "identifier": "gitHubRepoPath",
                "newPage": false,
                "searchKey": "query.gitHubRepoPath",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var gitHubRepoPath"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gitHubRepoPath = lazyregexp.New(`github\\.com\\/([a-z\\d]+-)*[a-z\\d]+\\/(.+)`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#globSpecialSymbols",
              "documentation": {
                "identifier": "globSpecialSymbols",
                "newPage": false,
                "searchKey": "query.globSpecialSymbols",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var globSpecialSymbols"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar globSpecialSymbols = map[rune]struct{}{\n\t'\\\\': {},\n\t'*':  {},\n\t'?':  {},\n\t'[':  {},\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#globSyntax",
              "documentation": {
                "identifier": "globSyntax",
                "newPage": false,
                "searchKey": "query.globSyntax",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var globSyntax"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar globSyntax = lazyregexp.New(`[][*?]`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#nameIndex",
              "documentation": {
                "identifier": "nameIndex",
                "newPage": false,
                "searchKey": "query.nameIndex",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var nameIndex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar nameIndex = predicateRegexp.SubexpIndex(\"name\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#paramsIndex",
              "documentation": {
                "identifier": "paramsIndex",
                "newPage": false,
                "searchKey": "query.paramsIndex",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var paramsIndex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar paramsIndex = predicateRegexp.SubexpIndex(\"params\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#predicateRegexp",
              "documentation": {
                "identifier": "predicateRegexp",
                "newPage": false,
                "searchKey": "query.predicateRegexp",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var predicateRegexp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar predicateRegexp = regexp.MustCompile(`^(?P<name>[a-z\\.]+)\\((?s:(?P<params>.*))\\)$`)\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/internal/search/query#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package",
            "private"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/internal/search/query#Annotation",
              "documentation": {
                "identifier": "Annotation",
                "newPage": false,
                "searchKey": "query.Annotation",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Annotation struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Annotation struct {\n\tLabels labels `json:\"labels\"`\n\tRange  Range  `json:\"range\"`\n}\n```\n\nAn annotation stores information associated with a node. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#BaseMapper",
              "documentation": {
                "identifier": "BaseMapper",
                "newPage": false,
                "searchKey": "query.BaseMapper",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type BaseMapper struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype BaseMapper struct{}\n```\n\nThe BaseMapper is a mapper that recursively visits each node in a query and maps it to itself. A BaseMapper's methods may be overriden by embedding it a custom mapper's definition. See ParameterMapper for an example. If the methods return nil, the respective node is removed. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#BaseMapper.MapNodes",
                    "documentation": {
                      "identifier": "BaseMapper.MapNodes",
                      "newPage": false,
                      "searchKey": "query.BaseMapper.MapNodes",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*BaseMapper) MapNodes(mapper Mapper, nodes []Node) []Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*BaseMapper) MapNodes(mapper Mapper, nodes []Node) []Node\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#BaseMapper.MapOperator",
                    "documentation": {
                      "identifier": "BaseMapper.MapOperator",
                      "newPage": false,
                      "searchKey": "query.BaseMapper.MapOperator",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*BaseMapper) MapOperator(mapper Mapper, kind operatorKind, operands []Node) []Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*BaseMapper) MapOperator(mapper Mapper, kind operatorKind, operands []Node) []Node\n```\n\nBase mapper for Operators. Reduces operands if changed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#BaseMapper.MapParameter",
                    "documentation": {
                      "identifier": "BaseMapper.MapParameter",
                      "newPage": false,
                      "searchKey": "query.BaseMapper.MapParameter",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*BaseMapper) MapParameter(mapper Mapper, field, value string, negated bool, annotation Annotation) Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*BaseMapper) MapParameter(mapper Mapper, field, value string, negated bool, annotation Annotation) Node\n```\n\nBase mapper for Parameters. It is the identity function. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#BaseMapper.MapPattern",
                    "documentation": {
                      "identifier": "BaseMapper.MapPattern",
                      "newPage": false,
                      "searchKey": "query.BaseMapper.MapPattern",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*BaseMapper) MapPattern(mapper Mapper, value string, negated bool, annotation Annotation) Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*BaseMapper) MapPattern(mapper Mapper, value string, negated bool, annotation Annotation) Node\n```\n\nBase mapper for Patterns. It is the identity function. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#BaseVisitor",
              "documentation": {
                "identifier": "BaseVisitor",
                "newPage": false,
                "searchKey": "query.BaseVisitor",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type BaseVisitor struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype BaseVisitor struct{}\n```\n\nBaseVisitor is a visitor that recursively visits each node in a query. A BaseVisitor's methods may be overriden by embedding it a custom visitor's definition. See OperatorVisitor for an example. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#BaseVisitor.VisitNodes",
                    "documentation": {
                      "identifier": "BaseVisitor.VisitNodes",
                      "newPage": false,
                      "searchKey": "query.BaseVisitor.VisitNodes",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*BaseVisitor) VisitNodes(visitor Visitor, nodes []Node)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*BaseVisitor) VisitNodes(visitor Visitor, nodes []Node)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#BaseVisitor.VisitOperator",
                    "documentation": {
                      "identifier": "BaseVisitor.VisitOperator",
                      "newPage": false,
                      "searchKey": "query.BaseVisitor.VisitOperator",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*BaseVisitor) VisitOperator(visitor Visitor, kind operatorKind, operands []Node)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*BaseVisitor) VisitOperator(visitor Visitor, kind operatorKind, operands []Node)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#BaseVisitor.VisitParameter",
                    "documentation": {
                      "identifier": "BaseVisitor.VisitParameter",
                      "newPage": false,
                      "searchKey": "query.BaseVisitor.VisitParameter",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*BaseVisitor) VisitParameter(visitor Visitor, field, value string, negated bool, annotation Annotation)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*BaseVisitor) VisitParameter(visitor Visitor, field, value string, negated bool, annotation Annotation)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#BaseVisitor.VisitPattern",
                    "documentation": {
                      "identifier": "BaseVisitor.VisitPattern",
                      "newPage": false,
                      "searchKey": "query.BaseVisitor.VisitPattern",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*BaseVisitor) VisitPattern(visitor Visitor, value string, negated bool, annotation Annotation)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*BaseVisitor) VisitPattern(visitor Visitor, value string, negated bool, annotation Annotation)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Basic",
              "documentation": {
                "identifier": "Basic",
                "newPage": false,
                "searchKey": "query.Basic",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Basic struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Basic struct {\n\tPattern    Node\n\tParameters []Parameter\n}\n```\n\nBasic represents a leaf expression to evaluate in our search engine. A basic query comprises: \n\n```\n(1) a single search pattern expression, which may contain\n    'and' or 'or' operators; and\n(2) parameters that scope the evaluation of search\n    patterns (e.g., to repos, files, etc.).\n\n```\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#ConcatRevFilters",
                    "documentation": {
                      "identifier": "ConcatRevFilters",
                      "newPage": false,
                      "searchKey": "query.ConcatRevFilters",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ConcatRevFilters(b Basic) Basic"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ConcatRevFilters(b Basic) Basic\n```\n\nconcatRevFilters removes rev: filters from parameters and attaches their value as @rev to the repo: filters. Invariant: Guaranteed to succeed on a validat Basic query. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Identity",
                    "documentation": {
                      "identifier": "Identity",
                      "newPage": false,
                      "searchKey": "query.Identity",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Identity(b Basic) Basic"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Identity(b Basic) Basic\n```\n\nIdentity is the identity transformer for basic queries. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#PatternToFile",
                    "documentation": {
                      "identifier": "PatternToFile",
                      "newPage": false,
                      "searchKey": "query.PatternToFile",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func PatternToFile(b Basic) Basic"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc PatternToFile(b Basic) Basic\n```\n\nPatternToFile transforms a search query such that `file:` is prefixed to the pattern. This transformation is used for generating suggestions. Succeeds only when the pattern expression is an atom. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#ToBasicQuery",
                    "documentation": {
                      "identifier": "ToBasicQuery",
                      "newPage": false,
                      "searchKey": "query.ToBasicQuery",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ToBasicQuery(nodes []Node) (Basic, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ToBasicQuery(nodes []Node) (Basic, error)\n```\n\nConverts a parse tree to a basic query by attempting to obtain a valid partition. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.AddCount",
                    "documentation": {
                      "identifier": "Basic.AddCount",
                      "newPage": false,
                      "searchKey": "query.Basic.AddCount",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) AddCount(count int) Basic"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) AddCount(count int) Basic\n```\n\nAddCount adds a count parameter to a basic query. Behavior of AddCount on a query that already has a count parameter is undefined. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.FindParameter",
                    "documentation": {
                      "identifier": "Basic.FindParameter",
                      "newPage": false,
                      "searchKey": "query.Basic.FindParameter",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) FindParameter(field string, f func(value string, negated bool, annotation Annotation))"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) FindParameter(field string, f func(value string, negated bool, annotation Annotation))\n```\n\nFindParameter calls f on parameters matching field in b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.FindValue",
                    "documentation": {
                      "identifier": "Basic.FindValue",
                      "newPage": false,
                      "searchKey": "query.Basic.FindValue",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) FindValue(field string) (value string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) FindValue(field string) (value string)\n```\n\nFindValue returns the first value of a parameter matching field in b. It doesn't inspect whether the field is negated. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.GetCount",
                    "documentation": {
                      "identifier": "Basic.GetCount",
                      "newPage": false,
                      "searchKey": "query.Basic.GetCount",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) GetCount() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) GetCount() string\n```\n\nGetCount returns the string value of the \"count:\" field. Returns empty string if none. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.HasPatternLabel",
                    "documentation": {
                      "identifier": "Basic.HasPatternLabel",
                      "newPage": false,
                      "searchKey": "query.Basic.HasPatternLabel",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) HasPatternLabel(label labels) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) HasPatternLabel(label labels) bool\n```\n\nHasPatternLabel returns whether a pattern atom has a specified label. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.Index",
                    "documentation": {
                      "identifier": "Basic.Index",
                      "newPage": false,
                      "searchKey": "query.Basic.Index",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) Index() YesNoOnly"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) Index() YesNoOnly\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.IsCaseSensitive",
                    "documentation": {
                      "identifier": "Basic.IsCaseSensitive",
                      "newPage": false,
                      "searchKey": "query.Basic.IsCaseSensitive",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) IsCaseSensitive() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) IsCaseSensitive() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.IsLiteral",
                    "documentation": {
                      "identifier": "Basic.IsLiteral",
                      "newPage": false,
                      "searchKey": "query.Basic.IsLiteral",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) IsLiteral() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) IsLiteral() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.IsRegexp",
                    "documentation": {
                      "identifier": "Basic.IsRegexp",
                      "newPage": false,
                      "searchKey": "query.Basic.IsRegexp",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) IsRegexp() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) IsRegexp() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.IsStructural",
                    "documentation": {
                      "identifier": "Basic.IsStructural",
                      "newPage": false,
                      "searchKey": "query.Basic.IsStructural",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) IsStructural() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) IsStructural() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.MapCount",
                    "documentation": {
                      "identifier": "Basic.MapCount",
                      "newPage": false,
                      "searchKey": "query.Basic.MapCount",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) MapCount(count int) Basic"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) MapCount(count int) Basic\n```\n\nMapCount returns a copy of a basic query with a count parameter set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.MapParameters",
                    "documentation": {
                      "identifier": "Basic.MapParameters",
                      "newPage": false,
                      "searchKey": "query.Basic.MapParameters",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) MapParameters(parameters []Parameter) Basic"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) MapParameters(parameters []Parameter) Basic\n```\n\nMapParameters returns a copy of a basic query with updated parameters. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.MapPattern",
                    "documentation": {
                      "identifier": "Basic.MapPattern",
                      "newPage": false,
                      "searchKey": "query.Basic.MapPattern",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) MapPattern(pattern Node) Basic"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) MapPattern(pattern Node) Basic\n```\n\nMapPattern returns a copy of a basic query with updated pattern. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.String",
                    "documentation": {
                      "identifier": "Basic.String",
                      "newPage": false,
                      "searchKey": "query.Basic.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.ToParseTree",
                    "documentation": {
                      "identifier": "Basic.ToParseTree",
                      "newPage": false,
                      "searchKey": "query.Basic.ToParseTree",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) ToParseTree() Q"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) ToParseTree() Q\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Basic.VisitParameter",
                    "documentation": {
                      "identifier": "Basic.VisitParameter",
                      "newPage": false,
                      "searchKey": "query.Basic.VisitParameter",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b Basic) VisitParameter(field string, f func(value string, negated bool, annotation Annotation))"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b Basic) VisitParameter(field string, f func(value string, negated bool, annotation Annotation))\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#BasicPass",
              "documentation": {
                "identifier": "BasicPass",
                "newPage": false,
                "searchKey": "query.BasicPass",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type BasicPass func(github.com/sourcegraph/sourcegraph/internal/search/query.Basic) github.com/sourcegraph/sourcegraph/internal/search/query.Basic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype BasicPass func(Basic) Basic\n```\n\nA BasicPass is a transformation on Basic queries. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ExpectedOperand",
              "documentation": {
                "identifier": "ExpectedOperand",
                "newPage": false,
                "searchKey": "query.ExpectedOperand",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ExpectedOperand struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ExpectedOperand struct {\n\tMsg string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#ExpectedOperand.Error",
                    "documentation": {
                      "identifier": "ExpectedOperand.Error",
                      "newPage": false,
                      "searchKey": "query.ExpectedOperand.Error",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *ExpectedOperand) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *ExpectedOperand) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldMapper",
              "documentation": {
                "identifier": "FieldMapper",
                "newPage": false,
                "searchKey": "query.FieldMapper",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type FieldMapper struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FieldMapper struct {\n\tBaseMapper\n\tfield    string\n\tcallback func(value string, negated bool) Node\n}\n```\n\nFieldMapper is a helper mapper that only maps patterns in a query, for a field specified in state. For each parameter with this field name it calls the callback that maps the field's members. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#FieldMapper.MapParameter",
                    "documentation": {
                      "identifier": "FieldMapper.MapParameter",
                      "newPage": false,
                      "searchKey": "query.FieldMapper.MapParameter",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *FieldMapper) MapParameter(mapper Mapper, field, value string, negated bool, annotation Annotation) Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *FieldMapper) MapParameter(mapper Mapper, field, value string, negated bool, annotation Annotation) Node\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FieldVisitor",
              "documentation": {
                "identifier": "FieldVisitor",
                "newPage": false,
                "searchKey": "query.FieldVisitor",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type FieldVisitor struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FieldVisitor struct {\n\tBaseVisitor\n\tfield    string\n\tcallback func(value string, negated bool, annotation Annotation)\n}\n```\n\nFieldVisitor is a helper visitor that only visits parameter fields in a query, for a field specified in the state. For each parameter with this field name it calls the callback with the field's members. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#FieldVisitor.VisitParameter",
                    "documentation": {
                      "identifier": "FieldVisitor.VisitParameter",
                      "newPage": false,
                      "searchKey": "query.FieldVisitor.VisitParameter",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *FieldVisitor) VisitParameter(visitor Visitor, field, value string, negated bool, annotation Annotation)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *FieldVisitor) VisitParameter(visitor Visitor, field, value string, negated bool, annotation Annotation)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Mapper",
              "documentation": {
                "identifier": "Mapper",
                "newPage": false,
                "searchKey": "query.Mapper",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Mapper interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Mapper interface {\n\tMapNodes(m Mapper, node []Node) []Node\n\tMapOperator(m Mapper, kind operatorKind, operands []Node) []Node\n\tMapParameter(m Mapper, field, value string, negated bool, annotation Annotation) Node\n\tMapPattern(m Mapper, value string, negated bool, annotation Annotation) Node\n}\n```\n\nThe Mapper interface allows to replace nodes for each respective part of the query grammar. It is a visitor that will replace the visited node by the returned value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Node",
              "documentation": {
                "identifier": "Node",
                "newPage": false,
                "searchKey": "query.Node",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Node interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Node interface {\n\tString() string\n\tnode()\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#PartitionSearchPattern",
                    "documentation": {
                      "identifier": "PartitionSearchPattern",
                      "newPage": false,
                      "searchKey": "query.PartitionSearchPattern",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func PartitionSearchPattern(nodes []Node) (parameters []Parameter, pattern Node, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc PartitionSearchPattern(nodes []Node) (parameters []Parameter, pattern Node, err error)\n```\n\nPartitionSearchPattern partitions an and/or query into (1) a single search pattern expression and (2) other parameters that scope the evaluation of search patterns (e.g., to repos, files, etc.). It validates that a query contains at most one search pattern expression and that scope parameters do not contain nested expressions. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Operator",
              "documentation": {
                "identifier": "Operator",
                "newPage": false,
                "searchKey": "query.Operator",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Operator struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Operator struct {\n\tKind       operatorKind\n\tOperands   []Node\n\tAnnotation Annotation\n}\n```\n\nOperator is a nonterminal node of kind Kind with child nodes Operands. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#Operator.String",
                    "documentation": {
                      "identifier": "Operator.String",
                      "newPage": false,
                      "searchKey": "query.Operator.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (node Operator) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (node Operator) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Operator.node",
                    "documentation": {
                      "identifier": "Operator.node",
                      "newPage": false,
                      "searchKey": "query.Operator.node",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (Operator) node()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (Operator) node()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#OperatorMapper",
              "documentation": {
                "identifier": "OperatorMapper",
                "newPage": false,
                "searchKey": "query.OperatorMapper",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type OperatorMapper struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype OperatorMapper struct {\n\tBaseMapper\n\tcallback func(kind operatorKind, operands []Node) []Node\n}\n```\n\nOperatorMapper is a helper mapper that maps operators in a query. It takes as state a callback that will call and map each visited operator with the return value. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#OperatorMapper.MapOperator",
                    "documentation": {
                      "identifier": "OperatorMapper.MapOperator",
                      "newPage": false,
                      "searchKey": "query.OperatorMapper.MapOperator",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *OperatorMapper) MapOperator(mapper Mapper, kind operatorKind, operands []Node) []Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *OperatorMapper) MapOperator(mapper Mapper, kind operatorKind, operands []Node) []Node\n```\n\nMapOperator implements OperatorMapper by overriding the BaseMapper's value to substitute a node computed by the callback. It reduces any substituted node. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#OperatorVisitor",
              "documentation": {
                "identifier": "OperatorVisitor",
                "newPage": false,
                "searchKey": "query.OperatorVisitor",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type OperatorVisitor struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype OperatorVisitor struct {\n\tBaseVisitor\n\tcallback func(kind operatorKind, operands []Node)\n}\n```\n\nParameterVisitor is a helper visitor that only visits operators in a query, and supplies the operator members via a callback. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#OperatorVisitor.VisitOperator",
                    "documentation": {
                      "identifier": "OperatorVisitor.VisitOperator",
                      "newPage": false,
                      "searchKey": "query.OperatorVisitor.VisitOperator",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *OperatorVisitor) VisitOperator(visitor Visitor, kind operatorKind, operands []Node)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *OperatorVisitor) VisitOperator(visitor Visitor, kind operatorKind, operands []Node)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Parameter",
              "documentation": {
                "identifier": "Parameter",
                "newPage": false,
                "searchKey": "query.Parameter",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Parameter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Parameter struct {\n\tField      string     `json:\"field\"`   // The repo part in repo:sourcegraph.\n\tValue      string     `json:\"value\"`   // The sourcegraph part in repo:sourcegraph.\n\tNegated    bool       `json:\"negated\"` // True if the - prefix exists, as in -repo:sourcegraph.\n\tAnnotation Annotation `json:\"-\"`\n}\n```\n\nParameter is a leaf node of expressions representing a parameter of format \"repo:foo\". \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#Parameter.String",
                    "documentation": {
                      "identifier": "Parameter.String",
                      "newPage": false,
                      "searchKey": "query.Parameter.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (node Parameter) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (node Parameter) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Parameter.node",
                    "documentation": {
                      "identifier": "Parameter.node",
                      "newPage": false,
                      "searchKey": "query.Parameter.node",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (Parameter) node()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (Parameter) node()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ParameterMapper",
              "documentation": {
                "identifier": "ParameterMapper",
                "newPage": false,
                "searchKey": "query.ParameterMapper",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ParameterMapper struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ParameterMapper struct {\n\tBaseMapper\n\tcallback func(field, value string, negated bool, annotation Annotation) Node\n}\n```\n\nParameterMapper is a helper mapper that only maps parameters in a query. It takes as state a callback that will call and map each visited parameter by the return value. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#ParameterMapper.MapParameter",
                    "documentation": {
                      "identifier": "ParameterMapper.MapParameter",
                      "newPage": false,
                      "searchKey": "query.ParameterMapper.MapParameter",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *ParameterMapper) MapParameter(mapper Mapper, field, value string, negated bool, annotation Annotation) Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *ParameterMapper) MapParameter(mapper Mapper, field, value string, negated bool, annotation Annotation) Node\n```\n\nMapParameter implements ParameterMapper by overriding the BaseMapper's value to substitute a node computed by the callback. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ParameterVisitor",
              "documentation": {
                "identifier": "ParameterVisitor",
                "newPage": false,
                "searchKey": "query.ParameterVisitor",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ParameterVisitor struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ParameterVisitor struct {\n\tBaseVisitor\n\tcallback func(field, value string, negated bool, annotation Annotation)\n}\n```\n\nParameterVisitor is a helper visitor that only visits parameters in a query, and supplies the parameter members via a callback. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#ParameterVisitor.VisitParameter",
                    "documentation": {
                      "identifier": "ParameterVisitor.VisitParameter",
                      "newPage": false,
                      "searchKey": "query.ParameterVisitor.VisitParameter",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *ParameterVisitor) VisitParameter(visitor Visitor, field, value string, negated bool, annotation Annotation)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *ParameterVisitor) VisitParameter(visitor Visitor, field, value string, negated bool, annotation Annotation)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Pattern",
              "documentation": {
                "identifier": "Pattern",
                "newPage": false,
                "searchKey": "query.Pattern",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Pattern struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Pattern struct {\n\tValue      string     `json:\"value\"`   // The pattern value.\n\tNegated    bool       `json:\"negated\"` // True if this pattern is negated.\n\tAnnotation Annotation `json:\"-\"`       // An annotation attached to this pattern.\n}\n```\n\nPattern is a leaf node of expressions representing a search pattern fragment. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#fuzzyRegexp",
                    "documentation": {
                      "identifier": "fuzzyRegexp",
                      "newPage": false,
                      "searchKey": "query.fuzzyRegexp",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func fuzzyRegexp(patterns []Pattern) Pattern"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc fuzzyRegexp(patterns []Pattern) Pattern\n```\n\nfuzzyRegexp interpolates patterns with .*? regular expressions and concatenates them. Invariant: len(patterns) > 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#newPattern",
                    "documentation": {
                      "identifier": "newPattern",
                      "newPage": false,
                      "searchKey": "query.newPattern",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newPattern(value string, negated bool, labels labels, range_ Range) Pattern"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newPattern(value string, negated bool, labels labels, range_ Range) Pattern\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#space",
                    "documentation": {
                      "identifier": "space",
                      "newPage": false,
                      "searchKey": "query.space",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func space(patterns []Pattern) Pattern"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc space(patterns []Pattern) Pattern\n```\n\nfuzzyRegexp interpolates patterns with spaces and concatenates them. Invariant: len(patterns) > 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Pattern.String",
                    "documentation": {
                      "identifier": "Pattern.String",
                      "newPage": false,
                      "searchKey": "query.Pattern.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (node Pattern) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (node Pattern) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Pattern.node",
                    "documentation": {
                      "identifier": "Pattern.node",
                      "newPage": false,
                      "searchKey": "query.Pattern.node",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (Pattern) node()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (Pattern) node()\n```\n\nAll terms that implement Node. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#PatternMapper",
              "documentation": {
                "identifier": "PatternMapper",
                "newPage": false,
                "searchKey": "query.PatternMapper",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type PatternMapper struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PatternMapper struct {\n\tBaseMapper\n\tcallback func(value string, negated bool, annotation Annotation) Node\n}\n```\n\nPatternMapper is a helper mapper that only maps patterns in a query. It takes as state a callback that will call and map each visited pattern by the return value. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#PatternMapper.MapPattern",
                    "documentation": {
                      "identifier": "PatternMapper.MapPattern",
                      "newPage": false,
                      "searchKey": "query.PatternMapper.MapPattern",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *PatternMapper) MapPattern(mapper Mapper, value string, negated bool, annotation Annotation) Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *PatternMapper) MapPattern(mapper Mapper, value string, negated bool, annotation Annotation) Node\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#PatternVisitor",
              "documentation": {
                "identifier": "PatternVisitor",
                "newPage": false,
                "searchKey": "query.PatternVisitor",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type PatternVisitor struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PatternVisitor struct {\n\tBaseVisitor\n\tcallback func(value string, negated bool, annotation Annotation)\n}\n```\n\nPatternVisitor is a helper visitor that only visits patterns in a query, and supplies the pattern members via a callback. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#PatternVisitor.VisitPattern",
                    "documentation": {
                      "identifier": "PatternVisitor.VisitPattern",
                      "newPage": false,
                      "searchKey": "query.PatternVisitor.VisitPattern",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *PatternVisitor) VisitPattern(visitor Visitor, value string, negated bool, annotation Annotation)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *PatternVisitor) VisitPattern(visitor Visitor, value string, negated bool, annotation Annotation)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Plan",
              "documentation": {
                "identifier": "Plan",
                "newPage": false,
                "searchKey": "query.Plan",
                "tags": [
                  "array",
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Plan []query.Basic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Plan []Basic\n```\n\nA query plan represents a set of disjoint queries for the search engine to execute. The result of executing a plan is the union of individual query results. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#MapPlan",
                    "documentation": {
                      "identifier": "MapPlan",
                      "newPage": false,
                      "searchKey": "query.MapPlan",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MapPlan(plan Plan, pass BasicPass) Plan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MapPlan(plan Plan, pass BasicPass) Plan\n```\n\nMapPlan applies a conversion to all Basic queries in a plan. It expects a valid plan. guarantee transformation succeeds. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Pipeline",
                    "documentation": {
                      "identifier": "Pipeline",
                      "newPage": false,
                      "searchKey": "query.Pipeline",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Pipeline(steps ...step) (Plan, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Pipeline(steps ...step) (Plan, error)\n```\n\nPipeline processes zero or more steps to produce a query. The first step must be Init, otherwise this function is a no-op. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#ToPlan",
                    "documentation": {
                      "identifier": "ToPlan",
                      "newPage": false,
                      "searchKey": "query.ToPlan",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ToPlan(disjuncts [][]Node) (Plan, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ToPlan(disjuncts [][]Node) (Plan, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Plan.ToParseTree",
                    "documentation": {
                      "identifier": "Plan.ToParseTree",
                      "newPage": false,
                      "searchKey": "query.Plan.ToParseTree",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p Plan) ToParseTree() Q"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p Plan) ToParseTree() Q\n```\n\nToParseTree models a plan as a parse tree of an Or-expression on plan queries. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Predicate",
              "documentation": {
                "identifier": "Predicate",
                "newPage": false,
                "searchKey": "query.Predicate",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Predicate interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Predicate interface {\n\t// Field is the name of the field that the predicate applies to.\n\t// For example, with `file:contains()`, Field returns \"file\".\n\tField() string\n\n\t// Name is the name of the predicate.\n\t// For example, with `file:contains()`, Name returns \"contains\".\n\tName() string\n\n\t// ParseParams parses the contents of the predicate arguments\n\t// into the predicate object.\n\tParseParams(string) error\n\n\t// Plan generates a plan of (possibly multiple) queries to execute the\n\t// behavior of a predicate in a query Q.\n\tPlan(parent Basic) (Plan, error)\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Q",
              "documentation": {
                "identifier": "Q",
                "newPage": false,
                "searchKey": "query.Q",
                "tags": [
                  "array",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Q []query.Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Q []Node\n```\n\nA query is a tree of Nodes. We choose the type name Q so that external uses like query.Q do not stutter. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#ParseLiteral",
                    "documentation": {
                      "identifier": "ParseLiteral",
                      "newPage": false,
                      "searchKey": "query.ParseLiteral",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseLiteral(in string) (Q, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseLiteral(in string) (Q, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#ParseRegexp",
                    "documentation": {
                      "identifier": "ParseRegexp",
                      "newPage": false,
                      "searchKey": "query.ParseRegexp",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseRegexp(in string) (Q, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseRegexp(in string) (Q, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#ParseSearchType",
                    "documentation": {
                      "identifier": "ParseSearchType",
                      "newPage": false,
                      "searchKey": "query.ParseSearchType",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseSearchType(in string, searchType SearchType) (Q, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseSearchType(in string, searchType SearchType) (Q, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.Archived",
                    "documentation": {
                      "identifier": "Q.Archived",
                      "newPage": false,
                      "searchKey": "query.Q.Archived",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) Archived() *YesNoOnly"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) Archived() *YesNoOnly\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.BoolValue",
                    "documentation": {
                      "identifier": "Q.BoolValue",
                      "newPage": false,
                      "searchKey": "query.Q.BoolValue",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) BoolValue(field string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) BoolValue(field string) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.Count",
                    "documentation": {
                      "identifier": "Q.Count",
                      "newPage": false,
                      "searchKey": "query.Q.Count",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) Count() *int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) Count() *int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.Fields",
                    "documentation": {
                      "identifier": "Q.Fields",
                      "newPage": false,
                      "searchKey": "query.Q.Fields",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) Fields() map[string][]*Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) Fields() map[string][]*Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.Fork",
                    "documentation": {
                      "identifier": "Q.Fork",
                      "newPage": false,
                      "searchKey": "query.Q.Fork",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) Fork() *YesNoOnly"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) Fork() *YesNoOnly\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.IsCaseSensitive",
                    "documentation": {
                      "identifier": "Q.IsCaseSensitive",
                      "newPage": false,
                      "searchKey": "query.Q.IsCaseSensitive",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) IsCaseSensitive() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) IsCaseSensitive() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.RegexpPatterns",
                    "documentation": {
                      "identifier": "Q.RegexpPatterns",
                      "newPage": false,
                      "searchKey": "query.Q.RegexpPatterns",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) RegexpPatterns(field string) (values, negatedValues []string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) RegexpPatterns(field string) (values, negatedValues []string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.Repositories",
                    "documentation": {
                      "identifier": "Q.Repositories",
                      "newPage": false,
                      "searchKey": "query.Q.Repositories",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) Repositories() (repos []string, negatedRepos []string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) Repositories() (repos []string, negatedRepos []string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.String",
                    "documentation": {
                      "identifier": "Q.String",
                      "newPage": false,
                      "searchKey": "query.Q.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.StringValue",
                    "documentation": {
                      "identifier": "Q.StringValue",
                      "newPage": false,
                      "searchKey": "query.Q.StringValue",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) StringValue(field string) (value, negatedValue string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) StringValue(field string) (value, negatedValue string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.StringValues",
                    "documentation": {
                      "identifier": "Q.StringValues",
                      "newPage": false,
                      "searchKey": "query.Q.StringValues",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) StringValues(field string) (values, negatedValues []string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) StringValues(field string) (values, negatedValues []string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.Timeout",
                    "documentation": {
                      "identifier": "Q.Timeout",
                      "newPage": false,
                      "searchKey": "query.Q.Timeout",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) Timeout() *time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) Timeout() *time.Duration\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.Values",
                    "documentation": {
                      "identifier": "Q.Values",
                      "newPage": false,
                      "searchKey": "query.Q.Values",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) Values(field string) []*Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) Values(field string) []*Value\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.valueToTypedValue",
                    "documentation": {
                      "identifier": "Q.valueToTypedValue",
                      "newPage": false,
                      "searchKey": "query.Q.valueToTypedValue",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) valueToTypedValue(field, value string, label labels) []*Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) valueToTypedValue(field, value string, label labels) []*Value\n```\n\nvalueToTypedValue approximately preserves the field validation of our previous query processing. It does not check the validity of field negation or if the same field is specified more than once. This role is now performed by validate.go. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Q.yesNoOnlyValue",
                    "documentation": {
                      "identifier": "Q.yesNoOnlyValue",
                      "newPage": false,
                      "searchKey": "query.Q.yesNoOnlyValue",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q Q) yesNoOnlyValue(field string) *YesNoOnly"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q Q) yesNoOnlyValue(field string) *YesNoOnly\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#QueryInfo",
              "documentation": {
                "identifier": "QueryInfo",
                "newPage": false,
                "searchKey": "query.QueryInfo",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type QueryInfo interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype QueryInfo interface {\n\tCount() *int\n\tArchived() *YesNoOnly\n\tFork() *YesNoOnly\n\tTimeout() *time.Duration\n\tRepositories() (repos []string, negated []string)\n\tRegexpPatterns(field string) (values, negatedValues []string)\n\tStringValues(field string) (values, negatedValues []string)\n\tStringValue(field string) (value, negatedValue string)\n\tValues(field string) []*Value\n\tFields() map[string][]*Value\n\tBoolValue(field string) bool\n\tIsCaseSensitive() bool\n}\n```\n\nQueryInfo is an interface for accessing query values that drive our search logic. It will be removed in favor of a cleaner query API to access values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Range",
              "documentation": {
                "identifier": "Range",
                "newPage": false,
                "searchKey": "query.Range",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Range struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Range struct {\n\tStart position `json:\"start\"`\n\tEnd   position `json:\"end\"`\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#newRange",
                    "documentation": {
                      "identifier": "newRange",
                      "newPage": false,
                      "searchKey": "query.newRange",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newRange(start int, end int) Range"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newRange(start int, end int) Range\n```\n\nReturns a new range that assumes the string happens on one line. Column positions are in the interval [start, end]. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Range.String",
                    "documentation": {
                      "identifier": "Range.String",
                      "newPage": false,
                      "searchKey": "query.Range.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rrange Range) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rrange Range) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#RepoContainsCommitAfterPredicate",
              "documentation": {
                "identifier": "RepoContainsCommitAfterPredicate",
                "newPage": false,
                "searchKey": "query.RepoContainsCommitAfterPredicate",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RepoContainsCommitAfterPredicate struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RepoContainsCommitAfterPredicate struct {\n\tTimeRef string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsCommitAfterPredicate.Field",
                    "documentation": {
                      "identifier": "RepoContainsCommitAfterPredicate.Field",
                      "newPage": false,
                      "searchKey": "query.RepoContainsCommitAfterPredicate.Field",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f RepoContainsCommitAfterPredicate) Field() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f RepoContainsCommitAfterPredicate) Field() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsCommitAfterPredicate.Name",
                    "documentation": {
                      "identifier": "RepoContainsCommitAfterPredicate.Name",
                      "newPage": false,
                      "searchKey": "query.RepoContainsCommitAfterPredicate.Name",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f RepoContainsCommitAfterPredicate) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f RepoContainsCommitAfterPredicate) Name() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsCommitAfterPredicate.ParseParams",
                    "documentation": {
                      "identifier": "RepoContainsCommitAfterPredicate.ParseParams",
                      "newPage": false,
                      "searchKey": "query.RepoContainsCommitAfterPredicate.ParseParams",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsCommitAfterPredicate) ParseParams(params string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsCommitAfterPredicate) ParseParams(params string) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsCommitAfterPredicate.Plan",
                    "documentation": {
                      "identifier": "RepoContainsCommitAfterPredicate.Plan",
                      "newPage": false,
                      "searchKey": "query.RepoContainsCommitAfterPredicate.Plan",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsCommitAfterPredicate) Plan(parent Basic) (Plan, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsCommitAfterPredicate) Plan(parent Basic) (Plan, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#RepoContainsContentPredicate",
              "documentation": {
                "identifier": "RepoContainsContentPredicate",
                "newPage": false,
                "searchKey": "query.RepoContainsContentPredicate",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RepoContainsContentPredicate struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RepoContainsContentPredicate struct {\n\tPattern string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsContentPredicate.Field",
                    "documentation": {
                      "identifier": "RepoContainsContentPredicate.Field",
                      "newPage": false,
                      "searchKey": "query.RepoContainsContentPredicate.Field",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsContentPredicate) Field() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsContentPredicate) Field() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsContentPredicate.Name",
                    "documentation": {
                      "identifier": "RepoContainsContentPredicate.Name",
                      "newPage": false,
                      "searchKey": "query.RepoContainsContentPredicate.Name",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsContentPredicate) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsContentPredicate) Name() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsContentPredicate.ParseParams",
                    "documentation": {
                      "identifier": "RepoContainsContentPredicate.ParseParams",
                      "newPage": false,
                      "searchKey": "query.RepoContainsContentPredicate.ParseParams",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsContentPredicate) ParseParams(params string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsContentPredicate) ParseParams(params string) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsContentPredicate.Plan",
                    "documentation": {
                      "identifier": "RepoContainsContentPredicate.Plan",
                      "newPage": false,
                      "searchKey": "query.RepoContainsContentPredicate.Plan",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsContentPredicate) Plan(parent Basic) (Plan, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsContentPredicate) Plan(parent Basic) (Plan, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#RepoContainsFilePredicate",
              "documentation": {
                "identifier": "RepoContainsFilePredicate",
                "newPage": false,
                "searchKey": "query.RepoContainsFilePredicate",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RepoContainsFilePredicate struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RepoContainsFilePredicate struct {\n\tPattern string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsFilePredicate.Field",
                    "documentation": {
                      "identifier": "RepoContainsFilePredicate.Field",
                      "newPage": false,
                      "searchKey": "query.RepoContainsFilePredicate.Field",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsFilePredicate) Field() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsFilePredicate) Field() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsFilePredicate.Name",
                    "documentation": {
                      "identifier": "RepoContainsFilePredicate.Name",
                      "newPage": false,
                      "searchKey": "query.RepoContainsFilePredicate.Name",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsFilePredicate) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsFilePredicate) Name() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsFilePredicate.ParseParams",
                    "documentation": {
                      "identifier": "RepoContainsFilePredicate.ParseParams",
                      "newPage": false,
                      "searchKey": "query.RepoContainsFilePredicate.ParseParams",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsFilePredicate) ParseParams(params string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsFilePredicate) ParseParams(params string) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsFilePredicate.Plan",
                    "documentation": {
                      "identifier": "RepoContainsFilePredicate.Plan",
                      "newPage": false,
                      "searchKey": "query.RepoContainsFilePredicate.Plan",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsFilePredicate) Plan(parent Basic) (Plan, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsFilePredicate) Plan(parent Basic) (Plan, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#RepoContainsPredicate",
              "documentation": {
                "identifier": "RepoContainsPredicate",
                "newPage": false,
                "searchKey": "query.RepoContainsPredicate",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RepoContainsPredicate struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RepoContainsPredicate struct {\n\tFile    string\n\tContent string\n}\n```\n\nRepoContainsPredicate represents the `repo:contains()` predicate, which filters to repos that contain either a file or content \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsPredicate.Field",
                    "documentation": {
                      "identifier": "RepoContainsPredicate.Field",
                      "newPage": false,
                      "searchKey": "query.RepoContainsPredicate.Field",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsPredicate) Field() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsPredicate) Field() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsPredicate.Name",
                    "documentation": {
                      "identifier": "RepoContainsPredicate.Name",
                      "newPage": false,
                      "searchKey": "query.RepoContainsPredicate.Name",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsPredicate) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsPredicate) Name() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsPredicate.ParseParams",
                    "documentation": {
                      "identifier": "RepoContainsPredicate.ParseParams",
                      "newPage": false,
                      "searchKey": "query.RepoContainsPredicate.ParseParams",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsPredicate) ParseParams(params string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsPredicate) ParseParams(params string) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsPredicate.Plan",
                    "documentation": {
                      "identifier": "RepoContainsPredicate.Plan",
                      "newPage": false,
                      "searchKey": "query.RepoContainsPredicate.Plan",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsPredicate) Plan(parent Basic) (Plan, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsPredicate) Plan(parent Basic) (Plan, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#RepoContainsPredicate.parseNode",
                    "documentation": {
                      "identifier": "RepoContainsPredicate.parseNode",
                      "newPage": false,
                      "searchKey": "query.RepoContainsPredicate.parseNode",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *RepoContainsPredicate) parseNode(n Node) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *RepoContainsPredicate) parseNode(n Node) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#SearchType",
              "documentation": {
                "identifier": "SearchType",
                "newPage": false,
                "searchKey": "query.SearchType",
                "tags": [
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type SearchType int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype SearchType int\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#SearchType.String",
                    "documentation": {
                      "identifier": "SearchType.String",
                      "newPage": false,
                      "searchKey": "query.SearchType.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s SearchType) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s SearchType) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#UnsupportedError",
              "documentation": {
                "identifier": "UnsupportedError",
                "newPage": false,
                "searchKey": "query.UnsupportedError",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type UnsupportedError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype UnsupportedError struct {\n\tMsg string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#UnsupportedError.Error",
                    "documentation": {
                      "identifier": "UnsupportedError.Error",
                      "newPage": false,
                      "searchKey": "query.UnsupportedError.Error",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *UnsupportedError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *UnsupportedError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Value",
              "documentation": {
                "identifier": "Value",
                "newPage": false,
                "searchKey": "query.Value",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Value struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Value struct {\n\tString *string        // if a string value, the string value (with escape sequences interpreted)\n\tRegexp *regexp.Regexp // if a regexp pattern, the compiled regular expression (call its String method to get source pattern string)\n\tBool   *bool          // if a bool value, the bool value\n}\n```\n\nA Value is a field value in a query. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#Value.ToString",
                    "documentation": {
                      "identifier": "Value.ToString",
                      "newPage": false,
                      "searchKey": "query.Value.ToString",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v *Value) ToString() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v *Value) ToString() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Value.Value",
                    "documentation": {
                      "identifier": "Value.Value",
                      "newPage": false,
                      "searchKey": "query.Value.Value",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v *Value) Value() interface{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v *Value) Value() interface{}\n```\n\nValue returns the value as an interface{}. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ValueType",
              "documentation": {
                "identifier": "ValueType",
                "newPage": false,
                "searchKey": "query.ValueType",
                "tags": [
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ValueType int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ValueType int\n```\n\nValueType is the set of types of values in queries. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Visitor",
              "documentation": {
                "identifier": "Visitor",
                "newPage": false,
                "searchKey": "query.Visitor",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Visitor interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Visitor interface {\n\tVisitNodes(v Visitor, node []Node)\n\tVisitOperator(v Visitor, kind operatorKind, operands []Node)\n\tVisitParameter(v Visitor, field, value string, negated bool, annotation Annotation)\n\tVisitPattern(v Visitor, value string, negated bool, annotation Annotation)\n}\n```\n\nThe Visitor interface allows to visit nodes for each respective part of the query grammar. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#YesNoOnly",
              "documentation": {
                "identifier": "YesNoOnly",
                "newPage": false,
                "searchKey": "query.YesNoOnly",
                "tags": [
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type YesNoOnly string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype YesNoOnly string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#ParseYesNoOnly",
                    "documentation": {
                      "identifier": "ParseYesNoOnly",
                      "newPage": false,
                      "searchKey": "query.ParseYesNoOnly",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseYesNoOnly(s string) YesNoOnly"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseYesNoOnly(s string) YesNoOnly\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#globError",
              "documentation": {
                "identifier": "globError",
                "newPage": false,
                "searchKey": "query.globError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type globError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype globError struct {\n\tfield string\n\terr   error\n}\n```\n\nglobError carries the error message and the name of field where the error occurred. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#globError.Error",
                    "documentation": {
                      "identifier": "globError.Error",
                      "newPage": false,
                      "searchKey": "query.globError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (g globError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (g globError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#heuristics",
              "documentation": {
                "identifier": "heuristics",
                "newPage": false,
                "searchKey": "query.heuristics",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type heuristics uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype heuristics uint8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#keyword",
              "documentation": {
                "identifier": "keyword",
                "newPage": false,
                "searchKey": "query.keyword",
                "tags": [
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type keyword string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype keyword string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#labels",
              "documentation": {
                "identifier": "labels",
                "newPage": false,
                "searchKey": "query.labels",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type labels uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype labels uint16\n```\n\nLabels are general-purpose annotations that store information about a node. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#collectLabels",
                    "documentation": {
                      "identifier": "collectLabels",
                      "newPage": false,
                      "searchKey": "query.collectLabels",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func collectLabels(nodes []Node) (result labels)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc collectLabels(nodes []Node) (result labels)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#labels.IsSet",
                    "documentation": {
                      "identifier": "labels.IsSet",
                      "newPage": false,
                      "searchKey": "query.labels.IsSet",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *labels) IsSet(label labels) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *labels) IsSet(label labels) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#labels.String",
                    "documentation": {
                      "identifier": "labels.String",
                      "newPage": false,
                      "searchKey": "query.labels.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *labels) String() []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *labels) String() []string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#labels.set",
                    "documentation": {
                      "identifier": "labels.set",
                      "newPage": false,
                      "searchKey": "query.labels.set",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *labels) set(label labels)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *labels) set(label labels)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#labels.unset",
                    "documentation": {
                      "identifier": "labels.unset",
                      "newPage": false,
                      "searchKey": "query.labels.unset",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *labels) unset(label labels)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *labels) unset(label labels)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#operatorKind",
              "documentation": {
                "identifier": "operatorKind",
                "newPage": false,
                "searchKey": "query.operatorKind",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type operatorKind int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype operatorKind int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#parser",
              "documentation": {
                "identifier": "parser",
                "newPage": false,
                "searchKey": "query.parser",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type parser struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype parser struct {\n\tbuf        []byte\n\theuristics heuristics\n\tpos        int\n\tbalanced   int\n\tleafParser SearchType\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.ParseFieldValue",
                    "documentation": {
                      "identifier": "parser.ParseFieldValue",
                      "newPage": false,
                      "searchKey": "query.parser.ParseFieldValue",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) ParseFieldValue(field string) (string, labels, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) ParseFieldValue(field string) (string, labels, error)\n```\n\nParseFieldValue parses a value after a field like \"repo:\". It returns the parsed value and any labels to annotate this value with. If the value starts with a recognized quoting delimiter but does not close it, an error is returned. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.ParseParameter",
                    "documentation": {
                      "identifier": "parser.ParseParameter",
                      "newPage": false,
                      "searchKey": "query.parser.ParseParameter",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) ParseParameter() (Parameter, bool, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) ParseParameter() (Parameter, bool, error)\n```\n\nParseParameter returns a leaf node corresponding to the syntax (-?)field:<string> where : matches the first encountered colon, and field must match ^[a-zA-Z]+ and be allowed by allFields. Field may optionally be preceded by '-' which means the parameter is negated. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.ParsePattern",
                    "documentation": {
                      "identifier": "parser.ParsePattern",
                      "newPage": false,
                      "searchKey": "query.parser.ParsePattern",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) ParsePattern(label labels) Pattern"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) ParsePattern(label labels) Pattern\n```\n\nParsePattern parses a leaf node Pattern that corresponds to a search pattern. Note that ParsePattern may be called multiple times (a query can have multiple Patterns concatenated together). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.TryParseDelimitedPattern",
                    "documentation": {
                      "identifier": "parser.TryParseDelimitedPattern",
                      "newPage": false,
                      "searchKey": "query.parser.TryParseDelimitedPattern",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) TryParseDelimitedPattern() (Pattern, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) TryParseDelimitedPattern() (Pattern, bool)\n```\n\nTry parse a delimited pattern, quoted as \"...\", '...', or /.../. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.TryParseDelimiter",
                    "documentation": {
                      "identifier": "parser.TryParseDelimiter",
                      "newPage": false,
                      "searchKey": "query.parser.TryParseDelimiter",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) TryParseDelimiter() (string, rune, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) TryParseDelimiter() (string, rune, bool)\n```\n\nTryParseDelimiter tries to parse a delimited string, returning the interpreted (i.e., unquoted) value if it succeeds, the delimiter that suceeded parsing, and whether it succeeded. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.TryScanBalancedPattern",
                    "documentation": {
                      "identifier": "parser.TryScanBalancedPattern",
                      "newPage": false,
                      "searchKey": "query.parser.TryScanBalancedPattern",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) TryScanBalancedPattern(label labels) (Pattern, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) TryScanBalancedPattern(label labels) (Pattern, bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.done",
                    "documentation": {
                      "identifier": "parser.done",
                      "newPage": false,
                      "searchKey": "query.parser.done",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) done() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) done() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.expect",
                    "documentation": {
                      "identifier": "parser.expect",
                      "newPage": false,
                      "searchKey": "query.parser.expect",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) expect(keyword keyword) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) expect(keyword keyword) bool\n```\n\nexpect returns the result of match, and advances the position if it succeeds. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.match",
                    "documentation": {
                      "identifier": "parser.match",
                      "newPage": false,
                      "searchKey": "query.parser.match",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) match(keyword keyword) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) match(keyword keyword) bool\n```\n\nmatch returns whether it succeeded matching a keyword at the current position. It does not advance the position. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.matchKeyword",
                    "documentation": {
                      "identifier": "parser.matchKeyword",
                      "newPage": false,
                      "searchKey": "query.parser.matchKeyword",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) matchKeyword(keyword keyword) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) matchKeyword(keyword keyword) bool\n```\n\nmatchKeyword is like match but expects the keyword to be preceded and followed by whitespace. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.matchUnaryKeyword",
                    "documentation": {
                      "identifier": "parser.matchUnaryKeyword",
                      "newPage": false,
                      "searchKey": "query.parser.matchUnaryKeyword",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) matchUnaryKeyword(keyword keyword) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) matchUnaryKeyword(keyword keyword) bool\n```\n\nmatchUnaryKeyword is like match but expects the keyword to be followed by whitespace. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.next",
                    "documentation": {
                      "identifier": "parser.next",
                      "newPage": false,
                      "searchKey": "query.parser.next",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) next() rune"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) next() rune\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.parseAnd",
                    "documentation": {
                      "identifier": "parser.parseAnd",
                      "newPage": false,
                      "searchKey": "query.parser.parseAnd",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseAnd() ([]Node, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseAnd() ([]Node, error)\n```\n\nparseAnd parses and-expressions. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.parseLeaves",
                    "documentation": {
                      "identifier": "parser.parseLeaves",
                      "newPage": false,
                      "searchKey": "query.parser.parseLeaves",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseLeaves(label labels) ([]Node, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseLeaves(label labels) ([]Node, error)\n```\n\nparseLeaves scans for consecutive leaf nodes and applies label to patterns. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.parseOr",
                    "documentation": {
                      "identifier": "parser.parseOr",
                      "newPage": false,
                      "searchKey": "query.parser.parseOr",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseOr() ([]Node, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseOr() ([]Node, error)\n```\n\nparseOr parses or-expressions. Or operators have lower precedence than And operators, therefore this function calls parseAnd. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.peek",
                    "documentation": {
                      "identifier": "parser.peek",
                      "newPage": false,
                      "searchKey": "query.parser.peek",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) peek(n int) (string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) peek(n int) (string, error)\n```\n\npeek looks ahead n runes in the input and returns a string if it succeeds, or an error if the length exceeds what's available in the buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.skipSpaces",
                    "documentation": {
                      "identifier": "parser.skipSpaces",
                      "newPage": false,
                      "searchKey": "query.parser.skipSpaces",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) skipSpaces() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) skipSpaces() error\n```\n\nskipSpaces advances the input and places the parser position at the next non-space value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#parser.tryFallbackParser",
                    "documentation": {
                      "identifier": "parser.tryFallbackParser",
                      "newPage": false,
                      "searchKey": "query.parser.tryFallbackParser",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) tryFallbackParser(in string) ([]Node, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) tryFallbackParser(in string) ([]Node, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#pass",
              "documentation": {
                "identifier": "pass",
                "newPage": false,
                "searchKey": "query.pass",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type pass func(nodes []github.com/sourcegraph/sourcegraph/internal/search/query.Node) []github.com/sourcegraph/sourcegraph/internal/search/query.Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pass func(nodes []Node) []Node\n```\n\nA pass is a step that never fails. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#position",
              "documentation": {
                "identifier": "position",
                "newPage": false,
                "searchKey": "query.position",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type position struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype position struct {\n\tLine   int `json:\"line\"`\n\tColumn int `json:\"column\"`\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#predicateRegistry",
              "documentation": {
                "identifier": "predicateRegistry",
                "newPage": false,
                "searchKey": "query.predicateRegistry",
                "tags": [
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type predicateRegistry map[string]map[string]func() github.com/sourcegraph/sourcegraph/internal/search/query.Predicate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype predicateRegistry map[string]map[string]func() Predicate\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#predicateRegistry.Get",
                    "documentation": {
                      "identifier": "predicateRegistry.Get",
                      "newPage": false,
                      "searchKey": "query.predicateRegistry.Get",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pr predicateRegistry) Get(field, name string) Predicate"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pr predicateRegistry) Get(field, name string) Predicate\n```\n\nGet returns a predicate for the given field with the given name. It assumes it exists, and panics otherwise. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#repoVisibility",
              "documentation": {
                "identifier": "repoVisibility",
                "newPage": false,
                "searchKey": "query.repoVisibility",
                "tags": [
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type repoVisibility string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype repoVisibility string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#ParseVisibility",
                    "documentation": {
                      "identifier": "ParseVisibility",
                      "newPage": false,
                      "searchKey": "query.ParseVisibility",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseVisibility(s string) repoVisibility"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseVisibility(s string) repoVisibility\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#step",
              "documentation": {
                "identifier": "step",
                "newPage": false,
                "searchKey": "query.step",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type step func(nodes []github.com/sourcegraph/sourcegraph/internal/search/query.Node) ([]github.com/sourcegraph/sourcegraph/internal/search/query.Node, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype step func(nodes []Node) ([]Node, error)\n```\n\nA step performs a transformation on nodes, which may fail. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/search/query#For",
                    "documentation": {
                      "identifier": "For",
                      "newPage": false,
                      "searchKey": "query.For",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func For(searchType SearchType) step"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc For(searchType SearchType) step\n```\n\nFor runs processing steps for a given search type. This includes normalization, substitution for whitespace, and pattern labeling. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#Init",
                    "documentation": {
                      "identifier": "Init",
                      "newPage": false,
                      "searchKey": "query.Init",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Init(in string, searchType SearchType) step"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Init(in string, searchType SearchType) step\n```\n\nInit creates a step from an input string and search type. It parses the initial input string. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#InitLiteral",
                    "documentation": {
                      "identifier": "InitLiteral",
                      "newPage": false,
                      "searchKey": "query.InitLiteral",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func InitLiteral(in string) step"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc InitLiteral(in string) step\n```\n\nInitLiteral is Init where SearchType is Literal. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#InitRegexp",
                    "documentation": {
                      "identifier": "InitRegexp",
                      "newPage": false,
                      "searchKey": "query.InitRegexp",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func InitRegexp(in string) step"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc InitRegexp(in string) step\n```\n\nInitRegexp is Init where SearchType is Regex. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#InitStructural",
                    "documentation": {
                      "identifier": "InitStructural",
                      "newPage": false,
                      "searchKey": "query.InitStructural",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func InitStructural(in string) step"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc InitStructural(in string) step\n```\n\nInitStructural is Init where SearchType is Structural. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#With",
                    "documentation": {
                      "identifier": "With",
                      "newPage": false,
                      "searchKey": "query.With",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func With(enabled bool, step step) step"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc With(enabled bool, step step) step\n```\n\nWith returns step if enabled is true. Use it to compose a pipeline that conditionally run steps. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#sequence",
                    "documentation": {
                      "identifier": "sequence",
                      "newPage": false,
                      "searchKey": "query.sequence",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func sequence(steps ...step) step"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc sequence(steps ...step) step\n```\n\nsequence sequences zero or more steps to create a single step. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/search/query#succeeds",
                    "documentation": {
                      "identifier": "succeeds",
                      "newPage": false,
                      "searchKey": "query.succeeds",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func succeeds(passes ...pass) step"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc succeeds(passes ...pass) step\n```\n\nsucceeds converts a sequence of passes into a single step. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/internal/search/query#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package",
            "private"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/internal/search/query#AddRegexpField",
              "documentation": {
                "identifier": "AddRegexpField",
                "newPage": false,
                "searchKey": "query.AddRegexpField",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func AddRegexpField(q Q, field, pattern string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc AddRegexpField(q Q, field, pattern string) string\n```\n\naddRegexpField adds a new expr to the query with the given field and pattern value. The nonnegated field is assumed to associate with a regexp value. The pattern value is assumed to be unquoted. \n\nIt tries to remove redundancy in the result. For example, given a query like \"x:foo\", if given a field \"x\" with pattern \"foobar\" to add, it will return a query \"x:foobar\" instead of \"x:foo x:foobar\". It is not guaranteed to always return the simplest query. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ContainsNoGlobSyntax",
              "documentation": {
                "identifier": "ContainsNoGlobSyntax",
                "newPage": false,
                "searchKey": "query.ContainsNoGlobSyntax",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ContainsNoGlobSyntax(value string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ContainsNoGlobSyntax(value string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ContainsRefGlobs",
              "documentation": {
                "identifier": "ContainsRefGlobs",
                "newPage": false,
                "searchKey": "query.ContainsRefGlobs",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ContainsRefGlobs(q Q) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ContainsRefGlobs(q Q) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ContainsRegexpMetasyntax",
              "documentation": {
                "identifier": "ContainsRegexpMetasyntax",
                "newPage": false,
                "searchKey": "query.ContainsRegexpMetasyntax",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ContainsRegexpMetasyntax(input string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ContainsRegexpMetasyntax(input string) bool\n```\n\nContainsRegexpMetasyntax returns true if a string is a valid regular expression and contains regex metasyntax (i.e., it is not a literal). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Dnf",
              "documentation": {
                "identifier": "Dnf",
                "newPage": false,
                "searchKey": "query.Dnf",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Dnf(query []Node) [][]Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Dnf(query []Node) [][]Node\n```\n\nDnf returns the Disjunctive Normal Form of a query (a flat sequence of or-expressions) by applying the distributive property on (possibly nested) or-expressions. For example, the query: \n\n(repo:a (file:b OR file:c)) in DNF becomes: (repo:a file:b) OR (repo:a file:c) \n\nUsing the DNF expression makes it easy to support general nested queries that imply scope, like the one above: We simply evaluate all disjuncts and union the results. Note that various optimizations are possible during evaluation, but those are separate query pre- or postprocessing steps separate from this general transformation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#FuzzifyRegexPatterns",
              "documentation": {
                "identifier": "FuzzifyRegexPatterns",
                "newPage": false,
                "searchKey": "query.FuzzifyRegexPatterns",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func FuzzifyRegexPatterns(nodes []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc FuzzifyRegexPatterns(nodes []Node) []Node\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Globbing",
              "documentation": {
                "identifier": "Globbing",
                "newPage": false,
                "searchKey": "query.Globbing",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Globbing(nodes []Node) ([]Node, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Globbing(nodes []Node) ([]Node, error)\n```\n\nGlobbing translates glob to regexp for fields repo, file, and repohasfile. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#HasTypeRepo",
              "documentation": {
                "identifier": "HasTypeRepo",
                "newPage": false,
                "searchKey": "query.HasTypeRepo",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func HasTypeRepo(q Q) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc HasTypeRepo(q Q) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Hoist",
              "documentation": {
                "identifier": "Hoist",
                "newPage": false,
                "searchKey": "query.Hoist",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Hoist(nodes []Node) ([]Node, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Hoist(nodes []Node) ([]Node, error)\n```\n\nHoist is a heuristic that rewrites simple but possibly ambiguous queries. It changes certain expressions in a way that some consider to be more natural. For example, the following query without parentheses is interpreted as follows in the grammar: \n\nrepo:foo a or b and c => (repo:foo a) or ((b) and (c)) \n\nThis function rewrites the above expression as follows: \n\nrepo:foo a or b and c => repo:foo (a or b and c) \n\nAny number of field:value parameters may occur before and after the pattern expression separated by or- or and-operators, and these are hoisted out. The pattern expression must be contiguous. If not, we want to preserve the default interpretation, which corresponds more naturally to groupings with field parameters, i.e., \n\nrepo:foo a or b or repo:bar c => (repo:foo a) or (b) or (repo:bar c) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#IsBasic",
              "documentation": {
                "identifier": "IsBasic",
                "newPage": false,
                "searchKey": "query.IsBasic",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsBasic(nodes []Node) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsBasic(nodes []Node) bool\n```\n\nIsBasic returns whether a query is a basic query. A basic query is one which does not have a DNF-expansion. I.e., there is only one disjunct. A basic query implies that it has no subexpressions that we need to evaluate. IsBasic is used in our codebase where legacy code has not been updated to handle queries with multiple expressions (like alerts), and assume only one evaluatable query. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#IsPatternAtom",
              "documentation": {
                "identifier": "IsPatternAtom",
                "newPage": false,
                "searchKey": "query.IsPatternAtom",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsPatternAtom(b Basic) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsPatternAtom(b Basic) bool\n```\n\nIsPatternAtom returns whether a node is a non-negated pattern atom. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#IsStreamingCompatible",
              "documentation": {
                "identifier": "IsStreamingCompatible",
                "newPage": false,
                "searchKey": "query.IsStreamingCompatible",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsStreamingCompatible(p Plan) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsStreamingCompatible(p Plan) bool\n```\n\nIsStreamingCompatible returns whether a backend search process may immediately send results over a streaming interface. A query is streaming compatible if a streaming search engine component (like git-powered commit search or Zoekt) may assume that it's processing just one logical search expression which is not subject to additional merge/deduplication processing, which are otherwise required by `and` and `or` expressions in the Sourcegraph query evaluation routine. A single logical search expression is represented by a single Basic query which contains either no pattern node, or a single pattern node. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#LooksLikeGitHubRepo",
              "documentation": {
                "identifier": "LooksLikeGitHubRepo",
                "newPage": false,
                "searchKey": "query.LooksLikeGitHubRepo",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LooksLikeGitHubRepo(value string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LooksLikeGitHubRepo(value string) bool\n```\n\nLooksLikeGitHubRepo returns whether string value looks like a valid GitHub repo path. This condition is used to guess whether we should make a pattern fuzzy, or try it as an exact match. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#LowercaseFieldNames",
              "documentation": {
                "identifier": "LowercaseFieldNames",
                "newPage": false,
                "searchKey": "query.LowercaseFieldNames",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LowercaseFieldNames(nodes []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LowercaseFieldNames(nodes []Node) []Node\n```\n\nLowercaseFieldNames performs strings.ToLower on every field name. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Map",
              "documentation": {
                "identifier": "Map",
                "newPage": false,
                "searchKey": "query.Map",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Map(query []Node, fns ...func([]Node) []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Map(query []Node, fns ...func([]Node) []Node) []Node\n```\n\nMap pipes query through one or more query transformer functions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#MapField",
              "documentation": {
                "identifier": "MapField",
                "newPage": false,
                "searchKey": "query.MapField",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func MapField(nodes []Node, field string, callback func(value string, negated bool) Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MapField(nodes []Node, field string, callback func(value string, negated bool) Node) []Node\n```\n\nMapField is a convenience function that calls callback on all parameter nodes whose field matches the field argument, substituting them for callback's return value. callback supplies the node's value, and whether the value is negated. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#MapOperator",
              "documentation": {
                "identifier": "MapOperator",
                "newPage": false,
                "searchKey": "query.MapOperator",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func MapOperator(nodes []Node, callback func(kind operatorKind, operands []Node) []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MapOperator(nodes []Node, callback func(kind operatorKind, operands []Node) []Node) []Node\n```\n\nMapOperator is a convenience function that calls callback on all operator nodes, substituting them for callback's return value. callback supplies the node's kind and operands. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#MapParameter",
              "documentation": {
                "identifier": "MapParameter",
                "newPage": false,
                "searchKey": "query.MapParameter",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func MapParameter(nodes []Node, callback func(field, value string, negated bool, annotation Annotation) Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MapParameter(nodes []Node, callback func(field, value string, negated bool, annotation Annotation) Node) []Node\n```\n\nMapParameter is a convenience function that calls callback on all parameter nodes, substituting them for callback's return value. callback supplies the node's field, value, and whether the value is negated. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#MapPattern",
              "documentation": {
                "identifier": "MapPattern",
                "newPage": false,
                "searchKey": "query.MapPattern",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func MapPattern(nodes []Node, callback func(value string, negated bool, annotation Annotation) Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MapPattern(nodes []Node, callback func(value string, negated bool, annotation Annotation) Node) []Node\n```\n\nMapPattern is a convenience function that calls callback on all pattern nodes, substituting them for callback's return value. callback supplies the node's field, value, and whether the value is negated. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#OmitField",
              "documentation": {
                "identifier": "OmitField",
                "newPage": false,
                "searchKey": "query.OmitField",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func OmitField(q Q, field string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc OmitField(q Q, field string) string\n```\n\nOmitField removes all fields `field` from a query. The `field` string should be the canonical name and not an alias (\"repo\", not \"r\"). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#OverrideField",
              "documentation": {
                "identifier": "OverrideField",
                "newPage": false,
                "searchKey": "query.OverrideField",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func OverrideField(nodes []Node, field, value string) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc OverrideField(nodes []Node, field, value string) []Node\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Parse",
              "documentation": {
                "identifier": "Parse",
                "newPage": false,
                "searchKey": "query.Parse",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Parse(in string, searchType SearchType) ([]Node, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Parse(in string, searchType SearchType) ([]Node, error)\n```\n\nParse parses a raw input string into a parse tree comprising Nodes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ParseAsPredicate",
              "documentation": {
                "identifier": "ParseAsPredicate",
                "newPage": false,
                "searchKey": "query.ParseAsPredicate",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ParseAsPredicate(value string) (name, params string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ParseAsPredicate(value string) (name, params string)\n```\n\nParsePredicate returns the name and value of syntax conforming to name(value). It assumes this syntax is already validated prior. If not, it panics. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Run",
              "documentation": {
                "identifier": "Run",
                "newPage": false,
                "searchKey": "query.Run",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Run(step step) ([]Node, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Run(step step) ([]Node, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ScanAnyPattern",
              "documentation": {
                "identifier": "ScanAnyPattern",
                "newPage": false,
                "searchKey": "query.ScanAnyPattern",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ScanAnyPattern(buf []byte) (scanned string, count int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ScanAnyPattern(buf []byte) (scanned string, count int)\n```\n\nScanAnyPattern consumes all characters up to a whitespace character and returns the string and how much it consumed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ScanBalancedParens",
              "documentation": {
                "identifier": "ScanBalancedParens",
                "newPage": false,
                "searchKey": "query.ScanBalancedParens",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ScanBalancedParens(buf []byte) (string, int, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ScanBalancedParens(buf []byte) (string, int, bool)\n```\n\nScanBalancedParens will return the full string including and inside the parantheses that start with the first character. This is different from ScanBalancedPattern because that attempts to take into account whether the content looks like other filters. In the case of predicates, we offload the job of parsing parameters onto the predicates themselves, so we just want the full content of the parameters, whatever it contains. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ScanBalancedPattern",
              "documentation": {
                "identifier": "ScanBalancedPattern",
                "newPage": false,
                "searchKey": "query.ScanBalancedPattern",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ScanBalancedPattern(buf []byte) (scanned string, count int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ScanBalancedPattern(buf []byte) (scanned string, count int, ok bool)\n```\n\nScanBalancedPattern attempts to scan parentheses as literal patterns. This ensures that we interpret patterns containing parentheses _as patterns_ and not groups. For example, it accepts these patterns: \n\n((a|b)|c)              - a regular expression with balanced parentheses for grouping myFunction(arg1, arg2) - a literal string with parens that should be literally interpreted foo(...)               - a structural search pattern \n\nIf it weren't for this scanner, the above parentheses would have to be interpreted as part of the query language group syntax, like these: \n\n(foo or (bar and baz)) \n\nSo, this scanner detects parentheses as patterns without needing the user to explicitly escape them. As such, there are cases where this scanner should not succeed: \n\n(foo or (bar and baz)) - a valid query with and/or expression groups in the query langugae (repo:foo bar baz)     - a valid query containing a recognized repo: field. Here parentheses are interpreted as a group, not a pattern. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ScanDelimited",
              "documentation": {
                "identifier": "ScanDelimited",
                "newPage": false,
                "searchKey": "query.ScanDelimited",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ScanDelimited(buf []byte, strict bool, delimiter rune) (string, int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ScanDelimited(buf []byte, strict bool, delimiter rune) (string, int, error)\n```\n\nScanDelimited takes a delimited (e.g., quoted) value for some arbitrary delimiter, returning the undelimited value, and the end position of the original delimited value (i.e., including quotes). `\\` is treated as an escape character for the delimiter and traditional string escape sequences. The `strict` input parameter sets whether this delimiter may contain only recognized escaped characters (strict), or arbitrary ones. The input buffer must start with the chosen delimiter. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ScanField",
              "documentation": {
                "identifier": "ScanField",
                "newPage": false,
                "searchKey": "query.ScanField",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ScanField(buf []byte) (string, bool, int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ScanField(buf []byte) (string, bool, int)\n```\n\nScanField scans an optional '-' at the beginning of a string, and then scans one or more alphabetic characters until it encounters a ':'. The prefix string is checked against valid fields. If it is valid, the function returns the value before the colon, whether it's negated, and its length. In all other cases it returns zero values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ScanPredicate",
              "documentation": {
                "identifier": "ScanPredicate",
                "newPage": false,
                "searchKey": "query.ScanPredicate",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ScanPredicate(field string, buf []byte) (string, int, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ScanPredicate(field string, buf []byte) (string, int, bool)\n```\n\nScanPredicate scans for a predicate that exists in the predicate registry. It takes the current field as context. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ScanPredicateName",
              "documentation": {
                "identifier": "ScanPredicateName",
                "newPage": false,
                "searchKey": "query.ScanPredicateName",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ScanPredicateName(fieldRegistry map[string]func() Predicate, buf []byte) (string, int, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ScanPredicateName(fieldRegistry map[string]func() Predicate, buf []byte) (string, int, bool)\n```\n\nScanPredicateName scans for a well-known predicate name for he given field \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ScanValue",
              "documentation": {
                "identifier": "ScanValue",
                "newPage": false,
                "searchKey": "query.ScanValue",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ScanValue(buf []byte, allowDanglingParens bool) (string, int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ScanValue(buf []byte, allowDanglingParens bool) (string, int)\n```\n\nScanValue scans for a value (e.g., of a parameter, or a string corresponding to a search pattern). Its main function is to determine when to stop scanning a value (e.g., at a parentheses), and which escape sequences to interpret. It returns the scanned value, how much was advanced, and whether to allow scanning dangling parentheses in patterns like \"foo(\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#StringHuman",
              "documentation": {
                "identifier": "StringHuman",
                "newPage": false,
                "searchKey": "query.StringHuman",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func StringHuman(nodes []Node) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc StringHuman(nodes []Node) string\n```\n\nStringHuman creates a valid query string from a parsed query. It is used in contexts like query suggestions where we take the original query string of a user, parse it to a tree, modify the tree, and return a valid string representation. To faithfully preserve the meaning of the original tree, we need to consider whether to add operators like \"and\" contextually and must process the tree as a whole: \n\nrepo:foo file:bar a and b -> preserve 'and', but do not insert 'and' between 'repo:foo file:bar'. repo:foo file:bar a b     -> do not insert any 'and', especially not between 'a b'. \n\nIt strives to be syntax preserving, but may in some cases affect whitespace, operator capitalization, or parenthesized groupings. In very complex queries, additional 'and' operators may be inserted to segment parameters from patterns to preserve the original meaning. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#SubstituteAliases",
              "documentation": {
                "identifier": "SubstituteAliases",
                "newPage": false,
                "searchKey": "query.SubstituteAliases",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SubstituteAliases(searchType SearchType) func(nodes []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SubstituteAliases(searchType SearchType) func(nodes []Node) []Node\n```\n\nSubstituteAliases substitutes field name aliases for their canonical names, and substitutes `content:` for pattern nodes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#SubstituteCountAll",
              "documentation": {
                "identifier": "SubstituteCountAll",
                "newPage": false,
                "searchKey": "query.SubstituteCountAll",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SubstituteCountAll(nodes []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SubstituteCountAll(nodes []Node) []Node\n```\n\nSubstituteCountAll replaces count:all with count:99999999. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestAndOrQuery_IsCaseSensitive",
              "documentation": {
                "identifier": "TestAndOrQuery_IsCaseSensitive",
                "newPage": false,
                "searchKey": "query.TestAndOrQuery_IsCaseSensitive",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAndOrQuery_IsCaseSensitive(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAndOrQuery_IsCaseSensitive(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestAndOrQuery_RegexpPatterns",
              "documentation": {
                "identifier": "TestAndOrQuery_RegexpPatterns",
                "newPage": false,
                "searchKey": "query.TestAndOrQuery_RegexpPatterns",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAndOrQuery_RegexpPatterns(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAndOrQuery_RegexpPatterns(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestAndOrQuery_Validation",
              "documentation": {
                "identifier": "TestAndOrQuery_Validation",
                "newPage": false,
                "searchKey": "query.TestAndOrQuery_Validation",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAndOrQuery_Validation(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAndOrQuery_Validation(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestConcatRevFilters",
              "documentation": {
                "identifier": "TestConcatRevFilters",
                "newPage": false,
                "searchKey": "query.TestConcatRevFilters",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConcatRevFilters(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConcatRevFilters(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestConcatRevFiltersTopLevelAnd",
              "documentation": {
                "identifier": "TestConcatRevFiltersTopLevelAnd",
                "newPage": false,
                "searchKey": "query.TestConcatRevFiltersTopLevelAnd",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConcatRevFiltersTopLevelAnd(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConcatRevFiltersTopLevelAnd(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestContainsNoGlobSyntax",
              "documentation": {
                "identifier": "TestContainsNoGlobSyntax",
                "newPage": false,
                "searchKey": "query.TestContainsNoGlobSyntax",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestContainsNoGlobSyntax(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestContainsNoGlobSyntax(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestContainsRefGlobs",
              "documentation": {
                "identifier": "TestContainsRefGlobs",
                "newPage": false,
                "searchKey": "query.TestContainsRefGlobs",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestContainsRefGlobs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestContainsRefGlobs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestConvertEmptyGroupsToLiteral",
              "documentation": {
                "identifier": "TestConvertEmptyGroupsToLiteral",
                "newPage": false,
                "searchKey": "query.TestConvertEmptyGroupsToLiteral",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConvertEmptyGroupsToLiteral(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConvertEmptyGroupsToLiteral(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestEllipsesForHoles",
              "documentation": {
                "identifier": "TestEllipsesForHoles",
                "newPage": false,
                "searchKey": "query.TestEllipsesForHoles",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEllipsesForHoles(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEllipsesForHoles(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestExpandOr",
              "documentation": {
                "identifier": "TestExpandOr",
                "newPage": false,
                "searchKey": "query.TestExpandOr",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExpandOr(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExpandOr(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestForAll",
              "documentation": {
                "identifier": "TestForAll",
                "newPage": false,
                "searchKey": "query.TestForAll",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestForAll(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestForAll(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestFuzzifyGlobPattern",
              "documentation": {
                "identifier": "TestFuzzifyGlobPattern",
                "newPage": false,
                "searchKey": "query.TestFuzzifyGlobPattern",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFuzzifyGlobPattern(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFuzzifyGlobPattern(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestFuzzifyRegexPatterns",
              "documentation": {
                "identifier": "TestFuzzifyRegexPatterns",
                "newPage": false,
                "searchKey": "query.TestFuzzifyRegexPatterns",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFuzzifyRegexPatterns(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFuzzifyRegexPatterns(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestHasTypeRepo",
              "documentation": {
                "identifier": "TestHasTypeRepo",
                "newPage": false,
                "searchKey": "query.TestHasTypeRepo",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHasTypeRepo(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHasTypeRepo(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestHoist",
              "documentation": {
                "identifier": "TestHoist",
                "newPage": false,
                "searchKey": "query.TestHoist",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHoist(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHoist(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestLowercaseFieldNames",
              "documentation": {
                "identifier": "TestLowercaseFieldNames",
                "newPage": false,
                "searchKey": "query.TestLowercaseFieldNames",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLowercaseFieldNames(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLowercaseFieldNames(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestMap",
              "documentation": {
                "identifier": "TestMap",
                "newPage": false,
                "searchKey": "query.TestMap",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMap(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMap(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestMapField",
              "documentation": {
                "identifier": "TestMapField",
                "newPage": false,
                "searchKey": "query.TestMapField",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMapField(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMapField(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestMapGlobToRegex",
              "documentation": {
                "identifier": "TestMapGlobToRegex",
                "newPage": false,
                "searchKey": "query.TestMapGlobToRegex",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMapGlobToRegex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMapGlobToRegex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestMapOperator",
              "documentation": {
                "identifier": "TestMapOperator",
                "newPage": false,
                "searchKey": "query.TestMapOperator",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMapOperator(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMapOperator(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestMatchUnaryKeyword",
              "documentation": {
                "identifier": "TestMatchUnaryKeyword",
                "newPage": false,
                "searchKey": "query.TestMatchUnaryKeyword",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMatchUnaryKeyword(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMatchUnaryKeyword(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestMergePatterns",
              "documentation": {
                "identifier": "TestMergePatterns",
                "newPage": false,
                "searchKey": "query.TestMergePatterns",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMergePatterns(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMergePatterns(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestParse",
              "documentation": {
                "identifier": "TestParse",
                "newPage": false,
                "searchKey": "query.TestParse",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParse(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestParseAndOrLiteral",
              "documentation": {
                "identifier": "TestParseAndOrLiteral",
                "newPage": false,
                "searchKey": "query.TestParseAndOrLiteral",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseAndOrLiteral(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseAndOrLiteral(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestParseAsPredicate",
              "documentation": {
                "identifier": "TestParseAsPredicate",
                "newPage": false,
                "searchKey": "query.TestParseAsPredicate",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseAsPredicate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseAsPredicate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestParseParameterList",
              "documentation": {
                "identifier": "TestParseParameterList",
                "newPage": false,
                "searchKey": "query.TestParseParameterList",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseParameterList(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseParameterList(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestPartitionSearchPattern",
              "documentation": {
                "identifier": "TestPartitionSearchPattern",
                "newPage": false,
                "searchKey": "query.TestPartitionSearchPattern",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPartitionSearchPattern(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPartitionSearchPattern(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestPipeline",
              "documentation": {
                "identifier": "TestPipeline",
                "newPage": false,
                "searchKey": "query.TestPipeline",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPipeline(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPipeline(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestPipeline_equivalence",
              "documentation": {
                "identifier": "TestPipeline_equivalence",
                "newPage": false,
                "searchKey": "query.TestPipeline_equivalence",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPipeline_equivalence(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPipeline_equivalence(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestQueryField",
              "documentation": {
                "identifier": "TestQueryField",
                "newPage": false,
                "searchKey": "query.TestQueryField",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestQueryField(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestQueryField(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestRepoContainsPredicate",
              "documentation": {
                "identifier": "TestRepoContainsPredicate",
                "newPage": false,
                "searchKey": "query.TestRepoContainsPredicate",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRepoContainsPredicate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRepoContainsPredicate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestReporevToRegex",
              "documentation": {
                "identifier": "TestReporevToRegex",
                "newPage": false,
                "searchKey": "query.TestReporevToRegex",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReporevToRegex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReporevToRegex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestScanBalancedPattern",
              "documentation": {
                "identifier": "TestScanBalancedPattern",
                "newPage": false,
                "searchKey": "query.TestScanBalancedPattern",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestScanBalancedPattern(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestScanBalancedPattern(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestScanDelimited",
              "documentation": {
                "identifier": "TestScanDelimited",
                "newPage": false,
                "searchKey": "query.TestScanDelimited",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestScanDelimited(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestScanDelimited(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestScanField",
              "documentation": {
                "identifier": "TestScanField",
                "newPage": false,
                "searchKey": "query.TestScanField",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestScanField(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestScanField(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestScanPredicate",
              "documentation": {
                "identifier": "TestScanPredicate",
                "newPage": false,
                "searchKey": "query.TestScanPredicate",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestScanPredicate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestScanPredicate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestStringHuman",
              "documentation": {
                "identifier": "TestStringHuman",
                "newPage": false,
                "searchKey": "query.TestStringHuman",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestStringHuman(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestStringHuman(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestSubstituteAliases",
              "documentation": {
                "identifier": "TestSubstituteAliases",
                "newPage": false,
                "searchKey": "query.TestSubstituteAliases",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSubstituteAliases(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSubstituteAliases(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestSubstituteConcat",
              "documentation": {
                "identifier": "TestSubstituteConcat",
                "newPage": false,
                "searchKey": "query.TestSubstituteConcat",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSubstituteConcat(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSubstituteConcat(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestSubstituteCountAll",
              "documentation": {
                "identifier": "TestSubstituteCountAll",
                "newPage": false,
                "searchKey": "query.TestSubstituteCountAll",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSubstituteCountAll(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSubstituteCountAll(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestSubstituteOrForRegexp",
              "documentation": {
                "identifier": "TestSubstituteOrForRegexp",
                "newPage": false,
                "searchKey": "query.TestSubstituteOrForRegexp",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSubstituteOrForRegexp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSubstituteOrForRegexp(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestTranslateBadGlobPattern",
              "documentation": {
                "identifier": "TestTranslateBadGlobPattern",
                "newPage": false,
                "searchKey": "query.TestTranslateBadGlobPattern",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTranslateBadGlobPattern(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTranslateBadGlobPattern(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#TestTranslateGlobToRegex",
              "documentation": {
                "identifier": "TestTranslateGlobToRegex",
                "newPage": false,
                "searchKey": "query.TestTranslateGlobToRegex",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTranslateGlobToRegex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTranslateGlobToRegex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ToNodes",
              "documentation": {
                "identifier": "ToNodes",
                "newPage": false,
                "searchKey": "query.ToNodes",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ToNodes(parameters []Parameter) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ToNodes(parameters []Parameter) []Node\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#Validate",
              "documentation": {
                "identifier": "Validate",
                "newPage": false,
                "searchKey": "query.Validate",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Validate(disjuncts [][]Node) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Validate(disjuncts [][]Node) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#VisitField",
              "documentation": {
                "identifier": "VisitField",
                "newPage": false,
                "searchKey": "query.VisitField",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func VisitField(nodes []Node, field string, callback func(value string, negated bool, annotation Annotation))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc VisitField(nodes []Node, field string, callback func(value string, negated bool, annotation Annotation))\n```\n\nVisitField convenience function that calls callback on all parameter nodes whose field matches the field argument. callback supplies the node's value and whether the value is negated. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#VisitOperator",
              "documentation": {
                "identifier": "VisitOperator",
                "newPage": false,
                "searchKey": "query.VisitOperator",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func VisitOperator(nodes []Node, callback func(kind operatorKind, operands []Node))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc VisitOperator(nodes []Node, callback func(kind operatorKind, operands []Node))\n```\n\nVisitOperator is a convenience function that calls callback on all operator nodes. callback supplies the node's kind and operands. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#VisitParameter",
              "documentation": {
                "identifier": "VisitParameter",
                "newPage": false,
                "searchKey": "query.VisitParameter",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func VisitParameter(nodes []Node, callback func(field, value string, negated bool, annotation Annotation))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc VisitParameter(nodes []Node, callback func(field, value string, negated bool, annotation Annotation))\n```\n\nVisitParameter is a convenience function that calls callback on all parameter nodes. callback supplies the node's field, value, and whether the value is negated. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#VisitPattern",
              "documentation": {
                "identifier": "VisitPattern",
                "newPage": false,
                "searchKey": "query.VisitPattern",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func VisitPattern(nodes []Node, callback func(value string, negated bool, annotation Annotation))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc VisitPattern(nodes []Node, callback func(value string, negated bool, annotation Annotation))\n```\n\nVisitPattern is a convenience function that calls callback on all pattern nodes. callback supplies the node's value value, and whether the value is negated or quoted. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#containsPattern",
              "documentation": {
                "identifier": "containsPattern",
                "newPage": false,
                "searchKey": "query.containsPattern",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func containsPattern(node Node) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc containsPattern(node Node) bool\n```\n\ncontainsPattern returns true if any descendent of nodes is a search pattern. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#distribute",
              "documentation": {
                "identifier": "distribute",
                "newPage": false,
                "searchKey": "query.distribute",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func distribute(prefixes [][]Node, nodes []Node) [][]Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc distribute(prefixes [][]Node, nodes []Node) [][]Node\n```\n\ndistribute applies the distributed property to nodes. See the dnf function for context. Its first argument takes the current set of prefixes to prepend to each term in an or-expression. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#ellipsesForHoles",
              "documentation": {
                "identifier": "ellipsesForHoles",
                "newPage": false,
                "searchKey": "query.ellipsesForHoles",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ellipsesForHoles(nodes []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ellipsesForHoles(nodes []Node) []Node\n```\n\nellipsesForHoles substitutes ellipses ... for :[_] holes in structural search queries. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#escapeParens",
              "documentation": {
                "identifier": "escapeParens",
                "newPage": false,
                "searchKey": "query.escapeParens",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func escapeParens(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc escapeParens(s string) string\n```\n\nescapeParens is a heuristic used in the context of regular expression search. It escapes two kinds of patterns: \n\n1. Any occurrence of () is converted to \\(\\). In regex () implies the empty string, which is meaningless as a search query and probably not what the user intended. \n\n2. If the pattern ends with a trailing and unescaped (, it is escaped. Normally, a pattern like foo.*bar( would be an invalid regexp, and we would show no results. But, it is a common and convenient syntax to search for, so we convert thsi pattern to interpret a trailing parenthesis literally. \n\nAny other forms are ignored, for example, foo.*(bar is unchanged. In the parser pipeline, such unchanged and invalid patterns are rejected by the validate function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#escapeParensHeuristic",
              "documentation": {
                "identifier": "escapeParensHeuristic",
                "newPage": false,
                "searchKey": "query.escapeParensHeuristic",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func escapeParensHeuristic(nodes []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc escapeParensHeuristic(nodes []Node) []Node\n```\n\nescapeParensHeuristic escapes certain parentheses in search patterns (see escapeParens). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#exists",
              "documentation": {
                "identifier": "exists",
                "newPage": false,
                "searchKey": "query.exists",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func exists(nodes []Node, fn func(node Node) bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc exists(nodes []Node, fn func(node Node) bool) bool\n```\n\nexists traverses every node in nodes and returns early as soon as fn is satisfied. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#forAll",
              "documentation": {
                "identifier": "forAll",
                "newPage": false,
                "searchKey": "query.forAll",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func forAll(nodes []Node, fn func(node Node) bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc forAll(nodes []Node, fn func(node Node) bool) bool\n```\n\nforAll traverses every node in nodes and returns whether all nodes satisfy fn. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#fuzzifyGlobPattern",
              "documentation": {
                "identifier": "fuzzifyGlobPattern",
                "newPage": false,
                "searchKey": "query.fuzzifyGlobPattern",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fuzzifyGlobPattern(value string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fuzzifyGlobPattern(value string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#globToRegex",
              "documentation": {
                "identifier": "globToRegex",
                "newPage": false,
                "searchKey": "query.globToRegex",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func globToRegex(value string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc globToRegex(value string) (string, error)\n```\n\nglobToRegex converts a glob string to a regular expression. We support: *, ?, and character classes [...]. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#identity",
              "documentation": {
                "identifier": "identity",
                "newPage": false,
                "searchKey": "query.identity",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func identity(nodes []Node) ([]Node, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc identity(nodes []Node) ([]Node, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#isPatternExpression",
              "documentation": {
                "identifier": "isPatternExpression",
                "newPage": false,
                "searchKey": "query.isPatternExpression",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isPatternExpression(nodes []Node) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isPatternExpression(nodes []Node) bool\n```\n\nisPatternExpression returns true if every leaf node in nodes is a search pattern expression. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#isSet",
              "documentation": {
                "identifier": "isSet",
                "newPage": false,
                "searchKey": "query.isSet",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isSet(h, heuristic heuristics) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isSet(h, heuristic heuristics) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#isSpace",
              "documentation": {
                "identifier": "isSpace",
                "newPage": false,
                "searchKey": "query.isSpace",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isSpace(buf []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isSpace(buf []byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#labelStructural",
              "documentation": {
                "identifier": "labelStructural",
                "newPage": false,
                "searchKey": "query.labelStructural",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func labelStructural(nodes []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc labelStructural(nodes []Node) []Node\n```\n\nlabelStructural converts Literal labels to Structural labels. Structural queries are parsed the same as literal queries, we just convert the labels as a postprocessing step to keep the parser lean. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#labelsToString",
              "documentation": {
                "identifier": "labelsToString",
                "newPage": false,
                "searchKey": "query.labelsToString",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func labelsToString(nodes []Node) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc labelsToString(nodes []Node) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#newOperator",
              "documentation": {
                "identifier": "newOperator",
                "newPage": false,
                "searchKey": "query.newOperator",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func newOperator(nodes []Node, kind operatorKind) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newOperator(nodes []Node, kind operatorKind) []Node\n```\n\nnewOperator constructs a new node of kind operatorKind with operands nodes, reducing nodes as needed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#nodesToJSON",
              "documentation": {
                "identifier": "nodesToJSON",
                "newPage": false,
                "searchKey": "query.nodesToJSON",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func nodesToJSON(nodes []Node) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nodesToJSON(nodes []Node) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#nonPredicateRepos",
              "documentation": {
                "identifier": "nonPredicateRepos",
                "newPage": false,
                "searchKey": "query.nonPredicateRepos",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func nonPredicateRepos(q Basic) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nonPredicateRepos(q Basic) []Node\n```\n\nnonPredicateRepos returns the repo nodes in a query that aren't predicates, respecting parameters that determine repo results. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#parseAndOrGrammar",
              "documentation": {
                "identifier": "parseAndOrGrammar",
                "newPage": false,
                "searchKey": "query.parseAndOrGrammar",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseAndOrGrammar(in string) ([]Node, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseAndOrGrammar(in string) ([]Node, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#parseBool",
              "documentation": {
                "identifier": "parseBool",
                "newPage": false,
                "searchKey": "query.parseBool",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseBool(s string) (bool, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseBool(s string) (bool, error)\n```\n\nparseBool is like strconv.ParseBool except that it also accepts y, Y, yes, YES, Yes, n, N, no, NO, No. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#parseRegexpOrPanic",
              "documentation": {
                "identifier": "parseRegexpOrPanic",
                "newPage": false,
                "searchKey": "query.parseRegexpOrPanic",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseRegexpOrPanic(field, value string) *regexp.Regexp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseRegexpOrPanic(field, value string) *regexp.Regexp\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#partition",
              "documentation": {
                "identifier": "partition",
                "newPage": false,
                "searchKey": "query.partition",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func partition(nodes []Node, fn func(node Node) bool) (left, right []Node)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc partition(nodes []Node, fn func(node Node) bool) (left, right []Node)\n```\n\npartition partitions nodes into left and right groups. A node is put in the left group if fn evaluates to true, or in the right group if fn evaluates to false. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#partitionParameters",
              "documentation": {
                "identifier": "partitionParameters",
                "newPage": false,
                "searchKey": "query.partitionParameters",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func partitionParameters(nodes []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc partitionParameters(nodes []Node) []Node\n```\n\npartitionParameters constructs a parse tree to distinguish terms where ordering is insignificant (e.g., \"repo:foo file:bar\") versus terms where ordering may be significant (e.g., search patterns like \"foo bar\"). \n\nThe resulting tree defines an ordering relation on nodes in the following cases: (1) When more than one search patterns exist at the same operator level, they are concatenated in order. (2) Any nonterminal node is concatenated (ordered in the tree) if its descendents contain one or more search patterns. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#planToString",
              "documentation": {
                "identifier": "planToString",
                "newPage": false,
                "searchKey": "query.planToString",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func planToString(disjuncts [][]Node) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc planToString(disjuncts [][]Node) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#processTopLevel",
              "documentation": {
                "identifier": "processTopLevel",
                "newPage": false,
                "searchKey": "query.processTopLevel",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func processTopLevel(nodes []Node) ([]Node, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc processTopLevel(nodes []Node) ([]Node, error)\n```\n\nprocessTopLevel processes the top level of a query. It validates that we can process the query with respect to and/or expressions on file content, but not otherwise for nested parameters. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#product",
              "documentation": {
                "identifier": "product",
                "newPage": false,
                "searchKey": "query.product",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func product(left [][]Node, right []Node) [][]Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc product(left [][]Node, right []Node) [][]Node\n```\n\nproduct appends the list of n elements in right to each of the m rows in left. If left is empty, it is initialized with right. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#reduce",
              "documentation": {
                "identifier": "reduce",
                "newPage": false,
                "searchKey": "query.reduce",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func reduce(left, right []Node, kind operatorKind) ([]Node, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reduce(left, right []Node, kind operatorKind) ([]Node, bool)\n```\n\nreduce takes lists of left and right nodes and reduces them if possible. For example, (and a (b and c))       => (and a b c) (((a and b) or c) or d) => (or (and a b) c d) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#reporevToRegex",
              "documentation": {
                "identifier": "reporevToRegex",
                "newPage": false,
                "searchKey": "query.reporevToRegex",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func reporevToRegex(value string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reporevToRegex(value string) (string, error)\n```\n\nreporevToRegex is a wrapper around globToRegex that takes care of treating repo and rev (as in repo@rev) separately during translation from glob to regex. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#resolveFieldAlias",
              "documentation": {
                "identifier": "resolveFieldAlias",
                "newPage": false,
                "searchKey": "query.resolveFieldAlias",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func resolveFieldAlias(field string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resolveFieldAlias(field string) string\n```\n\nresolveFieldAlias resolves an aliased field like `r:` to its canonical name like `repo:`. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#skipSpace",
              "documentation": {
                "identifier": "skipSpace",
                "newPage": false,
                "searchKey": "query.skipSpace",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func skipSpace(buf []byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc skipSpace(buf []byte) int\n```\n\nskipSpace returns the number of whitespace bytes skipped from the beginning of a buffer buf. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#stringHumanParameters",
              "documentation": {
                "identifier": "stringHumanParameters",
                "newPage": false,
                "searchKey": "query.stringHumanParameters",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringHumanParameters(parameters []Parameter) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringHumanParameters(parameters []Parameter) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#stringHumanPattern",
              "documentation": {
                "identifier": "stringHumanPattern",
                "newPage": false,
                "searchKey": "query.stringHumanPattern",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringHumanPattern(nodes []Node) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringHumanPattern(nodes []Node) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#substituteConcat",
              "documentation": {
                "identifier": "substituteConcat",
                "newPage": false,
                "searchKey": "query.substituteConcat",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func substituteConcat(callback func([]Pattern) Pattern) func(nodes []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc substituteConcat(callback func([]Pattern) Pattern) func(nodes []Node) []Node\n```\n\nsubstituteConcat returns a function that concatenates all contiguous patterns in the tree, rooted by a concat operator. Concat operators containing negated patterns are lifted out: (concat \"a\" (not \"b\")) -> (\"a\" (not \"b\")) \n\nThe callback parameter defines how the function concatenates patterns. The return value of callback is substituted in-place in the tree. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#substituteOrForRegexp",
              "documentation": {
                "identifier": "substituteOrForRegexp",
                "newPage": false,
                "searchKey": "query.substituteOrForRegexp",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func substituteOrForRegexp(nodes []Node) []Node"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc substituteOrForRegexp(nodes []Node) []Node\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#toJSON",
              "documentation": {
                "identifier": "toJSON",
                "newPage": false,
                "searchKey": "query.toJSON",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func toJSON(node Node) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc toJSON(node Node) interface{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#toParameters",
              "documentation": {
                "identifier": "toParameters",
                "newPage": false,
                "searchKey": "query.toParameters",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func toParameters(nodes []Node) []Parameter"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc toParameters(nodes []Node) []Parameter\n```\n\nConverts a flat list of nodes to parameters. Invariant: nodes are parameters. This function is intended for internal use only, which assumes the invariant. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#toString",
              "documentation": {
                "identifier": "toString",
                "newPage": false,
                "searchKey": "query.toString",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func toString(nodes []Node) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc toString(nodes []Node) string\n```\n\ntoString returns a string representation of a query's structure. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#translateCharacterClass",
              "documentation": {
                "identifier": "translateCharacterClass",
                "newPage": false,
                "searchKey": "query.translateCharacterClass",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func translateCharacterClass(r []rune, startIx int) (int, string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc translateCharacterClass(r []rune, startIx int) (int, string, error)\n```\n\ntranslateCharacterClass translates character classes like [a-zA-Z]. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#validate",
              "documentation": {
                "identifier": "validate",
                "newPage": false,
                "searchKey": "query.validate",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validate(nodes []Node) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validate(nodes []Node) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#validateCommitParameters",
              "documentation": {
                "identifier": "validateCommitParameters",
                "newPage": false,
                "searchKey": "query.validateCommitParameters",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validateCommitParameters(nodes []Node) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validateCommitParameters(nodes []Node) error\n```\n\nQueries containing commit parameters without type:diff or type:commit are not valid. cf. [https://docs.sourcegraph.com/code_search/reference/language#commit-parameter](https://docs.sourcegraph.com/code_search/reference/language#commit-parameter) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#validateField",
              "documentation": {
                "identifier": "validateField",
                "newPage": false,
                "searchKey": "query.validateField",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validateField(field, value string, negated bool, seen map[string]struct{}) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validateField(field, value string, negated bool, seen map[string]struct{}) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#validateParameters",
              "documentation": {
                "identifier": "validateParameters",
                "newPage": false,
                "searchKey": "query.validateParameters",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validateParameters(nodes []Node) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validateParameters(nodes []Node) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#validatePattern",
              "documentation": {
                "identifier": "validatePattern",
                "newPage": false,
                "searchKey": "query.validatePattern",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validatePattern(nodes []Node) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validatePattern(nodes []Node) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#validatePredicates",
              "documentation": {
                "identifier": "validatePredicates",
                "newPage": false,
                "searchKey": "query.validatePredicates",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validatePredicates(nodes []Node) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validatePredicates(nodes []Node) error\n```\n\nvalidatePredicates validates predicate parameters with respect to their validation logic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#validatePureLiteralPattern",
              "documentation": {
                "identifier": "validatePureLiteralPattern",
                "newPage": false,
                "searchKey": "query.validatePureLiteralPattern",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validatePureLiteralPattern(nodes []Node, balanced bool) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validatePureLiteralPattern(nodes []Node, balanced bool) error\n```\n\nvalidatePureLiteralPattern checks that no pattern expression contains and/or operators nested inside concat. It may happen that we interpret a query this way due to ambiguity. If this happens, return an error message. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#validateRepoHasFile",
              "documentation": {
                "identifier": "validateRepoHasFile",
                "newPage": false,
                "searchKey": "query.validateRepoHasFile",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validateRepoHasFile(nodes []Node) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validateRepoHasFile(nodes []Node) error\n```\n\nvalidateRepoHasFile validates that the repohasfile parameter can be executed. A query like `repohasfile:foo type:symbol patter-to-match-symbols` is currently not supported. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#validateRepoRevPair",
              "documentation": {
                "identifier": "validateRepoRevPair",
                "newPage": false,
                "searchKey": "query.validateRepoRevPair",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validateRepoRevPair(nodes []Node) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validateRepoRevPair(nodes []Node) error\n```\n\nA query is invalid if it contains a rev: filter and a repo is specified with @. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/search/query#validateTypeStructural",
              "documentation": {
                "identifier": "validateTypeStructural",
                "newPage": false,
                "searchKey": "query.validateTypeStructural",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validateTypeStructural(nodes []Node) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validateTypeStructural(nodes []Node) error\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
