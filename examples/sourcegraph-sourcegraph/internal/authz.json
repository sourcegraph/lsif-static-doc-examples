{
  "pathID": "/internal/authz",
  "documentation": {
    "identifier": "authz",
    "newPage": true,
    "searchKey": "internal/authz",
    "tags": []
  },
  "label": {
    "kind": "plaintext",
    "value": "Package authz"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package authz contains common logic and interfaces for authorization to external providers (such as GitLab). \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/internal/authz#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/internal/authz#SourcegraphServiceType",
              "documentation": {
                "identifier": "SourcegraphServiceType",
                "newPage": false,
                "searchKey": "authz.SourcegraphServiceType",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SourcegraphServiceType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SourcegraphServiceType = \"sourcegraph\"\n```\n\nThe service type and service ID for explicit repository permissions APIs (aka Sourcegraph authz provider). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#SourcegraphServiceID",
              "documentation": {
                "identifier": "SourcegraphServiceID",
                "newPage": false,
                "searchKey": "authz.SourcegraphServiceID",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SourcegraphServiceID"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SourcegraphServiceID = \"https://sourcegraph.com/\"\n```\n\nThe service type and service ID for explicit repository permissions APIs (aka Sourcegraph authz provider). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#SchemeToken",
              "documentation": {
                "identifier": "SchemeToken",
                "newPage": false,
                "searchKey": "authz.SchemeToken",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SchemeToken"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SchemeToken = \"token\" // Scheme for Authorization header with only an access token\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#SchemeTokenSudo",
              "documentation": {
                "identifier": "SchemeTokenSudo",
                "newPage": false,
                "searchKey": "authz.SchemeTokenSudo",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SchemeTokenSudo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SchemeTokenSudo // Scheme for Authorization header with access token and sudo user\n = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#None",
              "documentation": {
                "identifier": "None",
                "newPage": false,
                "searchKey": "authz.None",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const None"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst None Perms = 0\n```\n\nPerm constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#Read",
              "documentation": {
                "identifier": "Read",
                "newPage": false,
                "searchKey": "authz.Read",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Read"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Read Perms = 1 << iota\n```\n\nPerm constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#Write",
              "documentation": {
                "identifier": "Write",
                "newPage": false,
                "searchKey": "authz.Write",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Write"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Write\n```\n\nPerm constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#PermRepos",
              "documentation": {
                "identifier": "PermRepos",
                "newPage": false,
                "searchKey": "authz.PermRepos",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const PermRepos"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PermRepos PermType = \"repos\"\n```\n\nPermRepos is the list of available user permission types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#ScopeUserAll",
              "documentation": {
                "identifier": "ScopeUserAll",
                "newPage": false,
                "searchKey": "authz.ScopeUserAll",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ScopeUserAll"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ScopeUserAll = \"user:all\" // Full control of all resources accessible to the user account.\n\n```\n\nAccess token scopes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#ScopeSiteAdminSudo",
              "documentation": {
                "identifier": "ScopeSiteAdminSudo",
                "newPage": false,
                "searchKey": "authz.ScopeSiteAdminSudo",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ScopeSiteAdminSudo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ScopeSiteAdminSudo = \"site-admin:sudo\" // Ability to perform any action as any other user.\n\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/internal/authz#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/internal/authz#errUnrecognizedScheme",
              "documentation": {
                "identifier": "errUnrecognizedScheme",
                "newPage": false,
                "searchKey": "authz.errUnrecognizedScheme",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errUnrecognizedScheme"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errUnrecognizedScheme = ...\n```\n\nerrUnrecognizedScheme occurs when the Authorization header scheme (the first token) is not recognized. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#errHTTPAuthParamsDuplicateKey",
              "documentation": {
                "identifier": "errHTTPAuthParamsDuplicateKey",
                "newPage": false,
                "searchKey": "authz.errHTTPAuthParamsDuplicateKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errHTTPAuthParamsDuplicateKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errHTTPAuthParamsDuplicateKey = errors.New(\"duplicate key in HTTP auth-params\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#errHTTPAuthParamsNoEquals",
              "documentation": {
                "identifier": "errHTTPAuthParamsNoEquals",
                "newPage": false,
                "searchKey": "authz.errHTTPAuthParamsNoEquals",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errHTTPAuthParamsNoEquals"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errHTTPAuthParamsNoEquals = errors.New(\"invalid HTTP auth-params list (parameter has no value)\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#ErrPermsNotFound",
              "documentation": {
                "identifier": "ErrPermsNotFound",
                "newPage": false,
                "searchKey": "authz.ErrPermsNotFound",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrPermsNotFound"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrPermsNotFound = errors.New(\"permissions not found\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#allowAccessByDefault",
              "documentation": {
                "identifier": "allowAccessByDefault",
                "newPage": false,
                "searchKey": "authz.allowAccessByDefault",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var allowAccessByDefault"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allowAccessByDefault = true\n```\n\nallowAccessByDefault, if set to true, grants all users access to repositories that are not matched by any authz provider. The default value is true. It is only set to false in error modes (when the configuration is in a state where interpreting it literally could lead to leakage of private repositories). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#authzProvidersReadyOnce",
              "documentation": {
                "identifier": "authzProvidersReadyOnce",
                "newPage": false,
                "searchKey": "authz.authzProvidersReadyOnce",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var authzProvidersReadyOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar authzProvidersReadyOnce sync.Once\n```\n\nauthzProvidersReady and authzProvidersReadyOnce together indicate when GetProviders should no longer block. It should block until SetProviders is called at least once. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#authzProvidersReady",
              "documentation": {
                "identifier": "authzProvidersReady",
                "newPage": false,
                "searchKey": "authz.authzProvidersReady",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var authzProvidersReady"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar authzProvidersReady = make(chan struct{})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#authzProviders",
              "documentation": {
                "identifier": "authzProviders",
                "newPage": false,
                "searchKey": "authz.authzProviders",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var authzProviders"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar authzProviders []Provider\n```\n\nauthzProviders is the currently registered list of authorization providers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#authzMu",
              "documentation": {
                "identifier": "authzMu",
                "newPage": false,
                "searchKey": "authz.authzMu",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var authzMu"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar authzMu sync.RWMutex\n```\n\nauthzMu protects access to both allowAccessByDefault and authzProviders \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#isTest",
              "documentation": {
                "identifier": "isTest",
                "newPage": false,
                "searchKey": "authz.isTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var isTest"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar isTest = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#AllScopes",
              "documentation": {
                "identifier": "AllScopes",
                "newPage": false,
                "searchKey": "authz.AllScopes",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var AllScopes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar AllScopes = []string{\n\tScopeUserAll,\n\tScopeSiteAdminSudo,\n}\n```\n\nAllScopes is a list of all known access token scopes. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/internal/authz#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/internal/authz#ExternalUserPermissions",
              "documentation": {
                "identifier": "ExternalUserPermissions",
                "newPage": false,
                "searchKey": "authz.ExternalUserPermissions",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ExternalUserPermissions struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ExternalUserPermissions struct {\n\tExacts          []extsvc.RepoID\n\tIncludePrefixes []extsvc.RepoID\n\tExcludePrefixes []extsvc.RepoID\n}\n```\n\nExternalUserPermissions is a collection of accessible repository/project IDs (on code host). It contains exact IDs, as well as prefixes to both include and exclude IDs. \n\n🚨 SECURITY: Every call site should evaluate all fields of this struct to have a complete set of IDs. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#Provider",
              "documentation": {
                "identifier": "Provider",
                "newPage": false,
                "searchKey": "authz.Provider",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Provider interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Provider interface {\n\t// FetchAccount returns the external account that identifies the user to this authz provider,\n\t// taking as input the current list of external accounts associated with the\n\t// user. Implementations should always recompute the returned account (rather than returning an\n\t// element of `current` if it has the correct ServiceID and ServiceType).\n\t//\n\t// Implementations should use only the `user` and `current` parameters to compute the returned\n\t// external account. Specifically, they should not try to get the currently authenticated user\n\t// from the context parameter.\n\t//\n\t// The `user` argument should always be non-nil. If no external account can be computed for the\n\t// provided user, implementations should return nil, nil.\n\t//\n\t// The `verifiedEmails` should only contain a list of verified emails that is\n\t// associated to the `user`.\n\tFetchAccount(ctx context.Context, user *types.User, current []*extsvc.Account, verifiedEmails []string) (mine *extsvc.Account, err error)\n\n\t// FetchUserPerms returns a collection of accessible repository/project IDs (on\n\t// code host) that the given account has read access on the code host. The\n\t// repository/project ID should be the same value as it would be used as or\n\t// prefix of api.ExternalRepoSpec.ID. The returned set should only include\n\t// private repositories/project IDs.\n\t//\n\t// Because permissions fetching APIs are often expensive, the implementation should\n\t// try to return partial but valid results in case of error, and it is up to callers\n\t// to decide whether to discard.\n\tFetchUserPerms(ctx context.Context, account *extsvc.Account) (*ExternalUserPermissions, error)\n\n\t// FetchRepoPerms returns a list of user IDs (on code host) who have read access to\n\t// the given repository/project on the code host. The user ID should be the same value\n\t// as it would be used as extsvc.Account.AccountID. The returned list should\n\t// include both direct access and inherited from the group/organization/team membership.\n\t//\n\t// Because permissions fetching APIs are often expensive, the implementation should\n\t// try to return partial but valid results in case of error, and it is up to callers\n\t// to decide whether to discard.\n\tFetchRepoPerms(ctx context.Context, repo *extsvc.Repository) ([]extsvc.AccountID, error)\n\n\t// ServiceType returns the service type (e.g., \"gitlab\") of this authz provider.\n\tServiceType() string\n\n\t// ServiceID returns the service ID (e.g., \"https://gitlab.mycompany.com/\") of this authz\n\t// provider.\n\tServiceID() string\n\n\t// URN returns the unique resource identifier of external service where the authz provider\n\t// is defined.\n\tURN() string\n\n\t// Validate checks the configuration and credentials of the authz provider and returns any\n\t// problems.\n\tValidate() (problems []string)\n}\n```\n\nProvider defines a source of truth of which repositories a user is authorized to view. The user is identified by an extsvc.Account instance. Examples of authz providers include the following: \n\n* Code host * LDAP groups * SAML identity provider (via SAML group permissions) \n\nIn most cases, an authz provider represents a code host, because it is the source of truth for repository permissions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#RepoPerms",
              "documentation": {
                "identifier": "RepoPerms",
                "newPage": false,
                "searchKey": "authz.RepoPerms",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RepoPerms struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RepoPerms struct {\n\tRepo  *types.Repo\n\tPerms Perms\n}\n```\n\nRepoPerms contains a repo and the permissions a given user has associated with it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#Perms",
              "documentation": {
                "identifier": "Perms",
                "newPage": false,
                "searchKey": "authz.Perms",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Perms uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Perms uint32\n```\n\nPerms is a permission set represented as bitset. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/authz#Perms.Include",
                    "documentation": {
                      "identifier": "Perms.Include",
                      "newPage": false,
                      "searchKey": "authz.Perms.Include",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p Perms) Include(other Perms) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p Perms) Include(other Perms) bool\n```\n\nInclude is a convenience method to test if Perms includes all the other Perms. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/authz#Perms.String",
                    "documentation": {
                      "identifier": "Perms.String",
                      "newPage": false,
                      "searchKey": "authz.Perms.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p Perms) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p Perms) String() string\n```\n\nString implements the fmt.Stringer interface. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#PermType",
              "documentation": {
                "identifier": "PermType",
                "newPage": false,
                "searchKey": "authz.PermType",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type PermType string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PermType string\n```\n\nPermType is the object type of the user permissions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#RepoPermsSort",
              "documentation": {
                "identifier": "RepoPermsSort",
                "newPage": false,
                "searchKey": "authz.RepoPermsSort",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RepoPermsSort []authz.RepoPerms"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RepoPermsSort []RepoPerms\n```\n\nRepoPermsSort sorts a slice of RepoPerms to guarantee a stable ordering. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/authz#RepoPermsSort.Len",
                    "documentation": {
                      "identifier": "RepoPermsSort.Len",
                      "newPage": false,
                      "searchKey": "authz.RepoPermsSort.Len",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s RepoPermsSort) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s RepoPermsSort) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/authz#RepoPermsSort.Swap",
                    "documentation": {
                      "identifier": "RepoPermsSort.Swap",
                      "newPage": false,
                      "searchKey": "authz.RepoPermsSort.Swap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s RepoPermsSort) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s RepoPermsSort) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/authz#RepoPermsSort.Less",
                    "documentation": {
                      "identifier": "RepoPermsSort.Less",
                      "newPage": false,
                      "searchKey": "authz.RepoPermsSort.Less",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s RepoPermsSort) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s RepoPermsSort) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#ErrStalePermissions",
              "documentation": {
                "identifier": "ErrStalePermissions",
                "newPage": false,
                "searchKey": "authz.ErrStalePermissions",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ErrStalePermissions struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ErrStalePermissions struct {\n\tUserID int32\n\tPerm   Perms\n\tType   PermType\n}\n```\n\nErrStalePermissions is returned by LoadPermissions when the stored permissions are stale (e.g. the first time a user needs them and they haven't been fetched yet). Callers should pass this error up to the user and show a more friendly prompt message in the UI. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/authz#ErrStalePermissions.Error",
                    "documentation": {
                      "identifier": "ErrStalePermissions.Error",
                      "newPage": false,
                      "searchKey": "authz.ErrStalePermissions.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e ErrStalePermissions) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e ErrStalePermissions) Error() string\n```\n\nError implements the error interface. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#UserPermissions",
              "documentation": {
                "identifier": "UserPermissions",
                "newPage": false,
                "searchKey": "authz.UserPermissions",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type UserPermissions struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype UserPermissions struct {\n\tUserID    int32           // The internal database ID of a user\n\tPerm      Perms           // The permission set\n\tType      PermType        // The type of the permissions\n\tIDs       *roaring.Bitmap // The object IDs\n\tUpdatedAt time.Time       // The last updated time\n\tSyncedAt  time.Time       // The last user-centric synced time\n}\n```\n\nUserPermissions are the permissions of a user to perform an action on the given set of object IDs of the defined type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/authz#UserPermissions.Expired",
                    "documentation": {
                      "identifier": "UserPermissions.Expired",
                      "newPage": false,
                      "searchKey": "authz.UserPermissions.Expired",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *UserPermissions) Expired(ttl time.Duration, now time.Time) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *UserPermissions) Expired(ttl time.Duration, now time.Time) bool\n```\n\nExpired returns true if these UserPermissions have elapsed the given ttl. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/authz#UserPermissions.AuthorizedRepos",
                    "documentation": {
                      "identifier": "UserPermissions.AuthorizedRepos",
                      "newPage": false,
                      "searchKey": "authz.UserPermissions.AuthorizedRepos",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *UserPermissions) AuthorizedRepos(repos []*types.Repo) []RepoPerms"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *UserPermissions) AuthorizedRepos(repos []*types.Repo) []RepoPerms\n```\n\nAuthorizedRepos returns the intersection of the given repository IDs with the authorized IDs. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/authz#UserPermissions.TracingFields",
                    "documentation": {
                      "identifier": "UserPermissions.TracingFields",
                      "newPage": false,
                      "searchKey": "authz.UserPermissions.TracingFields",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *UserPermissions) TracingFields() []otlog.Field"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *UserPermissions) TracingFields() []otlog.Field\n```\n\nTracingFields returns tracing fields for the opentracing log. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#RepoPermissions",
              "documentation": {
                "identifier": "RepoPermissions",
                "newPage": false,
                "searchKey": "authz.RepoPermissions",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RepoPermissions struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RepoPermissions struct {\n\tRepoID    int32           // The internal database ID of a repository\n\tPerm      Perms           // The permission set\n\tUserIDs   *roaring.Bitmap // The user IDs\n\tUpdatedAt time.Time       // The last updated time\n\tSyncedAt  time.Time       // The last repo-centric synced time\n}\n```\n\nRepoPermissions declares which users have access to a given repository \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/authz#RepoPermissions.Expired",
                    "documentation": {
                      "identifier": "RepoPermissions.Expired",
                      "newPage": false,
                      "searchKey": "authz.RepoPermissions.Expired",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *RepoPermissions) Expired(ttl time.Duration, now time.Time) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *RepoPermissions) Expired(ttl time.Duration, now time.Time) bool\n```\n\nExpired returns true if these RepoPermissions have elapsed the given ttl. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/internal/authz#RepoPermissions.TracingFields",
                    "documentation": {
                      "identifier": "RepoPermissions.TracingFields",
                      "newPage": false,
                      "searchKey": "authz.RepoPermissions.TracingFields",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *RepoPermissions) TracingFields() []otlog.Field"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *RepoPermissions) TracingFields() []otlog.Field\n```\n\nTracingFields returns tracing fields for the opentracing log. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#UserPendingPermissions",
              "documentation": {
                "identifier": "UserPendingPermissions",
                "newPage": false,
                "searchKey": "authz.UserPendingPermissions",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type UserPendingPermissions struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype UserPendingPermissions struct {\n\t// The auto-generated internal database ID.\n\tID int32\n\t// The type of the code host as if it would be used as extsvc.AccountSpec.ServiceType,\n\t// e.g. \"github\", \"gitlab\", \"bitbucketServer\" and \"sourcegraph\".\n\tServiceType string\n\t// The ID of the code host as if it would be used as extsvc.AccountSpec.ServiceID,\n\t// e.g. \"https://github.com/\", \"https://gitlab.com/\" and \"https://sourcegraph.com/\".\n\tServiceID string\n\t// The account ID that a code host (and its authz provider) uses to identify a user,\n\t// e.g. a username (for Bitbucket Server), a GraphID ( for GitHub), or a user ID\n\t// (for GitLab).\n\t//\n\t// When use the Sourcegraph authz provider, \"BindID\" can be either a username or\n\t// an email based on site configuration.\n\tBindID string\n\t// The permissions this user has to the \"IDs\" of the \"Type\".\n\tPerm Perms\n\t// The type of permissions this user has.\n\tType PermType\n\t// The object IDs with the \"Type\".\n\tIDs *roaring.Bitmap\n\t// The last updated time.\n\tUpdatedAt time.Time\n}\n```\n\nUserPendingPermissions defines permissions that a not-yet-created user has to perform on a given set of object IDs. Not-yet-created users may exist on the code host but not yet in Sourcegraph. \"ServiceType\", \"ServiceID\" and \"BindID\" are used to map this stub user to an actual user when the user is created. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/internal/authz#UserPendingPermissions.TracingFields",
                    "documentation": {
                      "identifier": "UserPendingPermissions.TracingFields",
                      "newPage": false,
                      "searchKey": "authz.UserPendingPermissions.TracingFields",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *UserPendingPermissions) TracingFields() []otlog.Field"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *UserPendingPermissions) TracingFields() []otlog.Field\n```\n\nTracingFields returns tracing fields for the opentracing log. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/internal/authz#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/internal/authz#IsUnrecognizedScheme",
              "documentation": {
                "identifier": "IsUnrecognizedScheme",
                "newPage": false,
                "searchKey": "authz.IsUnrecognizedScheme",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsUnrecognizedScheme(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsUnrecognizedScheme(err error) bool\n```\n\nIsUnrecognizedScheme reports whether err indicates that the request's Authorization header scheme is unrecognized or unparseable (i.e., is neither \"token\" nor \"token-sudo\"). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#ParseAuthorizationHeader",
              "documentation": {
                "identifier": "ParseAuthorizationHeader",
                "newPage": false,
                "searchKey": "authz.ParseAuthorizationHeader",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ParseAuthorizationHeader(headerValue string) (token, sudoUser string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ParseAuthorizationHeader(headerValue string) (token, sudoUser string, err error)\n```\n\nParseAuthorizationHeader parses the HTTP Authorization request header for supported credentials values. \n\nTwo forms of the Authorization header's \"credentials\" token are supported (see [RFC 7235, Appendix C]([https://tools.ietf.org/html/rfc7235#appendix-C](https://tools.ietf.org/html/rfc7235#appendix-C)): \n\n- With only an access token: \"token\" 1*SP token68 - With a token as params: \n\n```\n\"token\" 1*SP \"token\" BWS \"=\" BWS quoted-string\n\n```\nThe returned values are derived directly from user input and have not been validated or authenticated. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#parseHTTPCredentials",
              "documentation": {
                "identifier": "parseHTTPCredentials",
                "newPage": false,
                "searchKey": "authz.parseHTTPCredentials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseHTTPCredentials(credentials string) (scheme, token68 string, params map[string]string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseHTTPCredentials(credentials string) (scheme, token68 string, params map[string]string, err error)\n```\n\nparseHTTPCredentials parses the \"credentials\" token as defined in [RFC 7235 Appendix C]([https://tools.ietf.org/html/rfc7235#appendix-C](https://tools.ietf.org/html/rfc7235#appendix-C)). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#parseHTTPAuthParams",
              "documentation": {
                "identifier": "parseHTTPAuthParams",
                "newPage": false,
                "searchKey": "authz.parseHTTPAuthParams",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseHTTPAuthParams(value string) (params map[string]string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseHTTPAuthParams(value string) (params map[string]string, err error)\n```\n\nparseHTTPAuthParams extracts key/value pairs from a comma-separated list of auth-params as defined in [RFC 7235, Appendix C]([https://tools.ietf.org/html/rfc7235#appendix-C](https://tools.ietf.org/html/rfc7235#appendix-C)) and returns a map. \n\nThe resulting values are unquoted. The keys are matched case-insensitively, and each key MUST only occur once per challenge (according to [RFC 7235, Section 2.1]([https://tools.ietf.org/html/rfc7235#section-2.1](https://tools.ietf.org/html/rfc7235#section-2.1))). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#parseHTTPHeaderList",
              "documentation": {
                "identifier": "parseHTTPHeaderList",
                "newPage": false,
                "searchKey": "authz.parseHTTPHeaderList",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseHTTPHeaderList(value string) []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseHTTPHeaderList(value string) []string\n```\n\nparseHTTPHeaderList parses a \"#rule\" as defined in [RFC 2068 Section 2.1]([https://tools.ietf.org/html/rfc2068#section-2.1](https://tools.ietf.org/html/rfc2068#section-2.1)). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#SetProviders",
              "documentation": {
                "identifier": "SetProviders",
                "newPage": false,
                "searchKey": "authz.SetProviders",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetProviders(authzAllowByDefault bool, z []Provider)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetProviders(authzAllowByDefault bool, z []Provider)\n```\n\nSetProviders sets the current authz parameters. It is concurrency-safe. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#GetProviders",
              "documentation": {
                "identifier": "GetProviders",
                "newPage": false,
                "searchKey": "authz.GetProviders",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func GetProviders() (authzAllowByDefault bool, providers []Provider)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc GetProviders() (authzAllowByDefault bool, providers []Provider)\n```\n\nGetProviders returns the current authz parameters. It is concurrency-safe. \n\nIt blocks until SetProviders has been called at least once. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#TestParseAuthorizationHeader",
              "documentation": {
                "identifier": "TestParseAuthorizationHeader",
                "newPage": false,
                "searchKey": "authz.TestParseAuthorizationHeader",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseAuthorizationHeader(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseAuthorizationHeader(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#TestParseHTTPCredentials",
              "documentation": {
                "identifier": "TestParseHTTPCredentials",
                "newPage": false,
                "searchKey": "authz.TestParseHTTPCredentials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseHTTPCredentials(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseHTTPCredentials(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#TestPermsInclude",
              "documentation": {
                "identifier": "TestPermsInclude",
                "newPage": false,
                "searchKey": "authz.TestPermsInclude",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPermsInclude(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPermsInclude(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#BenchmarkPermsInclude",
              "documentation": {
                "identifier": "BenchmarkPermsInclude",
                "newPage": false,
                "searchKey": "authz.BenchmarkPermsInclude",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkPermsInclude(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkPermsInclude(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#TestPermsString",
              "documentation": {
                "identifier": "TestPermsString",
                "newPage": false,
                "searchKey": "authz.TestPermsString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPermsString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPermsString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#BenchmarkPermsString",
              "documentation": {
                "identifier": "BenchmarkPermsString",
                "newPage": false,
                "searchKey": "authz.BenchmarkPermsString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkPermsString(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkPermsString(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#bitmap",
              "documentation": {
                "identifier": "bitmap",
                "newPage": false,
                "searchKey": "authz.bitmap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bitmap(ids ...uint32) *roaring.Bitmap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bitmap(ids ...uint32) *roaring.Bitmap\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/internal/authz#TestUserPermissions_AuthorizedRepos",
              "documentation": {
                "identifier": "TestUserPermissions_AuthorizedRepos",
                "newPage": false,
                "searchKey": "authz.TestUserPermissions_AuthorizedRepos",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUserPermissions_AuthorizedRepos(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUserPermissions_AuthorizedRepos(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "pathID": "/internal/authz/bitbucketserver"
    },
    {
      "pathID": "/internal/authz/github"
    },
    {
      "pathID": "/internal/authz/gitlab"
    },
    {
      "pathID": "/internal/authz/perforce"
    }
  ]
}
