{
  "pathID": "/crypto/ed25519_test",
  "documentation": {
    "identifier": "ed25519_test",
    "newPage": true,
    "searchKey": "crypto/ed25519_test",
    "tags": [
      "private",
      "package"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package ed25519_test"
  },
  "detail": {
    "kind": "markdown",
    "value": ""
  },
  "children": [
    {
      "node": {
        "pathID": "/crypto/ed25519_test#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "private"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/crypto/ed25519_test#TestEd25519Vectors",
              "documentation": {
                "identifier": "TestEd25519Vectors",
                "newPage": false,
                "searchKey": "ed25519_test.TestEd25519Vectors",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEd25519Vectors(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEd25519Vectors(t *testing.T)\n```\n\nTestEd25519Vectors runs a very large set of test vectors that exercise all combinations of low-order points, low-order components, and non-canonical encodings. These vectors lock in unspecified and spec-divergent behaviors in edge cases that are not security relevant in most contexts, but that can cause issues in consensus applications if changed. \n\nOur behavior matches the \"classic\" unwritten verification rules of the \"ref10\" reference implementation. \n\nNote that although we test for these edge cases, they are not covered by the Go 1 Compatibility Promise. Applications that need stable verification rules should use github.com/hdevalence/ed25519consensus. \n\nSee [https://hdevalence.ca/blog/2020-10-04-its-25519am](https://hdevalence.ca/blog/2020-10-04-its-25519am) for more details. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/crypto/ed25519_test#decodeHex",
              "documentation": {
                "identifier": "decodeHex",
                "newPage": false,
                "searchKey": "ed25519_test.decodeHex",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func decodeHex(t *testing.T, s string) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc decodeHex(t *testing.T, s string) []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/crypto/ed25519_test#downloadEd25519Vectors",
              "documentation": {
                "identifier": "downloadEd25519Vectors",
                "newPage": false,
                "searchKey": "ed25519_test.downloadEd25519Vectors",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func downloadEd25519Vectors(t *testing.T) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc downloadEd25519Vectors(t *testing.T) []byte\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
