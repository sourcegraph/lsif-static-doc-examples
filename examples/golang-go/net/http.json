{
  "pathID": "/net/http",
  "documentation": {
    "identifier": "http",
    "newPage": true,
    "searchKey": "net/http",
    "tags": [
      "package"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package http"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package http provides HTTP client and server implementations. \n\nGet, Head, Post, and PostForm make HTTP (or HTTPS) requests: \n\n```\nresp, err := http.Get(\"[http://example.com/](http://example.com/)\")\n...\nresp, err := http.Post(\"[http://example.com/upload](http://example.com/upload)\", \"image/jpeg\", &buf)\n...\nresp, err := http.PostForm(\"[http://example.com/form](http://example.com/form)\",\n\turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n\n```\nThe client must close the response body when finished with it: \n\n```\nresp, err := http.Get(\"[http://example.com/](http://example.com/)\")\nif err != nil {\n\t// handle error\n}\ndefer resp.Body.Close()\nbody, err := io.ReadAll(resp.Body)\n// ...\n\n```\nFor control over HTTP client headers, redirect policy, and other settings, create a Client: \n\n```\nclient := &http.Client{\n\tCheckRedirect: redirectPolicyFunc,\n}\n\nresp, err := client.Get(\"[http://example.com](http://example.com)\")\n// ...\n\nreq, err := http.NewRequest(\"GET\", \"[http://example.com](http://example.com)\", nil)\n// ...\nreq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\nresp, err := client.Do(req)\n// ...\n\n```\nFor control over proxies, TLS configuration, keep-alives, compression, and other settings, create a Transport: \n\n```\ntr := &http.Transport{\n\tMaxIdleConns:       10,\n\tIdleConnTimeout:    30 * time.Second,\n\tDisableCompression: true,\n}\nclient := &http.Client{Transport: tr}\nresp, err := client.Get(\"[https://example.com](https://example.com)\")\n\n```\nClients and Transports are safe for concurrent use by multiple goroutines and for efficiency should only be created once and re-used. \n\nListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux: \n\n```\nhttp.Handle(\"/foo\", fooHandler)\n\nhttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n})\n\nlog.Fatal(http.ListenAndServe(\":8080\", nil))\n\n```\nMore control over the server's behavior is available by creating a custom Server: \n\n```\ns := &http.Server{\n\tAddr:           \":8080\",\n\tHandler:        myHandler,\n\tReadTimeout:    10 * time.Second,\n\tWriteTimeout:   10 * time.Second,\n\tMaxHeaderBytes: 1 << 20,\n}\nlog.Fatal(s.ListenAndServe())\n\n```\nStarting with Go 1.6, the http package has transparent support for the HTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2 can do so by setting Transport.TLSNextProto (for clients) or Server.TLSNextProto (for servers) to a non-nil, empty map. Alternatively, the following GODEBUG environment variables are currently supported: \n\n```\nGODEBUG=http2client=0  # disable HTTP/2 client support\nGODEBUG=http2server=0  # disable HTTP/2 server support\nGODEBUG=http2debug=1   # enable verbose HTTP/2 debug logs\nGODEBUG=http2debug=2   # ... even more verbose, with frame dumps\n\n```\nThe GODEBUG variables are not covered by Go's API compatibility promise. Please report any issues before disabling HTTP/2 support: [https://golang.org/s/http2bug](https://golang.org/s/http2bug) \n\nThe http package's Transport and Server both automatically enable HTTP/2 support for simple configurations. To enable HTTP/2 for more complex configurations, to use lower-level HTTP/2 features, or to use a newer version of Go's http2 package, import \"golang.org/x/net/http2\" directly and use its ConfigureTransport and/or ConfigureServer functions. Manually configuring HTTP/2 via the golang.org/x/net/http2 package takes precedence over the net/http package's built-in HTTP/2 support. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/net/http#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/net/http#DefaultMaxHeaderBytes",
              "documentation": {
                "identifier": "DefaultMaxHeaderBytes",
                "newPage": false,
                "searchKey": "http.DefaultMaxHeaderBytes",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const DefaultMaxHeaderBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst DefaultMaxHeaderBytes = 1 << 20 // 1 MB\n\n```\n\nDefaultMaxHeaderBytes is the maximum permitted size of the headers in an HTTP request. This can be overridden by setting Server.MaxHeaderBytes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#DefaultMaxIdleConnsPerHost",
              "documentation": {
                "identifier": "DefaultMaxIdleConnsPerHost",
                "newPage": false,
                "searchKey": "http.DefaultMaxIdleConnsPerHost",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const DefaultMaxIdleConnsPerHost"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst DefaultMaxIdleConnsPerHost = 2\n```\n\nDefaultMaxIdleConnsPerHost is the default value of Transport's MaxIdleConnsPerHost. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#MaxWriteWaitBeforeConnReuse",
              "documentation": {
                "identifier": "MaxWriteWaitBeforeConnReuse",
                "newPage": false,
                "searchKey": "http.MaxWriteWaitBeforeConnReuse",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MaxWriteWaitBeforeConnReuse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MaxWriteWaitBeforeConnReuse = maxWriteWaitBeforeConnReuse\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#MethodConnect",
              "documentation": {
                "identifier": "MethodConnect",
                "newPage": false,
                "searchKey": "http.MethodConnect",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MethodConnect"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MethodConnect = \"CONNECT\"\n```\n\nCommon HTTP methods. \n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#MethodDelete",
              "documentation": {
                "identifier": "MethodDelete",
                "newPage": false,
                "searchKey": "http.MethodDelete",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MethodDelete"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MethodDelete = \"DELETE\"\n```\n\nCommon HTTP methods. \n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#MethodGet",
              "documentation": {
                "identifier": "MethodGet",
                "newPage": false,
                "searchKey": "http.MethodGet",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MethodGet"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MethodGet = \"GET\"\n```\n\nCommon HTTP methods. \n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#MethodHead",
              "documentation": {
                "identifier": "MethodHead",
                "newPage": false,
                "searchKey": "http.MethodHead",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MethodHead"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MethodHead = \"HEAD\"\n```\n\nCommon HTTP methods. \n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#MethodOptions",
              "documentation": {
                "identifier": "MethodOptions",
                "newPage": false,
                "searchKey": "http.MethodOptions",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MethodOptions"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MethodOptions = \"OPTIONS\"\n```\n\nCommon HTTP methods. \n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#MethodPatch",
              "documentation": {
                "identifier": "MethodPatch",
                "newPage": false,
                "searchKey": "http.MethodPatch",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MethodPatch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MethodPatch = \"PATCH\" // RFC 5789\n\n```\n\nCommon HTTP methods. \n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#MethodPost",
              "documentation": {
                "identifier": "MethodPost",
                "newPage": false,
                "searchKey": "http.MethodPost",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MethodPost"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MethodPost = \"POST\"\n```\n\nCommon HTTP methods. \n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#MethodPut",
              "documentation": {
                "identifier": "MethodPut",
                "newPage": false,
                "searchKey": "http.MethodPut",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MethodPut"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MethodPut = \"PUT\"\n```\n\nCommon HTTP methods. \n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#MethodTrace",
              "documentation": {
                "identifier": "MethodTrace",
                "newPage": false,
                "searchKey": "http.MethodTrace",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MethodTrace"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MethodTrace = \"TRACE\"\n```\n\nCommon HTTP methods. \n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#SameSiteDefaultMode",
              "documentation": {
                "identifier": "SameSiteDefaultMode",
                "newPage": false,
                "searchKey": "http.SameSiteDefaultMode",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SameSiteDefaultMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SameSiteDefaultMode SameSite = iota + 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#SameSiteLaxMode",
              "documentation": {
                "identifier": "SameSiteLaxMode",
                "newPage": false,
                "searchKey": "http.SameSiteLaxMode",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SameSiteLaxMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SameSiteLaxMode\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#SameSiteNoneMode",
              "documentation": {
                "identifier": "SameSiteNoneMode",
                "newPage": false,
                "searchKey": "http.SameSiteNoneMode",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SameSiteNoneMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SameSiteNoneMode\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#SameSiteStrictMode",
              "documentation": {
                "identifier": "SameSiteStrictMode",
                "newPage": false,
                "searchKey": "http.SameSiteStrictMode",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SameSiteStrictMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SameSiteStrictMode\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StateActive",
              "documentation": {
                "identifier": "StateActive",
                "newPage": false,
                "searchKey": "http.StateActive",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StateActive"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StateActive\n```\n\nStateActive represents a connection that has read 1 or more bytes of a request. The Server.ConnState hook for StateActive fires before the request has entered a handler and doesn't fire again until the request has been handled. After the request is handled, the state transitions to StateClosed, StateHijacked, or StateIdle. For HTTP/2, StateActive fires on the transition from zero to one active request, and only transitions away once all active requests are complete. That means that ConnState cannot be used to do per-request work; ConnState only notes the overall state of the connection. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StateClosed",
              "documentation": {
                "identifier": "StateClosed",
                "newPage": false,
                "searchKey": "http.StateClosed",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StateClosed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StateClosed\n```\n\nStateClosed represents a closed connection. This is a terminal state. Hijacked connections do not transition to StateClosed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StateHijacked",
              "documentation": {
                "identifier": "StateHijacked",
                "newPage": false,
                "searchKey": "http.StateHijacked",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StateHijacked"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StateHijacked\n```\n\nStateHijacked represents a hijacked connection. This is a terminal state. It does not transition to StateClosed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StateIdle",
              "documentation": {
                "identifier": "StateIdle",
                "newPage": false,
                "searchKey": "http.StateIdle",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StateIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StateIdle\n```\n\nStateIdle represents a connection that has finished handling a request and is in the keep-alive state, waiting for a new request. Connections transition from StateIdle to either StateActive or StateClosed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StateNew",
              "documentation": {
                "identifier": "StateNew",
                "newPage": false,
                "searchKey": "http.StateNew",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StateNew"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StateNew ConnState = iota\n```\n\nStateNew represents a new connection that is expected to send a request immediately. Connections begin at this state and then transition to either StateActive or StateClosed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusAccepted",
              "documentation": {
                "identifier": "StatusAccepted",
                "newPage": false,
                "searchKey": "http.StatusAccepted",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusAccepted"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusAccepted = 202 // RFC 7231, 6.3.3\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusAlreadyReported",
              "documentation": {
                "identifier": "StatusAlreadyReported",
                "newPage": false,
                "searchKey": "http.StatusAlreadyReported",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusAlreadyReported"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusAlreadyReported = 208 // RFC 5842, 7.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusBadGateway",
              "documentation": {
                "identifier": "StatusBadGateway",
                "newPage": false,
                "searchKey": "http.StatusBadGateway",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusBadGateway"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusBadGateway = 502 // RFC 7231, 6.6.3\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusBadRequest",
              "documentation": {
                "identifier": "StatusBadRequest",
                "newPage": false,
                "searchKey": "http.StatusBadRequest",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusBadRequest"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusBadRequest = 400 // RFC 7231, 6.5.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusConflict",
              "documentation": {
                "identifier": "StatusConflict",
                "newPage": false,
                "searchKey": "http.StatusConflict",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusConflict"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusConflict = 409 // RFC 7231, 6.5.8\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusContinue",
              "documentation": {
                "identifier": "StatusContinue",
                "newPage": false,
                "searchKey": "http.StatusContinue",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusContinue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusContinue = 100 // RFC 7231, 6.2.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusCreated",
              "documentation": {
                "identifier": "StatusCreated",
                "newPage": false,
                "searchKey": "http.StatusCreated",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusCreated"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusCreated = 201 // RFC 7231, 6.3.2\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusEarlyHints",
              "documentation": {
                "identifier": "StatusEarlyHints",
                "newPage": false,
                "searchKey": "http.StatusEarlyHints",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusEarlyHints"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusEarlyHints = 103 // RFC 8297\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusExpectationFailed",
              "documentation": {
                "identifier": "StatusExpectationFailed",
                "newPage": false,
                "searchKey": "http.StatusExpectationFailed",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusExpectationFailed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusExpectationFailed = 417 // RFC 7231, 6.5.14\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusFailedDependency",
              "documentation": {
                "identifier": "StatusFailedDependency",
                "newPage": false,
                "searchKey": "http.StatusFailedDependency",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusFailedDependency"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusFailedDependency = 424 // RFC 4918, 11.4\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusForbidden",
              "documentation": {
                "identifier": "StatusForbidden",
                "newPage": false,
                "searchKey": "http.StatusForbidden",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusForbidden"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusForbidden = 403 // RFC 7231, 6.5.3\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusFound",
              "documentation": {
                "identifier": "StatusFound",
                "newPage": false,
                "searchKey": "http.StatusFound",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusFound"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusFound = 302 // RFC 7231, 6.4.3\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusGatewayTimeout",
              "documentation": {
                "identifier": "StatusGatewayTimeout",
                "newPage": false,
                "searchKey": "http.StatusGatewayTimeout",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusGatewayTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusGatewayTimeout = 504 // RFC 7231, 6.6.5\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusGone",
              "documentation": {
                "identifier": "StatusGone",
                "newPage": false,
                "searchKey": "http.StatusGone",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusGone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusGone = 410 // RFC 7231, 6.5.9\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusHTTPVersionNotSupported",
              "documentation": {
                "identifier": "StatusHTTPVersionNotSupported",
                "newPage": false,
                "searchKey": "http.StatusHTTPVersionNotSupported",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusHTTPVersionNotSupported"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusHTTPVersionNotSupported = 505 // RFC 7231, 6.6.6\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusIMUsed",
              "documentation": {
                "identifier": "StatusIMUsed",
                "newPage": false,
                "searchKey": "http.StatusIMUsed",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusIMUsed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusIMUsed = 226 // RFC 3229, 10.4.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusInsufficientStorage",
              "documentation": {
                "identifier": "StatusInsufficientStorage",
                "newPage": false,
                "searchKey": "http.StatusInsufficientStorage",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusInsufficientStorage"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusInsufficientStorage = 507 // RFC 4918, 11.5\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusInternalServerError",
              "documentation": {
                "identifier": "StatusInternalServerError",
                "newPage": false,
                "searchKey": "http.StatusInternalServerError",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusInternalServerError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusInternalServerError = 500 // RFC 7231, 6.6.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusLengthRequired",
              "documentation": {
                "identifier": "StatusLengthRequired",
                "newPage": false,
                "searchKey": "http.StatusLengthRequired",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusLengthRequired"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusLengthRequired = 411 // RFC 7231, 6.5.10\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusLocked",
              "documentation": {
                "identifier": "StatusLocked",
                "newPage": false,
                "searchKey": "http.StatusLocked",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusLocked"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusLocked = 423 // RFC 4918, 11.3\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusLoopDetected",
              "documentation": {
                "identifier": "StatusLoopDetected",
                "newPage": false,
                "searchKey": "http.StatusLoopDetected",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusLoopDetected"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusLoopDetected = 508 // RFC 5842, 7.2\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusMethodNotAllowed",
              "documentation": {
                "identifier": "StatusMethodNotAllowed",
                "newPage": false,
                "searchKey": "http.StatusMethodNotAllowed",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusMethodNotAllowed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusMethodNotAllowed = 405 // RFC 7231, 6.5.5\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusMisdirectedRequest",
              "documentation": {
                "identifier": "StatusMisdirectedRequest",
                "newPage": false,
                "searchKey": "http.StatusMisdirectedRequest",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusMisdirectedRequest"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusMisdirectedRequest = 421 // RFC 7540, 9.1.2\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusMovedPermanently",
              "documentation": {
                "identifier": "StatusMovedPermanently",
                "newPage": false,
                "searchKey": "http.StatusMovedPermanently",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusMovedPermanently"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusMovedPermanently = 301 // RFC 7231, 6.4.2\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusMultiStatus",
              "documentation": {
                "identifier": "StatusMultiStatus",
                "newPage": false,
                "searchKey": "http.StatusMultiStatus",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusMultiStatus"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusMultiStatus = 207 // RFC 4918, 11.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusMultipleChoices",
              "documentation": {
                "identifier": "StatusMultipleChoices",
                "newPage": false,
                "searchKey": "http.StatusMultipleChoices",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusMultipleChoices"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusMultipleChoices = 300 // RFC 7231, 6.4.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusNetworkAuthenticationRequired",
              "documentation": {
                "identifier": "StatusNetworkAuthenticationRequired",
                "newPage": false,
                "searchKey": "http.StatusNetworkAuthenticationRequired",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusNetworkAuthenticationRequired"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusNetworkAuthenticationRequired = 511 // RFC 6585, 6\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusNoContent",
              "documentation": {
                "identifier": "StatusNoContent",
                "newPage": false,
                "searchKey": "http.StatusNoContent",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusNoContent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusNoContent = 204 // RFC 7231, 6.3.5\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusNonAuthoritativeInfo",
              "documentation": {
                "identifier": "StatusNonAuthoritativeInfo",
                "newPage": false,
                "searchKey": "http.StatusNonAuthoritativeInfo",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusNonAuthoritativeInfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusNonAuthoritativeInfo = 203 // RFC 7231, 6.3.4\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusNotAcceptable",
              "documentation": {
                "identifier": "StatusNotAcceptable",
                "newPage": false,
                "searchKey": "http.StatusNotAcceptable",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusNotAcceptable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusNotAcceptable = 406 // RFC 7231, 6.5.6\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusNotExtended",
              "documentation": {
                "identifier": "StatusNotExtended",
                "newPage": false,
                "searchKey": "http.StatusNotExtended",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusNotExtended"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusNotExtended = 510 // RFC 2774, 7\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusNotFound",
              "documentation": {
                "identifier": "StatusNotFound",
                "newPage": false,
                "searchKey": "http.StatusNotFound",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusNotFound"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusNotFound = 404 // RFC 7231, 6.5.4\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusNotImplemented",
              "documentation": {
                "identifier": "StatusNotImplemented",
                "newPage": false,
                "searchKey": "http.StatusNotImplemented",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusNotImplemented"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusNotImplemented = 501 // RFC 7231, 6.6.2\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusNotModified",
              "documentation": {
                "identifier": "StatusNotModified",
                "newPage": false,
                "searchKey": "http.StatusNotModified",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusNotModified"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusNotModified = 304 // RFC 7232, 4.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusOK",
              "documentation": {
                "identifier": "StatusOK",
                "newPage": false,
                "searchKey": "http.StatusOK",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusOK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusOK = 200 // RFC 7231, 6.3.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusPartialContent",
              "documentation": {
                "identifier": "StatusPartialContent",
                "newPage": false,
                "searchKey": "http.StatusPartialContent",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusPartialContent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusPartialContent = 206 // RFC 7233, 4.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusPaymentRequired",
              "documentation": {
                "identifier": "StatusPaymentRequired",
                "newPage": false,
                "searchKey": "http.StatusPaymentRequired",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusPaymentRequired"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusPaymentRequired = 402 // RFC 7231, 6.5.2\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusPermanentRedirect",
              "documentation": {
                "identifier": "StatusPermanentRedirect",
                "newPage": false,
                "searchKey": "http.StatusPermanentRedirect",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusPermanentRedirect"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusPermanentRedirect = 308 // RFC 7538, 3\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusPreconditionFailed",
              "documentation": {
                "identifier": "StatusPreconditionFailed",
                "newPage": false,
                "searchKey": "http.StatusPreconditionFailed",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusPreconditionFailed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusPreconditionFailed = 412 // RFC 7232, 4.2\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusPreconditionRequired",
              "documentation": {
                "identifier": "StatusPreconditionRequired",
                "newPage": false,
                "searchKey": "http.StatusPreconditionRequired",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusPreconditionRequired"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusPreconditionRequired = 428 // RFC 6585, 3\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusProcessing",
              "documentation": {
                "identifier": "StatusProcessing",
                "newPage": false,
                "searchKey": "http.StatusProcessing",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusProcessing"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusProcessing = 102 // RFC 2518, 10.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusProxyAuthRequired",
              "documentation": {
                "identifier": "StatusProxyAuthRequired",
                "newPage": false,
                "searchKey": "http.StatusProxyAuthRequired",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusProxyAuthRequired"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusProxyAuthRequired = 407 // RFC 7235, 3.2\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusRequestEntityTooLarge",
              "documentation": {
                "identifier": "StatusRequestEntityTooLarge",
                "newPage": false,
                "searchKey": "http.StatusRequestEntityTooLarge",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusRequestEntityTooLarge"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusRequestEntityTooLarge = 413 // RFC 7231, 6.5.11\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusRequestHeaderFieldsTooLarge",
              "documentation": {
                "identifier": "StatusRequestHeaderFieldsTooLarge",
                "newPage": false,
                "searchKey": "http.StatusRequestHeaderFieldsTooLarge",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusRequestHeaderFieldsTooLarge"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusRequestHeaderFieldsTooLarge = 431 // RFC 6585, 5\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusRequestTimeout",
              "documentation": {
                "identifier": "StatusRequestTimeout",
                "newPage": false,
                "searchKey": "http.StatusRequestTimeout",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusRequestTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusRequestTimeout = 408 // RFC 7231, 6.5.7\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusRequestURITooLong",
              "documentation": {
                "identifier": "StatusRequestURITooLong",
                "newPage": false,
                "searchKey": "http.StatusRequestURITooLong",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusRequestURITooLong"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusRequestURITooLong = 414 // RFC 7231, 6.5.12\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusRequestedRangeNotSatisfiable",
              "documentation": {
                "identifier": "StatusRequestedRangeNotSatisfiable",
                "newPage": false,
                "searchKey": "http.StatusRequestedRangeNotSatisfiable",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusRequestedRangeNotSatisfiable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusRequestedRangeNotSatisfiable = 416 // RFC 7233, 4.4\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusResetContent",
              "documentation": {
                "identifier": "StatusResetContent",
                "newPage": false,
                "searchKey": "http.StatusResetContent",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusResetContent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusResetContent = 205 // RFC 7231, 6.3.6\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusSeeOther",
              "documentation": {
                "identifier": "StatusSeeOther",
                "newPage": false,
                "searchKey": "http.StatusSeeOther",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusSeeOther"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusSeeOther = 303 // RFC 7231, 6.4.4\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusServiceUnavailable",
              "documentation": {
                "identifier": "StatusServiceUnavailable",
                "newPage": false,
                "searchKey": "http.StatusServiceUnavailable",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusServiceUnavailable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusServiceUnavailable = 503 // RFC 7231, 6.6.4\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusSwitchingProtocols",
              "documentation": {
                "identifier": "StatusSwitchingProtocols",
                "newPage": false,
                "searchKey": "http.StatusSwitchingProtocols",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusSwitchingProtocols"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusTeapot",
              "documentation": {
                "identifier": "StatusTeapot",
                "newPage": false,
                "searchKey": "http.StatusTeapot",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusTeapot"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusTeapot = 418 // RFC 7168, 2.3.3\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusTemporaryRedirect",
              "documentation": {
                "identifier": "StatusTemporaryRedirect",
                "newPage": false,
                "searchKey": "http.StatusTemporaryRedirect",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusTemporaryRedirect"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusTemporaryRedirect = 307 // RFC 7231, 6.4.7\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusTooEarly",
              "documentation": {
                "identifier": "StatusTooEarly",
                "newPage": false,
                "searchKey": "http.StatusTooEarly",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusTooEarly"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusTooEarly = 425 // RFC 8470, 5.2.\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusTooManyRequests",
              "documentation": {
                "identifier": "StatusTooManyRequests",
                "newPage": false,
                "searchKey": "http.StatusTooManyRequests",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusTooManyRequests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusTooManyRequests = 429 // RFC 6585, 4\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusUnauthorized",
              "documentation": {
                "identifier": "StatusUnauthorized",
                "newPage": false,
                "searchKey": "http.StatusUnauthorized",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusUnauthorized"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusUnauthorized = 401 // RFC 7235, 3.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusUnavailableForLegalReasons",
              "documentation": {
                "identifier": "StatusUnavailableForLegalReasons",
                "newPage": false,
                "searchKey": "http.StatusUnavailableForLegalReasons",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusUnavailableForLegalReasons"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusUnavailableForLegalReasons = 451 // RFC 7725, 3\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusUnprocessableEntity",
              "documentation": {
                "identifier": "StatusUnprocessableEntity",
                "newPage": false,
                "searchKey": "http.StatusUnprocessableEntity",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusUnprocessableEntity"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusUnprocessableEntity = 422 // RFC 4918, 11.2\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusUnsupportedMediaType",
              "documentation": {
                "identifier": "StatusUnsupportedMediaType",
                "newPage": false,
                "searchKey": "http.StatusUnsupportedMediaType",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusUnsupportedMediaType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusUnsupportedMediaType = 415 // RFC 7231, 6.5.13\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusUpgradeRequired",
              "documentation": {
                "identifier": "StatusUpgradeRequired",
                "newPage": false,
                "searchKey": "http.StatusUpgradeRequired",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusUpgradeRequired"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusUpgradeRequired = 426 // RFC 7231, 6.5.15\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusUseProxy",
              "documentation": {
                "identifier": "StatusUseProxy",
                "newPage": false,
                "searchKey": "http.StatusUseProxy",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusUseProxy"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusUseProxy = 305 // RFC 7231, 6.4.5\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusVariantAlsoNegotiates",
              "documentation": {
                "identifier": "StatusVariantAlsoNegotiates",
                "newPage": false,
                "searchKey": "http.StatusVariantAlsoNegotiates",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StatusVariantAlsoNegotiates"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StatusVariantAlsoNegotiates = 506 // RFC 2295, 8.1\n\n```\n\nHTTP status codes as registered with IANA. See: [https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml](https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TimeFormat",
              "documentation": {
                "identifier": "TimeFormat",
                "newPage": false,
                "searchKey": "http.TimeFormat",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TimeFormat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TimeFormat = \"Mon, 02 Jan 2006 15:04:05 GMT\"\n```\n\nTimeFormat is the time format to use when generating times in HTTP headers. It is like time.RFC1123 but hard-codes GMT as the time zone. The time being formatted must be in UTC for Format to generate the correct format. \n\nFor parsing this time format, see ParseTime. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TrailerPrefix",
              "documentation": {
                "identifier": "TrailerPrefix",
                "newPage": false,
                "searchKey": "http.TrailerPrefix",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TrailerPrefix"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TrailerPrefix = \"Trailer:\"\n```\n\nTrailerPrefix is a magic prefix for ResponseWriter.Header map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers. \n\nThis mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred: \n\n```\n[https://golang.org/pkg/net/http/#ResponseWriter](https://golang.org/pkg/net/http/#ResponseWriter)\n[https://golang.org/pkg/net/http/#example_ResponseWriter_trailers](https://golang.org/pkg/net/http/#example_ResponseWriter_trailers)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#bufferBeforeChunkingSize",
              "documentation": {
                "identifier": "bufferBeforeChunkingSize",
                "newPage": false,
                "searchKey": "http.bufferBeforeChunkingSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const bufferBeforeChunkingSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bufferBeforeChunkingSize = 2048\n```\n\nThis should be >= 512 bytes for DetectContentType, but otherwise it's somewhat arbitrary. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#condFalse",
              "documentation": {
                "identifier": "condFalse",
                "newPage": false,
                "searchKey": "http.condFalse",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const condFalse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst condFalse\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#condNone",
              "documentation": {
                "identifier": "condNone",
                "newPage": false,
                "searchKey": "http.condNone",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const condNone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst condNone condResult = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#condTrue",
              "documentation": {
                "identifier": "condTrue",
                "newPage": false,
                "searchKey": "http.condTrue",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const condTrue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst condTrue\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#debugServerConnections",
              "documentation": {
                "identifier": "debugServerConnections",
                "newPage": false,
                "searchKey": "http.debugServerConnections",
                "tags": [
                  "constant",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugServerConnections"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugServerConnections = false\n```\n\ndebugServerConnections controls whether all server connections are wrapped with a verbose logging wrapper. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#defaultMaxMemory",
              "documentation": {
                "identifier": "defaultMaxMemory",
                "newPage": false,
                "searchKey": "http.defaultMaxMemory",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const defaultMaxMemory"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst defaultMaxMemory = 32 << 20 // 32 MB\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#defaultUserAgent",
              "documentation": {
                "identifier": "defaultUserAgent",
                "newPage": false,
                "searchKey": "http.defaultUserAgent",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const defaultUserAgent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst defaultUserAgent = \"Go-http-client/1.1\"\n```\n\nNOTE: This is not intended to reflect the actual Go version being used. It was changed at the time of Go 1.1 release because the former User-Agent had ended up blocked by some intrusion detection systems. See [https://codereview.appspot.com/7532043](https://codereview.appspot.com/7532043). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ClientPreface",
              "documentation": {
                "identifier": "http2ClientPreface",
                "newPage": false,
                "searchKey": "http.http2ClientPreface",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ClientPreface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ClientPreface = \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\"\n```\n\nClientPreface is the string that must be sent by new connections from clients. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeCancel",
              "documentation": {
                "identifier": "http2ErrCodeCancel",
                "newPage": false,
                "searchKey": "http.http2ErrCodeCancel",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeCancel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeCancel http2ErrCode = 0x8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeCompression",
              "documentation": {
                "identifier": "http2ErrCodeCompression",
                "newPage": false,
                "searchKey": "http.http2ErrCodeCompression",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeCompression"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeCompression http2ErrCode = 0x9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeConnect",
              "documentation": {
                "identifier": "http2ErrCodeConnect",
                "newPage": false,
                "searchKey": "http.http2ErrCodeConnect",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeConnect"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeConnect http2ErrCode = 0xa\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeEnhanceYourCalm",
              "documentation": {
                "identifier": "http2ErrCodeEnhanceYourCalm",
                "newPage": false,
                "searchKey": "http.http2ErrCodeEnhanceYourCalm",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeEnhanceYourCalm"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeEnhanceYourCalm http2ErrCode = 0xb\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeFlowControl",
              "documentation": {
                "identifier": "http2ErrCodeFlowControl",
                "newPage": false,
                "searchKey": "http.http2ErrCodeFlowControl",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeFlowControl"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeFlowControl http2ErrCode = 0x3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeFrameSize",
              "documentation": {
                "identifier": "http2ErrCodeFrameSize",
                "newPage": false,
                "searchKey": "http.http2ErrCodeFrameSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeFrameSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeFrameSize http2ErrCode = 0x6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeHTTP11Required",
              "documentation": {
                "identifier": "http2ErrCodeHTTP11Required",
                "newPage": false,
                "searchKey": "http.http2ErrCodeHTTP11Required",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeHTTP11Required"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeHTTP11Required http2ErrCode = 0xd\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeInadequateSecurity",
              "documentation": {
                "identifier": "http2ErrCodeInadequateSecurity",
                "newPage": false,
                "searchKey": "http.http2ErrCodeInadequateSecurity",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeInadequateSecurity"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeInadequateSecurity http2ErrCode = 0xc\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeInternal",
              "documentation": {
                "identifier": "http2ErrCodeInternal",
                "newPage": false,
                "searchKey": "http.http2ErrCodeInternal",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeInternal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeInternal http2ErrCode = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeNo",
              "documentation": {
                "identifier": "http2ErrCodeNo",
                "newPage": false,
                "searchKey": "http.http2ErrCodeNo",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeNo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeNo http2ErrCode = 0x0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeProtocol",
              "documentation": {
                "identifier": "http2ErrCodeProtocol",
                "newPage": false,
                "searchKey": "http.http2ErrCodeProtocol",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeProtocol"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeProtocol http2ErrCode = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeRefusedStream",
              "documentation": {
                "identifier": "http2ErrCodeRefusedStream",
                "newPage": false,
                "searchKey": "http.http2ErrCodeRefusedStream",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeRefusedStream"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeRefusedStream http2ErrCode = 0x7\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeSettingsTimeout",
              "documentation": {
                "identifier": "http2ErrCodeSettingsTimeout",
                "newPage": false,
                "searchKey": "http.http2ErrCodeSettingsTimeout",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeSettingsTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeSettingsTimeout http2ErrCode = 0x4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCodeStreamClosed",
              "documentation": {
                "identifier": "http2ErrCodeStreamClosed",
                "newPage": false,
                "searchKey": "http.http2ErrCodeStreamClosed",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2ErrCodeStreamClosed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2ErrCodeStreamClosed http2ErrCode = 0x5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FlagContinuationEndHeaders",
              "documentation": {
                "identifier": "http2FlagContinuationEndHeaders",
                "newPage": false,
                "searchKey": "http.http2FlagContinuationEndHeaders",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FlagContinuationEndHeaders"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FlagContinuationEndHeaders http2Flags = 0x4\n```\n\nFrame-specific FrameHeader flag bits. \n\nContinuation Frame \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FlagDataEndStream",
              "documentation": {
                "identifier": "http2FlagDataEndStream",
                "newPage": false,
                "searchKey": "http.http2FlagDataEndStream",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FlagDataEndStream"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FlagDataEndStream http2Flags = 0x1\n```\n\nFrame-specific FrameHeader flag bits. \n\nData Frame \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FlagDataPadded",
              "documentation": {
                "identifier": "http2FlagDataPadded",
                "newPage": false,
                "searchKey": "http.http2FlagDataPadded",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FlagDataPadded"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FlagDataPadded http2Flags = 0x8\n```\n\nFrame-specific FrameHeader flag bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FlagHeadersEndHeaders",
              "documentation": {
                "identifier": "http2FlagHeadersEndHeaders",
                "newPage": false,
                "searchKey": "http.http2FlagHeadersEndHeaders",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FlagHeadersEndHeaders"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FlagHeadersEndHeaders http2Flags = 0x4\n```\n\nFrame-specific FrameHeader flag bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FlagHeadersEndStream",
              "documentation": {
                "identifier": "http2FlagHeadersEndStream",
                "newPage": false,
                "searchKey": "http.http2FlagHeadersEndStream",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FlagHeadersEndStream"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FlagHeadersEndStream http2Flags = 0x1\n```\n\nFrame-specific FrameHeader flag bits. \n\nHeaders Frame \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FlagHeadersPadded",
              "documentation": {
                "identifier": "http2FlagHeadersPadded",
                "newPage": false,
                "searchKey": "http.http2FlagHeadersPadded",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FlagHeadersPadded"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FlagHeadersPadded http2Flags = 0x8\n```\n\nFrame-specific FrameHeader flag bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FlagHeadersPriority",
              "documentation": {
                "identifier": "http2FlagHeadersPriority",
                "newPage": false,
                "searchKey": "http.http2FlagHeadersPriority",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FlagHeadersPriority"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FlagHeadersPriority http2Flags = 0x20\n```\n\nFrame-specific FrameHeader flag bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FlagPingAck",
              "documentation": {
                "identifier": "http2FlagPingAck",
                "newPage": false,
                "searchKey": "http.http2FlagPingAck",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FlagPingAck"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FlagPingAck http2Flags = 0x1\n```\n\nFrame-specific FrameHeader flag bits. \n\nPing Frame \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FlagPushPromiseEndHeaders",
              "documentation": {
                "identifier": "http2FlagPushPromiseEndHeaders",
                "newPage": false,
                "searchKey": "http.http2FlagPushPromiseEndHeaders",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FlagPushPromiseEndHeaders"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FlagPushPromiseEndHeaders http2Flags = 0x4\n```\n\nFrame-specific FrameHeader flag bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FlagPushPromisePadded",
              "documentation": {
                "identifier": "http2FlagPushPromisePadded",
                "newPage": false,
                "searchKey": "http.http2FlagPushPromisePadded",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FlagPushPromisePadded"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FlagPushPromisePadded http2Flags = 0x8\n```\n\nFrame-specific FrameHeader flag bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FlagSettingsAck",
              "documentation": {
                "identifier": "http2FlagSettingsAck",
                "newPage": false,
                "searchKey": "http.http2FlagSettingsAck",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FlagSettingsAck"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FlagSettingsAck http2Flags = 0x1\n```\n\nFrame-specific FrameHeader flag bits. \n\nSettings Frame \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FrameContinuation",
              "documentation": {
                "identifier": "http2FrameContinuation",
                "newPage": false,
                "searchKey": "http.http2FrameContinuation",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FrameContinuation"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FrameContinuation http2FrameType = 0x9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FrameData",
              "documentation": {
                "identifier": "http2FrameData",
                "newPage": false,
                "searchKey": "http.http2FrameData",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FrameData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FrameData http2FrameType = 0x0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FrameGoAway",
              "documentation": {
                "identifier": "http2FrameGoAway",
                "newPage": false,
                "searchKey": "http.http2FrameGoAway",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FrameGoAway"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FrameGoAway http2FrameType = 0x7\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FrameHeaders",
              "documentation": {
                "identifier": "http2FrameHeaders",
                "newPage": false,
                "searchKey": "http.http2FrameHeaders",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FrameHeaders"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FrameHeaders http2FrameType = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FramePing",
              "documentation": {
                "identifier": "http2FramePing",
                "newPage": false,
                "searchKey": "http.http2FramePing",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FramePing"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FramePing http2FrameType = 0x6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FramePriority",
              "documentation": {
                "identifier": "http2FramePriority",
                "newPage": false,
                "searchKey": "http.http2FramePriority",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FramePriority"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FramePriority http2FrameType = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FramePushPromise",
              "documentation": {
                "identifier": "http2FramePushPromise",
                "newPage": false,
                "searchKey": "http.http2FramePushPromise",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FramePushPromise"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FramePushPromise http2FrameType = 0x5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FrameRSTStream",
              "documentation": {
                "identifier": "http2FrameRSTStream",
                "newPage": false,
                "searchKey": "http.http2FrameRSTStream",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FrameRSTStream"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FrameRSTStream http2FrameType = 0x3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FrameSettings",
              "documentation": {
                "identifier": "http2FrameSettings",
                "newPage": false,
                "searchKey": "http.http2FrameSettings",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FrameSettings"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FrameSettings http2FrameType = 0x4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FrameWindowUpdate",
              "documentation": {
                "identifier": "http2FrameWindowUpdate",
                "newPage": false,
                "searchKey": "http.http2FrameWindowUpdate",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2FrameWindowUpdate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2FrameWindowUpdate http2FrameType = 0x8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2NextProtoTLS",
              "documentation": {
                "identifier": "http2NextProtoTLS",
                "newPage": false,
                "searchKey": "http.http2NextProtoTLS",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2NextProtoTLS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2NextProtoTLS = \"h2\"\n```\n\nNextProtoTLS is the NPN/ALPN protocol negotiated during HTTP/2's TLS setup. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2SettingEnablePush",
              "documentation": {
                "identifier": "http2SettingEnablePush",
                "newPage": false,
                "searchKey": "http.http2SettingEnablePush",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2SettingEnablePush"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2SettingEnablePush http2SettingID = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2SettingHeaderTableSize",
              "documentation": {
                "identifier": "http2SettingHeaderTableSize",
                "newPage": false,
                "searchKey": "http.http2SettingHeaderTableSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2SettingHeaderTableSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2SettingHeaderTableSize http2SettingID = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2SettingInitialWindowSize",
              "documentation": {
                "identifier": "http2SettingInitialWindowSize",
                "newPage": false,
                "searchKey": "http.http2SettingInitialWindowSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2SettingInitialWindowSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2SettingInitialWindowSize http2SettingID = 0x4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2SettingMaxConcurrentStreams",
              "documentation": {
                "identifier": "http2SettingMaxConcurrentStreams",
                "newPage": false,
                "searchKey": "http.http2SettingMaxConcurrentStreams",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2SettingMaxConcurrentStreams"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2SettingMaxConcurrentStreams http2SettingID = 0x3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2SettingMaxFrameSize",
              "documentation": {
                "identifier": "http2SettingMaxFrameSize",
                "newPage": false,
                "searchKey": "http.http2SettingMaxFrameSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2SettingMaxFrameSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2SettingMaxFrameSize http2SettingID = 0x5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2SettingMaxHeaderListSize",
              "documentation": {
                "identifier": "http2SettingMaxHeaderListSize",
                "newPage": false,
                "searchKey": "http.http2SettingMaxHeaderListSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2SettingMaxHeaderListSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2SettingMaxHeaderListSize http2SettingID = 0x6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2TrailerPrefix",
              "documentation": {
                "identifier": "http2TrailerPrefix",
                "newPage": false,
                "searchKey": "http.http2TrailerPrefix",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2TrailerPrefix"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2TrailerPrefix = \"Trailer:\"\n```\n\nTrailerPrefix is a magic prefix for ResponseWriter.Header map keys that, if present, signals that the map entry is actually for the response trailers, and not the response headers. The prefix is stripped after the ServeHTTP call finishes and the values are sent in the trailers. \n\nThis mechanism is intended only for trailers that are not known prior to the headers being written. If the set of trailers is fixed or known before the header is written, the normal Go trailers mechanism is preferred: \n\n```\n[https://golang.org/pkg/net/http/#ResponseWriter](https://golang.org/pkg/net/http/#ResponseWriter)\n[https://golang.org/pkg/net/http/#example_ResponseWriter_trailers](https://golang.org/pkg/net/http/#example_ResponseWriter_trailers)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2bufWriterPoolBufferSize",
              "documentation": {
                "identifier": "http2bufWriterPoolBufferSize",
                "newPage": false,
                "searchKey": "http.http2bufWriterPoolBufferSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2bufWriterPoolBufferSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2bufWriterPoolBufferSize = 4 << 10\n```\n\nbufWriterPoolBufferSize is the size of bufio.Writer's buffers created using bufWriterPool. \n\nTODO: pick a less arbitrary value? this is a bit under (3 x typical 1500 byte MTU) at least. Other than that, not much thought went into it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0011\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA uint16 = 0x0013\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA uint16 = 0x0032\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 uint16 = 0x0040\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 uint16 = 0x00A2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA uint16 = 0x0038\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 uint16 = 0x006A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 uint16 = 0x00A3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC042\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC056\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC043\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC057\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0044\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BD\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC080\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0087\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC081\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA uint16 = 0x0012\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA uint16 = 0x0099\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA uint16 = 0x008F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA uint16 = 0x0090\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 uint16 = 0x00B2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM uint16 = 0xC0A6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 uint16 = 0x00AA\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA uint16 = 0x0091\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 uint16 = 0x00B3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM uint16 = 0xC0A7\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 uint16 = 0x00AB\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC066\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC06C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC067\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC06D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC096\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC090\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC097\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC091\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCAD\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_NULL_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_NULL_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_NULL_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_NULL_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_NULL_SHA uint16 = 0x002D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256 uint16 = 0x00B4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384 uint16 = 0x00B5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA uint16 = 0x008E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0014\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0x0016\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA uint16 = 0x0033\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0x0067\n```\n\nReserved uint16 =  0x0047-4F Reserved uint16 =  0x0050-58 Reserved uint16 =  0x0059-5C Unassigned uint16 =  0x005D-5F Reserved uint16 =  0x0060-66 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM uint16 = 0xC09E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8 uint16 = 0xC0A2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0x009E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA uint16 = 0x0039\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 uint16 = 0x006B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM uint16 = 0xC09F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8 uint16 = 0xC0A3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0x009F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC044\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC052\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC045\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC053\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0045\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BE\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC07C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0088\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC07D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCAA\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA uint16 = 0x0015\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA uint16 = 0x009A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x000B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA uint16 = 0x000D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA uint16 = 0x0030\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256 uint16 = 0x003E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256 uint16 = 0x00A4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA uint16 = 0x0036\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256 uint16 = 0x0068\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384 uint16 = 0x00A5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC03E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC058\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC03F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC059\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0042\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BB\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC082\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0085\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC083\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA uint16 = 0x000C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA uint16 = 0x0097\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x000E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0x0010\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA uint16 = 0x0031\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0x003F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0x00A0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA uint16 = 0x0037\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256 uint16 = 0x0069\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0x00A1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC040\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC054\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC041\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC055\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0043\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BC\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC07E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0086\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC07F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA uint16 = 0x000F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA uint16 = 0x0098\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0019\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 uint16 = 0x0017\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA uint16 = 0x001B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA uint16 = 0x0034\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256 uint16 = 0x006C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256 uint16 = 0x00A6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA uint16 = 0x003A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256 uint16 = 0x006D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384 uint16 = 0x00A7\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC046\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC05A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC047\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC05B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0046\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BF\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC084\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0089\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC085\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA uint16 = 0x001A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_RC4_128_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_RC4_128_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_RC4_128_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_RC4_128_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_RC4_128_MD5 uint16 = 0x0018\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA uint16 = 0x009B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC008\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA uint16 = 0xC009\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 uint16 = 0xC023\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM uint16 = 0xC0AC\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 uint16 = 0xC0AE\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xC02B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA uint16 = 0xC00A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 uint16 = 0xC024\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM uint16 = 0xC0AD\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 uint16 = 0xC0AF\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 uint16 = 0xC02C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC048\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC05C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC049\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC05D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC072\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC086\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC073\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC087\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCA9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA uint16 = 0xC006\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA uint16 = 0xC007\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA uint16 = 0xC034\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA uint16 = 0xC035\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 uint16 = 0xC037\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA uint16 = 0xC036\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 uint16 = 0xC038\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC070\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC071\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC09A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC09B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCAC\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA uint16 = 0xC039\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256 uint16 = 0xC03A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384 uint16 = 0xC03B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA uint16 = 0xC033\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC012\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA uint16 = 0xC013\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0xC027\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0xC02F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA uint16 = 0xC014\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 uint16 = 0xC028\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0xC030\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC04C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC060\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC04D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC061\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC076\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC08A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC077\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC08B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCA8\n```\n\nUnassigned uint16 =  0xC0B0-FF Unassigned uint16 =  0xC1-CB,* Unassigned uint16 =  0xCC00-A7 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA uint16 = 0xC010\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA uint16 = 0xC011\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC003\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA uint16 = 0xC004\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 uint16 = 0xC025\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xC02D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA uint16 = 0xC005\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 uint16 = 0xC026\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 uint16 = 0xC02E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC04A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC05E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC04B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC05F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC074\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC088\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC075\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC089\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA uint16 = 0xC001\n```\n\nUnassigned                                   uint16 = 0x5601 - 0xC000 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA uint16 = 0xC002\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC00D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA uint16 = 0xC00E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0xC029\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0xC031\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA uint16 = 0xC00F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 uint16 = 0xC02A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0xC032\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC04E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC062\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC04F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC063\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC078\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC08C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC079\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC08D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA uint16 = 0xC00B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA uint16 = 0xC00C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA uint16 = 0xC017\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA uint16 = 0xC018\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA uint16 = 0xC019\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_anon_WITH_NULL_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_anon_WITH_NULL_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_anon_WITH_NULL_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_anon_WITH_NULL_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_anon_WITH_NULL_SHA uint16 = 0xC015\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA uint16 = 0xC016\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV",
              "documentation": {
                "identifier": "http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV uint16 = 0x00FF\n```\n\nUnassigned uint16 =  0x00C6-FE \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_FALLBACK_SCSV",
              "documentation": {
                "identifier": "http2cipher_TLS_FALLBACK_SCSV",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_FALLBACK_SCSV",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_FALLBACK_SCSV"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_FALLBACK_SCSV uint16 = 0x5600\n```\n\nUnassigned uint16 =  0x01-55,* \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 uint16 = 0x0029\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA uint16 = 0x0026\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 uint16 = 0x002A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA uint16 = 0x0027\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5 uint16 = 0x002B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA uint16 = 0x0028\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5 uint16 = 0x0023\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA uint16 = 0x001F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_WITH_DES_CBC_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_WITH_DES_CBC_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_WITH_DES_CBC_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_WITH_DES_CBC_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_WITH_DES_CBC_MD5 uint16 = 0x0022\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_WITH_DES_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_WITH_DES_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_WITH_DES_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_WITH_DES_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_WITH_DES_CBC_SHA uint16 = 0x001E\n```\n\nReserved uint16 =  0x001C-1D \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5 uint16 = 0x0025\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA uint16 = 0x0021\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_WITH_RC4_128_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_WITH_RC4_128_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_WITH_RC4_128_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_WITH_RC4_128_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_WITH_RC4_128_MD5 uint16 = 0x0024\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_KRB5_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_KRB5_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_KRB5_WITH_RC4_128_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_KRB5_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_KRB5_WITH_RC4_128_SHA uint16 = 0x0020\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_NULL_WITH_NULL_NULL",
              "documentation": {
                "identifier": "http2cipher_TLS_NULL_WITH_NULL_NULL",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_NULL_WITH_NULL_NULL",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_NULL_WITH_NULL_NULL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_NULL_WITH_NULL_NULL uint16 = 0x0000\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8 uint16 = 0xC0AA\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8 uint16 = 0xC0AB\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA uint16 = 0x008B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA uint16 = 0x008C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256 uint16 = 0x00AE\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_AES_128_CCM",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_AES_128_CCM",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_AES_128_CCM",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_AES_128_CCM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_AES_128_CCM uint16 = 0xC0A4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_AES_128_CCM_8",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_AES_128_CCM_8",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_AES_128_CCM_8",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_AES_128_CCM_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_AES_128_CCM_8 uint16 = 0xC0A8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256 uint16 = 0x00A8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA uint16 = 0x008D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384 uint16 = 0x00AF\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_AES_256_CCM",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_AES_256_CCM",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_AES_256_CCM",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_AES_256_CCM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_AES_256_CCM uint16 = 0xC0A5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_AES_256_CCM_8",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_AES_256_CCM_8",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_AES_256_CCM_8",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_AES_256_CCM_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_AES_256_CCM_8 uint16 = 0xC0A9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384 uint16 = 0x00A9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC064\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC06A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC065\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC06B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC094\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC08E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC095\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC08F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCAB\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_NULL_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_NULL_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_NULL_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_NULL_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_NULL_SHA uint16 = 0x002C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_NULL_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_NULL_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_NULL_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_NULL_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_NULL_SHA256 uint16 = 0x00B0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_NULL_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_NULL_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_NULL_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_NULL_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_NULL_SHA384 uint16 = 0x00B1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_PSK_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_PSK_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_PSK_WITH_RC4_128_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_PSK_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_PSK_WITH_RC4_128_SHA uint16 = 0x008A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA uint16 = 0x0008\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 uint16 = 0x0006\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5 uint16 = 0x0003\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA uint16 = 0x0093\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA uint16 = 0x0094\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 uint16 = 0x00B6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 uint16 = 0x00AC\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA uint16 = 0x0095\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 uint16 = 0x00B7\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 uint16 = 0x00AD\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC068\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC06E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC069\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC06F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0xC098\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC092\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 uint16 = 0xC099\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC093\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xCCAE\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_NULL_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_NULL_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_NULL_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_NULL_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_NULL_SHA uint16 = 0x002E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256 uint16 = 0x00B8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384 uint16 = 0x00B9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA uint16 = 0x0092\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0x000A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA uint16 = 0x002F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0x003C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_AES_128_CCM",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_AES_128_CCM",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_AES_128_CCM",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_AES_128_CCM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_AES_128_CCM uint16 = 0xC09C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_AES_128_CCM_8",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_AES_128_CCM_8",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_AES_128_CCM_8",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_AES_128_CCM_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_AES_128_CCM_8 uint16 = 0xC0A0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0x009C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA uint16 = 0x0035\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256 uint16 = 0x003D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_AES_256_CCM",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_AES_256_CCM",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_AES_256_CCM",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_AES_256_CCM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_AES_256_CCM uint16 = 0xC09D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_AES_256_CCM_8",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_AES_256_CCM_8",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_AES_256_CCM_8",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_AES_256_CCM_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_AES_256_CCM_8 uint16 = 0xC0A1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0x009D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256 uint16 = 0xC03C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256 uint16 = 0xC050\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384 uint16 = 0xC03D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384 uint16 = 0xC051\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA uint16 = 0x0041\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 uint16 = 0x00BA\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 uint16 = 0xC07A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA uint16 = 0x0084\n```\n\nUnassigned uint16 =  0x006E-83 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 uint16 = 0x00C0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 uint16 = 0xC07B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_DES_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_DES_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_DES_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_DES_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_DES_CBC_SHA uint16 = 0x0009\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA uint16 = 0x0007\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_NULL_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_NULL_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_NULL_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_NULL_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_NULL_MD5 uint16 = 0x0001\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_NULL_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_NULL_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_NULL_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_NULL_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_NULL_SHA uint16 = 0x0002\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_NULL_SHA256",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_NULL_SHA256",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_NULL_SHA256",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_NULL_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_NULL_SHA256 uint16 = 0x003B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_RC4_128_MD5",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_RC4_128_MD5",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_RC4_128_MD5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_RC4_128_MD5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_RC4_128_MD5 uint16 = 0x0004\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_RC4_128_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_RC4_128_SHA uint16 = 0x0005\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_RSA_WITH_SEED_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_RSA_WITH_SEED_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_RSA_WITH_SEED_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_RSA_WITH_SEED_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_RSA_WITH_SEED_CBC_SHA uint16 = 0x0096\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA uint16 = 0xC01C\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA uint16 = 0xC01F\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA uint16 = 0xC022\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC01B\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA uint16 = 0xC01E\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA uint16 = 0xC021\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA uint16 = 0xC01A\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA uint16 = 0xC01D\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "http.http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA uint16 = 0xC020\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2defaultMaxReadFrameSize",
              "documentation": {
                "identifier": "http2defaultMaxReadFrameSize",
                "newPage": false,
                "searchKey": "http.http2defaultMaxReadFrameSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2defaultMaxReadFrameSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2defaultMaxReadFrameSize = 1 << 20\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2defaultMaxStreams",
              "documentation": {
                "identifier": "http2defaultMaxStreams",
                "newPage": false,
                "searchKey": "http.http2defaultMaxStreams",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2defaultMaxStreams"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2defaultMaxStreams = 250 // TODO: make this 100 as the GFE seems to?\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2defaultUserAgent",
              "documentation": {
                "identifier": "http2defaultUserAgent",
                "newPage": false,
                "searchKey": "http.http2defaultUserAgent",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2defaultUserAgent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2defaultUserAgent = \"Go-http-client/2.0\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2dialOnMiss",
              "documentation": {
                "identifier": "http2dialOnMiss",
                "newPage": false,
                "searchKey": "http.http2dialOnMiss",
                "tags": [
                  "constant",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2dialOnMiss"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2dialOnMiss = true\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2firstSettingsTimeout",
              "documentation": {
                "identifier": "http2firstSettingsTimeout",
                "newPage": false,
                "searchKey": "http.http2firstSettingsTimeout",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2firstSettingsTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2firstSettingsTimeout = 2 * time.Second // should be in-flight with preface anyway\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2frameHeaderLen",
              "documentation": {
                "identifier": "http2frameHeaderLen",
                "newPage": false,
                "searchKey": "http.http2frameHeaderLen",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2frameHeaderLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2frameHeaderLen = 9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2handlerChunkWriteSize",
              "documentation": {
                "identifier": "http2handlerChunkWriteSize",
                "newPage": false,
                "searchKey": "http.http2handlerChunkWriteSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2handlerChunkWriteSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2handlerChunkWriteSize = 4 << 10\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2initialHeaderTableSize",
              "documentation": {
                "identifier": "http2initialHeaderTableSize",
                "newPage": false,
                "searchKey": "http.http2initialHeaderTableSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2initialHeaderTableSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2initialHeaderTableSize = 4096\n```\n\n[http://http2.github.io/http2-spec/#SettingValues](http://http2.github.io/http2-spec/#SettingValues) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2initialMaxFrameSize",
              "documentation": {
                "identifier": "http2initialMaxFrameSize",
                "newPage": false,
                "searchKey": "http.http2initialMaxFrameSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2initialMaxFrameSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2initialMaxFrameSize = 16384\n```\n\nSETTINGS_MAX_FRAME_SIZE default [http://http2.github.io/http2-spec/#rfc.section.6.5.2](http://http2.github.io/http2-spec/#rfc.section.6.5.2) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2initialWindowSize",
              "documentation": {
                "identifier": "http2initialWindowSize",
                "newPage": false,
                "searchKey": "http.http2initialWindowSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2initialWindowSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2initialWindowSize = 65535 // 6.9.2 Initial Flow Control Window Size\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2maxAllocFrameSize",
              "documentation": {
                "identifier": "http2maxAllocFrameSize",
                "newPage": false,
                "searchKey": "http.http2maxAllocFrameSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2maxAllocFrameSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2maxAllocFrameSize = 512 << 10\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2maxFrameSize",
              "documentation": {
                "identifier": "http2maxFrameSize",
                "newPage": false,
                "searchKey": "http.http2maxFrameSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2maxFrameSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2maxFrameSize = 1<<24 - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2maxQueuedControlFrames",
              "documentation": {
                "identifier": "http2maxQueuedControlFrames",
                "newPage": false,
                "searchKey": "http.http2maxQueuedControlFrames",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2maxQueuedControlFrames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2maxQueuedControlFrames = 10000\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2minMaxFrameSize",
              "documentation": {
                "identifier": "http2minMaxFrameSize",
                "newPage": false,
                "searchKey": "http.http2minMaxFrameSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2minMaxFrameSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2minMaxFrameSize = 1 << 14\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2noDialOnMiss",
              "documentation": {
                "identifier": "http2noDialOnMiss",
                "newPage": false,
                "searchKey": "http.http2noDialOnMiss",
                "tags": [
                  "constant",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2noDialOnMiss"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2noDialOnMiss = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2prefaceTimeout",
              "documentation": {
                "identifier": "http2prefaceTimeout",
                "newPage": false,
                "searchKey": "http.http2prefaceTimeout",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2prefaceTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2prefaceTimeout = 10 * time.Second\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2priorityDefaultWeight",
              "documentation": {
                "identifier": "http2priorityDefaultWeight",
                "newPage": false,
                "searchKey": "http.http2priorityDefaultWeight",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2priorityDefaultWeight"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2priorityDefaultWeight = 15 // 16 = 15 + 1\n\n```\n\nRFC 7540, Section 5.3.5: the default weight is 16. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2priorityNodeClosed",
              "documentation": {
                "identifier": "http2priorityNodeClosed",
                "newPage": false,
                "searchKey": "http.http2priorityNodeClosed",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2priorityNodeClosed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2priorityNodeClosed\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2priorityNodeIdle",
              "documentation": {
                "identifier": "http2priorityNodeIdle",
                "newPage": false,
                "searchKey": "http.http2priorityNodeIdle",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2priorityNodeIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2priorityNodeIdle\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2priorityNodeOpen",
              "documentation": {
                "identifier": "http2priorityNodeOpen",
                "newPage": false,
                "searchKey": "http.http2priorityNodeOpen",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2priorityNodeOpen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2priorityNodeOpen http2priorityNodeState = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2stateClosed",
              "documentation": {
                "identifier": "http2stateClosed",
                "newPage": false,
                "searchKey": "http.http2stateClosed",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2stateClosed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2stateClosed\n```\n\nHTTP/2 stream states. \n\nSee [http://tools.ietf.org/html/rfc7540#section-5.1](http://tools.ietf.org/html/rfc7540#section-5.1). \n\nFor simplicity, the server code merges \"reserved (local)\" into \"half-closed (remote)\". This is one less state transition to track. The only downside is that we send PUSH_PROMISEs slightly less liberally than allowable. More discussion here: [https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html](https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html) \n\n\"reserved (remote)\" is omitted since the client code does not support server push. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2stateHalfClosedLocal",
              "documentation": {
                "identifier": "http2stateHalfClosedLocal",
                "newPage": false,
                "searchKey": "http.http2stateHalfClosedLocal",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2stateHalfClosedLocal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2stateHalfClosedLocal\n```\n\nHTTP/2 stream states. \n\nSee [http://tools.ietf.org/html/rfc7540#section-5.1](http://tools.ietf.org/html/rfc7540#section-5.1). \n\nFor simplicity, the server code merges \"reserved (local)\" into \"half-closed (remote)\". This is one less state transition to track. The only downside is that we send PUSH_PROMISEs slightly less liberally than allowable. More discussion here: [https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html](https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html) \n\n\"reserved (remote)\" is omitted since the client code does not support server push. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2stateHalfClosedRemote",
              "documentation": {
                "identifier": "http2stateHalfClosedRemote",
                "newPage": false,
                "searchKey": "http.http2stateHalfClosedRemote",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2stateHalfClosedRemote"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2stateHalfClosedRemote\n```\n\nHTTP/2 stream states. \n\nSee [http://tools.ietf.org/html/rfc7540#section-5.1](http://tools.ietf.org/html/rfc7540#section-5.1). \n\nFor simplicity, the server code merges \"reserved (local)\" into \"half-closed (remote)\". This is one less state transition to track. The only downside is that we send PUSH_PROMISEs slightly less liberally than allowable. More discussion here: [https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html](https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html) \n\n\"reserved (remote)\" is omitted since the client code does not support server push. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2stateIdle",
              "documentation": {
                "identifier": "http2stateIdle",
                "newPage": false,
                "searchKey": "http.http2stateIdle",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2stateIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2stateIdle http2streamState = iota\n```\n\nHTTP/2 stream states. \n\nSee [http://tools.ietf.org/html/rfc7540#section-5.1](http://tools.ietf.org/html/rfc7540#section-5.1). \n\nFor simplicity, the server code merges \"reserved (local)\" into \"half-closed (remote)\". This is one less state transition to track. The only downside is that we send PUSH_PROMISEs slightly less liberally than allowable. More discussion here: [https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html](https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html) \n\n\"reserved (remote)\" is omitted since the client code does not support server push. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2stateOpen",
              "documentation": {
                "identifier": "http2stateOpen",
                "newPage": false,
                "searchKey": "http.http2stateOpen",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2stateOpen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2stateOpen\n```\n\nHTTP/2 stream states. \n\nSee [http://tools.ietf.org/html/rfc7540#section-5.1](http://tools.ietf.org/html/rfc7540#section-5.1). \n\nFor simplicity, the server code merges \"reserved (local)\" into \"half-closed (remote)\". This is one less state transition to track. The only downside is that we send PUSH_PROMISEs slightly less liberally than allowable. More discussion here: [https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html](https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html) \n\n\"reserved (remote)\" is omitted since the client code does not support server push. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2transportDefaultConnFlow",
              "documentation": {
                "identifier": "http2transportDefaultConnFlow",
                "newPage": false,
                "searchKey": "http.http2transportDefaultConnFlow",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2transportDefaultConnFlow"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2transportDefaultConnFlow = 1 << 30\n```\n\ntransportDefaultConnFlow is how many connection-level flow control tokens we give the server at start-up, past the default 64k. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2transportDefaultStreamFlow",
              "documentation": {
                "identifier": "http2transportDefaultStreamFlow",
                "newPage": false,
                "searchKey": "http.http2transportDefaultStreamFlow",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2transportDefaultStreamFlow"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2transportDefaultStreamFlow = 4 << 20\n```\n\ntransportDefaultStreamFlow is how many stream-level flow control tokens we announce to the peer, and how many bytes we buffer per stream. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2transportDefaultStreamMinRefresh",
              "documentation": {
                "identifier": "http2transportDefaultStreamMinRefresh",
                "newPage": false,
                "searchKey": "http.http2transportDefaultStreamMinRefresh",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const http2transportDefaultStreamMinRefresh"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst http2transportDefaultStreamMinRefresh = 4 << 10\n```\n\ntransportDefaultStreamMinRefresh is the minimum number of bytes we'll send a stream-level WINDOW_UPDATE for at a time. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#maxInt64",
              "documentation": {
                "identifier": "maxInt64",
                "newPage": false,
                "searchKey": "http.maxInt64",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxInt64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxInt64 = 1<<63 - 1\n```\n\nmaxInt64 is the effective \"infinite\" value for the Server and Transport's byte-limiting readers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#maxPostHandlerReadBytes",
              "documentation": {
                "identifier": "maxPostHandlerReadBytes",
                "newPage": false,
                "searchKey": "http.maxPostHandlerReadBytes",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxPostHandlerReadBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxPostHandlerReadBytes = 256 << 10\n```\n\nmaxPostHandlerReadBytes is the max number of Request.Body bytes not consumed by a handler that the server will read from the client in order to keep a connection alive. If there are more bytes than this then the server to be paranoid instead sends a \"Connection: close\" response. \n\nThis number is approximately what a typical machine's TCP buffer size is anyway.  (if we have the bytes on the machine, we might as well read them) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#maxWriteWaitBeforeConnReuse",
              "documentation": {
                "identifier": "maxWriteWaitBeforeConnReuse",
                "newPage": false,
                "searchKey": "http.maxWriteWaitBeforeConnReuse",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxWriteWaitBeforeConnReuse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxWriteWaitBeforeConnReuse = 50 * time.Millisecond\n```\n\nmaxWriteWaitBeforeConnReuse is how long the a Transport RoundTrip will wait to see the Request's Body.Write result after getting a response from the server. See comments in (*persistConn).wroteRequest. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#rstAvoidanceDelay",
              "documentation": {
                "identifier": "rstAvoidanceDelay",
                "newPage": false,
                "searchKey": "http.rstAvoidanceDelay",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const rstAvoidanceDelay"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst rstAvoidanceDelay = 500 * time.Millisecond\n```\n\nrstAvoidanceDelay is the amount of time we sleep after closing the write side of a TCP connection before closing the entire socket. By sleeping, we increase the chances that the client sees our FIN and processes its final data before they process the subsequent RST from closing a connection with known unread data. This RST seems to occur mostly on BSD systems. (And Windows?) This timeout is somewhat arbitrary (~latency around the planet). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#runHooks",
              "documentation": {
                "identifier": "runHooks",
                "newPage": false,
                "searchKey": "http.runHooks",
                "tags": [
                  "constant",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const runHooks"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst runHooks = true\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#shutdownPollIntervalMax",
              "documentation": {
                "identifier": "shutdownPollIntervalMax",
                "newPage": false,
                "searchKey": "http.shutdownPollIntervalMax",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const shutdownPollIntervalMax"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst shutdownPollIntervalMax = 500 * time.Millisecond\n```\n\nshutdownPollIntervalMax is the max polling interval when checking quiescence during Server.Shutdown. Polling starts with a small interval and backs off to the max. Ideally we could find a solution that doesn't involve polling, but which also doesn't have a high runtime cost (and doesn't involve any contentious mutexes), but that is left as an exercise for the reader. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#skipHooks",
              "documentation": {
                "identifier": "skipHooks",
                "newPage": false,
                "searchKey": "http.skipHooks",
                "tags": [
                  "constant",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const skipHooks"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst skipHooks = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#sniffLen",
              "documentation": {
                "identifier": "sniffLen",
                "newPage": false,
                "searchKey": "http.sniffLen",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const sniffLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sniffLen = 512\n```\n\nThe algorithm uses at most sniffLen bytes to make its decision. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksAddrTypeFQDN",
              "documentation": {
                "identifier": "socksAddrTypeFQDN",
                "newPage": false,
                "searchKey": "http.socksAddrTypeFQDN",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const socksAddrTypeFQDN"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst socksAddrTypeFQDN = 0x03\n```\n\nWire protocol constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksAddrTypeIPv4",
              "documentation": {
                "identifier": "socksAddrTypeIPv4",
                "newPage": false,
                "searchKey": "http.socksAddrTypeIPv4",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const socksAddrTypeIPv4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst socksAddrTypeIPv4 = 0x01\n```\n\nWire protocol constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksAddrTypeIPv6",
              "documentation": {
                "identifier": "socksAddrTypeIPv6",
                "newPage": false,
                "searchKey": "http.socksAddrTypeIPv6",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const socksAddrTypeIPv6"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst socksAddrTypeIPv6 = 0x04\n```\n\nWire protocol constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksAuthMethodNoAcceptableMethods",
              "documentation": {
                "identifier": "socksAuthMethodNoAcceptableMethods",
                "newPage": false,
                "searchKey": "http.socksAuthMethodNoAcceptableMethods",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const socksAuthMethodNoAcceptableMethods"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst socksAuthMethodNoAcceptableMethods socksAuthMethod // no acceptable authentication methods\n = ...\n```\n\nWire protocol constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksAuthMethodNotRequired",
              "documentation": {
                "identifier": "socksAuthMethodNotRequired",
                "newPage": false,
                "searchKey": "http.socksAuthMethodNotRequired",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const socksAuthMethodNotRequired"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst socksAuthMethodNotRequired socksAuthMethod = 0x00 // no authentication required\n\n```\n\nWire protocol constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksAuthMethodUsernamePassword",
              "documentation": {
                "identifier": "socksAuthMethodUsernamePassword",
                "newPage": false,
                "searchKey": "http.socksAuthMethodUsernamePassword",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const socksAuthMethodUsernamePassword"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst socksAuthMethodUsernamePassword socksAuthMethod = 0x02 // use username/password\n\n```\n\nWire protocol constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksCmdConnect",
              "documentation": {
                "identifier": "socksCmdConnect",
                "newPage": false,
                "searchKey": "http.socksCmdConnect",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const socksCmdConnect"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst socksCmdConnect socksCommand = 0x01 // establishes an active-open forward proxy connection\n\n```\n\nWire protocol constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksStatusSucceeded",
              "documentation": {
                "identifier": "socksStatusSucceeded",
                "newPage": false,
                "searchKey": "http.socksStatusSucceeded",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const socksStatusSucceeded"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst socksStatusSucceeded socksReply = 0x00\n```\n\nWire protocol constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksVersion5",
              "documentation": {
                "identifier": "socksVersion5",
                "newPage": false,
                "searchKey": "http.socksVersion5",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const socksVersion5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst socksVersion5 = 0x05\n```\n\nWire protocol constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksauthStatusSucceeded",
              "documentation": {
                "identifier": "socksauthStatusSucceeded",
                "newPage": false,
                "searchKey": "http.socksauthStatusSucceeded",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const socksauthStatusSucceeded"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst socksauthStatusSucceeded = 0x00\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksauthUsernamePasswordVersion",
              "documentation": {
                "identifier": "socksauthUsernamePasswordVersion",
                "newPage": false,
                "searchKey": "http.socksauthUsernamePasswordVersion",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const socksauthUsernamePasswordVersion"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst socksauthUsernamePasswordVersion = 0x01\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#sockscmdBind",
              "documentation": {
                "identifier": "sockscmdBind",
                "newPage": false,
                "searchKey": "http.sockscmdBind",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const sockscmdBind"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sockscmdBind socksCommand = 0x02 // establishes a passive-open forward proxy connection\n\n```\n\nWire protocol constants. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/net/http#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/net/http#DefaultClient",
              "documentation": {
                "identifier": "DefaultClient",
                "newPage": false,
                "searchKey": "http.DefaultClient",
                "tags": [
                  "variable",
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var DefaultClient"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar DefaultClient = &Client{}\n```\n\nDefaultClient is the default Client and is used by Get, Head, and Post. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#DefaultServeMux",
              "documentation": {
                "identifier": "DefaultServeMux",
                "newPage": false,
                "searchKey": "http.DefaultServeMux",
                "tags": [
                  "variable",
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var DefaultServeMux"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar DefaultServeMux = &defaultServeMux\n```\n\nDefaultServeMux is the default ServeMux used by Serve. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#DefaultTransport",
              "documentation": {
                "identifier": "DefaultTransport",
                "newPage": false,
                "searchKey": "http.DefaultTransport",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var DefaultTransport"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar DefaultTransport RoundTripper = ...\n```\n\nDefaultTransport is the default implementation of Transport and is used by DefaultClient. It establishes network connections as needed and caches them for reuse by subsequent calls. It uses HTTP proxies as directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy) environment variables. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#DefaultUserAgent",
              "documentation": {
                "identifier": "DefaultUserAgent",
                "newPage": false,
                "searchKey": "http.DefaultUserAgent",
                "tags": [
                  "variable",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var DefaultUserAgent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar DefaultUserAgent = defaultUserAgent\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrAbortHandler",
              "documentation": {
                "identifier": "ErrAbortHandler",
                "newPage": false,
                "searchKey": "http.ErrAbortHandler",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrAbortHandler"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrAbortHandler = errors.New(\"net/http: abort Handler\")\n```\n\nErrAbortHandler is a sentinel panic value to abort a handler. While any panic from ServeHTTP aborts the response to the client, panicking with ErrAbortHandler also suppresses logging of a stack trace to the server's error log. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrBodyNotAllowed",
              "documentation": {
                "identifier": "ErrBodyNotAllowed",
                "newPage": false,
                "searchKey": "http.ErrBodyNotAllowed",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrBodyNotAllowed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrBodyNotAllowed = ...\n```\n\nErrors used by the HTTP server. \n\nErrBodyNotAllowed is returned by ResponseWriter.Write calls when the HTTP method or response code does not permit a body. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrBodyReadAfterClose",
              "documentation": {
                "identifier": "ErrBodyReadAfterClose",
                "newPage": false,
                "searchKey": "http.ErrBodyReadAfterClose",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrBodyReadAfterClose"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrBodyReadAfterClose = errors.New(\"http: invalid Read on closed Body\")\n```\n\nErrBodyReadAfterClose is returned when reading a Request or Response Body after the body has been closed. This typically happens when the body is read after an HTTP Handler calls WriteHeader or Write on its ResponseWriter. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrContentLength",
              "documentation": {
                "identifier": "ErrContentLength",
                "newPage": false,
                "searchKey": "http.ErrContentLength",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrContentLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrContentLength = errors.New(\"http: wrote more than the declared Content-Length\")\n```\n\nErrors used by the HTTP server. \n\nErrContentLength is returned by ResponseWriter.Write calls when a Handler set a Content-Length response header with a declared size and then attempted to write more bytes than declared. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrHandlerTimeout",
              "documentation": {
                "identifier": "ErrHandlerTimeout",
                "newPage": false,
                "searchKey": "http.ErrHandlerTimeout",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrHandlerTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrHandlerTimeout = errors.New(\"http: Handler timeout\")\n```\n\nErrHandlerTimeout is returned on ResponseWriter Write calls in handlers which have timed out. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrHeaderTooLong",
              "documentation": {
                "identifier": "ErrHeaderTooLong",
                "newPage": false,
                "searchKey": "http.ErrHeaderTooLong",
                "tags": [
                  "variable",
                  "struct",
                  "deprecated"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrHeaderTooLong"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrHeaderTooLong = &ProtocolError{\"header too long\"}\n```\n\nDeprecated: ErrHeaderTooLong is no longer returned by anything in the net/http package. Callers should not compare errors against this variable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrHijacked",
              "documentation": {
                "identifier": "ErrHijacked",
                "newPage": false,
                "searchKey": "http.ErrHijacked",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrHijacked"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrHijacked = errors.New(\"http: connection has been hijacked\")\n```\n\nErrors used by the HTTP server. \n\nErrHijacked is returned by ResponseWriter.Write calls when the underlying connection has been hijacked using the Hijacker interface. A zero-byte write on a hijacked connection will return ErrHijacked without any other side effects. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrLineTooLong",
              "documentation": {
                "identifier": "ErrLineTooLong",
                "newPage": false,
                "searchKey": "http.ErrLineTooLong",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrLineTooLong"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrLineTooLong = internal.ErrLineTooLong\n```\n\nErrLineTooLong is returned when reading request or response bodies with malformed chunked encoding. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrMissingBoundary",
              "documentation": {
                "identifier": "ErrMissingBoundary",
                "newPage": false,
                "searchKey": "http.ErrMissingBoundary",
                "tags": [
                  "variable",
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrMissingBoundary"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrMissingBoundary = &ProtocolError{\"no multipart boundary param in Content-Type\"}\n```\n\nErrMissingBoundary is returned by Request.MultipartReader when the request's Content-Type does not include a \"boundary\" parameter. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrMissingContentLength",
              "documentation": {
                "identifier": "ErrMissingContentLength",
                "newPage": false,
                "searchKey": "http.ErrMissingContentLength",
                "tags": [
                  "variable",
                  "struct",
                  "deprecated"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrMissingContentLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrMissingContentLength = &ProtocolError{\"missing ContentLength in HEAD response\"}\n```\n\nDeprecated: ErrMissingContentLength is no longer returned by anything in the net/http package. Callers should not compare errors against this variable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrMissingFile",
              "documentation": {
                "identifier": "ErrMissingFile",
                "newPage": false,
                "searchKey": "http.ErrMissingFile",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrMissingFile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrMissingFile = errors.New(\"http: no such file\")\n```\n\nErrMissingFile is returned by FormFile when the provided file field name is either not present in the request or not a file field. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrNoCookie",
              "documentation": {
                "identifier": "ErrNoCookie",
                "newPage": false,
                "searchKey": "http.ErrNoCookie",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrNoCookie"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrNoCookie = errors.New(\"http: named cookie not present\")\n```\n\nErrNoCookie is returned by Request's Cookie method when a cookie is not found. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrNoLocation",
              "documentation": {
                "identifier": "ErrNoLocation",
                "newPage": false,
                "searchKey": "http.ErrNoLocation",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrNoLocation"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrNoLocation = errors.New(\"http: no Location header in response\")\n```\n\nErrNoLocation is returned by Response's Location method when no Location header is present. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrNotMultipart",
              "documentation": {
                "identifier": "ErrNotMultipart",
                "newPage": false,
                "searchKey": "http.ErrNotMultipart",
                "tags": [
                  "variable",
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrNotMultipart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrNotMultipart = &ProtocolError{\"request Content-Type isn't multipart/form-data\"}\n```\n\nErrNotMultipart is returned by Request.MultipartReader when the request's Content-Type is not multipart/form-data. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrNotSupported",
              "documentation": {
                "identifier": "ErrNotSupported",
                "newPage": false,
                "searchKey": "http.ErrNotSupported",
                "tags": [
                  "variable",
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrNotSupported"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrNotSupported = &ProtocolError{\"feature not supported\"}\n```\n\nErrNotSupported is returned by the Push method of Pusher implementations to indicate that HTTP/2 Push support is not available. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrServerClosed",
              "documentation": {
                "identifier": "ErrServerClosed",
                "newPage": false,
                "searchKey": "http.ErrServerClosed",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrServerClosed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrServerClosed = errors.New(\"http: Server closed\")\n```\n\nErrServerClosed is returned by the Server's Serve, ServeTLS, ListenAndServe, and ListenAndServeTLS methods after a call to Shutdown or Close. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrShortBody",
              "documentation": {
                "identifier": "ErrShortBody",
                "newPage": false,
                "searchKey": "http.ErrShortBody",
                "tags": [
                  "variable",
                  "struct",
                  "deprecated"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrShortBody"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrShortBody = &ProtocolError{\"entity body too short\"}\n```\n\nDeprecated: ErrShortBody is no longer returned by anything in the net/http package. Callers should not compare errors against this variable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrSkipAltProtocol",
              "documentation": {
                "identifier": "ErrSkipAltProtocol",
                "newPage": false,
                "searchKey": "http.ErrSkipAltProtocol",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrSkipAltProtocol"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrSkipAltProtocol = errors.New(\"net/http: skip alternate protocol\")\n```\n\nErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrUnexpectedTrailer",
              "documentation": {
                "identifier": "ErrUnexpectedTrailer",
                "newPage": false,
                "searchKey": "http.ErrUnexpectedTrailer",
                "tags": [
                  "variable",
                  "struct",
                  "deprecated"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrUnexpectedTrailer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrUnexpectedTrailer = &ProtocolError{\"trailer header without chunked transfer encoding\"}\n```\n\nDeprecated: ErrUnexpectedTrailer is no longer returned by anything in the net/http package. Callers should not compare errors against this variable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrUseLastResponse",
              "documentation": {
                "identifier": "ErrUseLastResponse",
                "newPage": false,
                "searchKey": "http.ErrUseLastResponse",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrUseLastResponse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrUseLastResponse = errors.New(\"net/http: use last response\")\n```\n\nErrUseLastResponse can be returned by Client.CheckRedirect hooks to control how redirects are processed. If returned, the next request is not sent and the most recent response is returned with its body unclosed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ErrWriteAfterFlush",
              "documentation": {
                "identifier": "ErrWriteAfterFlush",
                "newPage": false,
                "searchKey": "http.ErrWriteAfterFlush",
                "tags": [
                  "variable",
                  "interface",
                  "deprecated"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrWriteAfterFlush"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrWriteAfterFlush = errors.New(\"unused\")\n```\n\nErrors used by the HTTP server. \n\nDeprecated: ErrWriteAfterFlush is no longer returned by anything in the net/http package. Callers should not compare errors against this variable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportAppendTime",
              "documentation": {
                "identifier": "ExportAppendTime",
                "newPage": false,
                "searchKey": "http.ExportAppendTime",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ExportAppendTime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ExportAppendTime = appendTime\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportCloseWriteAndWait",
              "documentation": {
                "identifier": "ExportCloseWriteAndWait",
                "newPage": false,
                "searchKey": "http.ExportCloseWriteAndWait",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ExportCloseWriteAndWait"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ExportCloseWriteAndWait = (*conn).closeWriteAndWait\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportErrRequestCanceled",
              "documentation": {
                "identifier": "ExportErrRequestCanceled",
                "newPage": false,
                "searchKey": "http.ExportErrRequestCanceled",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ExportErrRequestCanceled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ExportErrRequestCanceled = errRequestCanceled\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportErrRequestCanceledConn",
              "documentation": {
                "identifier": "ExportErrRequestCanceledConn",
                "newPage": false,
                "searchKey": "http.ExportErrRequestCanceledConn",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ExportErrRequestCanceledConn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ExportErrRequestCanceledConn = errRequestCanceledConn\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportErrServerClosedIdle",
              "documentation": {
                "identifier": "ExportErrServerClosedIdle",
                "newPage": false,
                "searchKey": "http.ExportErrServerClosedIdle",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ExportErrServerClosedIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ExportErrServerClosedIdle = errServerClosedIdle\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportHttp2ConfigureServer",
              "documentation": {
                "identifier": "ExportHttp2ConfigureServer",
                "newPage": false,
                "searchKey": "http.ExportHttp2ConfigureServer",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ExportHttp2ConfigureServer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ExportHttp2ConfigureServer = http2ConfigureServer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportRefererForURL",
              "documentation": {
                "identifier": "ExportRefererForURL",
                "newPage": false,
                "searchKey": "http.ExportRefererForURL",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ExportRefererForURL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ExportRefererForURL = refererForURL\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportScanETag",
              "documentation": {
                "identifier": "ExportScanETag",
                "newPage": false,
                "searchKey": "http.ExportScanETag",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ExportScanETag"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ExportScanETag = scanETag\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportServeFile",
              "documentation": {
                "identifier": "ExportServeFile",
                "newPage": false,
                "searchKey": "http.ExportServeFile",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ExportServeFile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ExportServeFile = serveFile\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportServerNewConn",
              "documentation": {
                "identifier": "ExportServerNewConn",
                "newPage": false,
                "searchKey": "http.ExportServerNewConn",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ExportServerNewConn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ExportServerNewConn = (*Server).newConn\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#Export_is408Message",
              "documentation": {
                "identifier": "Export_is408Message",
                "newPage": false,
                "searchKey": "http.Export_is408Message",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Export_is408Message"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Export_is408Message = is408Message\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#Export_shouldCopyHeaderOnRedirect",
              "documentation": {
                "identifier": "Export_shouldCopyHeaderOnRedirect",
                "newPage": false,
                "searchKey": "http.Export_shouldCopyHeaderOnRedirect",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Export_shouldCopyHeaderOnRedirect"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Export_shouldCopyHeaderOnRedirect = shouldCopyHeaderOnRedirect\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#Export_writeStatusLine",
              "documentation": {
                "identifier": "Export_writeStatusLine",
                "newPage": false,
                "searchKey": "http.Export_writeStatusLine",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Export_writeStatusLine"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Export_writeStatusLine = writeStatusLine\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#LocalAddrContextKey",
              "documentation": {
                "identifier": "LocalAddrContextKey",
                "newPage": false,
                "searchKey": "http.LocalAddrContextKey",
                "tags": [
                  "variable",
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var LocalAddrContextKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar LocalAddrContextKey = &contextKey{\"local-addr\"}\n```\n\nLocalAddrContextKey is a context key. It can be used in HTTP handlers with Context.Value to access the local address the connection arrived on. The associated value will be of type net.Addr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#NewLoggingConn",
              "documentation": {
                "identifier": "NewLoggingConn",
                "newPage": false,
                "searchKey": "http.NewLoggingConn",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var NewLoggingConn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar NewLoggingConn = newLoggingConn\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#NoBody",
              "documentation": {
                "identifier": "NoBody",
                "newPage": false,
                "searchKey": "http.NoBody",
                "tags": [
                  "variable",
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var NoBody"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar NoBody = noBody{}\n```\n\nNoBody is an io.ReadCloser with no bytes. Read always returns EOF and Close always returns nil. It can be used in an outgoing client request to explicitly signal that a request has zero bytes. An alternative, however, is to simply set Request.Body to nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ParseRangeTests",
              "documentation": {
                "identifier": "ParseRangeTests",
                "newPage": false,
                "searchKey": "http.ParseRangeTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ParseRangeTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ParseRangeTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ServerContextKey",
              "documentation": {
                "identifier": "ServerContextKey",
                "newPage": false,
                "searchKey": "http.ServerContextKey",
                "tags": [
                  "variable",
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ServerContextKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ServerContextKey = &contextKey{\"http-server\"}\n```\n\nServerContextKey is a context key. It can be used in HTTP handlers with Context.Value to access the server that started the handler. The associated value will be of type *Server. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#SetEnterRoundTripHook",
              "documentation": {
                "identifier": "SetEnterRoundTripHook",
                "newPage": false,
                "searchKey": "http.SetEnterRoundTripHook",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var SetEnterRoundTripHook"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar SetEnterRoundTripHook = hookSetter(&testHookEnterRoundTrip)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#SetRoundTripRetried",
              "documentation": {
                "identifier": "SetRoundTripRetried",
                "newPage": false,
                "searchKey": "http.SetRoundTripRetried",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var SetRoundTripRetried"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar SetRoundTripRetried = hookSetter(&testHookRoundTripRetried)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#aLongTimeAgo",
              "documentation": {
                "identifier": "aLongTimeAgo",
                "newPage": false,
                "searchKey": "http.aLongTimeAgo",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var aLongTimeAgo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar aLongTimeAgo = time.Unix(1, 0)\n```\n\naLongTimeAgo is a non-zero time, far in the past, used for immediate cancellation of network operations. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#addCookieTests",
              "documentation": {
                "identifier": "addCookieTests",
                "newPage": false,
                "searchKey": "http.addCookieTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var addCookieTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar addCookieTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#badRequestTests",
              "documentation": {
                "identifier": "badRequestTests",
                "newPage": false,
                "searchKey": "http.badRequestTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var badRequestTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badRequestTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#buf",
              "documentation": {
                "identifier": "buf",
                "newPage": false,
                "searchKey": "http.buf",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var buf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar buf bytes.Buffer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#bufioReaderPool",
              "documentation": {
                "identifier": "bufioReaderPool",
                "newPage": false,
                "searchKey": "http.bufioReaderPool",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var bufioReaderPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bufioReaderPool sync.Pool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#bufioWriter2kPool",
              "documentation": {
                "identifier": "bufioWriter2kPool",
                "newPage": false,
                "searchKey": "http.bufioWriter2kPool",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var bufioWriter2kPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bufioWriter2kPool sync.Pool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#bufioWriter4kPool",
              "documentation": {
                "identifier": "bufioWriter4kPool",
                "newPage": false,
                "searchKey": "http.bufioWriter4kPool",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var bufioWriter4kPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bufioWriter4kPool sync.Pool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#cacheKeysTests",
              "documentation": {
                "identifier": "cacheKeysTests",
                "newPage": false,
                "searchKey": "http.cacheKeysTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var cacheKeysTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cacheKeysTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#colonSpace",
              "documentation": {
                "identifier": "colonSpace",
                "newPage": false,
                "searchKey": "http.colonSpace",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var colonSpace"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar colonSpace = []byte(\": \")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#cookieNameSanitizer",
              "documentation": {
                "identifier": "cookieNameSanitizer",
                "newPage": false,
                "searchKey": "http.cookieNameSanitizer",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var cookieNameSanitizer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cookieNameSanitizer = strings.NewReplacer(\"\\n\", \"-\", \"\\r\", \"-\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#copyBufPool",
              "documentation": {
                "identifier": "copyBufPool",
                "newPage": false,
                "searchKey": "http.copyBufPool",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var copyBufPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar copyBufPool = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#crlf",
              "documentation": {
                "identifier": "crlf",
                "newPage": false,
                "searchKey": "http.crlf",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var crlf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar crlf = []byte(\"\\r\\n\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#defaultServeMux",
              "documentation": {
                "identifier": "defaultServeMux",
                "newPage": false,
                "searchKey": "http.defaultServeMux",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var defaultServeMux"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar defaultServeMux ServeMux\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#doubleCRLF",
              "documentation": {
                "identifier": "doubleCRLF",
                "newPage": false,
                "searchKey": "http.doubleCRLF",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var doubleCRLF"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar doubleCRLF = []byte(\"\\r\\n\\r\\n\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#envProxyFuncValue",
              "documentation": {
                "identifier": "envProxyFuncValue",
                "newPage": false,
                "searchKey": "http.envProxyFuncValue",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var envProxyFuncValue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar envProxyFuncValue func(*url.URL) (*url.URL, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#envProxyOnce",
              "documentation": {
                "identifier": "envProxyOnce",
                "newPage": false,
                "searchKey": "http.envProxyOnce",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var envProxyOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar envProxyOnce sync.Once\n```\n\nproxyConfigOnce guards proxyConfig \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errCallerOwnsConn",
              "documentation": {
                "identifier": "errCallerOwnsConn",
                "newPage": false,
                "searchKey": "http.errCallerOwnsConn",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errCallerOwnsConn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errCallerOwnsConn = errors.New(\"read loop ending; caller owns writable underlying conn\")\n```\n\nerrCallerOwnsConn is an internal sentinel error used when we hand off a writable response.Body to the caller. We use this to prevent closing a net.Conn that is now owned by the caller. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errCannotRewind",
              "documentation": {
                "identifier": "errCannotRewind",
                "newPage": false,
                "searchKey": "http.errCannotRewind",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errCannotRewind"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errCannotRewind = errors.New(\"net/http: cannot rewind body after connection loss\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errCloseIdle",
              "documentation": {
                "identifier": "errCloseIdle",
                "newPage": false,
                "searchKey": "http.errCloseIdle",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errCloseIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errCloseIdle = errors.New(\"http: putIdleConn: CloseIdleConnections was called\")\n```\n\nerror values for debugging and testing, not seen by users. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errCloseIdleConns",
              "documentation": {
                "identifier": "errCloseIdleConns",
                "newPage": false,
                "searchKey": "http.errCloseIdleConns",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errCloseIdleConns"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errCloseIdleConns = errors.New(\"http: CloseIdleConnections called\")\n```\n\nerror values for debugging and testing, not seen by users. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errConnBroken",
              "documentation": {
                "identifier": "errConnBroken",
                "newPage": false,
                "searchKey": "http.errConnBroken",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errConnBroken"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errConnBroken = errors.New(\"http: putIdleConn: connection is in bad state\")\n```\n\nerror values for debugging and testing, not seen by users. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errIdleConnTimeout",
              "documentation": {
                "identifier": "errIdleConnTimeout",
                "newPage": false,
                "searchKey": "http.errIdleConnTimeout",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errIdleConnTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errIdleConnTimeout = errors.New(\"http: idle connection timeout\")\n```\n\nerror values for debugging and testing, not seen by users. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errKeepAlivesDisabled",
              "documentation": {
                "identifier": "errKeepAlivesDisabled",
                "newPage": false,
                "searchKey": "http.errKeepAlivesDisabled",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errKeepAlivesDisabled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errKeepAlivesDisabled = errors.New(\"http: putIdleConn: keep alives disabled\")\n```\n\nerror values for debugging and testing, not seen by users. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errMissingHost",
              "documentation": {
                "identifier": "errMissingHost",
                "newPage": false,
                "searchKey": "http.errMissingHost",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errMissingHost"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errMissingHost = errors.New(\"http: Request.Write on Request with no Host or URL set\")\n```\n\nerrMissingHost is returned by Write when there is no Host or URL present in the Request. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errMissingReadDir",
              "documentation": {
                "identifier": "errMissingReadDir",
                "newPage": false,
                "searchKey": "http.errMissingReadDir",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errMissingReadDir"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errMissingReadDir = errors.New(\"io.File directory missing ReadDir method\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errMissingSeek",
              "documentation": {
                "identifier": "errMissingSeek",
                "newPage": false,
                "searchKey": "http.errMissingSeek",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errMissingSeek"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errMissingSeek = errors.New(\"io.File missing Seek method\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errNoOverlap",
              "documentation": {
                "identifier": "errNoOverlap",
                "newPage": false,
                "searchKey": "http.errNoOverlap",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errNoOverlap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errNoOverlap = errors.New(\"invalid range: failed to overlap\")\n```\n\nerrNoOverlap is returned by serveContent's parseRange if first-byte-pos of all of the byte-range-spec values is greater than the content size. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errReadLoopExiting",
              "documentation": {
                "identifier": "errReadLoopExiting",
                "newPage": false,
                "searchKey": "http.errReadLoopExiting",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errReadLoopExiting"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errReadLoopExiting = errors.New(\"http: persistConn.readLoop exiting\")\n```\n\nerror values for debugging and testing, not seen by users. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errReadOnClosedResBody",
              "documentation": {
                "identifier": "errReadOnClosedResBody",
                "newPage": false,
                "searchKey": "http.errReadOnClosedResBody",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errReadOnClosedResBody"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errReadOnClosedResBody = errors.New(\"http: read on closed response body\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errRequestCanceled",
              "documentation": {
                "identifier": "errRequestCanceled",
                "newPage": false,
                "searchKey": "http.errRequestCanceled",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errRequestCanceled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errRequestCanceled = http2errRequestCanceled\n```\n\nerrRequestCanceled is set to be identical to the one from h2 to facilitate testing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errRequestCanceledConn",
              "documentation": {
                "identifier": "errRequestCanceledConn",
                "newPage": false,
                "searchKey": "http.errRequestCanceledConn",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errRequestCanceledConn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errRequestCanceledConn // TODO: unify?\n = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errSeeker",
              "documentation": {
                "identifier": "errSeeker",
                "newPage": false,
                "searchKey": "http.errSeeker",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errSeeker"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errSeeker = errors.New(\"seeker can't seek\")\n```\n\nerrSeeker is returned by ServeContent's sizeFunc when the content doesn't seek properly. The underlying Seeker's error text isn't included in the sizeFunc reply so it's not sent over HTTP to end users. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errServerClosedIdle",
              "documentation": {
                "identifier": "errServerClosedIdle",
                "newPage": false,
                "searchKey": "http.errServerClosedIdle",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errServerClosedIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errServerClosedIdle = errors.New(\"http: server closed idle connection\")\n```\n\nerror values for debugging and testing, not seen by users. \n\nerrServerClosedIdle is not seen by users for idempotent requests, but may be seen by a user if the server shuts down an idle connection and sends its FIN in flight with already-written POST body bytes from the client. See [https://github.com/golang/go/issues/19943#issuecomment-355607646](https://github.com/golang/go/issues/19943#issuecomment-355607646) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errTimeout",
              "documentation": {
                "identifier": "errTimeout",
                "newPage": false,
                "searchKey": "http.errTimeout",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errTimeout error = &httpError{err: \"net/http: timeout awaiting response headers\", timeout: true}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errTooLarge",
              "documentation": {
                "identifier": "errTooLarge",
                "newPage": false,
                "searchKey": "http.errTooLarge",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errTooLarge"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errTooLarge = errors.New(\"http: request too large\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errTooManyIdle",
              "documentation": {
                "identifier": "errTooManyIdle",
                "newPage": false,
                "searchKey": "http.errTooManyIdle",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errTooManyIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errTooManyIdle = errors.New(\"http: putIdleConn: too many idle connections\")\n```\n\nerror values for debugging and testing, not seen by users. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errTooManyIdleHost",
              "documentation": {
                "identifier": "errTooManyIdleHost",
                "newPage": false,
                "searchKey": "http.errTooManyIdleHost",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errTooManyIdleHost"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errTooManyIdleHost = errors.New(\"http: putIdleConn: too many idle connections for host\")\n```\n\nerror values for debugging and testing, not seen by users. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errTrailerEOF",
              "documentation": {
                "identifier": "errTrailerEOF",
                "newPage": false,
                "searchKey": "http.errTrailerEOF",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errTrailerEOF"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errTrailerEOF = errors.New(\"http: unexpected EOF reading trailer\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#extraHeaderKeys",
              "documentation": {
                "identifier": "extraHeaderKeys",
                "newPage": false,
                "searchKey": "http.extraHeaderKeys",
                "tags": [
                  "variable",
                  "array",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var extraHeaderKeys"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar extraHeaderKeys = ...\n```\n\nSorted the same as extraHeader.Write's loop. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#forbiddenStringsFunctions",
              "documentation": {
                "identifier": "forbiddenStringsFunctions",
                "newPage": false,
                "searchKey": "http.forbiddenStringsFunctions",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var forbiddenStringsFunctions"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar forbiddenStringsFunctions = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#hasTokenTests",
              "documentation": {
                "identifier": "hasTokenTests",
                "newPage": false,
                "searchKey": "http.hasTokenTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var hasTokenTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar hasTokenTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#headerContentLength",
              "documentation": {
                "identifier": "headerContentLength",
                "newPage": false,
                "searchKey": "http.headerContentLength",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var headerContentLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar headerContentLength = []byte(\"Content-Length: \")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#headerDate",
              "documentation": {
                "identifier": "headerDate",
                "newPage": false,
                "searchKey": "http.headerDate",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var headerDate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar headerDate = []byte(\"Date: \")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#headerNewlineToSpace",
              "documentation": {
                "identifier": "headerNewlineToSpace",
                "newPage": false,
                "searchKey": "http.headerNewlineToSpace",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var headerNewlineToSpace"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar headerNewlineToSpace = strings.NewReplacer(\"\\n\", \" \", \"\\r\", \" \")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#headerSorterPool",
              "documentation": {
                "identifier": "headerSorterPool",
                "newPage": false,
                "searchKey": "http.headerSorterPool",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var headerSorterPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar headerSorterPool = sync.Pool{\n\tNew: func() interface{} { return new(headerSorter) },\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#headerWriteTests",
              "documentation": {
                "identifier": "headerWriteTests",
                "newPage": false,
                "searchKey": "http.headerWriteTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var headerWriteTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar headerWriteTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#htmlReplacer",
              "documentation": {
                "identifier": "htmlReplacer",
                "newPage": false,
                "searchKey": "http.htmlReplacer",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var htmlReplacer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar htmlReplacer = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2DebugGoroutines",
              "documentation": {
                "identifier": "http2DebugGoroutines",
                "newPage": false,
                "searchKey": "http.http2DebugGoroutines",
                "tags": [
                  "variable",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2DebugGoroutines"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2DebugGoroutines = os.Getenv(\"DEBUG_HTTP2_GOROUTINES\") == \"1\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrFrameTooLarge",
              "documentation": {
                "identifier": "http2ErrFrameTooLarge",
                "newPage": false,
                "searchKey": "http.http2ErrFrameTooLarge",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2ErrFrameTooLarge"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2ErrFrameTooLarge = errors.New(\"http2: frame too large\")\n```\n\nErrFrameTooLarge is returned from Framer.ReadFrame when the peer sends a frame that is larger than declared with SetMaxReadFrameSize. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrNoCachedConn",
              "documentation": {
                "identifier": "http2ErrNoCachedConn",
                "newPage": false,
                "searchKey": "http.http2ErrNoCachedConn",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2ErrNoCachedConn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2ErrNoCachedConn error = http2noCachedConnError{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrPushLimitReached",
              "documentation": {
                "identifier": "http2ErrPushLimitReached",
                "newPage": false,
                "searchKey": "http.http2ErrPushLimitReached",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2ErrPushLimitReached"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2ErrPushLimitReached = ...\n```\n\nPush errors. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrRecursivePush",
              "documentation": {
                "identifier": "http2ErrRecursivePush",
                "newPage": false,
                "searchKey": "http.http2ErrRecursivePush",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2ErrRecursivePush"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2ErrRecursivePush = errors.New(\"http2: recursive push not allowed\")\n```\n\nPush errors. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2VerboseLogs",
              "documentation": {
                "identifier": "http2VerboseLogs",
                "newPage": false,
                "searchKey": "http.http2VerboseLogs",
                "tags": [
                  "variable",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2VerboseLogs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2VerboseLogs bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2bufWriterPool",
              "documentation": {
                "identifier": "http2bufWriterPool",
                "newPage": false,
                "searchKey": "http.http2bufWriterPool",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2bufWriterPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2bufWriterPool = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2clientPreface",
              "documentation": {
                "identifier": "http2clientPreface",
                "newPage": false,
                "searchKey": "http.http2clientPreface",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2clientPreface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2clientPreface = []byte(http2ClientPreface)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2commonBuildOnce",
              "documentation": {
                "identifier": "http2commonBuildOnce",
                "newPage": false,
                "searchKey": "http.http2commonBuildOnce",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2commonBuildOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2commonBuildOnce sync.Once\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2commonCanonHeader",
              "documentation": {
                "identifier": "http2commonCanonHeader",
                "newPage": false,
                "searchKey": "http.http2commonCanonHeader",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2commonCanonHeader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2commonCanonHeader map[string]string // lower-case -> Go-Canonical-Case\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2commonLowerHeader",
              "documentation": {
                "identifier": "http2commonLowerHeader",
                "newPage": false,
                "searchKey": "http.http2commonLowerHeader",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2commonLowerHeader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2commonLowerHeader map[string]string // Go-Canonical-Case -> lower-case\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2connHeaders",
              "documentation": {
                "identifier": "http2connHeaders",
                "newPage": false,
                "searchKey": "http.http2connHeaders",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2connHeaders"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2connHeaders = ...\n```\n\nFrom [http://httpwg.org/specs/rfc7540.html#rfc.section.8.1.2.2](http://httpwg.org/specs/rfc7540.html#rfc.section.8.1.2.2) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2dataChunkPools",
              "documentation": {
                "identifier": "http2dataChunkPools",
                "newPage": false,
                "searchKey": "http.http2dataChunkPools",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2dataChunkPools"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2dataChunkPools = ...\n```\n\nBuffer chunks are allocated from a pool to reduce pressure on GC. The maximum wasted space per dataBuffer is 2x the largest size class, which happens when the dataBuffer has multiple chunks and there is one unread byte in both the first and last chunks. We use a few size classes to minimize overheads for servers that typically receive very small request bodies. \n\nTODO: Benchmark to determine if the pools are necessary. The GC may have improved enough that we can instead allocate chunks like this: make([]byte, max(16<<10, expectedBytesRemaining)) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2dataChunkSizeClasses",
              "documentation": {
                "identifier": "http2dataChunkSizeClasses",
                "newPage": false,
                "searchKey": "http.http2dataChunkSizeClasses",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2dataChunkSizeClasses"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2dataChunkSizeClasses = []int{\n\t1 << 10,\n\t2 << 10,\n\t4 << 10,\n\t8 << 10,\n\t16 << 10,\n}\n```\n\nBuffer chunks are allocated from a pool to reduce pressure on GC. The maximum wasted space per dataBuffer is 2x the largest size class, which happens when the dataBuffer has multiple chunks and there is one unread byte in both the first and last chunks. We use a few size classes to minimize overheads for servers that typically receive very small request bodies. \n\nTODO: Benchmark to determine if the pools are necessary. The GC may have improved enough that we can instead allocate chunks like this: make([]byte, max(16<<10, expectedBytesRemaining)) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errChanPool",
              "documentation": {
                "identifier": "http2errChanPool",
                "newPage": false,
                "searchKey": "http.http2errChanPool",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errChanPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errChanPool = sync.Pool{\n\tNew: func() interface{} { return make(chan error, 1) },\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errClientConnClosed",
              "documentation": {
                "identifier": "http2errClientConnClosed",
                "newPage": false,
                "searchKey": "http.http2errClientConnClosed",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errClientConnClosed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errClientConnClosed = errors.New(\"http2: client conn is closed\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errClientConnGotGoAway",
              "documentation": {
                "identifier": "http2errClientConnGotGoAway",
                "newPage": false,
                "searchKey": "http.http2errClientConnGotGoAway",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errClientConnGotGoAway"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errClientConnGotGoAway = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errClientConnUnusable",
              "documentation": {
                "identifier": "http2errClientConnUnusable",
                "newPage": false,
                "searchKey": "http.http2errClientConnUnusable",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errClientConnUnusable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errClientConnUnusable = errors.New(\"http2: client conn not usable\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errClientDisconnected",
              "documentation": {
                "identifier": "http2errClientDisconnected",
                "newPage": false,
                "searchKey": "http.http2errClientDisconnected",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errClientDisconnected"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errClientDisconnected = errors.New(\"client disconnected\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errClosedBody",
              "documentation": {
                "identifier": "http2errClosedBody",
                "newPage": false,
                "searchKey": "http.http2errClosedBody",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errClosedBody"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errClosedBody = errors.New(\"body closed by handler\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errClosedPipeWrite",
              "documentation": {
                "identifier": "http2errClosedPipeWrite",
                "newPage": false,
                "searchKey": "http.http2errClosedPipeWrite",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errClosedPipeWrite"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errClosedPipeWrite = errors.New(\"write on closed buffer\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errClosedResponseBody",
              "documentation": {
                "identifier": "http2errClosedResponseBody",
                "newPage": false,
                "searchKey": "http.http2errClosedResponseBody",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errClosedResponseBody"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errClosedResponseBody = errors.New(\"http2: response body closed\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errCodeName",
              "documentation": {
                "identifier": "http2errCodeName",
                "newPage": false,
                "searchKey": "http.http2errCodeName",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errCodeName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errCodeName = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errDepStreamID",
              "documentation": {
                "identifier": "http2errDepStreamID",
                "newPage": false,
                "searchKey": "http.http2errDepStreamID",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errDepStreamID"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errDepStreamID = errors.New(\"invalid dependent stream ID\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errHandlerComplete",
              "documentation": {
                "identifier": "http2errHandlerComplete",
                "newPage": false,
                "searchKey": "http.http2errHandlerComplete",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errHandlerComplete"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errHandlerComplete = errors.New(\"http2: request body closed due to handler exiting\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errHandlerPanicked",
              "documentation": {
                "identifier": "http2errHandlerPanicked",
                "newPage": false,
                "searchKey": "http.http2errHandlerPanicked",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errHandlerPanicked"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errHandlerPanicked = errors.New(\"http2: handler panicked\")\n```\n\nerrHandlerPanicked is the error given to any callers blocked in a read from Request.Body when the main goroutine panics. Since most handlers read in the main ServeHTTP goroutine, this will show up rarely. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errMixPseudoHeaderTypes",
              "documentation": {
                "identifier": "http2errMixPseudoHeaderTypes",
                "newPage": false,
                "searchKey": "http.http2errMixPseudoHeaderTypes",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errMixPseudoHeaderTypes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errMixPseudoHeaderTypes = errors.New(\"mix of request and response pseudo headers\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errPadBytes",
              "documentation": {
                "identifier": "http2errPadBytes",
                "newPage": false,
                "searchKey": "http.http2errPadBytes",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errPadBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errPadBytes = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errPadLength",
              "documentation": {
                "identifier": "http2errPadLength",
                "newPage": false,
                "searchKey": "http.http2errPadLength",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errPadLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errPadLength = errors.New(\"pad length too large\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errPrefaceTimeout",
              "documentation": {
                "identifier": "http2errPrefaceTimeout",
                "newPage": false,
                "searchKey": "http.http2errPrefaceTimeout",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errPrefaceTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errPrefaceTimeout = errors.New(\"timeout waiting for client preface\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errPseudoAfterRegular",
              "documentation": {
                "identifier": "http2errPseudoAfterRegular",
                "newPage": false,
                "searchKey": "http.http2errPseudoAfterRegular",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errPseudoAfterRegular"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errPseudoAfterRegular = errors.New(\"pseudo header field after regular\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errReadEmpty",
              "documentation": {
                "identifier": "http2errReadEmpty",
                "newPage": false,
                "searchKey": "http.http2errReadEmpty",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errReadEmpty"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errReadEmpty = errors.New(\"read from empty dataBuffer\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errReqBodyTooLong",
              "documentation": {
                "identifier": "http2errReqBodyTooLong",
                "newPage": false,
                "searchKey": "http.http2errReqBodyTooLong",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errReqBodyTooLong"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errReqBodyTooLong = errors.New(\"http2: request body larger than specified content length\")\n```\n\ninternal error values; they don't escape to callers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errRequestCanceled",
              "documentation": {
                "identifier": "http2errRequestCanceled",
                "newPage": false,
                "searchKey": "http.http2errRequestCanceled",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errRequestCanceled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errRequestCanceled = errors.New(\"net/http: request canceled\")\n```\n\nerrRequestCanceled is a copy of net/http's errRequestCanceled because it's not exported. At least they'll be DeepEqual for h1-vs-h2 comparisons tests. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errRequestHeaderListSize",
              "documentation": {
                "identifier": "http2errRequestHeaderListSize",
                "newPage": false,
                "searchKey": "http.http2errRequestHeaderListSize",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errRequestHeaderListSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errRequestHeaderListSize = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errResponseHeaderListSize",
              "documentation": {
                "identifier": "http2errResponseHeaderListSize",
                "newPage": false,
                "searchKey": "http.http2errResponseHeaderListSize",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errResponseHeaderListSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errResponseHeaderListSize = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errStopReqBodyWrite",
              "documentation": {
                "identifier": "http2errStopReqBodyWrite",
                "newPage": false,
                "searchKey": "http.http2errStopReqBodyWrite",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errStopReqBodyWrite"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errStopReqBodyWrite = errors.New(\"http2: aborting request body write\")\n```\n\ninternal error values; they don't escape to callers \n\nabort request body write; don't send cancel \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errStopReqBodyWriteAndCancel",
              "documentation": {
                "identifier": "http2errStopReqBodyWriteAndCancel",
                "newPage": false,
                "searchKey": "http.http2errStopReqBodyWriteAndCancel",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errStopReqBodyWriteAndCancel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errStopReqBodyWriteAndCancel = errors.New(\"http2: canceling request\")\n```\n\ninternal error values; they don't escape to callers \n\nabort request body write, but send stream reset of cancel. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errStreamClosed",
              "documentation": {
                "identifier": "http2errStreamClosed",
                "newPage": false,
                "searchKey": "http.http2errStreamClosed",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errStreamClosed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errStreamClosed = errors.New(\"http2: stream closed\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errStreamID",
              "documentation": {
                "identifier": "http2errStreamID",
                "newPage": false,
                "searchKey": "http.http2errStreamID",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errStreamID"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errStreamID = errors.New(\"invalid stream ID\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errTimeout",
              "documentation": {
                "identifier": "http2errTimeout",
                "newPage": false,
                "searchKey": "http.http2errTimeout",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2errTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2errTimeout error = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2fhBytes",
              "documentation": {
                "identifier": "http2fhBytes",
                "newPage": false,
                "searchKey": "http.http2fhBytes",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2fhBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2fhBytes = ...\n```\n\nframe header bytes. Used only by ReadFrameHeader. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2flagName",
              "documentation": {
                "identifier": "http2flagName",
                "newPage": false,
                "searchKey": "http.http2flagName",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2flagName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2flagName = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2frameName",
              "documentation": {
                "identifier": "http2frameName",
                "newPage": false,
                "searchKey": "http.http2frameName",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2frameName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2frameName = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2frameParsers",
              "documentation": {
                "identifier": "http2frameParsers",
                "newPage": false,
                "searchKey": "http.http2frameParsers",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2frameParsers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2frameParsers = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2goAwayTimeout",
              "documentation": {
                "identifier": "http2goAwayTimeout",
                "newPage": false,
                "searchKey": "http.http2goAwayTimeout",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2goAwayTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2goAwayTimeout = 1 * time.Second\n```\n\nAfter sending GOAWAY with an error code (non-graceful shutdown), the connection will close after goAwayTimeout. \n\nIf we close the connection immediately after sending GOAWAY, there may be unsent data in our kernel receive buffer, which will cause the kernel to send a TCP RST on close() instead of a FIN. This RST will abort the connection immediately, whether or not the client had received the GOAWAY. \n\nIdeally we should delay for at least 1 RTT + epsilon so the client has a chance to read the GOAWAY and stop sending messages. Measuring RTT is hard, so we approximate with 1 second. See golang.org/issue/18701. \n\nThis is a var so it can be shorter in tests, where all requests uses the loopback interface making the expected RTT very small. \n\nTODO: configurable? \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2goroutineSpace",
              "documentation": {
                "identifier": "http2goroutineSpace",
                "newPage": false,
                "searchKey": "http.http2goroutineSpace",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2goroutineSpace"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2goroutineSpace = []byte(\"goroutine \")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2got1xxFuncForTests",
              "documentation": {
                "identifier": "http2got1xxFuncForTests",
                "newPage": false,
                "searchKey": "http.http2got1xxFuncForTests",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2got1xxFuncForTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2got1xxFuncForTests func(int, textproto.MIMEHeader) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2gracefulShutdownMsg",
              "documentation": {
                "identifier": "http2gracefulShutdownMsg",
                "newPage": false,
                "searchKey": "http.http2gracefulShutdownMsg",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2gracefulShutdownMsg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2gracefulShutdownMsg = new(http2serverMessage)\n```\n\nMessage values sent to serveMsgCh. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2idleTimerMsg",
              "documentation": {
                "identifier": "http2idleTimerMsg",
                "newPage": false,
                "searchKey": "http.http2idleTimerMsg",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2idleTimerMsg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2idleTimerMsg = new(http2serverMessage)\n```\n\nMessage values sent to serveMsgCh. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2inTests",
              "documentation": {
                "identifier": "http2inTests",
                "newPage": false,
                "searchKey": "http.http2inTests",
                "tags": [
                  "variable",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2inTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2inTests bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2littleBuf",
              "documentation": {
                "identifier": "http2littleBuf",
                "newPage": false,
                "searchKey": "http.http2littleBuf",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2littleBuf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2littleBuf = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2logFrameReads",
              "documentation": {
                "identifier": "http2logFrameReads",
                "newPage": false,
                "searchKey": "http.http2logFrameReads",
                "tags": [
                  "variable",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2logFrameReads"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2logFrameReads bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2logFrameWrites",
              "documentation": {
                "identifier": "http2logFrameWrites",
                "newPage": false,
                "searchKey": "http.http2logFrameWrites",
                "tags": [
                  "variable",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2logFrameWrites"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2logFrameWrites bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2noBody",
              "documentation": {
                "identifier": "http2noBody",
                "newPage": false,
                "searchKey": "http.http2noBody",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2noBody"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2noBody io.ReadCloser = ioutil.NopCloser(bytes.NewReader(nil))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2padZeros",
              "documentation": {
                "identifier": "http2padZeros",
                "newPage": false,
                "searchKey": "http.http2padZeros",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2padZeros"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2padZeros = make([]byte, 255) // zeros for padding\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2responseWriterStatePool",
              "documentation": {
                "identifier": "http2responseWriterStatePool",
                "newPage": false,
                "searchKey": "http.http2responseWriterStatePool",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2responseWriterStatePool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2responseWriterStatePool = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2settingName",
              "documentation": {
                "identifier": "http2settingName",
                "newPage": false,
                "searchKey": "http.http2settingName",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2settingName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2settingName = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2settingsTimerMsg",
              "documentation": {
                "identifier": "http2settingsTimerMsg",
                "newPage": false,
                "searchKey": "http.http2settingsTimerMsg",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2settingsTimerMsg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2settingsTimerMsg = new(http2serverMessage)\n```\n\nMessage values sent to serveMsgCh. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2shutdownEnterWaitStateHook",
              "documentation": {
                "identifier": "http2shutdownEnterWaitStateHook",
                "newPage": false,
                "searchKey": "http.http2shutdownEnterWaitStateHook",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2shutdownEnterWaitStateHook"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2shutdownEnterWaitStateHook = func() {}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2shutdownTimerMsg",
              "documentation": {
                "identifier": "http2shutdownTimerMsg",
                "newPage": false,
                "searchKey": "http.http2shutdownTimerMsg",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2shutdownTimerMsg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2shutdownTimerMsg = new(http2serverMessage)\n```\n\nMessage values sent to serveMsgCh. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2sorterPool",
              "documentation": {
                "identifier": "http2sorterPool",
                "newPage": false,
                "searchKey": "http.http2sorterPool",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2sorterPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2sorterPool = sync.Pool{New: func() interface{} { return new(http2sorter) }}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2stateName",
              "documentation": {
                "identifier": "http2stateName",
                "newPage": false,
                "searchKey": "http.http2stateName",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2stateName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2stateName = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2testHookGetServerConn",
              "documentation": {
                "identifier": "http2testHookGetServerConn",
                "newPage": false,
                "searchKey": "http.http2testHookGetServerConn",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2testHookGetServerConn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2testHookGetServerConn func(*http2serverConn)\n```\n\nTest hooks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2testHookOnConn",
              "documentation": {
                "identifier": "http2testHookOnConn",
                "newPage": false,
                "searchKey": "http.http2testHookOnConn",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2testHookOnConn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2testHookOnConn func()\n```\n\nTest hooks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2testHookOnPanic",
              "documentation": {
                "identifier": "http2testHookOnPanic",
                "newPage": false,
                "searchKey": "http.http2testHookOnPanic",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2testHookOnPanic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2testHookOnPanic func(sc *http2serverConn, panicVal interface{}) (rePanic bool)\n```\n\nTest hooks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2testHookOnPanicMu",
              "documentation": {
                "identifier": "http2testHookOnPanicMu",
                "newPage": false,
                "searchKey": "http.http2testHookOnPanicMu",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2testHookOnPanicMu"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2testHookOnPanicMu *sync.Mutex // nil except in tests\n\n```\n\nTest hooks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeDataPool",
              "documentation": {
                "identifier": "http2writeDataPool",
                "newPage": false,
                "searchKey": "http.http2writeDataPool",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var http2writeDataPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar http2writeDataPool = sync.Pool{\n\tNew: func() interface{} { return new(http2writeData) },\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#mp4",
              "documentation": {
                "identifier": "mp4",
                "newPage": false,
                "searchKey": "http.mp4",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var mp4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mp4 = []byte(\"mp4\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#mp4ftype",
              "documentation": {
                "identifier": "mp4ftype",
                "newPage": false,
                "searchKey": "http.mp4ftype",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var mp4ftype"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mp4ftype = []byte(\"ftyp\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#multipartByReader",
              "documentation": {
                "identifier": "multipartByReader",
                "newPage": false,
                "searchKey": "http.multipartByReader",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var multipartByReader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar multipartByReader = ...\n```\n\nmultipartByReader is a sentinel value. Its presence in Request.MultipartForm indicates that parsing of the request body has been handed off to a MultipartReader instead of ParseMultipartForm. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#noBodyStr",
              "documentation": {
                "identifier": "noBodyStr",
                "newPage": false,
                "searchKey": "http.noBodyStr",
                "tags": [
                  "variable",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var noBodyStr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar noBodyStr = \"\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#noError",
              "documentation": {
                "identifier": "noError",
                "newPage": false,
                "searchKey": "http.noError",
                "tags": [
                  "variable",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var noError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar noError = \"\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#noTrailer",
              "documentation": {
                "identifier": "noTrailer",
                "newPage": false,
                "searchKey": "http.noTrailer",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var noTrailer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar noTrailer Header = nil\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#nopCloserType",
              "documentation": {
                "identifier": "nopCloserType",
                "newPage": false,
                "searchKey": "http.nopCloserType",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var nopCloserType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar nopCloserType = reflect.TypeOf(io.NopCloser(nil))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#omitBundledHTTP2",
              "documentation": {
                "identifier": "omitBundledHTTP2",
                "newPage": false,
                "searchKey": "http.omitBundledHTTP2",
                "tags": [
                  "variable",
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var omitBundledHTTP2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar omitBundledHTTP2 bool\n```\n\nomitBundledHTTP2 is set by omithttp2.go when the nethttpomithttp2 build tag is set. That means h2_bundle.go isn't compiled in and we shouldn't try to use it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#parseTimeTests",
              "documentation": {
                "identifier": "parseTimeTests",
                "newPage": false,
                "searchKey": "http.parseTimeTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var parseTimeTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar parseTimeTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#portMap",
              "documentation": {
                "identifier": "portMap",
                "newPage": false,
                "searchKey": "http.portMap",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var portMap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar portMap = map[string]string{\n\t\"http\":   \"80\",\n\t\"https\":  \"443\",\n\t\"socks5\": \"1080\",\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#readCookiesTests",
              "documentation": {
                "identifier": "readCookiesTests",
                "newPage": false,
                "searchKey": "http.readCookiesTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var readCookiesTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar readCookiesTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#readResponseCloseInMiddleTests",
              "documentation": {
                "identifier": "readResponseCloseInMiddleTests",
                "newPage": false,
                "searchKey": "http.readResponseCloseInMiddleTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var readResponseCloseInMiddleTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar readResponseCloseInMiddleTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#readSetCookiesTests",
              "documentation": {
                "identifier": "readSetCookiesTests",
                "newPage": false,
                "searchKey": "http.readSetCookiesTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var readSetCookiesTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar readSetCookiesTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#reqTests",
              "documentation": {
                "identifier": "reqTests",
                "newPage": false,
                "searchKey": "http.reqTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var reqTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar reqTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#reqWriteExcludeHeader",
              "documentation": {
                "identifier": "reqWriteExcludeHeader",
                "newPage": false,
                "searchKey": "http.reqWriteExcludeHeader",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var reqWriteExcludeHeader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar reqWriteExcludeHeader = ...\n```\n\nHeaders that Request.Write handles itself and should be skipped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#reqWriteTests",
              "documentation": {
                "identifier": "reqWriteTests",
                "newPage": false,
                "searchKey": "http.reqWriteTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var reqWriteTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar reqWriteTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#respExcludeHeader",
              "documentation": {
                "identifier": "respExcludeHeader",
                "newPage": false,
                "searchKey": "http.respExcludeHeader",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var respExcludeHeader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar respExcludeHeader = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#respTests",
              "documentation": {
                "identifier": "respTests",
                "newPage": false,
                "searchKey": "http.respTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var respTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar respTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#responseLocationTests",
              "documentation": {
                "identifier": "responseLocationTests",
                "newPage": false,
                "searchKey": "http.responseLocationTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var responseLocationTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar responseLocationTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#silenceSemWarnContextKey",
              "documentation": {
                "identifier": "silenceSemWarnContextKey",
                "newPage": false,
                "searchKey": "http.silenceSemWarnContextKey",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var silenceSemWarnContextKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar silenceSemWarnContextKey = &contextKey{\"silence-semicolons\"}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#singleCRLF",
              "documentation": {
                "identifier": "singleCRLF",
                "newPage": false,
                "searchKey": "http.singleCRLF",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var singleCRLF"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar singleCRLF = []byte(\"\\r\\n\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#sniffSignatures",
              "documentation": {
                "identifier": "sniffSignatures",
                "newPage": false,
                "searchKey": "http.sniffSignatures",
                "tags": [
                  "variable",
                  "array",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var sniffSignatures"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sniffSignatures = ...\n```\n\nData matching the table in section 6. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksaLongTimeAgo",
              "documentation": {
                "identifier": "socksaLongTimeAgo",
                "newPage": false,
                "searchKey": "http.socksaLongTimeAgo",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var socksaLongTimeAgo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar socksaLongTimeAgo = time.Unix(1, 0)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksnoDeadline",
              "documentation": {
                "identifier": "socksnoDeadline",
                "newPage": false,
                "searchKey": "http.socksnoDeadline",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var socksnoDeadline"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar socksnoDeadline = time.Time{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#stateName",
              "documentation": {
                "identifier": "stateName",
                "newPage": false,
                "searchKey": "http.stateName",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var stateName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar stateName = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#statusText",
              "documentation": {
                "identifier": "statusText",
                "newPage": false,
                "searchKey": "http.statusText",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var statusText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar statusText = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#suppressedHeaders304",
              "documentation": {
                "identifier": "suppressedHeaders304",
                "newPage": false,
                "searchKey": "http.suppressedHeaders304",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var suppressedHeaders304"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar suppressedHeaders304 = []string{\"Content-Type\", \"Content-Length\", \"Transfer-Encoding\"}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#suppressedHeadersNoBody",
              "documentation": {
                "identifier": "suppressedHeadersNoBody",
                "newPage": false,
                "searchKey": "http.suppressedHeadersNoBody",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var suppressedHeadersNoBody"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar suppressedHeadersNoBody = []string{\"Content-Length\", \"Transfer-Encoding\"}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#testHeader",
              "documentation": {
                "identifier": "testHeader",
                "newPage": false,
                "searchKey": "http.testHeader",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHeader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHeader = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#testHookClientDoResult",
              "documentation": {
                "identifier": "testHookClientDoResult",
                "newPage": false,
                "searchKey": "http.testHookClientDoResult",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookClientDoResult"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookClientDoResult func(retres *Response, reterr error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#testHookEnterRoundTrip",
              "documentation": {
                "identifier": "testHookEnterRoundTrip",
                "newPage": false,
                "searchKey": "http.testHookEnterRoundTrip",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookEnterRoundTrip"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookEnterRoundTrip = nop\n```\n\ntestHooks. Always non-nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#testHookMu",
              "documentation": {
                "identifier": "testHookMu",
                "newPage": false,
                "searchKey": "http.testHookMu",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookMu"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookMu sync.Locker = fakeLocker{} // guards following\n\n```\n\ntestHooks. Always non-nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#testHookPostPendingDial",
              "documentation": {
                "identifier": "testHookPostPendingDial",
                "newPage": false,
                "searchKey": "http.testHookPostPendingDial",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookPostPendingDial"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookPostPendingDial = nop\n```\n\ntestHooks. Always non-nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#testHookPrePendingDial",
              "documentation": {
                "identifier": "testHookPrePendingDial",
                "newPage": false,
                "searchKey": "http.testHookPrePendingDial",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookPrePendingDial"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookPrePendingDial = nop\n```\n\ntestHooks. Always non-nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#testHookReadLoopBeforeNextRead",
              "documentation": {
                "identifier": "testHookReadLoopBeforeNextRead",
                "newPage": false,
                "searchKey": "http.testHookReadLoopBeforeNextRead",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookReadLoopBeforeNextRead"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookReadLoopBeforeNextRead = nop\n```\n\ntestHooks. Always non-nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#testHookRoundTripRetried",
              "documentation": {
                "identifier": "testHookRoundTripRetried",
                "newPage": false,
                "searchKey": "http.testHookRoundTripRetried",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookRoundTripRetried"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookRoundTripRetried = nop\n```\n\ntestHooks. Always non-nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#testHookServerServe",
              "documentation": {
                "identifier": "testHookServerServe",
                "newPage": false,
                "searchKey": "http.testHookServerServe",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookServerServe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookServerServe func(*Server, net.Listener) // used if non-nil\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#testHookWaitResLoop",
              "documentation": {
                "identifier": "testHookWaitResLoop",
                "newPage": false,
                "searchKey": "http.testHookWaitResLoop",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testHookWaitResLoop"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testHookWaitResLoop = nop\n```\n\ntestHooks. Always non-nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#textprotoReaderPool",
              "documentation": {
                "identifier": "textprotoReaderPool",
                "newPage": false,
                "searchKey": "http.textprotoReaderPool",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var textprotoReaderPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar textprotoReaderPool sync.Pool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#timeFormats",
              "documentation": {
                "identifier": "timeFormats",
                "newPage": false,
                "searchKey": "http.timeFormats",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var timeFormats"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar timeFormats = []string{\n\tTimeFormat,\n\ttime.RFC850,\n\ttime.ANSIC,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#uniqNameMu",
              "documentation": {
                "identifier": "uniqNameMu",
                "newPage": false,
                "searchKey": "http.uniqNameMu",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var uniqNameMu"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar uniqNameMu sync.Mutex\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#uniqNameNext",
              "documentation": {
                "identifier": "uniqNameNext",
                "newPage": false,
                "searchKey": "http.uniqNameNext",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var uniqNameNext"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar uniqNameNext = make(map[string]int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#unixEpochTime",
              "documentation": {
                "identifier": "unixEpochTime",
                "newPage": false,
                "searchKey": "http.unixEpochTime",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var unixEpochTime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar unixEpochTime = time.Unix(0, 0)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#valuesCount",
              "documentation": {
                "identifier": "valuesCount",
                "newPage": false,
                "searchKey": "http.valuesCount",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var valuesCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar valuesCount int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#writeSetCookiesTests",
              "documentation": {
                "identifier": "writeSetCookiesTests",
                "newPage": false,
                "searchKey": "http.writeSetCookiesTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var writeSetCookiesTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar writeSetCookiesTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#zeroDialer",
              "documentation": {
                "identifier": "zeroDialer",
                "newPage": false,
                "searchKey": "http.zeroDialer",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var zeroDialer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar zeroDialer net.Dialer\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/net/http#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/net/http#Client",
              "documentation": {
                "identifier": "Client",
                "newPage": false,
                "searchKey": "http.Client",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Client struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Client struct {\n\t// Transport specifies the mechanism by which individual\n\t// HTTP requests are made.\n\t// If nil, DefaultTransport is used.\n\tTransport RoundTripper\n\n\t// CheckRedirect specifies the policy for handling redirects.\n\t// If CheckRedirect is not nil, the client calls it before\n\t// following an HTTP redirect. The arguments req and via are\n\t// the upcoming request and the requests made already, oldest\n\t// first. If CheckRedirect returns an error, the Client's Get\n\t// method returns both the previous Response (with its Body\n\t// closed) and CheckRedirect's error (wrapped in a url.Error)\n\t// instead of issuing the Request req.\n\t// As a special case, if CheckRedirect returns ErrUseLastResponse,\n\t// then the most recent response is returned with its body\n\t// unclosed, along with a nil error.\n\t//\n\t// If CheckRedirect is nil, the Client uses its default policy,\n\t// which is to stop after 10 consecutive requests.\n\tCheckRedirect func(req *Request, via []*Request) error\n\n\t// Jar specifies the cookie jar.\n\t//\n\t// The Jar is used to insert relevant cookies into every\n\t// outbound Request and is updated with the cookie values\n\t// of every inbound Response. The Jar is consulted for every\n\t// redirect that the Client follows.\n\t//\n\t// If Jar is nil, cookies are only sent if they are explicitly\n\t// set on the Request.\n\tJar CookieJar\n\n\t// Timeout specifies a time limit for requests made by this\n\t// Client. The timeout includes connection time, any\n\t// redirects, and reading the response body. The timer remains\n\t// running after Get, Head, Post, or Do return and will\n\t// interrupt reading of the Response.Body.\n\t//\n\t// A Timeout of zero means no timeout.\n\t//\n\t// The Client cancels requests to the underlying Transport\n\t// as if the Request's Context ended.\n\t//\n\t// For compatibility, the Client will also use the deprecated\n\t// CancelRequest method on Transport if found. New\n\t// RoundTripper implementations should use the Request's Context\n\t// for cancellation instead of implementing CancelRequest.\n\tTimeout time.Duration\n}\n```\n\nA Client is an HTTP client. Its zero value (DefaultClient) is a usable client that uses DefaultTransport. \n\nThe Client's Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines. \n\nA Client is higher-level than a RoundTripper (such as Transport) and additionally handles HTTP details such as cookies and redirects. \n\nWhen following redirects, the Client will forward all headers set on the initial Request except: \n\n• when forwarding sensitive headers like \"Authorization\", \"WWW-Authenticate\", and \"Cookie\" to untrusted targets. These headers will be ignored when following a redirect to a domain that is not a subdomain match or exact match of the initial domain. For example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\" will forward the sensitive headers, but a redirect to \"bar.com\" will not. \n\n• when forwarding the \"Cookie\" header with a non-nil cookie Jar. Since each redirect may mutate the state of the cookie jar, a redirect may possibly alter a cookie set in the initial request. When forwarding the \"Cookie\" header, any mutated cookies will be omitted, with the expectation that the Jar will insert those mutated cookies with the updated values (assuming the origin matches). If Jar is nil, the initial cookies are forwarded without change. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#Client.CloseIdleConnections",
                    "documentation": {
                      "identifier": "Client.CloseIdleConnections",
                      "newPage": false,
                      "searchKey": "http.Client.CloseIdleConnections",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) CloseIdleConnections()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) CloseIdleConnections()\n```\n\nCloseIdleConnections closes any connections on its Transport which were previously connected from previous requests but are now sitting idle in a \"keep-alive\" state. It does not interrupt any connections currently in use. \n\nIf the Client's Transport does not have a CloseIdleConnections method then this method does nothing. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Client.Do",
                    "documentation": {
                      "identifier": "Client.Do",
                      "newPage": false,
                      "searchKey": "http.Client.Do",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) Do(req *Request) (*Response, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) Do(req *Request) (*Response, error)\n```\n\nDo sends an HTTP request and returns an HTTP response, following policy (such as redirects, cookies, auth) as configured on the client. \n\nAn error is returned if caused by client policy (such as CheckRedirect), or failure to speak HTTP (such as a network connectivity problem). A non-2xx status code doesn't cause an error. \n\nIf the returned error is nil, the Response will contain a non-nil Body which the user is expected to close. If the Body is not both read to EOF and closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent \"keep-alive\" request. \n\nThe request Body, if non-nil, will be closed by the underlying Transport, even on errors. \n\nOn error, any Response can be ignored. A non-nil Response with a non-nil error only occurs when CheckRedirect fails, and even then the returned Response.Body is already closed. \n\nGenerally Get, Post, or PostForm will be used instead of Do. \n\nIf the server replies with a redirect, the Client first uses the CheckRedirect function to determine whether the redirect should be followed. If permitted, a 301, 302, or 303 redirect causes subsequent requests to use HTTP method GET (or HEAD if the original request was HEAD), with no body. A 307 or 308 redirect preserves the original HTTP method and body, provided that the Request.GetBody function is defined. The NewRequest function automatically sets GetBody for common standard library body types. \n\nAny returned error will be of type *url.Error. The url.Error value's Timeout method will report true if the request timed out. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Client.Get",
                    "documentation": {
                      "identifier": "Client.Get",
                      "newPage": false,
                      "searchKey": "http.Client.Get",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) Get(url string) (resp *Response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) Get(url string) (resp *Response, err error)\n```\n\nGet issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect after calling the Client's CheckRedirect function: \n\n```\n301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n308 (Permanent Redirect)\n\n```\nAn error is returned if the Client's CheckRedirect function fails or if there was an HTTP protocol error. A non-2xx response doesn't cause an error. Any returned error will be of type *url.Error. The url.Error value's Timeout method will report true if the request timed out. \n\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. \n\nTo make a request with custom headers, use NewRequest and Client.Do. \n\nTo make a request with a specified context.Context, use NewRequestWithContext and Client.Do. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Client.Head",
                    "documentation": {
                      "identifier": "Client.Head",
                      "newPage": false,
                      "searchKey": "http.Client.Head",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) Head(url string) (resp *Response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) Head(url string) (resp *Response, err error)\n```\n\nHead issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect after calling the Client's CheckRedirect function: \n\n```\n301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n308 (Permanent Redirect)\n\n```\nTo make a request with a specified context.Context, use NewRequestWithContext and Client.Do. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Client.Post",
                    "documentation": {
                      "identifier": "Client.Post",
                      "newPage": false,
                      "searchKey": "http.Client.Post",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) Post(url, contentType string, body io.Reader) (resp *Response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) Post(url, contentType string, body io.Reader) (resp *Response, err error)\n```\n\nPost issues a POST to the specified URL. \n\nCaller should close resp.Body when done reading from it. \n\nIf the provided body is an io.Closer, it is closed after the request. \n\nTo set custom headers, use NewRequest and Client.Do. \n\nTo make a request with a specified context.Context, use NewRequestWithContext and Client.Do. \n\nSee the Client.Do method documentation for details on how redirects are handled. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Client.PostForm",
                    "documentation": {
                      "identifier": "Client.PostForm",
                      "newPage": false,
                      "searchKey": "http.Client.PostForm",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)\n```\n\nPostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body. \n\nThe Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and Client.Do. \n\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. \n\nSee the Client.Do method documentation for details on how redirects are handled. \n\nTo make a request with a specified context.Context, use NewRequestWithContext and Client.Do. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Client.checkRedirect",
                    "documentation": {
                      "identifier": "Client.checkRedirect",
                      "newPage": false,
                      "searchKey": "http.Client.checkRedirect",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) checkRedirect(req *Request, via []*Request) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) checkRedirect(req *Request, via []*Request) error\n```\n\ncheckRedirect calls either the user's configured CheckRedirect function, or the default. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Client.deadline",
                    "documentation": {
                      "identifier": "Client.deadline",
                      "newPage": false,
                      "searchKey": "http.Client.deadline",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) deadline() time.Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) deadline() time.Time\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Client.do",
                    "documentation": {
                      "identifier": "Client.do",
                      "newPage": false,
                      "searchKey": "http.Client.do",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) do(req *Request) (retres *Response, reterr error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) do(req *Request) (retres *Response, reterr error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Client.makeHeadersCopier",
                    "documentation": {
                      "identifier": "Client.makeHeadersCopier",
                      "newPage": false,
                      "searchKey": "http.Client.makeHeadersCopier",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) makeHeadersCopier(ireq *Request) func(*Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) makeHeadersCopier(ireq *Request) func(*Request)\n```\n\nmakeHeadersCopier makes a function that copies headers from the initial Request, ireq. For every redirect, this function must be called so that it can copy headers into the upcoming Request. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Client.send",
                    "documentation": {
                      "identifier": "Client.send",
                      "newPage": false,
                      "searchKey": "http.Client.send",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) send(req *Request, deadline time.Time) (resp *Response, didTimeout func() bool, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) send(req *Request, deadline time.Time) (resp *Response, didTimeout func() bool, err error)\n```\n\ndidTimeout is non-nil only if err != nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Client.transport",
                    "documentation": {
                      "identifier": "Client.transport",
                      "newPage": false,
                      "searchKey": "http.Client.transport",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Client) transport() RoundTripper"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Client) transport() RoundTripper\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#CloseNotifier",
              "documentation": {
                "identifier": "CloseNotifier",
                "newPage": false,
                "searchKey": "http.CloseNotifier",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type CloseNotifier interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype CloseNotifier interface {\n\t// CloseNotify returns a channel that receives at most a\n\t// single value (true) when the client connection has gone\n\t// away.\n\t//\n\t// CloseNotify may wait to notify until Request.Body has been\n\t// fully read.\n\t//\n\t// After the Handler has returned, there is no guarantee\n\t// that the channel receives a value.\n\t//\n\t// If the protocol is HTTP/1.1 and CloseNotify is called while\n\t// processing an idempotent request (such a GET) while\n\t// HTTP/1.1 pipelining is in use, the arrival of a subsequent\n\t// pipelined request may cause a value to be sent on the\n\t// returned channel. In practice HTTP/1.1 pipelining is not\n\t// enabled in browsers and not seen often in the wild. If this\n\t// is a problem, use HTTP/2 or only use CloseNotify on methods\n\t// such as POST.\n\tCloseNotify() <-chan bool\n}\n```\n\nThe CloseNotifier interface is implemented by ResponseWriters which allow detecting when the underlying connection has gone away. \n\nThis mechanism can be used to cancel long operations on the server if the client has disconnected before the response is ready. \n\nDeprecated: the CloseNotifier interface predates Go's context package. New code should use Request.Context instead. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ConnState",
              "documentation": {
                "identifier": "ConnState",
                "newPage": false,
                "searchKey": "http.ConnState",
                "tags": [
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ConnState int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ConnState int\n```\n\nA ConnState represents the state of a client connection to a server. It's used by the optional Server.ConnState hook. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#ConnState.String",
                    "documentation": {
                      "identifier": "ConnState.String",
                      "newPage": false,
                      "searchKey": "http.ConnState.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c ConnState) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c ConnState) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#Cookie",
              "documentation": {
                "identifier": "Cookie",
                "newPage": false,
                "searchKey": "http.Cookie",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Cookie struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Cookie struct {\n\tName  string\n\tValue string\n\n\tPath       string    // optional\n\tDomain     string    // optional\n\tExpires    time.Time // optional\n\tRawExpires string    // for reading cookies only\n\n\t// MaxAge=0 means no 'Max-Age' attribute specified.\n\t// MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'\n\t// MaxAge>0 means Max-Age attribute present and given in seconds\n\tMaxAge   int\n\tSecure   bool\n\tHttpOnly bool\n\tSameSite SameSite\n\tRaw      string\n\tUnparsed []string // Raw text of unparsed attribute-value pairs\n}\n```\n\nA Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. \n\nSee [https://tools.ietf.org/html/rfc6265](https://tools.ietf.org/html/rfc6265) for details. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#Cookie.String",
                    "documentation": {
                      "identifier": "Cookie.String",
                      "newPage": false,
                      "searchKey": "http.Cookie.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Cookie) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Cookie) String() string\n```\n\nString returns the serialization of the cookie for use in a Cookie header (if only Name and Value are set) or a Set-Cookie response header (if other fields are set). If c is nil or c.Name is invalid, the empty string is returned. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#CookieJar",
              "documentation": {
                "identifier": "CookieJar",
                "newPage": false,
                "searchKey": "http.CookieJar",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type CookieJar interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype CookieJar interface {\n\t// SetCookies handles the receipt of the cookies in a reply for the\n\t// given URL.  It may or may not choose to save the cookies, depending\n\t// on the jar's policy and implementation.\n\tSetCookies(u *url.URL, cookies []*Cookie)\n\n\t// Cookies returns the cookies to send in a request for the given URL.\n\t// It is up to the implementation to honor the standard cookie use\n\t// restrictions such as in RFC 6265.\n\tCookies(u *url.URL) []*Cookie\n}\n```\n\nA CookieJar manages storage and use of cookies in HTTP requests. \n\nImplementations of CookieJar must be safe for concurrent use by multiple goroutines. \n\nThe net/http/cookiejar package provides a CookieJar implementation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#Dir",
              "documentation": {
                "identifier": "Dir",
                "newPage": false,
                "searchKey": "http.Dir",
                "tags": [
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Dir string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Dir string\n```\n\nA Dir implements FileSystem using the native file system restricted to a specific directory tree. \n\nWhile the FileSystem.Open method takes '/'-separated paths, a Dir's string value is a filename on the native file system, not a URL, so it is separated by filepath.Separator, which isn't necessarily '/'. \n\nNote that Dir could expose sensitive files and directories. Dir will follow symlinks pointing out of the directory tree, which can be especially dangerous if serving from a directory in which users are able to create arbitrary symlinks. Dir will also allow access to files and directories starting with a period, which could expose sensitive directories like .git or sensitive files like .htpasswd. To exclude files with a leading period, remove the files/directories from the server or create a custom FileSystem implementation. \n\nAn empty Dir is treated as \".\". \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#Dir.Open",
                    "documentation": {
                      "identifier": "Dir.Open",
                      "newPage": false,
                      "searchKey": "http.Dir.Open",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d Dir) Open(name string) (File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d Dir) Open(name string) (File, error)\n```\n\nOpen implements FileSystem using os.Open, opening files for reading rooted and relative to the directory d. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#File",
              "documentation": {
                "identifier": "File",
                "newPage": false,
                "searchKey": "http.File",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type File interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype File interface {\n\tio.Closer\n\tio.Reader\n\tio.Seeker\n\tReaddir(count int) ([]fs.FileInfo, error)\n\tStat() (fs.FileInfo, error)\n}\n```\n\nA File is returned by a FileSystem's Open method and can be served by the FileServer implementation. \n\nThe methods should behave the same as those on an *os.File. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#FileSystem",
              "documentation": {
                "identifier": "FileSystem",
                "newPage": false,
                "searchKey": "http.FileSystem",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type FileSystem interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FileSystem interface {\n\tOpen(name string) (File, error)\n}\n```\n\nA FileSystem implements access to a collection of named files. The elements in a file path are separated by slash ('/', U+002F) characters, regardless of host operating system convention. See the FileServer function to convert a FileSystem to a Handler. \n\nThis interface predates the fs.FS interface, which can be used instead: the FS adapter function converts an fs.FS to a FileSystem. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#FS",
                    "documentation": {
                      "identifier": "FS",
                      "newPage": false,
                      "searchKey": "http.FS",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FS(fsys fs.FS) FileSystem"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FS(fsys fs.FS) FileSystem\n```\n\nFS converts fsys to a FileSystem implementation, for use with FileServer and NewFileTransport. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#Flusher",
              "documentation": {
                "identifier": "Flusher",
                "newPage": false,
                "searchKey": "http.Flusher",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Flusher interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Flusher interface {\n\t// Flush sends any buffered data to the client.\n\tFlush()\n}\n```\n\nThe Flusher interface is implemented by ResponseWriters that allow an HTTP handler to flush buffered data to the client. \n\nThe default HTTP/1.x and HTTP/2 ResponseWriter implementations support Flusher, but ResponseWriter wrappers may not. Handlers should always test for this ability at runtime. \n\nNote that even for ResponseWriters that support Flush, if the client is connected through an HTTP proxy, the buffered data may not reach the client until the response completes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#Handler",
              "documentation": {
                "identifier": "Handler",
                "newPage": false,
                "searchKey": "http.Handler",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Handler interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Handler interface {\n\tServeHTTP(ResponseWriter, *Request)\n}\n```\n\nA Handler responds to an HTTP request. \n\nServeHTTP should write reply headers and data to the ResponseWriter and then return. Returning signals that the request is finished; it is not valid to use the ResponseWriter or read from the Request.Body after or concurrently with the completion of the ServeHTTP call. \n\nDepending on the HTTP client software, HTTP protocol version, and any intermediaries between the client and the Go server, it may not be possible to read from the Request.Body after writing to the ResponseWriter. Cautious handlers should read the Request.Body first, and then reply. \n\nExcept for reading the body, handlers should not modify the provided Request. \n\nIf ServeHTTP panics, the server (the caller of ServeHTTP) assumes that the effect of the panic was isolated to the active request. It recovers the panic, logs a stack trace to the server error log, and either closes the network connection or sends an HTTP/2 RST_STREAM, depending on the HTTP protocol. To abort a handler so the client sees an interrupted response but the server doesn't log an error, panic with the value ErrAbortHandler. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#AllowQuerySemicolons",
                    "documentation": {
                      "identifier": "AllowQuerySemicolons",
                      "newPage": false,
                      "searchKey": "http.AllowQuerySemicolons",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func AllowQuerySemicolons(h Handler) Handler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc AllowQuerySemicolons(h Handler) Handler\n```\n\nAllowQuerySemicolons returns a handler that serves requests by converting any unescaped semicolons in the URL query to ampersands, and invoking the handler h. \n\nThis restores the pre-Go 1.17 behavior of splitting query parameters on both semicolons and ampersands. (See golang.org/issue/25192). Note that this behavior doesn't match that of many proxies, and the mismatch can lead to security issues. \n\nAllowQuerySemicolons should be invoked before Request.ParseForm is called. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#FileServer",
                    "documentation": {
                      "identifier": "FileServer",
                      "newPage": false,
                      "searchKey": "http.FileServer",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FileServer(root FileSystem) Handler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FileServer(root FileSystem) Handler\n```\n\nFileServer returns a handler that serves HTTP requests with the contents of the file system rooted at root. \n\nAs a special case, the returned file server redirects any request ending in \"/index.html\" to the same path, without the final \"index.html\". \n\nTo use the operating system's file system implementation, use http.Dir: \n\n```\nhttp.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\n```\nTo use an fs.FS implementation, use http.FS to convert it: \n\n```\nhttp.Handle(\"/\", http.FileServer(http.FS(fsys)))\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#NewTestTimeoutHandler",
                    "documentation": {
                      "identifier": "NewTestTimeoutHandler",
                      "newPage": false,
                      "searchKey": "http.NewTestTimeoutHandler",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewTestTimeoutHandler(handler Handler, ch <-chan time.Time) Handler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewTestTimeoutHandler(handler Handler, ch <-chan time.Time) Handler\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#NotFoundHandler",
                    "documentation": {
                      "identifier": "NotFoundHandler",
                      "newPage": false,
                      "searchKey": "http.NotFoundHandler",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NotFoundHandler() Handler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NotFoundHandler() Handler\n```\n\nNotFoundHandler returns a simple request handler that replies to each request with a `404 page not found' reply. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#RedirectHandler",
                    "documentation": {
                      "identifier": "RedirectHandler",
                      "newPage": false,
                      "searchKey": "http.RedirectHandler",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func RedirectHandler(url string, code int) Handler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc RedirectHandler(url string, code int) Handler\n```\n\nRedirectHandler returns a request handler that redirects each request it receives to the given url using the given status code. \n\nThe provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#StripPrefix",
                    "documentation": {
                      "identifier": "StripPrefix",
                      "newPage": false,
                      "searchKey": "http.StripPrefix",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func StripPrefix(prefix string, h Handler) Handler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc StripPrefix(prefix string, h Handler) Handler\n```\n\nStripPrefix returns a handler that serves HTTP requests by removing the given prefix from the request URL's Path (and RawPath if set) and invoking the handler h. StripPrefix handles a request for a path that doesn't begin with prefix by replying with an HTTP 404 not found error. The prefix must match exactly: if the prefix in the request contains escaped characters the reply is also an HTTP 404 not found error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#TimeoutHandler",
                    "documentation": {
                      "identifier": "TimeoutHandler",
                      "newPage": false,
                      "searchKey": "http.TimeoutHandler",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc TimeoutHandler(h Handler, dt time.Duration, msg string) Handler\n```\n\nTimeoutHandler returns a Handler that runs h with the given time limit. \n\nThe new Handler calls h.ServeHTTP to handle each request, but if a call runs for longer than its time limit, the handler responds with a 503 Service Unavailable error and the given message in its body. (If msg is empty, a suitable default message will be sent.) After such a timeout, writes by h to its ResponseWriter will return ErrHandlerTimeout. \n\nTimeoutHandler supports the Pusher interface but does not support the Hijacker or Flusher interfaces. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#HandlerFunc",
              "documentation": {
                "identifier": "HandlerFunc",
                "newPage": false,
                "searchKey": "http.HandlerFunc",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type HandlerFunc func(std/net/http.ResponseWriter, *std/net/http.Request)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype HandlerFunc func(ResponseWriter, *Request)\n```\n\nThe HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. If f is a function with the appropriate signature, HandlerFunc(f) is a Handler that calls f. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2new400Handler",
                    "documentation": {
                      "identifier": "http2new400Handler",
                      "newPage": false,
                      "searchKey": "http.http2new400Handler",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2new400Handler(err error) HandlerFunc"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2new400Handler(err error) HandlerFunc\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#HandlerFunc.ServeHTTP",
                    "documentation": {
                      "identifier": "HandlerFunc.ServeHTTP",
                      "newPage": false,
                      "searchKey": "http.HandlerFunc.ServeHTTP",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)\n```\n\nServeHTTP calls f(w, r). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#Header",
              "documentation": {
                "identifier": "Header",
                "newPage": false,
                "searchKey": "http.Header",
                "tags": [
                  "object"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Header map[string][]string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Header map[string][]string\n```\n\nA Header represents the key-value pairs in an HTTP header. \n\nThe keys should be in canonical form, as returned by CanonicalHeaderKey. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#cloneOrMakeHeader",
                    "documentation": {
                      "identifier": "cloneOrMakeHeader",
                      "newPage": false,
                      "searchKey": "http.cloneOrMakeHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cloneOrMakeHeader(hdr Header) Header"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cloneOrMakeHeader(hdr Header) Header\n```\n\ncloneOrMakeHeader invokes Header.Clone but if the result is nil, it'll instead make and return a non-nil Header. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#fixTrailer",
                    "documentation": {
                      "identifier": "fixTrailer",
                      "newPage": false,
                      "searchKey": "http.fixTrailer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func fixTrailer(header Header, chunked bool) (Header, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc fixTrailer(header Header, chunked bool) (Header, error)\n```\n\nParse the trailer header \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2cloneHeader",
                    "documentation": {
                      "identifier": "http2cloneHeader",
                      "newPage": false,
                      "searchKey": "http.http2cloneHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2cloneHeader(h Header) Header"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2cloneHeader(h Header) Header\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.Add",
                    "documentation": {
                      "identifier": "Header.Add",
                      "newPage": false,
                      "searchKey": "http.Header.Add",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) Add(key, value string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) Add(key, value string)\n```\n\nAdd adds the key, value pair to the header. It appends to any existing values associated with key. The key is case insensitive; it is canonicalized by CanonicalHeaderKey. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.Clone",
                    "documentation": {
                      "identifier": "Header.Clone",
                      "newPage": false,
                      "searchKey": "http.Header.Clone",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) Clone() Header"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) Clone() Header\n```\n\nClone returns a copy of h or nil if h is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.Del",
                    "documentation": {
                      "identifier": "Header.Del",
                      "newPage": false,
                      "searchKey": "http.Header.Del",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) Del(key string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) Del(key string)\n```\n\nDel deletes the values associated with key. The key is case insensitive; it is canonicalized by CanonicalHeaderKey. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.Get",
                    "documentation": {
                      "identifier": "Header.Get",
                      "newPage": false,
                      "searchKey": "http.Header.Get",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) Get(key string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) Get(key string) string\n```\n\nGet gets the first value associated with the given key. If there are no values associated with the key, Get returns \"\". It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.Set",
                    "documentation": {
                      "identifier": "Header.Set",
                      "newPage": false,
                      "searchKey": "http.Header.Set",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) Set(key, value string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) Set(key, value string)\n```\n\nSet sets the header entries associated with key to the single element value. It replaces any existing values associated with key. The key is case insensitive; it is canonicalized by textproto.CanonicalMIMEHeaderKey. To use non-canonical keys, assign to the map directly. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.Values",
                    "documentation": {
                      "identifier": "Header.Values",
                      "newPage": false,
                      "searchKey": "http.Header.Values",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) Values(key string) []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) Values(key string) []string\n```\n\nValues returns all values associated with the given key. It is case insensitive; textproto.CanonicalMIMEHeaderKey is used to canonicalize the provided key. To use non-canonical keys, access the map directly. The returned slice is not a copy. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.Write",
                    "documentation": {
                      "identifier": "Header.Write",
                      "newPage": false,
                      "searchKey": "http.Header.Write",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) Write(w io.Writer) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) Write(w io.Writer) error\n```\n\nWrite writes a header in wire format. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.WriteSubset",
                    "documentation": {
                      "identifier": "Header.WriteSubset",
                      "newPage": false,
                      "searchKey": "http.Header.WriteSubset",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error\n```\n\nWriteSubset writes a header in wire format. If exclude is not nil, keys where exclude[key] == true are not written. Keys are not canonicalized before checking the exclude map. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.get",
                    "documentation": {
                      "identifier": "Header.get",
                      "newPage": false,
                      "searchKey": "http.Header.get",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) get(key string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) get(key string) string\n```\n\nget is like Get, but key must already be in CanonicalHeaderKey form. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.has",
                    "documentation": {
                      "identifier": "Header.has",
                      "newPage": false,
                      "searchKey": "http.Header.has",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) has(key string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) has(key string) bool\n```\n\nhas reports whether h has the provided key defined, even if it's set to 0-length slice. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.sortedKeyValues",
                    "documentation": {
                      "identifier": "Header.sortedKeyValues",
                      "newPage": false,
                      "searchKey": "http.Header.sortedKeyValues",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) sortedKeyValues(exclude map[string]bool) (kvs []keyValues, hs *headerSorter)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) sortedKeyValues(exclude map[string]bool) (kvs []keyValues, hs *headerSorter)\n```\n\nsortedKeyValues returns h's keys sorted in the returned kvs slice. The headerSorter used to sort is also returned, for possible return to headerSorterCache. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.write",
                    "documentation": {
                      "identifier": "Header.write",
                      "newPage": false,
                      "searchKey": "http.Header.write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) write(w io.Writer, trace *httptrace.ClientTrace) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) write(w io.Writer, trace *httptrace.ClientTrace) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Header.writeSubset",
                    "documentation": {
                      "identifier": "Header.writeSubset",
                      "newPage": false,
                      "searchKey": "http.Header.writeSubset",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) writeSubset(w io.Writer, exclude map[string]bool, trace *httptrace.ClientTrace) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) writeSubset(w io.Writer, exclude map[string]bool, trace *httptrace.ClientTrace) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#Hijacker",
              "documentation": {
                "identifier": "Hijacker",
                "newPage": false,
                "searchKey": "http.Hijacker",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Hijacker interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Hijacker interface {\n\t// Hijack lets the caller take over the connection.\n\t// After a call to Hijack the HTTP server library\n\t// will not do anything else with the connection.\n\t//\n\t// It becomes the caller's responsibility to manage\n\t// and close the connection.\n\t//\n\t// The returned net.Conn may have read or write deadlines\n\t// already set, depending on the configuration of the\n\t// Server. It is the caller's responsibility to set\n\t// or clear those deadlines as needed.\n\t//\n\t// The returned bufio.Reader may contain unprocessed buffered\n\t// data from the client.\n\t//\n\t// After a call to Hijack, the original Request.Body must not\n\t// be used. The original Request's Context remains valid and\n\t// is not canceled until the Request's ServeHTTP method\n\t// returns.\n\tHijack() (net.Conn, *bufio.ReadWriter, error)\n}\n```\n\nThe Hijacker interface is implemented by ResponseWriters that allow an HTTP handler to take over the connection. \n\nThe default ResponseWriter for HTTP/1.x connections supports Hijacker, but HTTP/2 connections intentionally do not. ResponseWriter wrappers may also not support Hijacker. Handlers should always test for this ability at runtime. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ProtocolError",
              "documentation": {
                "identifier": "ProtocolError",
                "newPage": false,
                "searchKey": "http.ProtocolError",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ProtocolError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ProtocolError struct {\n\tErrorString string\n}\n```\n\nProtocolError represents an HTTP protocol error. \n\nDeprecated: Not all errors in the http package related to protocol errors are of type ProtocolError. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#ProtocolError.Error",
                    "documentation": {
                      "identifier": "ProtocolError.Error",
                      "newPage": false,
                      "searchKey": "http.ProtocolError.Error",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pe *ProtocolError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pe *ProtocolError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#PushOptions",
              "documentation": {
                "identifier": "PushOptions",
                "newPage": false,
                "searchKey": "http.PushOptions",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type PushOptions struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PushOptions struct {\n\t// Method specifies the HTTP method for the promised request.\n\t// If set, it must be \"GET\" or \"HEAD\". Empty means \"GET\".\n\tMethod string\n\n\t// Header specifies additional promised request headers. This cannot\n\t// include HTTP/2 pseudo header fields like \":path\" and \":scheme\",\n\t// which will be added automatically.\n\tHeader Header\n}\n```\n\nPushOptions describes options for Pusher.Push. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#Pusher",
              "documentation": {
                "identifier": "Pusher",
                "newPage": false,
                "searchKey": "http.Pusher",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Pusher interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Pusher interface {\n\t// Push initiates an HTTP/2 server push. This constructs a synthetic\n\t// request using the given target and options, serializes that request\n\t// into a PUSH_PROMISE frame, then dispatches that request using the\n\t// server's request handler. If opts is nil, default options are used.\n\t//\n\t// The target must either be an absolute path (like \"/path\") or an absolute\n\t// URL that contains a valid host and the same scheme as the parent request.\n\t// If the target is a path, it will inherit the scheme and host of the\n\t// parent request.\n\t//\n\t// The HTTP/2 spec disallows recursive pushes and cross-authority pushes.\n\t// Push may or may not detect these invalid pushes; however, invalid\n\t// pushes will be detected and canceled by conforming clients.\n\t//\n\t// Handlers that wish to push URL X should call Push before sending any\n\t// data that may trigger a request for URL X. This avoids a race where the\n\t// client issues requests for X before receiving the PUSH_PROMISE for X.\n\t//\n\t// Push will run in a separate goroutine making the order of arrival\n\t// non-deterministic. Any required synchronization needs to be implemented\n\t// by the caller.\n\t//\n\t// Push returns ErrNotSupported if the client has disabled push or if push\n\t// is not supported on the underlying connection.\n\tPush(target string, opts *PushOptions) error\n}\n```\n\nPusher is the interface implemented by ResponseWriters that support HTTP/2 server push. For more background, see [https://tools.ietf.org/html/rfc7540#section-8.2](https://tools.ietf.org/html/rfc7540#section-8.2). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#Request",
              "documentation": {
                "identifier": "Request",
                "newPage": false,
                "searchKey": "http.Request",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Request struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Request struct {\n\t// Method specifies the HTTP method (GET, POST, PUT, etc.).\n\t// For client requests, an empty string means GET.\n\t//\n\t// Go's HTTP client does not support sending a request with\n\t// the CONNECT method. See the documentation on Transport for\n\t// details.\n\tMethod string\n\n\t// URL specifies either the URI being requested (for server\n\t// requests) or the URL to access (for client requests).\n\t//\n\t// For server requests, the URL is parsed from the URI\n\t// supplied on the Request-Line as stored in RequestURI.  For\n\t// most requests, fields other than Path and RawQuery will be\n\t// empty. (See RFC 7230, Section 5.3)\n\t//\n\t// For client requests, the URL's Host specifies the server to\n\t// connect to, while the Request's Host field optionally\n\t// specifies the Host header value to send in the HTTP\n\t// request.\n\tURL *url.URL\n\n\t// The protocol version for incoming server requests.\n\t//\n\t// For client requests, these fields are ignored. The HTTP\n\t// client code always uses either HTTP/1.1 or HTTP/2.\n\t// See the docs on Transport for details.\n\tProto      string // \"HTTP/1.0\"\n\tProtoMajor int    // 1\n\tProtoMinor int    // 0\n\n\t// Header contains the request header fields either received\n\t// by the server or to be sent by the client.\n\t//\n\t// If a server received a request with header lines,\n\t//\n\t//\tHost: example.com\n\t//\taccept-encoding: gzip, deflate\n\t//\tAccept-Language: en-us\n\t//\tfOO: Bar\n\t//\tfoo: two\n\t//\n\t// then\n\t//\n\t//\tHeader = map[string][]string{\n\t//\t\t\"Accept-Encoding\": {\"gzip, deflate\"},\n\t//\t\t\"Accept-Language\": {\"en-us\"},\n\t//\t\t\"Foo\": {\"Bar\", \"two\"},\n\t//\t}\n\t//\n\t// For incoming requests, the Host header is promoted to the\n\t// Request.Host field and removed from the Header map.\n\t//\n\t// HTTP defines that header names are case-insensitive. The\n\t// request parser implements this by using CanonicalHeaderKey,\n\t// making the first character and any characters following a\n\t// hyphen uppercase and the rest lowercase.\n\t//\n\t// For client requests, certain headers such as Content-Length\n\t// and Connection are automatically written when needed and\n\t// values in Header may be ignored. See the documentation\n\t// for the Request.Write method.\n\tHeader Header\n\n\t// Body is the request's body.\n\t//\n\t// For client requests, a nil body means the request has no\n\t// body, such as a GET request. The HTTP Client's Transport\n\t// is responsible for calling the Close method.\n\t//\n\t// For server requests, the Request Body is always non-nil\n\t// but will return EOF immediately when no body is present.\n\t// The Server will close the request body. The ServeHTTP\n\t// Handler does not need to.\n\t//\n\t// Body must allow Read to be called concurrently with Close.\n\t// In particular, calling Close should unblock a Read waiting\n\t// for input.\n\tBody io.ReadCloser\n\n\t// GetBody defines an optional func to return a new copy of\n\t// Body. It is used for client requests when a redirect requires\n\t// reading the body more than once. Use of GetBody still\n\t// requires setting Body.\n\t//\n\t// For server requests, it is unused.\n\tGetBody func() (io.ReadCloser, error)\n\n\t// ContentLength records the length of the associated content.\n\t// The value -1 indicates that the length is unknown.\n\t// Values >= 0 indicate that the given number of bytes may\n\t// be read from Body.\n\t//\n\t// For client requests, a value of 0 with a non-nil Body is\n\t// also treated as unknown.\n\tContentLength int64\n\n\t// TransferEncoding lists the transfer encodings from outermost to\n\t// innermost. An empty list denotes the \"identity\" encoding.\n\t// TransferEncoding can usually be ignored; chunked encoding is\n\t// automatically added and removed as necessary when sending and\n\t// receiving requests.\n\tTransferEncoding []string\n\n\t// Close indicates whether to close the connection after\n\t// replying to this request (for servers) or after sending this\n\t// request and reading its response (for clients).\n\t//\n\t// For server requests, the HTTP server handles this automatically\n\t// and this field is not needed by Handlers.\n\t//\n\t// For client requests, setting this field prevents re-use of\n\t// TCP connections between requests to the same hosts, as if\n\t// Transport.DisableKeepAlives were set.\n\tClose bool\n\n\t// For server requests, Host specifies the host on which the\n\t// URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this\n\t// is either the value of the \"Host\" header or the host name\n\t// given in the URL itself. For HTTP/2, it is the value of the\n\t// \":authority\" pseudo-header field.\n\t// It may be of the form \"host:port\". For international domain\n\t// names, Host may be in Punycode or Unicode form. Use\n\t// golang.org/x/net/idna to convert it to either format if\n\t// needed.\n\t// To prevent DNS rebinding attacks, server Handlers should\n\t// validate that the Host header has a value for which the\n\t// Handler considers itself authoritative. The included\n\t// ServeMux supports patterns registered to particular host\n\t// names and thus protects its registered Handlers.\n\t//\n\t// For client requests, Host optionally overrides the Host\n\t// header to send. If empty, the Request.Write method uses\n\t// the value of URL.Host. Host may contain an international\n\t// domain name.\n\tHost string\n\n\t// Form contains the parsed form data, including both the URL\n\t// field's query parameters and the PATCH, POST, or PUT form data.\n\t// This field is only available after ParseForm is called.\n\t// The HTTP client ignores Form and uses Body instead.\n\tForm url.Values\n\n\t// PostForm contains the parsed form data from PATCH, POST\n\t// or PUT body parameters.\n\t//\n\t// This field is only available after ParseForm is called.\n\t// The HTTP client ignores PostForm and uses Body instead.\n\tPostForm url.Values\n\n\t// MultipartForm is the parsed multipart form, including file uploads.\n\t// This field is only available after ParseMultipartForm is called.\n\t// The HTTP client ignores MultipartForm and uses Body instead.\n\tMultipartForm *multipart.Form\n\n\t// Trailer specifies additional headers that are sent after the request\n\t// body.\n\t//\n\t// For server requests, the Trailer map initially contains only the\n\t// trailer keys, with nil values. (The client declares which trailers it\n\t// will later send.)  While the handler is reading from Body, it must\n\t// not reference Trailer. After reading from Body returns EOF, Trailer\n\t// can be read again and will contain non-nil values, if they were sent\n\t// by the client.\n\t//\n\t// For client requests, Trailer must be initialized to a map containing\n\t// the trailer keys to later send. The values may be nil or their final\n\t// values. The ContentLength must be 0 or -1, to send a chunked request.\n\t// After the HTTP request is sent the map values can be updated while\n\t// the request body is read. Once the body returns EOF, the caller must\n\t// not mutate Trailer.\n\t//\n\t// Few HTTP clients, servers, or proxies support HTTP trailers.\n\tTrailer Header\n\n\t// RemoteAddr allows HTTP servers and other software to record\n\t// the network address that sent the request, usually for\n\t// logging. This field is not filled in by ReadRequest and\n\t// has no defined format. The HTTP server in this package\n\t// sets RemoteAddr to an \"IP:port\" address before invoking a\n\t// handler.\n\t// This field is ignored by the HTTP client.\n\tRemoteAddr string\n\n\t// RequestURI is the unmodified request-target of the\n\t// Request-Line (RFC 7230, Section 3.1.1) as sent by the client\n\t// to a server. Usually the URL field should be used instead.\n\t// It is an error to set this field in an HTTP client request.\n\tRequestURI string\n\n\t// TLS allows HTTP servers and other software to record\n\t// information about the TLS connection on which the request\n\t// was received. This field is not filled in by ReadRequest.\n\t// The HTTP server in this package sets the field for\n\t// TLS-enabled connections before invoking a handler;\n\t// otherwise it leaves the field nil.\n\t// This field is ignored by the HTTP client.\n\tTLS *tls.ConnectionState\n\n\t// Cancel is an optional channel whose closure indicates that the client\n\t// request should be regarded as canceled. Not all implementations of\n\t// RoundTripper may support Cancel.\n\t//\n\t// For server requests, this field is not applicable.\n\t//\n\t// Deprecated: Set the Request's context with NewRequestWithContext\n\t// instead. If a Request's Cancel field and context are both\n\t// set, it is undefined whether Cancel is respected.\n\tCancel <-chan struct{}\n\n\t// Response is the redirect response which caused this request\n\t// to be created. This field is only populated during client\n\t// redirects.\n\tResponse *Response\n\n\t// ctx is either the client or server context. It should only\n\t// be modified via copying the whole Request using WithContext.\n\t// It is unexported to prevent people from using Context wrong\n\t// and mutating the contexts held by callers of the same request.\n\tctx context.Context\n}\n```\n\nA Request represents an HTTP request received by a server or to be sent by a client. \n\nThe field semantics differ slightly between client and server usage. In addition to the notes on the fields below, see the documentation for Request.Write and RoundTripper. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#NewRequest",
                    "documentation": {
                      "identifier": "NewRequest",
                      "newPage": false,
                      "searchKey": "http.NewRequest",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewRequest(method, url string, body io.Reader) (*Request, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewRequest(method, url string, body io.Reader) (*Request, error)\n```\n\nNewRequest wraps NewRequestWithContext using context.Background. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#NewRequestWithContext",
                    "documentation": {
                      "identifier": "NewRequestWithContext",
                      "newPage": false,
                      "searchKey": "http.NewRequestWithContext",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error)\n```\n\nNewRequestWithContext returns a new Request given a method, URL, and optional body. \n\nIf the provided body is also an io.Closer, the returned Request.Body is set to body and will be closed by the Client methods Do, Post, and PostForm, and Transport.RoundTrip. \n\nNewRequestWithContext returns a Request suitable for use with Client.Do or Transport.RoundTrip. To create a request for use with testing a Server Handler, either use the NewRequest function in the net/http/httptest package, use ReadRequest, or manually update the Request fields. For an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body. See the Request type's documentation for the difference between inbound and outbound request fields. \n\nIf body is of type *bytes.Buffer, *bytes.Reader, or *strings.Reader, the returned request's ContentLength is set to its exact value (instead of -1), GetBody is populated (so 307 and 308 redirects can replay the body), and Body is set to NoBody if the ContentLength is 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ReadRequest",
                    "documentation": {
                      "identifier": "ReadRequest",
                      "newPage": false,
                      "searchKey": "http.ReadRequest",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ReadRequest(b *bufio.Reader) (*Request, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ReadRequest(b *bufio.Reader) (*Request, error)\n```\n\nReadRequest reads and parses an incoming request from b. \n\nReadRequest is a low-level function and should only be used for specialized applications; most code should use the Server to read requests and handle them via the Handler interface. ReadRequest only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dummyReq",
                    "documentation": {
                      "identifier": "dummyReq",
                      "newPage": false,
                      "searchKey": "http.dummyReq",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func dummyReq(method string) *Request"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc dummyReq(method string) *Request\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dummyReq11",
                    "documentation": {
                      "identifier": "dummyReq11",
                      "newPage": false,
                      "searchKey": "http.dummyReq11",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func dummyReq11(method string) *Request"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc dummyReq11(method string) *Request\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dummyRequest",
                    "documentation": {
                      "identifier": "dummyRequest",
                      "newPage": false,
                      "searchKey": "http.dummyRequest",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func dummyRequest(method string) *Request"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc dummyRequest(method string) *Request\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dummyRequestWithBody",
                    "documentation": {
                      "identifier": "dummyRequestWithBody",
                      "newPage": false,
                      "searchKey": "http.dummyRequestWithBody",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func dummyRequestWithBody(method string) *Request"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc dummyRequestWithBody(method string) *Request\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dummyRequestWithBodyNoGetBody",
                    "documentation": {
                      "identifier": "dummyRequestWithBodyNoGetBody",
                      "newPage": false,
                      "searchKey": "http.dummyRequestWithBodyNoGetBody",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func dummyRequestWithBodyNoGetBody(method string) *Request"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc dummyRequestWithBodyNoGetBody(method string) *Request\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2shouldRetryRequest",
                    "documentation": {
                      "identifier": "http2shouldRetryRequest",
                      "newPage": false,
                      "searchKey": "http.http2shouldRetryRequest",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2shouldRetryRequest(req *Request, err error, afterBodyWrite bool) (*Request, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2shouldRetryRequest(req *Request, err error, afterBodyWrite bool) (*Request, error)\n```\n\nshouldRetryRequest is called by RoundTrip when a request fails to get response headers. It is always called with a non-nil error. It returns either a request to retry (either the same request, or a modified clone), or an error if the request can't be replayed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#readRequest",
                    "documentation": {
                      "identifier": "readRequest",
                      "newPage": false,
                      "searchKey": "http.readRequest",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func readRequest(b *bufio.Reader) (req *Request, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc readRequest(b *bufio.Reader) (req *Request, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#rewindBody",
                    "documentation": {
                      "identifier": "rewindBody",
                      "newPage": false,
                      "searchKey": "http.rewindBody",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func rewindBody(req *Request) (rewound *Request, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc rewindBody(req *Request) (rewound *Request, err error)\n```\n\nrewindBody returns a new request with the body rewound. It returns req unmodified if the body does not need rewinding. rewindBody takes care of closing req.Body when appropriate (in all cases except when rewindBody returns req unmodified). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#setupRewindBody",
                    "documentation": {
                      "identifier": "setupRewindBody",
                      "newPage": false,
                      "searchKey": "http.setupRewindBody",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func setupRewindBody(req *Request) *Request"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc setupRewindBody(req *Request) *Request\n```\n\nsetupRewindBody returns a new request with a custom body wrapper that can report whether the body needs rewinding. This lets rewindBody avoid an error result when the request does not have GetBody but the body hasn't been read at all yet. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.AddCookie",
                    "documentation": {
                      "identifier": "Request.AddCookie",
                      "newPage": false,
                      "searchKey": "http.Request.AddCookie",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) AddCookie(c *Cookie)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) AddCookie(c *Cookie)\n```\n\nAddCookie adds a cookie to the request. Per RFC 6265 section 5.4, AddCookie does not attach more than one Cookie header field. That means all cookies, if any, are written into the same line, separated by semicolon. AddCookie only sanitizes c's name and value, and does not sanitize a Cookie header already present in the request. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.BasicAuth",
                    "documentation": {
                      "identifier": "Request.BasicAuth",
                      "newPage": false,
                      "searchKey": "http.Request.BasicAuth",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) BasicAuth() (username, password string, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) BasicAuth() (username, password string, ok bool)\n```\n\nBasicAuth returns the username and password provided in the request's Authorization header, if the request uses HTTP Basic Authentication. See RFC 2617, Section 2. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.Clone",
                    "documentation": {
                      "identifier": "Request.Clone",
                      "newPage": false,
                      "searchKey": "http.Request.Clone",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) Clone(ctx context.Context) *Request"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) Clone(ctx context.Context) *Request\n```\n\nClone returns a deep copy of r with its context changed to ctx. The provided ctx must be non-nil. \n\nFor an outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.Context",
                    "documentation": {
                      "identifier": "Request.Context",
                      "newPage": false,
                      "searchKey": "http.Request.Context",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) Context() context.Context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) Context() context.Context\n```\n\nContext returns the request's context. To change the context, use WithContext. \n\nThe returned context is always non-nil; it defaults to the background context. \n\nFor outgoing client requests, the context controls cancellation. \n\nFor incoming server requests, the context is canceled when the client's connection closes, the request is canceled (with HTTP/2), or when the ServeHTTP method returns. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.Cookie",
                    "documentation": {
                      "identifier": "Request.Cookie",
                      "newPage": false,
                      "searchKey": "http.Request.Cookie",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) Cookie(name string) (*Cookie, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) Cookie(name string) (*Cookie, error)\n```\n\nCookie returns the named cookie provided in the request or ErrNoCookie if not found. If multiple cookies match the given name, only one cookie will be returned. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.Cookies",
                    "documentation": {
                      "identifier": "Request.Cookies",
                      "newPage": false,
                      "searchKey": "http.Request.Cookies",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) Cookies() []*Cookie"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) Cookies() []*Cookie\n```\n\nCookies parses and returns the HTTP cookies sent with the request. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.ExportIsReplayable",
                    "documentation": {
                      "identifier": "Request.ExportIsReplayable",
                      "newPage": false,
                      "searchKey": "http.Request.ExportIsReplayable",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) ExportIsReplayable() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) ExportIsReplayable() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.FormFile",
                    "documentation": {
                      "identifier": "Request.FormFile",
                      "newPage": false,
                      "searchKey": "http.Request.FormFile",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)\n```\n\nFormFile returns the first file for the provided form key. FormFile calls ParseMultipartForm and ParseForm if necessary. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.FormValue",
                    "documentation": {
                      "identifier": "Request.FormValue",
                      "newPage": false,
                      "searchKey": "http.Request.FormValue",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) FormValue(key string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) FormValue(key string) string\n```\n\nFormValue returns the first value for the named component of the query. POST and PUT body parameters take precedence over URL query string values. FormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, FormValue returns the empty string. To access multiple values of the same key, call ParseForm and then inspect Request.Form directly. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.MultipartReader",
                    "documentation": {
                      "identifier": "Request.MultipartReader",
                      "newPage": false,
                      "searchKey": "http.Request.MultipartReader",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) MultipartReader() (*multipart.Reader, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) MultipartReader() (*multipart.Reader, error)\n```\n\nMultipartReader returns a MIME multipart reader if this is a multipart/form-data or a multipart/mixed POST request, else returns nil and an error. Use this function instead of ParseMultipartForm to process the request body as a stream. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.ParseForm",
                    "documentation": {
                      "identifier": "Request.ParseForm",
                      "newPage": false,
                      "searchKey": "http.Request.ParseForm",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) ParseForm() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) ParseForm() error\n```\n\nParseForm populates r.Form and r.PostForm. \n\nFor all requests, ParseForm parses the raw query from the URL and updates r.Form. \n\nFor POST, PUT, and PATCH requests, it also reads the request body, parses it as a form and puts the results into both r.PostForm and r.Form. Request body parameters take precedence over URL query string values in r.Form. \n\nIf the request Body's size has not already been limited by MaxBytesReader, the size is capped at 10MB. \n\nFor other HTTP methods, or when the Content-Type is not application/x-www-form-urlencoded, the request Body is not read, and r.PostForm is initialized to a non-nil, empty value. \n\nParseMultipartForm calls ParseForm automatically. ParseForm is idempotent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.ParseMultipartForm",
                    "documentation": {
                      "identifier": "Request.ParseMultipartForm",
                      "newPage": false,
                      "searchKey": "http.Request.ParseMultipartForm",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) ParseMultipartForm(maxMemory int64) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) ParseMultipartForm(maxMemory int64) error\n```\n\nParseMultipartForm parses a request body as multipart/form-data. The whole request body is parsed and up to a total of maxMemory bytes of its file parts are stored in memory, with the remainder stored on disk in temporary files. ParseMultipartForm calls ParseForm if necessary. If ParseForm returns an error, ParseMultipartForm returns it but also continues parsing the request body. After one call to ParseMultipartForm, subsequent calls have no effect. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.PostFormValue",
                    "documentation": {
                      "identifier": "Request.PostFormValue",
                      "newPage": false,
                      "searchKey": "http.Request.PostFormValue",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) PostFormValue(key string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) PostFormValue(key string) string\n```\n\nPostFormValue returns the first value for the named component of the POST, PATCH, or PUT request body. URL query parameters are ignored. PostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores any errors returned by these functions. If key is not present, PostFormValue returns the empty string. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.ProtoAtLeast",
                    "documentation": {
                      "identifier": "Request.ProtoAtLeast",
                      "newPage": false,
                      "searchKey": "http.Request.ProtoAtLeast",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) ProtoAtLeast(major, minor int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) ProtoAtLeast(major, minor int) bool\n```\n\nProtoAtLeast reports whether the HTTP protocol used in the request is at least major.minor. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.Referer",
                    "documentation": {
                      "identifier": "Request.Referer",
                      "newPage": false,
                      "searchKey": "http.Request.Referer",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) Referer() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) Referer() string\n```\n\nReferer returns the referring URL, if sent in the request. \n\nReferer is misspelled as in the request itself, a mistake from the earliest days of HTTP.  This value can also be fetched from the Header map as Header[\"Referer\"]; the benefit of making it available as a method is that the compiler can diagnose programs that use the alternate (correct English) spelling req.Referrer() but cannot diagnose programs that use Header[\"Referrer\"]. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.SetBasicAuth",
                    "documentation": {
                      "identifier": "Request.SetBasicAuth",
                      "newPage": false,
                      "searchKey": "http.Request.SetBasicAuth",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) SetBasicAuth(username, password string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) SetBasicAuth(username, password string)\n```\n\nSetBasicAuth sets the request's Authorization header to use HTTP Basic Authentication with the provided username and password. \n\nWith HTTP Basic Authentication the provided username and password are not encrypted. \n\nSome protocols may impose additional requirements on pre-escaping the username and password. For instance, when used with OAuth2, both arguments must be URL encoded first with url.QueryEscape. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.UserAgent",
                    "documentation": {
                      "identifier": "Request.UserAgent",
                      "newPage": false,
                      "searchKey": "http.Request.UserAgent",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) UserAgent() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) UserAgent() string\n```\n\nUserAgent returns the client's User-Agent, if sent in the request. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.WithContext",
                    "documentation": {
                      "identifier": "Request.WithContext",
                      "newPage": false,
                      "searchKey": "http.Request.WithContext",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) WithContext(ctx context.Context) *Request"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) WithContext(ctx context.Context) *Request\n```\n\nWithContext returns a shallow copy of r with its context changed to ctx. The provided ctx must be non-nil. \n\nFor outgoing client request, the context controls the entire lifetime of a request and its response: obtaining a connection, sending the request, and reading the response headers and body. \n\nTo create a new request with a context, use NewRequestWithContext. To change the context of a request, such as an incoming request you want to modify before sending back out, use Request.Clone. Between those two uses, it's rare to need WithContext. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.WithT",
                    "documentation": {
                      "identifier": "Request.WithT",
                      "newPage": false,
                      "searchKey": "http.Request.WithT",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) WithT(t *testing.T) *Request"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) WithT(t *testing.T) *Request\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.Write",
                    "documentation": {
                      "identifier": "Request.Write",
                      "newPage": false,
                      "searchKey": "http.Request.Write",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) Write(w io.Writer) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) Write(w io.Writer) error\n```\n\nWrite writes an HTTP/1.1 request, which is the header and body, in wire format. This method consults the following fields of the request: \n\n```\nHost\nURL\nMethod (defaults to \"GET\")\nHeader\nContentLength\nTransferEncoding\nBody\n\n```\nIf Body is present, Content-Length is <= 0 and TransferEncoding hasn't been set to \"identity\", Write adds \"Transfer-Encoding: chunked\" to the header. Body is closed after it is sent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.WriteProxy",
                    "documentation": {
                      "identifier": "Request.WriteProxy",
                      "newPage": false,
                      "searchKey": "http.Request.WriteProxy",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) WriteProxy(w io.Writer) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) WriteProxy(w io.Writer) error\n```\n\nWriteProxy is like Write but writes the request in the form expected by an HTTP proxy. In particular, WriteProxy writes the initial Request-URI line of the request with an absolute URI, per section 5.3 of RFC 7230, including the scheme and host. In either case, WriteProxy also writes a Host header, using either r.Host or r.URL.Host. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.closeBody",
                    "documentation": {
                      "identifier": "Request.closeBody",
                      "newPage": false,
                      "searchKey": "http.Request.closeBody",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) closeBody() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) closeBody() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.expectsContinue",
                    "documentation": {
                      "identifier": "Request.expectsContinue",
                      "newPage": false,
                      "searchKey": "http.Request.expectsContinue",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) expectsContinue() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) expectsContinue() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.isH2Upgrade",
                    "documentation": {
                      "identifier": "Request.isH2Upgrade",
                      "newPage": false,
                      "searchKey": "http.Request.isH2Upgrade",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) isH2Upgrade() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) isH2Upgrade() bool\n```\n\nisH2Upgrade reports whether r represents the http2 \"client preface\" magic string. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.isReplayable",
                    "documentation": {
                      "identifier": "Request.isReplayable",
                      "newPage": false,
                      "searchKey": "http.Request.isReplayable",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) isReplayable() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) isReplayable() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.multipartReader",
                    "documentation": {
                      "identifier": "Request.multipartReader",
                      "newPage": false,
                      "searchKey": "http.Request.multipartReader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) multipartReader(allowMixed bool) (*multipart.Reader, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) multipartReader(allowMixed bool) (*multipart.Reader, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.outgoingLength",
                    "documentation": {
                      "identifier": "Request.outgoingLength",
                      "newPage": false,
                      "searchKey": "http.Request.outgoingLength",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) outgoingLength() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) outgoingLength() int64\n```\n\noutgoingLength reports the Content-Length of this outgoing (Client) request. It maps 0 into -1 (unknown) when the Body is non-nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.requiresHTTP1",
                    "documentation": {
                      "identifier": "Request.requiresHTTP1",
                      "newPage": false,
                      "searchKey": "http.Request.requiresHTTP1",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) requiresHTTP1() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) requiresHTTP1() bool\n```\n\nrequiresHTTP1 reports whether this request requires being sent on an HTTP/1 connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.wantsClose",
                    "documentation": {
                      "identifier": "Request.wantsClose",
                      "newPage": false,
                      "searchKey": "http.Request.wantsClose",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) wantsClose() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) wantsClose() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.wantsHttp10KeepAlive",
                    "documentation": {
                      "identifier": "Request.wantsHttp10KeepAlive",
                      "newPage": false,
                      "searchKey": "http.Request.wantsHttp10KeepAlive",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) wantsHttp10KeepAlive() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) wantsHttp10KeepAlive() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Request.write",
                    "documentation": {
                      "identifier": "Request.write",
                      "newPage": false,
                      "searchKey": "http.Request.write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Request) write(w io.Writer, usingProxy bool, extraHeaders Header, waitForContinue func() bool) (err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Request) write(w io.Writer, usingProxy bool, extraHeaders Header, waitForContinue func() bool) (err error)\n```\n\nextraHeaders may be nil waitForContinue may be nil always closes body \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#Response",
              "documentation": {
                "identifier": "Response",
                "newPage": false,
                "searchKey": "http.Response",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Response struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Response struct {\n\tStatus     string // e.g. \"200 OK\"\n\tStatusCode int    // e.g. 200\n\tProto      string // e.g. \"HTTP/1.0\"\n\tProtoMajor int    // e.g. 1\n\tProtoMinor int    // e.g. 0\n\n\t// Header maps header keys to values. If the response had multiple\n\t// headers with the same key, they may be concatenated, with comma\n\t// delimiters.  (RFC 7230, section 3.2.2 requires that multiple headers\n\t// be semantically equivalent to a comma-delimited sequence.) When\n\t// Header values are duplicated by other fields in this struct (e.g.,\n\t// ContentLength, TransferEncoding, Trailer), the field values are\n\t// authoritative.\n\t//\n\t// Keys in the map are canonicalized (see CanonicalHeaderKey).\n\tHeader Header\n\n\t// Body represents the response body.\n\t//\n\t// The response body is streamed on demand as the Body field\n\t// is read. If the network connection fails or the server\n\t// terminates the response, Body.Read calls return an error.\n\t//\n\t// The http Client and Transport guarantee that Body is always\n\t// non-nil, even on responses without a body or responses with\n\t// a zero-length body. It is the caller's responsibility to\n\t// close Body. The default HTTP client's Transport may not\n\t// reuse HTTP/1.x \"keep-alive\" TCP connections if the Body is\n\t// not read to completion and closed.\n\t//\n\t// The Body is automatically dechunked if the server replied\n\t// with a \"chunked\" Transfer-Encoding.\n\t//\n\t// As of Go 1.12, the Body will also implement io.Writer\n\t// on a successful \"101 Switching Protocols\" response,\n\t// as used by WebSockets and HTTP/2's \"h2c\" mode.\n\tBody io.ReadCloser\n\n\t// ContentLength records the length of the associated content. The\n\t// value -1 indicates that the length is unknown. Unless Request.Method\n\t// is \"HEAD\", values >= 0 indicate that the given number of bytes may\n\t// be read from Body.\n\tContentLength int64\n\n\t// Contains transfer encodings from outer-most to inner-most. Value is\n\t// nil, means that \"identity\" encoding is used.\n\tTransferEncoding []string\n\n\t// Close records whether the header directed that the connection be\n\t// closed after reading Body. The value is advice for clients: neither\n\t// ReadResponse nor Response.Write ever closes a connection.\n\tClose bool\n\n\t// Uncompressed reports whether the response was sent compressed but\n\t// was decompressed by the http package. When true, reading from\n\t// Body yields the uncompressed content instead of the compressed\n\t// content actually set from the server, ContentLength is set to -1,\n\t// and the \"Content-Length\" and \"Content-Encoding\" fields are deleted\n\t// from the responseHeader. To get the original response from\n\t// the server, set Transport.DisableCompression to true.\n\tUncompressed bool\n\n\t// Trailer maps trailer keys to values in the same\n\t// format as Header.\n\t//\n\t// The Trailer initially contains only nil values, one for\n\t// each key specified in the server's \"Trailer\" header\n\t// value. Those values are not added to Header.\n\t//\n\t// Trailer must not be accessed concurrently with Read calls\n\t// on the Body.\n\t//\n\t// After Body.Read has returned io.EOF, Trailer will contain\n\t// any trailer values sent by the server.\n\tTrailer Header\n\n\t// Request is the request that was sent to obtain this Response.\n\t// Request's Body is nil (having already been consumed).\n\t// This is only populated for Client requests.\n\tRequest *Request\n\n\t// TLS contains information about the TLS connection on which the\n\t// response was received. It is nil for unencrypted responses.\n\t// The pointer is shared between responses and should not be\n\t// modified.\n\tTLS *tls.ConnectionState\n}\n```\n\nResponse represents the response from an HTTP request. \n\nThe Client and Transport return Responses from servers once the response headers have been received. The response body is streamed on demand as the Body field is read. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#Get",
                    "documentation": {
                      "identifier": "Get",
                      "newPage": false,
                      "searchKey": "http.Get",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Get(url string) (resp *Response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Get(url string) (resp *Response, err error)\n```\n\nGet issues a GET to the specified URL. If the response is one of the following redirect codes, Get follows the redirect, up to a maximum of 10 redirects: \n\n```\n301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n308 (Permanent Redirect)\n\n```\nAn error is returned if there were too many redirects or if there was an HTTP protocol error. A non-2xx response doesn't cause an error. Any returned error will be of type *url.Error. The url.Error value's Timeout method will report true if the request timed out. \n\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. \n\nGet is a wrapper around DefaultClient.Get. \n\nTo make a request with custom headers, use NewRequest and DefaultClient.Do. \n\nTo make a request with a specified context.Context, use NewRequestWithContext and DefaultClient.Do. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Head",
                    "documentation": {
                      "identifier": "Head",
                      "newPage": false,
                      "searchKey": "http.Head",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Head(url string) (resp *Response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Head(url string) (resp *Response, err error)\n```\n\nHead issues a HEAD to the specified URL. If the response is one of the following redirect codes, Head follows the redirect, up to a maximum of 10 redirects: \n\n```\n301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n308 (Permanent Redirect)\n\n```\nHead is a wrapper around DefaultClient.Head \n\nTo make a request with a specified context.Context, use NewRequestWithContext and DefaultClient.Do. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Post",
                    "documentation": {
                      "identifier": "Post",
                      "newPage": false,
                      "searchKey": "http.Post",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Post(url, contentType string, body io.Reader) (resp *Response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Post(url, contentType string, body io.Reader) (resp *Response, err error)\n```\n\nPost issues a POST to the specified URL. \n\nCaller should close resp.Body when done reading from it. \n\nIf the provided body is an io.Closer, it is closed after the request. \n\nPost is a wrapper around DefaultClient.Post. \n\nTo set custom headers, use NewRequest and DefaultClient.Do. \n\nSee the Client.Do method documentation for details on how redirects are handled. \n\nTo make a request with a specified context.Context, use NewRequestWithContext and DefaultClient.Do. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#PostForm",
                    "documentation": {
                      "identifier": "PostForm",
                      "newPage": false,
                      "searchKey": "http.PostForm",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func PostForm(url string, data url.Values) (resp *Response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc PostForm(url string, data url.Values) (resp *Response, err error)\n```\n\nPostForm issues a POST to the specified URL, with data's keys and values URL-encoded as the request body. \n\nThe Content-Type header is set to application/x-www-form-urlencoded. To set other headers, use NewRequest and DefaultClient.Do. \n\nWhen err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. \n\nPostForm is a wrapper around DefaultClient.PostForm. \n\nSee the Client.Do method documentation for details on how redirects are handled. \n\nTo make a request with a specified context.Context, use NewRequestWithContext and DefaultClient.Do. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ReadResponse",
                    "documentation": {
                      "identifier": "ReadResponse",
                      "newPage": false,
                      "searchKey": "http.ReadResponse",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ReadResponse(r *bufio.Reader, req *Request) (*Response, error)\n```\n\nReadResponse reads and returns an HTTP response from r. The req parameter optionally specifies the Request that corresponds to this Response. If nil, a GET request is assumed. Clients must call resp.Body.Close when finished reading resp.Body. After that call, clients can inspect resp.Trailer to find key/value pairs included in the response trailer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#send",
                    "documentation": {
                      "identifier": "send",
                      "newPage": false,
                      "searchKey": "http.send",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func send(ireq *Request, rt RoundTripper, deadline time.Time) (resp *Response, didTimeout func() bool, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc send(ireq *Request, rt RoundTripper, deadline time.Time) (resp *Response, didTimeout func() bool, err error)\n```\n\nsend issues an HTTP request. Caller should close resp.Body when done reading from it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Response.Cookies",
                    "documentation": {
                      "identifier": "Response.Cookies",
                      "newPage": false,
                      "searchKey": "http.Response.Cookies",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Response) Cookies() []*Cookie"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Response) Cookies() []*Cookie\n```\n\nCookies parses and returns the cookies set in the Set-Cookie headers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Response.Location",
                    "documentation": {
                      "identifier": "Response.Location",
                      "newPage": false,
                      "searchKey": "http.Response.Location",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Response) Location() (*url.URL, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Response) Location() (*url.URL, error)\n```\n\nLocation returns the URL of the response's \"Location\" header, if present. Relative redirects are resolved relative to the Response's Request. ErrNoLocation is returned if no Location header is present. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Response.ProtoAtLeast",
                    "documentation": {
                      "identifier": "Response.ProtoAtLeast",
                      "newPage": false,
                      "searchKey": "http.Response.ProtoAtLeast",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Response) ProtoAtLeast(major, minor int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Response) ProtoAtLeast(major, minor int) bool\n```\n\nProtoAtLeast reports whether the HTTP protocol used in the response is at least major.minor. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Response.Write",
                    "documentation": {
                      "identifier": "Response.Write",
                      "newPage": false,
                      "searchKey": "http.Response.Write",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Response) Write(w io.Writer) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Response) Write(w io.Writer) error\n```\n\nWrite writes r to w in the HTTP/1.x server response format, including the status line, headers, body, and optional trailer. \n\nThis method consults the following fields of the response r: \n\n```\nStatusCode\nProtoMajor\nProtoMinor\nRequest.Method\nTransferEncoding\nTrailer\nBody\nContentLength\nHeader, values for non-canonical keys will have unpredictable behavior\n\n```\nThe Response Body is closed after it is sent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Response.bodyIsWritable",
                    "documentation": {
                      "identifier": "Response.bodyIsWritable",
                      "newPage": false,
                      "searchKey": "http.Response.bodyIsWritable",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Response) bodyIsWritable() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Response) bodyIsWritable() bool\n```\n\nbodyIsWritable reports whether the Body supports writing. The Transport returns Writable bodies for 101 Switching Protocols responses. The Transport uses this method to determine whether a persistent connection is done being managed from its perspective. Once we return a writable response body to a user, the net/http package is done managing that connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Response.closeBody",
                    "documentation": {
                      "identifier": "Response.closeBody",
                      "newPage": false,
                      "searchKey": "http.Response.closeBody",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Response) closeBody()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Response) closeBody()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Response.isProtocolSwitch",
                    "documentation": {
                      "identifier": "Response.isProtocolSwitch",
                      "newPage": false,
                      "searchKey": "http.Response.isProtocolSwitch",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Response) isProtocolSwitch() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Response) isProtocolSwitch() bool\n```\n\nisProtocolSwitch reports whether the response code and header indicate a successful protocol upgrade response. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#ResponseWriter",
              "documentation": {
                "identifier": "ResponseWriter",
                "newPage": false,
                "searchKey": "http.ResponseWriter",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ResponseWriter interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ResponseWriter interface {\n\t// Header returns the header map that will be sent by\n\t// WriteHeader. The Header map also is the mechanism with which\n\t// Handlers can set HTTP trailers.\n\t//\n\t// Changing the header map after a call to WriteHeader (or\n\t// Write) has no effect unless the modified headers are\n\t// trailers.\n\t//\n\t// There are two ways to set Trailers. The preferred way is to\n\t// predeclare in the headers which trailers you will later\n\t// send by setting the \"Trailer\" header to the names of the\n\t// trailer keys which will come later. In this case, those\n\t// keys of the Header map are treated as if they were\n\t// trailers. See the example. The second way, for trailer\n\t// keys not known to the Handler until after the first Write,\n\t// is to prefix the Header map keys with the TrailerPrefix\n\t// constant value. See TrailerPrefix.\n\t//\n\t// To suppress automatic response headers (such as \"Date\"), set\n\t// their value to nil.\n\tHeader() Header\n\n\t// Write writes the data to the connection as part of an HTTP reply.\n\t//\n\t// If WriteHeader has not yet been called, Write calls\n\t// WriteHeader(http.StatusOK) before writing the data. If the Header\n\t// does not contain a Content-Type line, Write adds a Content-Type set\n\t// to the result of passing the initial 512 bytes of written data to\n\t// DetectContentType. Additionally, if the total size of all written\n\t// data is under a few KB and there are no Flush calls, the\n\t// Content-Length header is added automatically.\n\t//\n\t// Depending on the HTTP protocol version and the client, calling\n\t// Write or WriteHeader may prevent future reads on the\n\t// Request.Body. For HTTP/1.x requests, handlers should read any\n\t// needed request body data before writing the response. Once the\n\t// headers have been flushed (due to either an explicit Flusher.Flush\n\t// call or writing enough data to trigger a flush), the request body\n\t// may be unavailable. For HTTP/2 requests, the Go HTTP server permits\n\t// handlers to continue to read the request body while concurrently\n\t// writing the response. However, such behavior may not be supported\n\t// by all HTTP/2 clients. Handlers should read before writing if\n\t// possible to maximize compatibility.\n\tWrite([]byte) (int, error)\n\n\t// WriteHeader sends an HTTP response header with the provided\n\t// status code.\n\t//\n\t// If WriteHeader is not called explicitly, the first call to Write\n\t// will trigger an implicit WriteHeader(http.StatusOK).\n\t// Thus explicit calls to WriteHeader are mainly used to\n\t// send error codes.\n\t//\n\t// The provided code must be a valid HTTP 1xx-5xx status code.\n\t// Only one header may be written. Go does not currently\n\t// support sending user-defined 1xx informational headers,\n\t// with the exception of 100-continue response header that the\n\t// Server sends automatically when the Request.Body is read.\n\tWriteHeader(statusCode int)\n}\n```\n\nA ResponseWriter interface is used by an HTTP handler to construct an HTTP response. \n\nA ResponseWriter may not be used after the Handler.ServeHTTP method has returned. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#RoundTripper",
              "documentation": {
                "identifier": "RoundTripper",
                "newPage": false,
                "searchKey": "http.RoundTripper",
                "tags": [
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RoundTripper interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RoundTripper interface {\n\t// RoundTrip executes a single HTTP transaction, returning\n\t// a Response for the provided Request.\n\t//\n\t// RoundTrip should not attempt to interpret the response. In\n\t// particular, RoundTrip must return err == nil if it obtained\n\t// a response, regardless of the response's HTTP status code.\n\t// A non-nil err should be reserved for failure to obtain a\n\t// response. Similarly, RoundTrip should not attempt to\n\t// handle higher-level protocol details such as redirects,\n\t// authentication, or cookies.\n\t//\n\t// RoundTrip should not modify the request, except for\n\t// consuming and closing the Request's Body. RoundTrip may\n\t// read fields of the request in a separate goroutine. Callers\n\t// should not mutate or reuse the request until the Response's\n\t// Body has been closed.\n\t//\n\t// RoundTrip must always close the body, including on errors,\n\t// but depending on the implementation may do so in a separate\n\t// goroutine even after RoundTrip returns. This means that\n\t// callers wanting to reuse the body for subsequent requests\n\t// must arrange to wait for the Close call before doing so.\n\t//\n\t// The Request's URL and Header fields must be initialized.\n\tRoundTrip(*Request) (*Response, error)\n}\n```\n\nRoundTripper is an interface representing the ability to execute a single HTTP transaction, obtaining the Response for a given Request. \n\nA RoundTripper must be safe for concurrent use by multiple goroutines. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#NewFileTransport",
                    "documentation": {
                      "identifier": "NewFileTransport",
                      "newPage": false,
                      "searchKey": "http.NewFileTransport",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewFileTransport(fs FileSystem) RoundTripper"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewFileTransport(fs FileSystem) RoundTripper\n```\n\nNewFileTransport returns a new RoundTripper, serving the provided FileSystem. The returned RoundTripper ignores the URL host in its incoming requests, as well as most other properties of the request. \n\nThe typical use case for NewFileTransport is to register the \"file\" protocol with a Transport, as in: \n\n```\nt := &http.Transport{}\nt.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\nc := &http.Client{Transport: t}\nres, err := c.Get(\"file:///etc/passwd\")\n...\n\n```\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#SameSite",
              "documentation": {
                "identifier": "SameSite",
                "newPage": false,
                "searchKey": "http.SameSite",
                "tags": [
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type SameSite int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype SameSite int\n```\n\nSameSite allows a server to define a cookie attribute making it impossible for the browser to send this cookie along with cross-site requests. The main goal is to mitigate the risk of cross-origin information leakage, and provide some protection against cross-site request forgery attacks. \n\nSee [https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for details. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ServeMux",
              "documentation": {
                "identifier": "ServeMux",
                "newPage": false,
                "searchKey": "http.ServeMux",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ServeMux struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ServeMux struct {\n\tmu    sync.RWMutex\n\tm     map[string]muxEntry\n\tes    []muxEntry // slice of entries sorted from longest to shortest.\n\thosts bool       // whether any patterns contain hostnames\n}\n```\n\nServeMux is an HTTP request multiplexer. It matches the URL of each incoming request against a list of registered patterns and calls the handler for the pattern that most closely matches the URL. \n\nPatterns name fixed, rooted paths, like \"/favicon.ico\", or rooted subtrees, like \"/images/\" (note the trailing slash). Longer patterns take precedence over shorter ones, so that if there are handlers registered for both \"/images/\" and \"/images/thumbnails/\", the latter handler will be called for paths beginning \"/images/thumbnails/\" and the former will receive requests for any other paths in the \"/images/\" subtree. \n\nNote that since a pattern ending in a slash names a rooted subtree, the pattern \"/\" matches all paths not matched by other registered patterns, not just the URL with Path == \"/\". \n\nIf a subtree has been registered and a request is received naming the subtree root without its trailing slash, ServeMux redirects that request to the subtree root (adding the trailing slash). This behavior can be overridden with a separate registration for the path without the trailing slash. For example, registering \"/images/\" causes ServeMux to redirect a request for \"/images\" to \"/images/\", unless \"/images\" has been registered separately. \n\nPatterns may optionally begin with a host name, restricting matches to URLs on that host only. Host-specific patterns take precedence over general patterns, so that a handler might register for the two patterns \"/codesearch\" and \"codesearch.google.com/\" without also taking over requests for \"[http://www.google.com/](http://www.google.com/)\". \n\nServeMux also takes care of sanitizing the URL request path and the Host header, stripping the port number and redirecting any request containing . or .. elements or repeated slashes to an equivalent, cleaner URL. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#NewServeMux",
                    "documentation": {
                      "identifier": "NewServeMux",
                      "newPage": false,
                      "searchKey": "http.NewServeMux",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewServeMux() *ServeMux"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewServeMux() *ServeMux\n```\n\nNewServeMux allocates and returns a new ServeMux. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ServeMux.Handle",
                    "documentation": {
                      "identifier": "ServeMux.Handle",
                      "newPage": false,
                      "searchKey": "http.ServeMux.Handle",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mux *ServeMux) Handle(pattern string, handler Handler)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mux *ServeMux) Handle(pattern string, handler Handler)\n```\n\nHandle registers the handler for the given pattern. If a handler already exists for pattern, Handle panics. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ServeMux.HandleFunc",
                    "documentation": {
                      "identifier": "ServeMux.HandleFunc",
                      "newPage": false,
                      "searchKey": "http.ServeMux.HandleFunc",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))\n```\n\nHandleFunc registers the handler function for the given pattern. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ServeMux.Handler",
                    "documentation": {
                      "identifier": "ServeMux.Handler",
                      "newPage": false,
                      "searchKey": "http.ServeMux.Handler",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)\n```\n\nHandler returns the handler to use for the given request, consulting r.Method, r.Host, and r.URL.Path. It always returns a non-nil handler. If the path is not in its canonical form, the handler will be an internally-generated handler that redirects to the canonical path. If the host contains a port, it is ignored when matching handlers. \n\nThe path and host are used unchanged for CONNECT requests. \n\nHandler also returns the registered pattern that matches the request or, in the case of internally-generated redirects, the pattern that will match after following the redirect. \n\nIf there is no registered handler that applies to the request, Handler returns a `page not found' handler and an empty pattern. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ServeMux.ServeHTTP",
                    "documentation": {
                      "identifier": "ServeMux.ServeHTTP",
                      "newPage": false,
                      "searchKey": "http.ServeMux.ServeHTTP",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)\n```\n\nServeHTTP dispatches the request to the handler whose pattern most closely matches the request URL. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ServeMux.handler",
                    "documentation": {
                      "identifier": "ServeMux.handler",
                      "newPage": false,
                      "searchKey": "http.ServeMux.handler",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mux *ServeMux) handler(host, path string) (h Handler, pattern string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mux *ServeMux) handler(host, path string) (h Handler, pattern string)\n```\n\nhandler is the main implementation of Handler. The path is known to be in canonical form, except for CONNECT methods. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ServeMux.match",
                    "documentation": {
                      "identifier": "ServeMux.match",
                      "newPage": false,
                      "searchKey": "http.ServeMux.match",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mux *ServeMux) match(path string) (h Handler, pattern string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mux *ServeMux) match(path string) (h Handler, pattern string)\n```\n\nFind a handler on a handler map given a path string. Most-specific (longest) pattern wins. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ServeMux.redirectToPathSlash",
                    "documentation": {
                      "identifier": "ServeMux.redirectToPathSlash",
                      "newPage": false,
                      "searchKey": "http.ServeMux.redirectToPathSlash",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mux *ServeMux) redirectToPathSlash(host, path string, u *url.URL) (*url.URL, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mux *ServeMux) redirectToPathSlash(host, path string, u *url.URL) (*url.URL, bool)\n```\n\nredirectToPathSlash determines if the given path needs appending \"/\" to it. This occurs when a handler for path + \"/\" was already registered, but not for path itself. If the path needs appending to, it creates a new URL, setting the path to u.Path + \"/\" and returning true to indicate so. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ServeMux.shouldRedirectRLocked",
                    "documentation": {
                      "identifier": "ServeMux.shouldRedirectRLocked",
                      "newPage": false,
                      "searchKey": "http.ServeMux.shouldRedirectRLocked",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mux *ServeMux) shouldRedirectRLocked(host, path string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mux *ServeMux) shouldRedirectRLocked(host, path string) bool\n```\n\nshouldRedirectRLocked reports whether the given path and host should be redirected to path+\"/\". This should happen if a handler is registered for path+\"/\" but not path -- see comments at ServeMux. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#Server",
              "documentation": {
                "identifier": "Server",
                "newPage": false,
                "searchKey": "http.Server",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Server struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Server struct {\n\t// Addr optionally specifies the TCP address for the server to listen on,\n\t// in the form \"host:port\". If empty, \":http\" (port 80) is used.\n\t// The service names are defined in RFC 6335 and assigned by IANA.\n\t// See net.Dial for details of the address format.\n\tAddr string\n\n\tHandler Handler // handler to invoke, http.DefaultServeMux if nil\n\n\t// TLSConfig optionally provides a TLS configuration for use\n\t// by ServeTLS and ListenAndServeTLS. Note that this value is\n\t// cloned by ServeTLS and ListenAndServeTLS, so it's not\n\t// possible to modify the configuration with methods like\n\t// tls.Config.SetSessionTicketKeys. To use\n\t// SetSessionTicketKeys, use Server.Serve with a TLS Listener\n\t// instead.\n\tTLSConfig *tls.Config\n\n\t// ReadTimeout is the maximum duration for reading the entire\n\t// request, including the body. A zero or negative value means\n\t// there will be no timeout.\n\t//\n\t// Because ReadTimeout does not let Handlers make per-request\n\t// decisions on each request body's acceptable deadline or\n\t// upload rate, most users will prefer to use\n\t// ReadHeaderTimeout. It is valid to use them both.\n\tReadTimeout time.Duration\n\n\t// ReadHeaderTimeout is the amount of time allowed to read\n\t// request headers. The connection's read deadline is reset\n\t// after reading the headers and the Handler can decide what\n\t// is considered too slow for the body. If ReadHeaderTimeout\n\t// is zero, the value of ReadTimeout is used. If both are\n\t// zero, there is no timeout.\n\tReadHeaderTimeout time.Duration\n\n\t// WriteTimeout is the maximum duration before timing out\n\t// writes of the response. It is reset whenever a new\n\t// request's header is read. Like ReadTimeout, it does not\n\t// let Handlers make decisions on a per-request basis.\n\t// A zero or negative value means there will be no timeout.\n\tWriteTimeout time.Duration\n\n\t// IdleTimeout is the maximum amount of time to wait for the\n\t// next request when keep-alives are enabled. If IdleTimeout\n\t// is zero, the value of ReadTimeout is used. If both are\n\t// zero, there is no timeout.\n\tIdleTimeout time.Duration\n\n\t// MaxHeaderBytes controls the maximum number of bytes the\n\t// server will read parsing the request header's keys and\n\t// values, including the request line. It does not limit the\n\t// size of the request body.\n\t// If zero, DefaultMaxHeaderBytes is used.\n\tMaxHeaderBytes int\n\n\t// TLSNextProto optionally specifies a function to take over\n\t// ownership of the provided TLS connection when an ALPN\n\t// protocol upgrade has occurred. The map key is the protocol\n\t// name negotiated. The Handler argument should be used to\n\t// handle HTTP requests and will initialize the Request's TLS\n\t// and RemoteAddr if not already set. The connection is\n\t// automatically closed when the function returns.\n\t// If TLSNextProto is not nil, HTTP/2 support is not enabled\n\t// automatically.\n\tTLSNextProto map[string]func(*Server, *tls.Conn, Handler)\n\n\t// ConnState specifies an optional callback function that is\n\t// called when a client connection changes state. See the\n\t// ConnState type and associated constants for details.\n\tConnState func(net.Conn, ConnState)\n\n\t// ErrorLog specifies an optional logger for errors accepting\n\t// connections, unexpected behavior from handlers, and\n\t// underlying FileSystem errors.\n\t// If nil, logging is done via the log package's standard logger.\n\tErrorLog *log.Logger\n\n\t// BaseContext optionally specifies a function that returns\n\t// the base context for incoming requests on this server.\n\t// The provided Listener is the specific Listener that's\n\t// about to start accepting requests.\n\t// If BaseContext is nil, the default is context.Background().\n\t// If non-nil, it must return a non-nil context.\n\tBaseContext func(net.Listener) context.Context\n\n\t// ConnContext optionally specifies a function that modifies\n\t// the context used for a new connection c. The provided ctx\n\t// is derived from the base context and has a ServerContextKey\n\t// value.\n\tConnContext func(ctx context.Context, c net.Conn) context.Context\n\n\tinShutdown atomicBool // true when server is in shutdown\n\n\tdisableKeepAlives int32     // accessed atomically.\n\tnextProtoOnce     sync.Once // guards setupHTTP2_* init\n\tnextProtoErr      error     // result of http2.ConfigureServer if used\n\n\tmu         sync.Mutex\n\tlisteners  map[*net.Listener]struct{}\n\tactiveConn map[*conn]struct{}\n\tdoneChan   chan struct{}\n\tonShutdown []func()\n}\n```\n\nA Server defines parameters for running an HTTP server. The zero value for Server is a valid configuration. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#Server.Close",
                    "documentation": {
                      "identifier": "Server.Close",
                      "newPage": false,
                      "searchKey": "http.Server.Close",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) Close() error\n```\n\nClose immediately closes all active net.Listeners and any connections in state StateNew, StateActive, or StateIdle. For a graceful shutdown, use Shutdown. \n\nClose does not attempt to close (and does not even know about) any hijacked connections, such as WebSockets. \n\nClose returns any error returned from closing the Server's underlying Listener(s). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.ExportAllConnsByState",
                    "documentation": {
                      "identifier": "Server.ExportAllConnsByState",
                      "newPage": false,
                      "searchKey": "http.Server.ExportAllConnsByState",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) ExportAllConnsByState() map[ConnState]int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) ExportAllConnsByState() map[ConnState]int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.ExportAllConnsIdle",
                    "documentation": {
                      "identifier": "Server.ExportAllConnsIdle",
                      "newPage": false,
                      "searchKey": "http.Server.ExportAllConnsIdle",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) ExportAllConnsIdle() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) ExportAllConnsIdle() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.ListenAndServe",
                    "documentation": {
                      "identifier": "Server.ListenAndServe",
                      "newPage": false,
                      "searchKey": "http.Server.ListenAndServe",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) ListenAndServe() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) ListenAndServe() error\n```\n\nListenAndServe listens on the TCP network address srv.Addr and then calls Serve to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives. \n\nIf srv.Addr is blank, \":http\" is used. \n\nListenAndServe always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.ListenAndServeTLS",
                    "documentation": {
                      "identifier": "Server.ListenAndServeTLS",
                      "newPage": false,
                      "searchKey": "http.Server.ListenAndServeTLS",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) ListenAndServeTLS(certFile, keyFile string) error\n```\n\nListenAndServeTLS listens on the TCP network address srv.Addr and then calls ServeTLS to handle requests on incoming TLS connections. Accepted connections are configured to enable TCP keep-alives. \n\nFilenames containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. \n\nIf srv.Addr is blank, \":https\" is used. \n\nListenAndServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.RegisterOnShutdown",
                    "documentation": {
                      "identifier": "Server.RegisterOnShutdown",
                      "newPage": false,
                      "searchKey": "http.Server.RegisterOnShutdown",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) RegisterOnShutdown(f func())"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) RegisterOnShutdown(f func())\n```\n\nRegisterOnShutdown registers a function to call on Shutdown. This can be used to gracefully shutdown connections that have undergone ALPN protocol upgrade or that have been hijacked. This function should start protocol-specific graceful shutdown, but should not wait for shutdown to complete. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.Serve",
                    "documentation": {
                      "identifier": "Server.Serve",
                      "newPage": false,
                      "searchKey": "http.Server.Serve",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) Serve(l net.Listener) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) Serve(l net.Listener) error\n```\n\nServe accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines read requests and then call srv.Handler to reply to them. \n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn connections and they were configured with \"h2\" in the TLS Config.NextProtos. \n\nServe always returns a non-nil error and closes l. After Shutdown or Close, the returned error is ErrServerClosed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.ServeTLS",
                    "documentation": {
                      "identifier": "Server.ServeTLS",
                      "newPage": false,
                      "searchKey": "http.Server.ServeTLS",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) ServeTLS(l net.Listener, certFile, keyFile string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) ServeTLS(l net.Listener, certFile, keyFile string) error\n```\n\nServeTLS accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutines perform TLS setup and then read requests, calling srv.Handler to reply to them. \n\nFiles containing a certificate and matching private key for the server must be provided if neither the Server's TLSConfig.Certificates nor TLSConfig.GetCertificate are populated. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. \n\nServeTLS always returns a non-nil error. After Shutdown or Close, the returned error is ErrServerClosed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.SetKeepAlivesEnabled",
                    "documentation": {
                      "identifier": "Server.SetKeepAlivesEnabled",
                      "newPage": false,
                      "searchKey": "http.Server.SetKeepAlivesEnabled",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) SetKeepAlivesEnabled(v bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) SetKeepAlivesEnabled(v bool)\n```\n\nSetKeepAlivesEnabled controls whether HTTP keep-alives are enabled. By default, keep-alives are always enabled. Only very resource-constrained environments or servers in the process of shutting down should disable them. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.Shutdown",
                    "documentation": {
                      "identifier": "Server.Shutdown",
                      "newPage": false,
                      "searchKey": "http.Server.Shutdown",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) Shutdown(ctx context.Context) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) Shutdown(ctx context.Context) error\n```\n\nShutdown gracefully shuts down the server without interrupting any active connections. Shutdown works by first closing all open listeners, then closing all idle connections, and then waiting indefinitely for connections to return to idle and then shut down. If the provided context expires before the shutdown is complete, Shutdown returns the context's error, otherwise it returns any error returned from closing the Server's underlying Listener(s). \n\nWhen Shutdown is called, Serve, ListenAndServe, and ListenAndServeTLS immediately return ErrServerClosed. Make sure the program doesn't exit and waits instead for Shutdown to return. \n\nShutdown does not attempt to close nor wait for hijacked connections such as WebSockets. The caller of Shutdown should separately notify such long-lived connections of shutdown and wait for them to close, if desired. See RegisterOnShutdown for a way to register shutdown notification functions. \n\nOnce Shutdown has been called on a server, it may not be reused; future calls to methods such as Serve will return ErrServerClosed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.closeDoneChanLocked",
                    "documentation": {
                      "identifier": "Server.closeDoneChanLocked",
                      "newPage": false,
                      "searchKey": "http.Server.closeDoneChanLocked",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) closeDoneChanLocked()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) closeDoneChanLocked()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.closeIdleConns",
                    "documentation": {
                      "identifier": "Server.closeIdleConns",
                      "newPage": false,
                      "searchKey": "http.Server.closeIdleConns",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) closeIdleConns() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) closeIdleConns() bool\n```\n\ncloseIdleConns closes all idle connections and reports whether the server is quiescent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.closeListenersLocked",
                    "documentation": {
                      "identifier": "Server.closeListenersLocked",
                      "newPage": false,
                      "searchKey": "http.Server.closeListenersLocked",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) closeListenersLocked() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) closeListenersLocked() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.doKeepAlives",
                    "documentation": {
                      "identifier": "Server.doKeepAlives",
                      "newPage": false,
                      "searchKey": "http.Server.doKeepAlives",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) doKeepAlives() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) doKeepAlives() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.getDoneChan",
                    "documentation": {
                      "identifier": "Server.getDoneChan",
                      "newPage": false,
                      "searchKey": "http.Server.getDoneChan",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) getDoneChan() <-chan struct{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) getDoneChan() <-chan struct{}\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.getDoneChanLocked",
                    "documentation": {
                      "identifier": "Server.getDoneChanLocked",
                      "newPage": false,
                      "searchKey": "http.Server.getDoneChanLocked",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) getDoneChanLocked() chan struct{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) getDoneChanLocked() chan struct{}\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.idleTimeout",
                    "documentation": {
                      "identifier": "Server.idleTimeout",
                      "newPage": false,
                      "searchKey": "http.Server.idleTimeout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) idleTimeout() time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) idleTimeout() time.Duration\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.initialReadLimitSize",
                    "documentation": {
                      "identifier": "Server.initialReadLimitSize",
                      "newPage": false,
                      "searchKey": "http.Server.initialReadLimitSize",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) initialReadLimitSize() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) initialReadLimitSize() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.logf",
                    "documentation": {
                      "identifier": "Server.logf",
                      "newPage": false,
                      "searchKey": "http.Server.logf",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) logf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) logf(format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.maxHeaderBytes",
                    "documentation": {
                      "identifier": "Server.maxHeaderBytes",
                      "newPage": false,
                      "searchKey": "http.Server.maxHeaderBytes",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) maxHeaderBytes() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) maxHeaderBytes() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.newConn",
                    "documentation": {
                      "identifier": "Server.newConn",
                      "newPage": false,
                      "searchKey": "http.Server.newConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) newConn(rwc net.Conn) *conn"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) newConn(rwc net.Conn) *conn\n```\n\nCreate new connection from rwc. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.numListeners",
                    "documentation": {
                      "identifier": "Server.numListeners",
                      "newPage": false,
                      "searchKey": "http.Server.numListeners",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) numListeners() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) numListeners() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.onceSetNextProtoDefaults",
                    "documentation": {
                      "identifier": "Server.onceSetNextProtoDefaults",
                      "newPage": false,
                      "searchKey": "http.Server.onceSetNextProtoDefaults",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) onceSetNextProtoDefaults()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) onceSetNextProtoDefaults()\n```\n\nonceSetNextProtoDefaults configures HTTP/2, if the user hasn't configured otherwise. (by setting srv.TLSNextProto non-nil) It must only be called via srv.nextProtoOnce (use srv.setupHTTP2_*). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.onceSetNextProtoDefaults_Serve",
                    "documentation": {
                      "identifier": "Server.onceSetNextProtoDefaults_Serve",
                      "newPage": false,
                      "searchKey": "http.Server.onceSetNextProtoDefaults_Serve",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) onceSetNextProtoDefaults_Serve()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) onceSetNextProtoDefaults_Serve()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.readHeaderTimeout",
                    "documentation": {
                      "identifier": "Server.readHeaderTimeout",
                      "newPage": false,
                      "searchKey": "http.Server.readHeaderTimeout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) readHeaderTimeout() time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) readHeaderTimeout() time.Duration\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.setupHTTP2_Serve",
                    "documentation": {
                      "identifier": "Server.setupHTTP2_Serve",
                      "newPage": false,
                      "searchKey": "http.Server.setupHTTP2_Serve",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) setupHTTP2_Serve() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) setupHTTP2_Serve() error\n```\n\nsetupHTTP2_Serve is called from (*Server).Serve and conditionally configures HTTP/2 on srv using a more conservative policy than setupHTTP2_ServeTLS because Serve is called after tls.Listen, and may be called concurrently. See shouldConfigureHTTP2ForServe. \n\nThe tests named TestTransportAutomaticHTTP2* and TestConcurrentServerServe in server_test.go demonstrate some of the supported use cases and motivations. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.setupHTTP2_ServeTLS",
                    "documentation": {
                      "identifier": "Server.setupHTTP2_ServeTLS",
                      "newPage": false,
                      "searchKey": "http.Server.setupHTTP2_ServeTLS",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) setupHTTP2_ServeTLS() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) setupHTTP2_ServeTLS() error\n```\n\nsetupHTTP2_ServeTLS conditionally configures HTTP/2 on srv and reports whether there was an error setting it up. If it is not configured for policy reasons, nil is returned. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.shouldConfigureHTTP2ForServe",
                    "documentation": {
                      "identifier": "Server.shouldConfigureHTTP2ForServe",
                      "newPage": false,
                      "searchKey": "http.Server.shouldConfigureHTTP2ForServe",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (srv *Server) shouldConfigureHTTP2ForServe() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (srv *Server) shouldConfigureHTTP2ForServe() bool\n```\n\nshouldDoServeHTTP2 reports whether Server.Serve should configure automatic HTTP/2. (which sets up the srv.TLSNextProto map) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.shuttingDown",
                    "documentation": {
                      "identifier": "Server.shuttingDown",
                      "newPage": false,
                      "searchKey": "http.Server.shuttingDown",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) shuttingDown() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) shuttingDown() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.trackConn",
                    "documentation": {
                      "identifier": "Server.trackConn",
                      "newPage": false,
                      "searchKey": "http.Server.trackConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) trackConn(c *conn, add bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) trackConn(c *conn, add bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Server.trackListener",
                    "documentation": {
                      "identifier": "Server.trackListener",
                      "newPage": false,
                      "searchKey": "http.Server.trackListener",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Server) trackListener(ln *net.Listener, add bool) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Server) trackListener(ln *net.Listener, add bool) bool\n```\n\ntrackListener adds or removes a net.Listener to the set of tracked listeners. \n\nWe store a pointer to interface in the map set, in case the net.Listener is not comparable. This is safe because we only call trackListener via Serve and can track+defer untrack the same pointer to local variable there. We never need to compare a Listener from another caller. \n\nIt reports whether the server is still up (not Shutdown or Closed). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#Transport",
              "documentation": {
                "identifier": "Transport",
                "newPage": false,
                "searchKey": "http.Transport",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Transport struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Transport struct {\n\tidleMu       sync.Mutex\n\tcloseIdle    bool                                // user has requested to close all idle conns\n\tidleConn     map[connectMethodKey][]*persistConn // most recently used at end\n\tidleConnWait map[connectMethodKey]wantConnQueue  // waiting getConns\n\tidleLRU      connLRU\n\n\treqMu       sync.Mutex\n\treqCanceler map[cancelKey]func(error)\n\n\taltMu    sync.Mutex   // guards changing altProto only\n\taltProto atomic.Value // of nil or map[string]RoundTripper, key is URI scheme\n\n\tconnsPerHostMu   sync.Mutex\n\tconnsPerHost     map[connectMethodKey]int\n\tconnsPerHostWait map[connectMethodKey]wantConnQueue // waiting getConns\n\n\t// Proxy specifies a function to return a proxy for a given\n\t// Request. If the function returns a non-nil error, the\n\t// request is aborted with the provided error.\n\t//\n\t// The proxy type is determined by the URL scheme. \"http\",\n\t// \"https\", and \"socks5\" are supported. If the scheme is empty,\n\t// \"http\" is assumed.\n\t//\n\t// If Proxy is nil or returns a nil *URL, no proxy is used.\n\tProxy func(*Request) (*url.URL, error)\n\n\t// DialContext specifies the dial function for creating unencrypted TCP connections.\n\t// If DialContext is nil (and the deprecated Dial below is also nil),\n\t// then the transport dials using package net.\n\t//\n\t// DialContext runs concurrently with calls to RoundTrip.\n\t// A RoundTrip call that initiates a dial may end up using\n\t// a connection dialed previously when the earlier connection\n\t// becomes idle before the later DialContext completes.\n\tDialContext func(ctx context.Context, network, addr string) (net.Conn, error)\n\n\t// Dial specifies the dial function for creating unencrypted TCP connections.\n\t//\n\t// Dial runs concurrently with calls to RoundTrip.\n\t// A RoundTrip call that initiates a dial may end up using\n\t// a connection dialed previously when the earlier connection\n\t// becomes idle before the later Dial completes.\n\t//\n\t// Deprecated: Use DialContext instead, which allows the transport\n\t// to cancel dials as soon as they are no longer needed.\n\t// If both are set, DialContext takes priority.\n\tDial func(network, addr string) (net.Conn, error)\n\n\t// DialTLSContext specifies an optional dial function for creating\n\t// TLS connections for non-proxied HTTPS requests.\n\t//\n\t// If DialTLSContext is nil (and the deprecated DialTLS below is also nil),\n\t// DialContext and TLSClientConfig are used.\n\t//\n\t// If DialTLSContext is set, the Dial and DialContext hooks are not used for HTTPS\n\t// requests and the TLSClientConfig and TLSHandshakeTimeout\n\t// are ignored. The returned net.Conn is assumed to already be\n\t// past the TLS handshake.\n\tDialTLSContext func(ctx context.Context, network, addr string) (net.Conn, error)\n\n\t// DialTLS specifies an optional dial function for creating\n\t// TLS connections for non-proxied HTTPS requests.\n\t//\n\t// Deprecated: Use DialTLSContext instead, which allows the transport\n\t// to cancel dials as soon as they are no longer needed.\n\t// If both are set, DialTLSContext takes priority.\n\tDialTLS func(network, addr string) (net.Conn, error)\n\n\t// TLSClientConfig specifies the TLS configuration to use with\n\t// tls.Client.\n\t// If nil, the default configuration is used.\n\t// If non-nil, HTTP/2 support may not be enabled by default.\n\tTLSClientConfig *tls.Config\n\n\t// TLSHandshakeTimeout specifies the maximum amount of time waiting to\n\t// wait for a TLS handshake. Zero means no timeout.\n\tTLSHandshakeTimeout time.Duration\n\n\t// DisableKeepAlives, if true, disables HTTP keep-alives and\n\t// will only use the connection to the server for a single\n\t// HTTP request.\n\t//\n\t// This is unrelated to the similarly named TCP keep-alives.\n\tDisableKeepAlives bool\n\n\t// DisableCompression, if true, prevents the Transport from\n\t// requesting compression with an \"Accept-Encoding: gzip\"\n\t// request header when the Request contains no existing\n\t// Accept-Encoding value. If the Transport requests gzip on\n\t// its own and gets a gzipped response, it's transparently\n\t// decoded in the Response.Body. However, if the user\n\t// explicitly requested gzip it is not automatically\n\t// uncompressed.\n\tDisableCompression bool\n\n\t// MaxIdleConns controls the maximum number of idle (keep-alive)\n\t// connections across all hosts. Zero means no limit.\n\tMaxIdleConns int\n\n\t// MaxIdleConnsPerHost, if non-zero, controls the maximum idle\n\t// (keep-alive) connections to keep per-host. If zero,\n\t// DefaultMaxIdleConnsPerHost is used.\n\tMaxIdleConnsPerHost int\n\n\t// MaxConnsPerHost optionally limits the total number of\n\t// connections per host, including connections in the dialing,\n\t// active, and idle states. On limit violation, dials will block.\n\t//\n\t// Zero means no limit.\n\tMaxConnsPerHost int\n\n\t// IdleConnTimeout is the maximum amount of time an idle\n\t// (keep-alive) connection will remain idle before closing\n\t// itself.\n\t// Zero means no limit.\n\tIdleConnTimeout time.Duration\n\n\t// ResponseHeaderTimeout, if non-zero, specifies the amount of\n\t// time to wait for a server's response headers after fully\n\t// writing the request (including its body, if any). This\n\t// time does not include the time to read the response body.\n\tResponseHeaderTimeout time.Duration\n\n\t// ExpectContinueTimeout, if non-zero, specifies the amount of\n\t// time to wait for a server's first response headers after fully\n\t// writing the request headers if the request has an\n\t// \"Expect: 100-continue\" header. Zero means no timeout and\n\t// causes the body to be sent immediately, without\n\t// waiting for the server to approve.\n\t// This time does not include the time to send the request header.\n\tExpectContinueTimeout time.Duration\n\n\t// TLSNextProto specifies how the Transport switches to an\n\t// alternate protocol (such as HTTP/2) after a TLS ALPN\n\t// protocol negotiation. If Transport dials an TLS connection\n\t// with a non-empty protocol name and TLSNextProto contains a\n\t// map entry for that key (such as \"h2\"), then the func is\n\t// called with the request's authority (such as \"example.com\"\n\t// or \"example.com:1234\") and the TLS connection. The function\n\t// must return a RoundTripper that then handles the request.\n\t// If TLSNextProto is not nil, HTTP/2 support is not enabled\n\t// automatically.\n\tTLSNextProto map[string]func(authority string, c *tls.Conn) RoundTripper\n\n\t// ProxyConnectHeader optionally specifies headers to send to\n\t// proxies during CONNECT requests.\n\t// To set the header dynamically, see GetProxyConnectHeader.\n\tProxyConnectHeader Header\n\n\t// GetProxyConnectHeader optionally specifies a func to return\n\t// headers to send to proxyURL during a CONNECT request to the\n\t// ip:port target.\n\t// If it returns an error, the Transport's RoundTrip fails with\n\t// that error. It can return (nil, nil) to not add headers.\n\t// If GetProxyConnectHeader is non-nil, ProxyConnectHeader is\n\t// ignored.\n\tGetProxyConnectHeader func(ctx context.Context, proxyURL *url.URL, target string) (Header, error)\n\n\t// MaxResponseHeaderBytes specifies a limit on how many\n\t// response bytes are allowed in the server's response\n\t// header.\n\t//\n\t// Zero means to use a default limit.\n\tMaxResponseHeaderBytes int64\n\n\t// WriteBufferSize specifies the size of the write buffer used\n\t// when writing to the transport.\n\t// If zero, a default (currently 4KB) is used.\n\tWriteBufferSize int\n\n\t// ReadBufferSize specifies the size of the read buffer used\n\t// when reading from the transport.\n\t// If zero, a default (currently 4KB) is used.\n\tReadBufferSize int\n\n\t// nextProtoOnce guards initialization of TLSNextProto and\n\t// h2transport (via onceSetNextProtoDefaults)\n\tnextProtoOnce      sync.Once\n\th2transport        h2Transport // non-nil if http2 wired up\n\ttlsNextProtoWasNil bool        // whether TLSNextProto was nil when the Once fired\n\n\t// ForceAttemptHTTP2 controls whether HTTP/2 is enabled when a non-zero\n\t// Dial, DialTLS, or DialContext func or TLSClientConfig is provided.\n\t// By default, use of any those fields conservatively disables HTTP/2.\n\t// To use a custom dialer or TLS config and still attempt HTTP/2\n\t// upgrades, set this to true.\n\tForceAttemptHTTP2 bool\n}\n```\n\nTransport is an implementation of RoundTripper that supports HTTP, HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT). \n\nBy default, Transport caches connections for future re-use. This may leave many open connections when accessing many hosts. This behavior can be managed using Transport's CloseIdleConnections method and the MaxIdleConnsPerHost and DisableKeepAlives fields. \n\nTransports should be reused instead of created as needed. Transports are safe for concurrent use by multiple goroutines. \n\nA Transport is a low-level primitive for making HTTP and HTTPS requests. For high-level functionality, such as cookies and redirects, see Client. \n\nTransport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2 for HTTPS URLs, depending on whether the server supports HTTP/2, and how the Transport is configured. The DefaultTransport supports HTTP/2. To explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2 and call ConfigureTransport. See the package docs for more about HTTP/2. \n\nResponses with status codes in the 1xx range are either handled automatically (100 expect-continue) or ignored. The one exception is HTTP status code 101 (Switching Protocols), which is considered a terminal status and returned by RoundTrip. To see the ignored 1xx responses, use the httptrace trace package's ClientTrace.Got1xxResponse. \n\nTransport only retries a request upon encountering a network error if the request is idempotent and either has no body or has its Request.GetBody defined. HTTP requests are considered idempotent if they have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their Header map contains an \"Idempotency-Key\" or \"X-Idempotency-Key\" entry. If the idempotency key value is a zero-length slice, the request is treated as idempotent but the header is not sent on the wire. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#Transport.CancelRequest",
                    "documentation": {
                      "identifier": "Transport.CancelRequest",
                      "newPage": false,
                      "searchKey": "http.Transport.CancelRequest",
                      "tags": [
                        "method",
                        "deprecated"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) CancelRequest(req *Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) CancelRequest(req *Request)\n```\n\nCancelRequest cancels an in-flight request by closing its connection. CancelRequest should only be called after RoundTrip has returned. \n\nDeprecated: Use Request.WithContext to create a request with a cancelable context instead. CancelRequest cannot cancel HTTP/2 requests. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.Clone",
                    "documentation": {
                      "identifier": "Transport.Clone",
                      "newPage": false,
                      "searchKey": "http.Transport.Clone",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) Clone() *Transport"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) Clone() *Transport\n```\n\nClone returns a deep copy of t's exported fields. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.CloseIdleConnections",
                    "documentation": {
                      "identifier": "Transport.CloseIdleConnections",
                      "newPage": false,
                      "searchKey": "http.Transport.CloseIdleConnections",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) CloseIdleConnections()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) CloseIdleConnections()\n```\n\nCloseIdleConnections closes any connections which were previously connected from previous requests but are now sitting idle in a \"keep-alive\" state. It does not interrupt any connections currently in use. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.IdleConnCountForTesting",
                    "documentation": {
                      "identifier": "Transport.IdleConnCountForTesting",
                      "newPage": false,
                      "searchKey": "http.Transport.IdleConnCountForTesting",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) IdleConnCountForTesting(scheme, addr string) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) IdleConnCountForTesting(scheme, addr string) int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.IdleConnKeyCountForTesting",
                    "documentation": {
                      "identifier": "Transport.IdleConnKeyCountForTesting",
                      "newPage": false,
                      "searchKey": "http.Transport.IdleConnKeyCountForTesting",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) IdleConnKeyCountForTesting() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) IdleConnKeyCountForTesting() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.IdleConnKeysForTesting",
                    "documentation": {
                      "identifier": "Transport.IdleConnKeysForTesting",
                      "newPage": false,
                      "searchKey": "http.Transport.IdleConnKeysForTesting",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) IdleConnKeysForTesting() (keys []string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) IdleConnKeysForTesting() (keys []string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.IdleConnStrsForTesting",
                    "documentation": {
                      "identifier": "Transport.IdleConnStrsForTesting",
                      "newPage": false,
                      "searchKey": "http.Transport.IdleConnStrsForTesting",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) IdleConnStrsForTesting() []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) IdleConnStrsForTesting() []string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.IdleConnStrsForTesting_h2",
                    "documentation": {
                      "identifier": "Transport.IdleConnStrsForTesting_h2",
                      "newPage": false,
                      "searchKey": "http.Transport.IdleConnStrsForTesting_h2",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) IdleConnStrsForTesting_h2() []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) IdleConnStrsForTesting_h2() []string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.IdleConnWaitMapSizeForTesting",
                    "documentation": {
                      "identifier": "Transport.IdleConnWaitMapSizeForTesting",
                      "newPage": false,
                      "searchKey": "http.Transport.IdleConnWaitMapSizeForTesting",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) IdleConnWaitMapSizeForTesting() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) IdleConnWaitMapSizeForTesting() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.IsIdleForTesting",
                    "documentation": {
                      "identifier": "Transport.IsIdleForTesting",
                      "newPage": false,
                      "searchKey": "http.Transport.IsIdleForTesting",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) IsIdleForTesting() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) IsIdleForTesting() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.NumPendingRequestsForTesting",
                    "documentation": {
                      "identifier": "Transport.NumPendingRequestsForTesting",
                      "newPage": false,
                      "searchKey": "http.Transport.NumPendingRequestsForTesting",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) NumPendingRequestsForTesting() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) NumPendingRequestsForTesting() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.PutIdleTestConn",
                    "documentation": {
                      "identifier": "Transport.PutIdleTestConn",
                      "newPage": false,
                      "searchKey": "http.Transport.PutIdleTestConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) PutIdleTestConn(scheme, addr string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) PutIdleTestConn(scheme, addr string) bool\n```\n\nPutIdleTestConn reports whether it was able to insert a fresh persistConn for scheme, addr into the idle connection pool. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.PutIdleTestConnH2",
                    "documentation": {
                      "identifier": "Transport.PutIdleTestConnH2",
                      "newPage": false,
                      "searchKey": "http.Transport.PutIdleTestConnH2",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) PutIdleTestConnH2(scheme, addr string, alt RoundTripper) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) PutIdleTestConnH2(scheme, addr string, alt RoundTripper) bool\n```\n\nPutIdleTestConnH2 reports whether it was able to insert a fresh HTTP/2 persistConn for scheme, addr into the idle connection pool. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.QueueForIdleConnForTesting",
                    "documentation": {
                      "identifier": "Transport.QueueForIdleConnForTesting",
                      "newPage": false,
                      "searchKey": "http.Transport.QueueForIdleConnForTesting",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) QueueForIdleConnForTesting()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) QueueForIdleConnForTesting()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.RegisterProtocol",
                    "documentation": {
                      "identifier": "Transport.RegisterProtocol",
                      "newPage": false,
                      "searchKey": "http.Transport.RegisterProtocol",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)\n```\n\nRegisterProtocol registers a new protocol with scheme. The Transport will pass requests using the given scheme to rt. It is rt's responsibility to simulate HTTP request semantics. \n\nRegisterProtocol can be used by other packages to provide implementations of protocol schemes like \"ftp\" or \"file\". \n\nIf rt.RoundTrip returns ErrSkipAltProtocol, the Transport will handle the RoundTrip itself for that one request, as if the protocol were not registered. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.RoundTrip",
                    "documentation": {
                      "identifier": "Transport.RoundTrip",
                      "newPage": false,
                      "searchKey": "http.Transport.RoundTrip",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) RoundTrip(req *Request) (*Response, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) RoundTrip(req *Request) (*Response, error)\n```\n\nRoundTrip implements the RoundTripper interface. \n\nFor higher-level HTTP client support (such as handling of cookies and redirects), see Get, Post, and the Client type. \n\nLike the RoundTripper interface, the error types returned by RoundTrip are unspecified. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.alternateRoundTripper",
                    "documentation": {
                      "identifier": "Transport.alternateRoundTripper",
                      "newPage": false,
                      "searchKey": "http.Transport.alternateRoundTripper",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) alternateRoundTripper(req *Request) RoundTripper"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) alternateRoundTripper(req *Request) RoundTripper\n```\n\nalternateRoundTripper returns the alternate RoundTripper to use for this request if the Request's URL scheme requires one, or nil for the normal case of using the Transport. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.cancelRequest",
                    "documentation": {
                      "identifier": "Transport.cancelRequest",
                      "newPage": false,
                      "searchKey": "http.Transport.cancelRequest",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) cancelRequest(key cancelKey, err error) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) cancelRequest(key cancelKey, err error) bool\n```\n\nCancel an in-flight request, recording the error value. Returns whether the request was canceled. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.connectMethodForRequest",
                    "documentation": {
                      "identifier": "Transport.connectMethodForRequest",
                      "newPage": false,
                      "searchKey": "http.Transport.connectMethodForRequest",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) connectMethodForRequest(treq *transportRequest) (cm connectMethod, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) connectMethodForRequest(treq *transportRequest) (cm connectMethod, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.customDialTLS",
                    "documentation": {
                      "identifier": "Transport.customDialTLS",
                      "newPage": false,
                      "searchKey": "http.Transport.customDialTLS",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) customDialTLS(ctx context.Context, network, addr string) (conn net.Conn, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) customDialTLS(ctx context.Context, network, addr string) (conn net.Conn, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.decConnsPerHost",
                    "documentation": {
                      "identifier": "Transport.decConnsPerHost",
                      "newPage": false,
                      "searchKey": "http.Transport.decConnsPerHost",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) decConnsPerHost(key connectMethodKey)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) decConnsPerHost(key connectMethodKey)\n```\n\ndecConnsPerHost decrements the per-host connection count for key, which may in turn give a different waiting goroutine permission to dial. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.dial",
                    "documentation": {
                      "identifier": "Transport.dial",
                      "newPage": false,
                      "searchKey": "http.Transport.dial",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) dial(ctx context.Context, network, addr string) (net.Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) dial(ctx context.Context, network, addr string) (net.Conn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.dialConn",
                    "documentation": {
                      "identifier": "Transport.dialConn",
                      "newPage": false,
                      "searchKey": "http.Transport.dialConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *persistConn, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.dialConnFor",
                    "documentation": {
                      "identifier": "Transport.dialConnFor",
                      "newPage": false,
                      "searchKey": "http.Transport.dialConnFor",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) dialConnFor(w *wantConn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) dialConnFor(w *wantConn)\n```\n\ndialConnFor dials on behalf of w and delivers the result to w. dialConnFor has received permission to dial w.cm and is counted in t.connCount[w.cm.key()]. If the dial is canceled or unsuccessful, dialConnFor decrements t.connCount[w.cm.key()]. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.getConn",
                    "documentation": {
                      "identifier": "Transport.getConn",
                      "newPage": false,
                      "searchKey": "http.Transport.getConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) getConn(treq *transportRequest, cm connectMethod) (pc *persistConn, err error)\n```\n\ngetConn dials and creates a new persistConn to the target as specified in the connectMethod. This includes doing a proxy CONNECT and/or setting up TLS.  If this doesn't return an error, the persistConn is ready to write requests to. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.hasCustomTLSDialer",
                    "documentation": {
                      "identifier": "Transport.hasCustomTLSDialer",
                      "newPage": false,
                      "searchKey": "http.Transport.hasCustomTLSDialer",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) hasCustomTLSDialer() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) hasCustomTLSDialer() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.maxIdleConnsPerHost",
                    "documentation": {
                      "identifier": "Transport.maxIdleConnsPerHost",
                      "newPage": false,
                      "searchKey": "http.Transport.maxIdleConnsPerHost",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) maxIdleConnsPerHost() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) maxIdleConnsPerHost() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.onceSetNextProtoDefaults",
                    "documentation": {
                      "identifier": "Transport.onceSetNextProtoDefaults",
                      "newPage": false,
                      "searchKey": "http.Transport.onceSetNextProtoDefaults",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) onceSetNextProtoDefaults()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) onceSetNextProtoDefaults()\n```\n\nonceSetNextProtoDefaults initializes TLSNextProto. It must be called via t.nextProtoOnce.Do. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.putOrCloseIdleConn",
                    "documentation": {
                      "identifier": "Transport.putOrCloseIdleConn",
                      "newPage": false,
                      "searchKey": "http.Transport.putOrCloseIdleConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) putOrCloseIdleConn(pconn *persistConn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) putOrCloseIdleConn(pconn *persistConn)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.queueForDial",
                    "documentation": {
                      "identifier": "Transport.queueForDial",
                      "newPage": false,
                      "searchKey": "http.Transport.queueForDial",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) queueForDial(w *wantConn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) queueForDial(w *wantConn)\n```\n\nqueueForDial queues w to wait for permission to begin dialing. Once w receives permission to dial, it will do so in a separate goroutine. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.queueForIdleConn",
                    "documentation": {
                      "identifier": "Transport.queueForIdleConn",
                      "newPage": false,
                      "searchKey": "http.Transport.queueForIdleConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) queueForIdleConn(w *wantConn) (delivered bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) queueForIdleConn(w *wantConn) (delivered bool)\n```\n\nqueueForIdleConn queues w to receive the next idle connection for w.cm. As an optimization hint to the caller, queueForIdleConn reports whether it successfully delivered an already-idle connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.readBufferSize",
                    "documentation": {
                      "identifier": "Transport.readBufferSize",
                      "newPage": false,
                      "searchKey": "http.Transport.readBufferSize",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) readBufferSize() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) readBufferSize() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.removeIdleConn",
                    "documentation": {
                      "identifier": "Transport.removeIdleConn",
                      "newPage": false,
                      "searchKey": "http.Transport.removeIdleConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) removeIdleConn(pconn *persistConn) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) removeIdleConn(pconn *persistConn) bool\n```\n\nremoveIdleConn marks pconn as dead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.removeIdleConnLocked",
                    "documentation": {
                      "identifier": "Transport.removeIdleConnLocked",
                      "newPage": false,
                      "searchKey": "http.Transport.removeIdleConnLocked",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) removeIdleConnLocked(pconn *persistConn) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) removeIdleConnLocked(pconn *persistConn) bool\n```\n\nt.idleMu must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.replaceReqCanceler",
                    "documentation": {
                      "identifier": "Transport.replaceReqCanceler",
                      "newPage": false,
                      "searchKey": "http.Transport.replaceReqCanceler",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) replaceReqCanceler(key cancelKey, fn func(error)) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) replaceReqCanceler(key cancelKey, fn func(error)) bool\n```\n\nreplaceReqCanceler replaces an existing cancel function. If there is no cancel function for the request, we don't set the function and return false. Since CancelRequest will clear the canceler, we can use the return value to detect if the request was canceled since the last setReqCancel call. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.roundTrip",
                    "documentation": {
                      "identifier": "Transport.roundTrip",
                      "newPage": false,
                      "searchKey": "http.Transport.roundTrip",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) roundTrip(req *Request) (*Response, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) roundTrip(req *Request) (*Response, error)\n```\n\nroundTrip implements a RoundTripper over HTTP. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.setReqCanceler",
                    "documentation": {
                      "identifier": "Transport.setReqCanceler",
                      "newPage": false,
                      "searchKey": "http.Transport.setReqCanceler",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) setReqCanceler(key cancelKey, fn func(error))"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) setReqCanceler(key cancelKey, fn func(error))\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.tryPutIdleConn",
                    "documentation": {
                      "identifier": "Transport.tryPutIdleConn",
                      "newPage": false,
                      "searchKey": "http.Transport.tryPutIdleConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) tryPutIdleConn(pconn *persistConn) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) tryPutIdleConn(pconn *persistConn) error\n```\n\ntryPutIdleConn adds pconn to the list of idle persistent connections awaiting a new request. If pconn is no longer needed or not in a good state, tryPutIdleConn returns an error explaining why it wasn't registered. tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.useRegisteredProtocol",
                    "documentation": {
                      "identifier": "Transport.useRegisteredProtocol",
                      "newPage": false,
                      "searchKey": "http.Transport.useRegisteredProtocol",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) useRegisteredProtocol(req *Request) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) useRegisteredProtocol(req *Request) bool\n```\n\nuseRegisteredProtocol reports whether an alternate protocol (as registered with Transport.RegisterProtocol) should be respected for this request. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#Transport.writeBufferSize",
                    "documentation": {
                      "identifier": "Transport.writeBufferSize",
                      "newPage": false,
                      "searchKey": "http.Transport.writeBufferSize",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Transport) writeBufferSize() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Transport) writeBufferSize() int\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#anyDirs",
              "documentation": {
                "identifier": "anyDirs",
                "newPage": false,
                "searchKey": "http.anyDirs",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type anyDirs interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype anyDirs interface {\n\tlen() int\n\tname(i int) string\n\tisDir(i int) bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#atomicBool",
              "documentation": {
                "identifier": "atomicBool",
                "newPage": false,
                "searchKey": "http.atomicBool",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type atomicBool int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype atomicBool int32\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#atomicBool.isSet",
                    "documentation": {
                      "identifier": "atomicBool.isSet",
                      "newPage": false,
                      "searchKey": "http.atomicBool.isSet",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *atomicBool) isSet() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *atomicBool) isSet() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#atomicBool.setFalse",
                    "documentation": {
                      "identifier": "atomicBool.setFalse",
                      "newPage": false,
                      "searchKey": "http.atomicBool.setFalse",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *atomicBool) setFalse()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *atomicBool) setFalse()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#atomicBool.setTrue",
                    "documentation": {
                      "identifier": "atomicBool.setTrue",
                      "newPage": false,
                      "searchKey": "http.atomicBool.setTrue",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *atomicBool) setTrue()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *atomicBool) setTrue()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#body",
              "documentation": {
                "identifier": "body",
                "newPage": false,
                "searchKey": "http.body",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type body struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype body struct {\n\tsrc          io.Reader\n\thdr          interface{}   // non-nil (Response or Request) value means read trailer\n\tr            *bufio.Reader // underlying wire-format reader for the trailer\n\tclosing      bool          // is the connection to be closed after reading body?\n\tdoEarlyClose bool          // whether Close should stop early\n\n\tmu         sync.Mutex // guards following, and calls to Read and Close\n\tsawEOF     bool\n\tclosed     bool\n\tearlyClose bool   // Close called and we didn't read to the end of src\n\tonHitEOF   func() // if non-nil, func to call when EOF is Read\n}\n```\n\nbody turns a Reader into a ReadCloser. Close ensures that the body has been fully read and then reads the trailer if necessary. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#body.Close",
                    "documentation": {
                      "identifier": "body.Close",
                      "newPage": false,
                      "searchKey": "http.body.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *body) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *body) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#body.Read",
                    "documentation": {
                      "identifier": "body.Read",
                      "newPage": false,
                      "searchKey": "http.body.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *body) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *body) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#body.bodyRemains",
                    "documentation": {
                      "identifier": "body.bodyRemains",
                      "newPage": false,
                      "searchKey": "http.body.bodyRemains",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *body) bodyRemains() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *body) bodyRemains() bool\n```\n\nbodyRemains reports whether future Read calls might yield data. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#body.didEarlyClose",
                    "documentation": {
                      "identifier": "body.didEarlyClose",
                      "newPage": false,
                      "searchKey": "http.body.didEarlyClose",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *body) didEarlyClose() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *body) didEarlyClose() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#body.readLocked",
                    "documentation": {
                      "identifier": "body.readLocked",
                      "newPage": false,
                      "searchKey": "http.body.readLocked",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *body) readLocked(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *body) readLocked(p []byte) (n int, err error)\n```\n\nMust hold b.mu. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#body.readTrailer",
                    "documentation": {
                      "identifier": "body.readTrailer",
                      "newPage": false,
                      "searchKey": "http.body.readTrailer",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *body) readTrailer() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *body) readTrailer() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#body.registerOnHitEOF",
                    "documentation": {
                      "identifier": "body.registerOnHitEOF",
                      "newPage": false,
                      "searchKey": "http.body.registerOnHitEOF",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *body) registerOnHitEOF(fn func())"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *body) registerOnHitEOF(fn func())\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#body.unreadDataSizeLocked",
                    "documentation": {
                      "identifier": "body.unreadDataSizeLocked",
                      "newPage": false,
                      "searchKey": "http.body.unreadDataSizeLocked",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *body) unreadDataSizeLocked() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *body) unreadDataSizeLocked() int64\n```\n\nunreadDataSizeLocked returns the number of bytes of unread input. It returns -1 if unknown. b.mu must be held. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#bodyEOFSignal",
              "documentation": {
                "identifier": "bodyEOFSignal",
                "newPage": false,
                "searchKey": "http.bodyEOFSignal",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type bodyEOFSignal struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bodyEOFSignal struct {\n\tbody         io.ReadCloser\n\tmu           sync.Mutex        // guards following 4 fields\n\tclosed       bool              // whether Close has been called\n\trerr         error             // sticky Read error\n\tfn           func(error) error // err will be nil on Read io.EOF\n\tearlyCloseFn func() error      // optional alt Close func used if io.EOF not seen\n}\n```\n\nbodyEOFSignal is used by the HTTP/1 transport when reading response bodies to make sure we see the end of a response body before proceeding and reading on the connection again. \n\nIt wraps a ReadCloser but runs fn (if non-nil) at most once, right before its final (error-producing) Read or Close call returns. fn should return the new error to return from Read or Close. \n\nIf earlyCloseFn is non-nil and Close is called before io.EOF is seen, earlyCloseFn is called instead of fn, and its return value is the return value from Close. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#bodyEOFSignal.Close",
                    "documentation": {
                      "identifier": "bodyEOFSignal.Close",
                      "newPage": false,
                      "searchKey": "http.bodyEOFSignal.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (es *bodyEOFSignal) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (es *bodyEOFSignal) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#bodyEOFSignal.Read",
                    "documentation": {
                      "identifier": "bodyEOFSignal.Read",
                      "newPage": false,
                      "searchKey": "http.bodyEOFSignal.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (es *bodyEOFSignal) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (es *bodyEOFSignal) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#bodyEOFSignal.condfn",
                    "documentation": {
                      "identifier": "bodyEOFSignal.condfn",
                      "newPage": false,
                      "searchKey": "http.bodyEOFSignal.condfn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (es *bodyEOFSignal) condfn(err error) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (es *bodyEOFSignal) condfn(err error) error\n```\n\ncaller must hold es.mu. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#bodyLocked",
              "documentation": {
                "identifier": "bodyLocked",
                "newPage": false,
                "searchKey": "http.bodyLocked",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type bodyLocked struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bodyLocked struct {\n\tb *body\n}\n```\n\nbodyLocked is a io.Reader reading from a *body when its mutex is already held. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#bodyLocked.Read",
                    "documentation": {
                      "identifier": "bodyLocked.Read",
                      "newPage": false,
                      "searchKey": "http.bodyLocked.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (bl bodyLocked) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (bl bodyLocked) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#bufioFlushWriter",
              "documentation": {
                "identifier": "bufioFlushWriter",
                "newPage": false,
                "searchKey": "http.bufioFlushWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type bufioFlushWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bufioFlushWriter struct{ w io.Writer }\n```\n\nbufioFlushWriter is an io.Writer wrapper that flushes all writes on its wrapped writer if it's a *bufio.Writer. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#bufioFlushWriter.Write",
                    "documentation": {
                      "identifier": "bufioFlushWriter.Write",
                      "newPage": false,
                      "searchKey": "http.bufioFlushWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fw bufioFlushWriter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fw bufioFlushWriter) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#byteReader",
              "documentation": {
                "identifier": "byteReader",
                "newPage": false,
                "searchKey": "http.byteReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type byteReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype byteReader struct {\n\tb    byte\n\tdone bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#byteReader.Read",
                    "documentation": {
                      "identifier": "byteReader.Read",
                      "newPage": false,
                      "searchKey": "http.byteReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (br *byteReader) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (br *byteReader) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#cancelKey",
              "documentation": {
                "identifier": "cancelKey",
                "newPage": false,
                "searchKey": "http.cancelKey",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type cancelKey struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cancelKey struct {\n\treq *Request\n}\n```\n\nA cancelKey is the key of the reqCanceler map. We wrap the *Request in this type since we want to use the original request, not any transient one created by roundTrip. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#cancelTimerBody",
              "documentation": {
                "identifier": "cancelTimerBody",
                "newPage": false,
                "searchKey": "http.cancelTimerBody",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type cancelTimerBody struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cancelTimerBody struct {\n\tstop          func() // stops the time.Timer waiting to cancel the request\n\trc            io.ReadCloser\n\treqDidTimeout func() bool\n}\n```\n\ncancelTimerBody is an io.ReadCloser that wraps rc with two features: 1) on Read error or close, the stop func is called. 2) On Read failure, if reqDidTimeout is true, the error is wrapped and \n\n```\nmarked as net.Error that hit its timeout.\n\n```\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#cancelTimerBody.Close",
                    "documentation": {
                      "identifier": "cancelTimerBody.Close",
                      "newPage": false,
                      "searchKey": "http.cancelTimerBody.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *cancelTimerBody) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *cancelTimerBody) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#cancelTimerBody.Read",
                    "documentation": {
                      "identifier": "cancelTimerBody.Read",
                      "newPage": false,
                      "searchKey": "http.cancelTimerBody.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *cancelTimerBody) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *cancelTimerBody) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#checkConnErrorWriter",
              "documentation": {
                "identifier": "checkConnErrorWriter",
                "newPage": false,
                "searchKey": "http.checkConnErrorWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type checkConnErrorWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype checkConnErrorWriter struct {\n\tc *conn\n}\n```\n\ncheckConnErrorWriter writes to c.rwc and records any write errors to c.werr. It only contains one field (and a pointer field at that), so it fits in an interface value without an extra allocation. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#checkConnErrorWriter.Write",
                    "documentation": {
                      "identifier": "checkConnErrorWriter.Write",
                      "newPage": false,
                      "searchKey": "http.checkConnErrorWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w checkConnErrorWriter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w checkConnErrorWriter) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#chunkWriter",
              "documentation": {
                "identifier": "chunkWriter",
                "newPage": false,
                "searchKey": "http.chunkWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type chunkWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype chunkWriter struct {\n\tres *response\n\n\t// header is either nil or a deep clone of res.handlerHeader\n\t// at the time of res.writeHeader, if res.writeHeader is\n\t// called and extra buffering is being done to calculate\n\t// Content-Type and/or Content-Length.\n\theader Header\n\n\t// wroteHeader tells whether the header's been written to \"the\n\t// wire\" (or rather: w.conn.buf). this is unlike\n\t// (*response).wroteHeader, which tells only whether it was\n\t// logically written.\n\twroteHeader bool\n\n\t// set by the writeHeader method:\n\tchunking bool // using chunked transfer encoding for reply body\n}\n```\n\nchunkWriter writes to a response's conn buffer, and is the writer wrapped by the response.w buffered writer. \n\nchunkWriter also is responsible for finalizing the Header, including conditionally setting the Content-Type and setting a Content-Length in cases where the handler's final output is smaller than the buffer size. It also conditionally adds chunk headers, when in chunking mode. \n\nSee the comment above (*response).Write for the entire write flow. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#chunkWriter.Write",
                    "documentation": {
                      "identifier": "chunkWriter.Write",
                      "newPage": false,
                      "searchKey": "http.chunkWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cw *chunkWriter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cw *chunkWriter) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#chunkWriter.close",
                    "documentation": {
                      "identifier": "chunkWriter.close",
                      "newPage": false,
                      "searchKey": "http.chunkWriter.close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cw *chunkWriter) close()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cw *chunkWriter) close()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#chunkWriter.flush",
                    "documentation": {
                      "identifier": "chunkWriter.flush",
                      "newPage": false,
                      "searchKey": "http.chunkWriter.flush",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cw *chunkWriter) flush()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cw *chunkWriter) flush()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#chunkWriter.writeHeader",
                    "documentation": {
                      "identifier": "chunkWriter.writeHeader",
                      "newPage": false,
                      "searchKey": "http.chunkWriter.writeHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cw *chunkWriter) writeHeader(p []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cw *chunkWriter) writeHeader(p []byte)\n```\n\nwriteHeader finalizes the header sent to the client and writes it to cw.res.conn.bufw. \n\np is not written by writeHeader, but is the first chunk of the body that will be written. It is sniffed for a Content-Type if none is set explicitly. It's also used to set the Content-Length, if the total body size was small and the handler has already finished running. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#closeChecker",
              "documentation": {
                "identifier": "closeChecker",
                "newPage": false,
                "searchKey": "http.closeChecker",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type closeChecker struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype closeChecker struct {\n\tio.Reader\n\tclosed bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#closeChecker.Close",
                    "documentation": {
                      "identifier": "closeChecker.Close",
                      "newPage": false,
                      "searchKey": "http.closeChecker.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rc *closeChecker) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rc *closeChecker) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#closeWriter",
              "documentation": {
                "identifier": "closeWriter",
                "newPage": false,
                "searchKey": "http.closeWriter",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type closeWriter interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype closeWriter interface {\n\tCloseWrite() error\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#condResult",
              "documentation": {
                "identifier": "condResult",
                "newPage": false,
                "searchKey": "http.condResult",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type condResult int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype condResult int\n```\n\ncondResult is the result of an HTTP request precondition check. See [https://tools.ietf.org/html/rfc7232](https://tools.ietf.org/html/rfc7232) section 3. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#checkIfMatch",
                    "documentation": {
                      "identifier": "checkIfMatch",
                      "newPage": false,
                      "searchKey": "http.checkIfMatch",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func checkIfMatch(w ResponseWriter, r *Request) condResult"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc checkIfMatch(w ResponseWriter, r *Request) condResult\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#checkIfModifiedSince",
                    "documentation": {
                      "identifier": "checkIfModifiedSince",
                      "newPage": false,
                      "searchKey": "http.checkIfModifiedSince",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func checkIfModifiedSince(r *Request, modtime time.Time) condResult"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc checkIfModifiedSince(r *Request, modtime time.Time) condResult\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#checkIfNoneMatch",
                    "documentation": {
                      "identifier": "checkIfNoneMatch",
                      "newPage": false,
                      "searchKey": "http.checkIfNoneMatch",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func checkIfNoneMatch(w ResponseWriter, r *Request) condResult"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc checkIfNoneMatch(w ResponseWriter, r *Request) condResult\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#checkIfRange",
                    "documentation": {
                      "identifier": "checkIfRange",
                      "newPage": false,
                      "searchKey": "http.checkIfRange",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func checkIfRange(w ResponseWriter, r *Request, modtime time.Time) condResult"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc checkIfRange(w ResponseWriter, r *Request, modtime time.Time) condResult\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#checkIfUnmodifiedSince",
                    "documentation": {
                      "identifier": "checkIfUnmodifiedSince",
                      "newPage": false,
                      "searchKey": "http.checkIfUnmodifiedSince",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func checkIfUnmodifiedSince(r *Request, modtime time.Time) condResult"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc checkIfUnmodifiedSince(r *Request, modtime time.Time) condResult\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#conn",
              "documentation": {
                "identifier": "conn",
                "newPage": false,
                "searchKey": "http.conn",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type conn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype conn struct {\n\t// server is the server on which the connection arrived.\n\t// Immutable; never nil.\n\tserver *Server\n\n\t// cancelCtx cancels the connection-level context.\n\tcancelCtx context.CancelFunc\n\n\t// rwc is the underlying network connection.\n\t// This is never wrapped by other types and is the value given out\n\t// to CloseNotifier callers. It is usually of type *net.TCPConn or\n\t// *tls.Conn.\n\trwc net.Conn\n\n\t// remoteAddr is rwc.RemoteAddr().String(). It is not populated synchronously\n\t// inside the Listener's Accept goroutine, as some implementations block.\n\t// It is populated immediately inside the (*conn).serve goroutine.\n\t// This is the value of a Handler's (*Request).RemoteAddr.\n\tremoteAddr string\n\n\t// tlsState is the TLS connection state when using TLS.\n\t// nil means not TLS.\n\ttlsState *tls.ConnectionState\n\n\t// werr is set to the first write error to rwc.\n\t// It is set via checkConnErrorWriter{w}, where bufw writes.\n\twerr error\n\n\t// r is bufr's read source. It's a wrapper around rwc that provides\n\t// io.LimitedReader-style limiting (while reading request headers)\n\t// and functionality to support CloseNotifier. See *connReader docs.\n\tr *connReader\n\n\t// bufr reads from r.\n\tbufr *bufio.Reader\n\n\t// bufw writes to checkConnErrorWriter{c}, which populates werr on error.\n\tbufw *bufio.Writer\n\n\t// lastMethod is the method of the most recent request\n\t// on this connection, if any.\n\tlastMethod string\n\n\tcurReq atomic.Value // of *response (which has a Request in it)\n\n\tcurState struct{ atomic uint64 } // packed (unixtime<<8|uint8(ConnState))\n\n\t// mu guards hijackedv\n\tmu sync.Mutex\n\n\t// hijackedv is whether this connection has been hijacked\n\t// by a Handler with the Hijacker interface.\n\t// It is guarded by mu.\n\thijackedv bool\n}\n```\n\nA conn represents the server side of an HTTP connection. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#conn.close",
                    "documentation": {
                      "identifier": "conn.close",
                      "newPage": false,
                      "searchKey": "http.conn.close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) close()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) close()\n```\n\nClose the connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#conn.closeWriteAndWait",
                    "documentation": {
                      "identifier": "conn.closeWriteAndWait",
                      "newPage": false,
                      "searchKey": "http.conn.closeWriteAndWait",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) closeWriteAndWait()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) closeWriteAndWait()\n```\n\ncloseWrite flushes any outstanding data and sends a FIN packet (if client is connected via TCP), signalling that we're done. We then pause for a bit, hoping the client processes it before any subsequent RST. \n\nSee [https://golang.org/issue/3595](https://golang.org/issue/3595) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#conn.finalFlush",
                    "documentation": {
                      "identifier": "conn.finalFlush",
                      "newPage": false,
                      "searchKey": "http.conn.finalFlush",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) finalFlush()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) finalFlush()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#conn.getState",
                    "documentation": {
                      "identifier": "conn.getState",
                      "newPage": false,
                      "searchKey": "http.conn.getState",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) getState() (state ConnState, unixSec int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) getState() (state ConnState, unixSec int64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#conn.hijackLocked",
                    "documentation": {
                      "identifier": "conn.hijackLocked",
                      "newPage": false,
                      "searchKey": "http.conn.hijackLocked",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) hijackLocked() (rwc net.Conn, buf *bufio.ReadWriter, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) hijackLocked() (rwc net.Conn, buf *bufio.ReadWriter, err error)\n```\n\nc.mu must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#conn.hijacked",
                    "documentation": {
                      "identifier": "conn.hijacked",
                      "newPage": false,
                      "searchKey": "http.conn.hijacked",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) hijacked() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) hijacked() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#conn.readRequest",
                    "documentation": {
                      "identifier": "conn.readRequest",
                      "newPage": false,
                      "searchKey": "http.conn.readRequest",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) readRequest(ctx context.Context) (w *response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) readRequest(ctx context.Context) (w *response, err error)\n```\n\nRead next request from connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#conn.serve",
                    "documentation": {
                      "identifier": "conn.serve",
                      "newPage": false,
                      "searchKey": "http.conn.serve",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) serve(ctx context.Context)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) serve(ctx context.Context)\n```\n\nServe a new connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#conn.setState",
                    "documentation": {
                      "identifier": "conn.setState",
                      "newPage": false,
                      "searchKey": "http.conn.setState",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *conn) setState(nc net.Conn, state ConnState, runHook bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *conn) setState(nc net.Conn, state ConnState, runHook bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#connLRU",
              "documentation": {
                "identifier": "connLRU",
                "newPage": false,
                "searchKey": "http.connLRU",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type connLRU struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype connLRU struct {\n\tll *list.List // list.Element.Value type is of *persistConn\n\tm  map[*persistConn]*list.Element\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#connLRU.add",
                    "documentation": {
                      "identifier": "connLRU.add",
                      "newPage": false,
                      "searchKey": "http.connLRU.add",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cl *connLRU) add(pc *persistConn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cl *connLRU) add(pc *persistConn)\n```\n\nadd adds pc to the head of the linked list. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connLRU.len",
                    "documentation": {
                      "identifier": "connLRU.len",
                      "newPage": false,
                      "searchKey": "http.connLRU.len",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cl *connLRU) len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cl *connLRU) len() int\n```\n\nlen returns the number of items in the cache. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connLRU.remove",
                    "documentation": {
                      "identifier": "connLRU.remove",
                      "newPage": false,
                      "searchKey": "http.connLRU.remove",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cl *connLRU) remove(pc *persistConn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cl *connLRU) remove(pc *persistConn)\n```\n\nremove removes pc from cl. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connLRU.removeOldest",
                    "documentation": {
                      "identifier": "connLRU.removeOldest",
                      "newPage": false,
                      "searchKey": "http.connLRU.removeOldest",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cl *connLRU) removeOldest() *persistConn"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cl *connLRU) removeOldest() *persistConn\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#connReader",
              "documentation": {
                "identifier": "connReader",
                "newPage": false,
                "searchKey": "http.connReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type connReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype connReader struct {\n\tconn *conn\n\n\tmu      sync.Mutex // guards following\n\thasByte bool\n\tbyteBuf [1]byte\n\tcond    *sync.Cond\n\tinRead  bool\n\taborted bool  // set true before conn.rwc deadline is set to past\n\tremain  int64 // bytes remaining\n}\n```\n\nconnReader is the io.Reader wrapper used by *conn. It combines a selectively-activated io.LimitedReader (to bound request header read sizes) with support for selectively keeping an io.Reader.Read call blocked in a background goroutine to wait for activity and trigger a CloseNotifier channel. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#connReader.Read",
                    "documentation": {
                      "identifier": "connReader.Read",
                      "newPage": false,
                      "searchKey": "http.connReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cr *connReader) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cr *connReader) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connReader.abortPendingRead",
                    "documentation": {
                      "identifier": "connReader.abortPendingRead",
                      "newPage": false,
                      "searchKey": "http.connReader.abortPendingRead",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cr *connReader) abortPendingRead()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cr *connReader) abortPendingRead()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connReader.backgroundRead",
                    "documentation": {
                      "identifier": "connReader.backgroundRead",
                      "newPage": false,
                      "searchKey": "http.connReader.backgroundRead",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cr *connReader) backgroundRead()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cr *connReader) backgroundRead()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connReader.closeNotify",
                    "documentation": {
                      "identifier": "connReader.closeNotify",
                      "newPage": false,
                      "searchKey": "http.connReader.closeNotify",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cr *connReader) closeNotify()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cr *connReader) closeNotify()\n```\n\nmay be called from multiple goroutines. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connReader.handleReadError",
                    "documentation": {
                      "identifier": "connReader.handleReadError",
                      "newPage": false,
                      "searchKey": "http.connReader.handleReadError",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cr *connReader) handleReadError(_ error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cr *connReader) handleReadError(_ error)\n```\n\nhandleReadError is called whenever a Read from the client returns a non-nil error. \n\nThe provided non-nil err is almost always io.EOF or a \"use of closed network connection\". In any case, the error is not particularly interesting, except perhaps for debugging during development. Any error means the connection is dead and we should down its context. \n\nIt may be called from multiple goroutines. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connReader.hitReadLimit",
                    "documentation": {
                      "identifier": "connReader.hitReadLimit",
                      "newPage": false,
                      "searchKey": "http.connReader.hitReadLimit",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cr *connReader) hitReadLimit() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cr *connReader) hitReadLimit() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connReader.lock",
                    "documentation": {
                      "identifier": "connReader.lock",
                      "newPage": false,
                      "searchKey": "http.connReader.lock",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cr *connReader) lock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cr *connReader) lock()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connReader.setInfiniteReadLimit",
                    "documentation": {
                      "identifier": "connReader.setInfiniteReadLimit",
                      "newPage": false,
                      "searchKey": "http.connReader.setInfiniteReadLimit",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cr *connReader) setInfiniteReadLimit()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cr *connReader) setInfiniteReadLimit()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connReader.setReadLimit",
                    "documentation": {
                      "identifier": "connReader.setReadLimit",
                      "newPage": false,
                      "searchKey": "http.connReader.setReadLimit",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cr *connReader) setReadLimit(remain int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cr *connReader) setReadLimit(remain int64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connReader.startBackgroundRead",
                    "documentation": {
                      "identifier": "connReader.startBackgroundRead",
                      "newPage": false,
                      "searchKey": "http.connReader.startBackgroundRead",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cr *connReader) startBackgroundRead()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cr *connReader) startBackgroundRead()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connReader.unlock",
                    "documentation": {
                      "identifier": "connReader.unlock",
                      "newPage": false,
                      "searchKey": "http.connReader.unlock",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cr *connReader) unlock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cr *connReader) unlock()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#connectMethod",
              "documentation": {
                "identifier": "connectMethod",
                "newPage": false,
                "searchKey": "http.connectMethod",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type connectMethod struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype connectMethod struct {\n\t_            incomparable\n\tproxyURL     *url.URL // nil for no proxy, else full proxy URL\n\ttargetScheme string   // \"http\" or \"https\"\n\t// If proxyURL specifies an http or https proxy, and targetScheme is http (not https),\n\t// then targetAddr is not included in the connect method key, because the socket can\n\t// be reused for different targetAddr values.\n\ttargetAddr string\n\tonlyH1     bool // whether to disable HTTP/2 and force HTTP/1\n}\n```\n\nconnectMethod is the map key (in its String form) for keeping persistent TCP connections alive for subsequent HTTP requests. \n\nA connect method may be of the following types: \n\n```\nconnectMethod.key().String()      Description\n------------------------------    -------------------------\n|http|foo.com                     http directly to server, no proxy\n|https|foo.com                    https directly to server, no proxy\n|https,h1|foo.com                 https directly to server w/o HTTP/2, no proxy\n[http://proxy.com](http://proxy.com)|https|foo.com    http to proxy, then CONNECT to foo.com\n[http://proxy.com](http://proxy.com)|http             http to proxy, http to anywhere after that\nsocks5://proxy.com|http|foo.com   socks5 to proxy, then http to foo.com\nsocks5://proxy.com|https|foo.com  socks5 to proxy, then https to foo.com\n[https://proxy.com](https://proxy.com)|https|foo.com   https to proxy, then CONNECT to foo.com\n[https://proxy.com](https://proxy.com)|http            https to proxy, http to anywhere after that\n\n```\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#connectMethod.addr",
                    "documentation": {
                      "identifier": "connectMethod.addr",
                      "newPage": false,
                      "searchKey": "http.connectMethod.addr",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cm *connectMethod) addr() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cm *connectMethod) addr() string\n```\n\naddr returns the first hop \"host:port\" to which we need to TCP connect. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connectMethod.key",
                    "documentation": {
                      "identifier": "connectMethod.key",
                      "newPage": false,
                      "searchKey": "http.connectMethod.key",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cm *connectMethod) key() connectMethodKey"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cm *connectMethod) key() connectMethodKey\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connectMethod.proxyAuth",
                    "documentation": {
                      "identifier": "connectMethod.proxyAuth",
                      "newPage": false,
                      "searchKey": "http.connectMethod.proxyAuth",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cm *connectMethod) proxyAuth() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cm *connectMethod) proxyAuth() string\n```\n\nproxyAuth returns the Proxy-Authorization header to set on requests, if applicable. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connectMethod.scheme",
                    "documentation": {
                      "identifier": "connectMethod.scheme",
                      "newPage": false,
                      "searchKey": "http.connectMethod.scheme",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cm *connectMethod) scheme() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cm *connectMethod) scheme() string\n```\n\nscheme returns the first hop scheme: http, https, or socks5 \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#connectMethod.tlsHost",
                    "documentation": {
                      "identifier": "connectMethod.tlsHost",
                      "newPage": false,
                      "searchKey": "http.connectMethod.tlsHost",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cm *connectMethod) tlsHost() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cm *connectMethod) tlsHost() string\n```\n\ntlsHost returns the host name to match against the peer's TLS certificate. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#connectMethodKey",
              "documentation": {
                "identifier": "connectMethodKey",
                "newPage": false,
                "searchKey": "http.connectMethodKey",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type connectMethodKey struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype connectMethodKey struct {\n\tproxy, scheme, addr string\n\tonlyH1              bool\n}\n```\n\nconnectMethodKey is the map key version of connectMethod, with a stringified proxy URL (or the empty string) instead of a pointer to a URL. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#connectMethodKey.String",
                    "documentation": {
                      "identifier": "connectMethodKey.String",
                      "newPage": false,
                      "searchKey": "http.connectMethodKey.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (k connectMethodKey) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (k connectMethodKey) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#contextKey",
              "documentation": {
                "identifier": "contextKey",
                "newPage": false,
                "searchKey": "http.contextKey",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type contextKey struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype contextKey struct {\n\tname string\n}\n```\n\ncontextKey is a value for use with context.WithValue. It's used as a pointer so it fits in an interface{} without allocation. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#contextKey.String",
                    "documentation": {
                      "identifier": "contextKey.String",
                      "newPage": false,
                      "searchKey": "http.contextKey.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (k *contextKey) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (k *contextKey) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#countingWriter",
              "documentation": {
                "identifier": "countingWriter",
                "newPage": false,
                "searchKey": "http.countingWriter",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type countingWriter int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype countingWriter int64\n```\n\ncountingWriter counts how many bytes have been written to it. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#countingWriter.Write",
                    "documentation": {
                      "identifier": "countingWriter.Write",
                      "newPage": false,
                      "searchKey": "http.countingWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *countingWriter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *countingWriter) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#delegateReader",
              "documentation": {
                "identifier": "delegateReader",
                "newPage": false,
                "searchKey": "http.delegateReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type delegateReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype delegateReader struct {\n\tc chan io.Reader\n\tr io.Reader // nil until received from c\n}\n```\n\ndelegateReader is a reader that delegates to another reader, once it arrives on a channel. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#delegateReader.Read",
                    "documentation": {
                      "identifier": "delegateReader.Read",
                      "newPage": false,
                      "searchKey": "http.delegateReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *delegateReader) Read(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *delegateReader) Read(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#dirEntryDirs",
              "documentation": {
                "identifier": "dirEntryDirs",
                "newPage": false,
                "searchKey": "http.dirEntryDirs",
                "tags": [
                  "array",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type dirEntryDirs []fs.DirEntry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dirEntryDirs []fs.DirEntry\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#dirEntryDirs.isDir",
                    "documentation": {
                      "identifier": "dirEntryDirs.isDir",
                      "newPage": false,
                      "searchKey": "http.dirEntryDirs.isDir",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d dirEntryDirs) isDir(i int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d dirEntryDirs) isDir(i int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dirEntryDirs.len",
                    "documentation": {
                      "identifier": "dirEntryDirs.len",
                      "newPage": false,
                      "searchKey": "http.dirEntryDirs.len",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d dirEntryDirs) len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d dirEntryDirs) len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dirEntryDirs.name",
                    "documentation": {
                      "identifier": "dirEntryDirs.name",
                      "newPage": false,
                      "searchKey": "http.dirEntryDirs.name",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d dirEntryDirs) name(i int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d dirEntryDirs) name(i int) string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#dumpConn",
              "documentation": {
                "identifier": "dumpConn",
                "newPage": false,
                "searchKey": "http.dumpConn",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type dumpConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dumpConn struct {\n\tio.Writer\n\tio.Reader\n}\n```\n\ndumpConn is a net.Conn that writes to Writer and reads from Reader. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#dumpConn.Close",
                    "documentation": {
                      "identifier": "dumpConn.Close",
                      "newPage": false,
                      "searchKey": "http.dumpConn.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *dumpConn) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *dumpConn) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dumpConn.LocalAddr",
                    "documentation": {
                      "identifier": "dumpConn.LocalAddr",
                      "newPage": false,
                      "searchKey": "http.dumpConn.LocalAddr",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *dumpConn) LocalAddr() net.Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *dumpConn) LocalAddr() net.Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dumpConn.RemoteAddr",
                    "documentation": {
                      "identifier": "dumpConn.RemoteAddr",
                      "newPage": false,
                      "searchKey": "http.dumpConn.RemoteAddr",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *dumpConn) RemoteAddr() net.Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *dumpConn) RemoteAddr() net.Addr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dumpConn.SetDeadline",
                    "documentation": {
                      "identifier": "dumpConn.SetDeadline",
                      "newPage": false,
                      "searchKey": "http.dumpConn.SetDeadline",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *dumpConn) SetDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *dumpConn) SetDeadline(t time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dumpConn.SetReadDeadline",
                    "documentation": {
                      "identifier": "dumpConn.SetReadDeadline",
                      "newPage": false,
                      "searchKey": "http.dumpConn.SetReadDeadline",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *dumpConn) SetReadDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *dumpConn) SetReadDeadline(t time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#dumpConn.SetWriteDeadline",
                    "documentation": {
                      "identifier": "dumpConn.SetWriteDeadline",
                      "newPage": false,
                      "searchKey": "http.dumpConn.SetWriteDeadline",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *dumpConn) SetWriteDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *dumpConn) SetWriteDeadline(t time.Time) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#erringRoundTripper",
              "documentation": {
                "identifier": "erringRoundTripper",
                "newPage": false,
                "searchKey": "http.erringRoundTripper",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type erringRoundTripper interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype erringRoundTripper interface {\n\tRoundTripErr() error\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#errorReader",
              "documentation": {
                "identifier": "errorReader",
                "newPage": false,
                "searchKey": "http.errorReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type errorReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype errorReader struct {\n\terr error\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#errorReader.Read",
                    "documentation": {
                      "identifier": "errorReader.Read",
                      "newPage": false,
                      "searchKey": "http.errorReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r errorReader) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r errorReader) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#exactSig",
              "documentation": {
                "identifier": "exactSig",
                "newPage": false,
                "searchKey": "http.exactSig",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type exactSig struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype exactSig struct {\n\tsig []byte\n\tct  string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#exactSig.match",
                    "documentation": {
                      "identifier": "exactSig.match",
                      "newPage": false,
                      "searchKey": "http.exactSig.match",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *exactSig) match(data []byte, firstNonWS int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *exactSig) match(data []byte, firstNonWS int) string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#expectContinueReader",
              "documentation": {
                "identifier": "expectContinueReader",
                "newPage": false,
                "searchKey": "http.expectContinueReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type expectContinueReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype expectContinueReader struct {\n\tresp       *response\n\treadCloser io.ReadCloser\n\tclosed     atomicBool\n\tsawEOF     atomicBool\n}\n```\n\nwrapper around io.ReadCloser which on first read, sends an HTTP/1.1 100 Continue header \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#expectContinueReader.Close",
                    "documentation": {
                      "identifier": "expectContinueReader.Close",
                      "newPage": false,
                      "searchKey": "http.expectContinueReader.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ecr *expectContinueReader) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ecr *expectContinueReader) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#expectContinueReader.Read",
                    "documentation": {
                      "identifier": "expectContinueReader.Read",
                      "newPage": false,
                      "searchKey": "http.expectContinueReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ecr *expectContinueReader) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ecr *expectContinueReader) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#extraHeader",
              "documentation": {
                "identifier": "extraHeader",
                "newPage": false,
                "searchKey": "http.extraHeader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type extraHeader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype extraHeader struct {\n\tcontentType      string\n\tconnection       string\n\ttransferEncoding string\n\tdate             []byte // written if not nil\n\tcontentLength    []byte // written if not nil\n}\n```\n\nextraHeader is the set of headers sometimes added by chunkWriter.writeHeader. This type is used to avoid extra allocations from cloning and/or populating the response Header map and all its 1-element slices. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#extraHeader.Write",
                    "documentation": {
                      "identifier": "extraHeader.Write",
                      "newPage": false,
                      "searchKey": "http.extraHeader.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h extraHeader) Write(w *bufio.Writer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h extraHeader) Write(w *bufio.Writer)\n```\n\nWrite writes the headers described in h to w. \n\nThis method has a value receiver, despite the somewhat large size of h, because it prevents an allocation. The escape analysis isn't smart enough to realize this function doesn't mutate h. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#fakeLocker",
              "documentation": {
                "identifier": "fakeLocker",
                "newPage": false,
                "searchKey": "http.fakeLocker",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type fakeLocker struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fakeLocker struct{}\n```\n\nfakeLocker is a sync.Locker which does nothing. It's used to guard test-only fields when not under test, to avoid runtime atomic overhead. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#fakeLocker.Lock",
                    "documentation": {
                      "identifier": "fakeLocker.Lock",
                      "newPage": false,
                      "searchKey": "http.fakeLocker.Lock",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fakeLocker) Lock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fakeLocker) Lock()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#fakeLocker.Unlock",
                    "documentation": {
                      "identifier": "fakeLocker.Unlock",
                      "newPage": false,
                      "searchKey": "http.fakeLocker.Unlock",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fakeLocker) Unlock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fakeLocker) Unlock()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#fileHandler",
              "documentation": {
                "identifier": "fileHandler",
                "newPage": false,
                "searchKey": "http.fileHandler",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type fileHandler struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fileHandler struct {\n\troot FileSystem\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#fileHandler.ServeHTTP",
                    "documentation": {
                      "identifier": "fileHandler.ServeHTTP",
                      "newPage": false,
                      "searchKey": "http.fileHandler.ServeHTTP",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fileHandler) ServeHTTP(w ResponseWriter, r *Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fileHandler) ServeHTTP(w ResponseWriter, r *Request)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#fileInfoDirs",
              "documentation": {
                "identifier": "fileInfoDirs",
                "newPage": false,
                "searchKey": "http.fileInfoDirs",
                "tags": [
                  "array",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type fileInfoDirs []fs.FileInfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fileInfoDirs []fs.FileInfo\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#fileInfoDirs.isDir",
                    "documentation": {
                      "identifier": "fileInfoDirs.isDir",
                      "newPage": false,
                      "searchKey": "http.fileInfoDirs.isDir",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d fileInfoDirs) isDir(i int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d fileInfoDirs) isDir(i int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#fileInfoDirs.len",
                    "documentation": {
                      "identifier": "fileInfoDirs.len",
                      "newPage": false,
                      "searchKey": "http.fileInfoDirs.len",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d fileInfoDirs) len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d fileInfoDirs) len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#fileInfoDirs.name",
                    "documentation": {
                      "identifier": "fileInfoDirs.name",
                      "newPage": false,
                      "searchKey": "http.fileInfoDirs.name",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d fileInfoDirs) name(i int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d fileInfoDirs) name(i int) string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#fileTransport",
              "documentation": {
                "identifier": "fileTransport",
                "newPage": false,
                "searchKey": "http.fileTransport",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type fileTransport struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fileTransport struct {\n\tfh fileHandler\n}\n```\n\nfileTransport implements RoundTripper for the 'file' protocol. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#fileTransport.RoundTrip",
                    "documentation": {
                      "identifier": "fileTransport.RoundTrip",
                      "newPage": false,
                      "searchKey": "http.fileTransport.RoundTrip",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t fileTransport) RoundTrip(req *Request) (resp *Response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t fileTransport) RoundTrip(req *Request) (resp *Response, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#finishAsyncByteRead",
              "documentation": {
                "identifier": "finishAsyncByteRead",
                "newPage": false,
                "searchKey": "http.finishAsyncByteRead",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type finishAsyncByteRead struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype finishAsyncByteRead struct {\n\ttw *transferWriter\n}\n```\n\nfinishAsyncByteRead finishes reading the 1-byte sniff from the ContentLength==0, Body!=nil case. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#finishAsyncByteRead.Read",
                    "documentation": {
                      "identifier": "finishAsyncByteRead.Read",
                      "newPage": false,
                      "searchKey": "http.finishAsyncByteRead.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr finishAsyncByteRead) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr finishAsyncByteRead) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#globalOptionsHandler",
              "documentation": {
                "identifier": "globalOptionsHandler",
                "newPage": false,
                "searchKey": "http.globalOptionsHandler",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type globalOptionsHandler struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype globalOptionsHandler struct{}\n```\n\nglobalOptionsHandler responds to \"OPTIONS *\" requests. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#globalOptionsHandler.ServeHTTP",
                    "documentation": {
                      "identifier": "globalOptionsHandler.ServeHTTP",
                      "newPage": false,
                      "searchKey": "http.globalOptionsHandler.ServeHTTP",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (globalOptionsHandler) ServeHTTP(w ResponseWriter, r *Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (globalOptionsHandler) ServeHTTP(w ResponseWriter, r *Request)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#gzipReader",
              "documentation": {
                "identifier": "gzipReader",
                "newPage": false,
                "searchKey": "http.gzipReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type gzipReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gzipReader struct {\n\t_    incomparable\n\tbody *bodyEOFSignal // underlying HTTP/1 response body framing\n\tzr   *gzip.Reader   // lazily-initialized gzip reader\n\tzerr error          // any error from gzip.NewReader; sticky\n}\n```\n\ngzipReader wraps a response body so it can lazily call gzip.NewReader on the first call to Read \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#gzipReader.Close",
                    "documentation": {
                      "identifier": "gzipReader.Close",
                      "newPage": false,
                      "searchKey": "http.gzipReader.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (gz *gzipReader) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (gz *gzipReader) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#gzipReader.Read",
                    "documentation": {
                      "identifier": "gzipReader.Read",
                      "newPage": false,
                      "searchKey": "http.gzipReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (gz *gzipReader) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (gz *gzipReader) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#h2Transport",
              "documentation": {
                "identifier": "h2Transport",
                "newPage": false,
                "searchKey": "http.h2Transport",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type h2Transport interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype h2Transport interface {\n\tCloseIdleConnections()\n}\n```\n\nh2Transport is the interface we expect to be able to call from net/http against an *http2.Transport that's either bundled into h2_bundle.go or supplied by the user via x/net/http2. \n\nWe name it with the \"h2\" prefix to stay out of the \"http2\" prefix namespace used by x/tools/cmd/bundle for h2_bundle.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#hasTokenTest",
              "documentation": {
                "identifier": "hasTokenTest",
                "newPage": false,
                "searchKey": "http.hasTokenTest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type hasTokenTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype hasTokenTest struct {\n\theader string\n\ttoken  string\n\twant   bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#headerOnlyResponseWriter",
              "documentation": {
                "identifier": "headerOnlyResponseWriter",
                "newPage": false,
                "searchKey": "http.headerOnlyResponseWriter",
                "tags": [
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type headerOnlyResponseWriter http.Header"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype headerOnlyResponseWriter Header\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#headerOnlyResponseWriter.Header",
                    "documentation": {
                      "identifier": "headerOnlyResponseWriter.Header",
                      "newPage": false,
                      "searchKey": "http.headerOnlyResponseWriter.Header",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ho headerOnlyResponseWriter) Header() Header"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ho headerOnlyResponseWriter) Header() Header\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#headerOnlyResponseWriter.Write",
                    "documentation": {
                      "identifier": "headerOnlyResponseWriter.Write",
                      "newPage": false,
                      "searchKey": "http.headerOnlyResponseWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ho headerOnlyResponseWriter) Write([]byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ho headerOnlyResponseWriter) Write([]byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#headerOnlyResponseWriter.WriteHeader",
                    "documentation": {
                      "identifier": "headerOnlyResponseWriter.WriteHeader",
                      "newPage": false,
                      "searchKey": "http.headerOnlyResponseWriter.WriteHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ho headerOnlyResponseWriter) WriteHeader(int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ho headerOnlyResponseWriter) WriteHeader(int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#headerSorter",
              "documentation": {
                "identifier": "headerSorter",
                "newPage": false,
                "searchKey": "http.headerSorter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type headerSorter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype headerSorter struct {\n\tkvs []keyValues\n}\n```\n\nA headerSorter implements sort.Interface by sorting a []keyValues by key. It's used as a pointer, so it can fit in a sort.Interface interface value without allocation. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#headerSorter.Len",
                    "documentation": {
                      "identifier": "headerSorter.Len",
                      "newPage": false,
                      "searchKey": "http.headerSorter.Len",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *headerSorter) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *headerSorter) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#headerSorter.Less",
                    "documentation": {
                      "identifier": "headerSorter.Less",
                      "newPage": false,
                      "searchKey": "http.headerSorter.Less",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *headerSorter) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *headerSorter) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#headerSorter.Swap",
                    "documentation": {
                      "identifier": "headerSorter.Swap",
                      "newPage": false,
                      "searchKey": "http.headerSorter.Swap",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *headerSorter) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *headerSorter) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#htmlSig",
              "documentation": {
                "identifier": "htmlSig",
                "newPage": false,
                "searchKey": "http.htmlSig",
                "tags": [
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type htmlSig []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype htmlSig []byte\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#htmlSig.match",
                    "documentation": {
                      "identifier": "htmlSig.match",
                      "newPage": false,
                      "searchKey": "http.htmlSig.match",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h htmlSig) match(data []byte, firstNonWS int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h htmlSig) match(data []byte, firstNonWS int) string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ClientConn",
              "documentation": {
                "identifier": "http2ClientConn",
                "newPage": false,
                "searchKey": "http.http2ClientConn",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2ClientConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2ClientConn struct {\n\tt         *http2Transport\n\ttconn     net.Conn             // usually *tls.Conn, except specialized impls\n\ttlsState  *tls.ConnectionState // nil only for specialized impls\n\treused    uint32               // whether conn is being reused; atomic\n\tsingleUse bool                 // whether being used for a single http.Request\n\n\t// readLoop goroutine fields:\n\treaderDone chan struct{} // closed on error\n\treaderErr  error         // set before readerDone is closed\n\n\tidleTimeout time.Duration // or 0 for never\n\tidleTimer   *time.Timer\n\n\tmu              sync.Mutex // guards following\n\tcond            *sync.Cond // hold mu; broadcast on flow/closed changes\n\tflow            http2flow  // our conn-level flow control quota (cs.flow is per stream)\n\tinflow          http2flow  // peer's conn-level flow control\n\tclosing         bool\n\tclosed          bool\n\twantSettingsAck bool                          // we sent a SETTINGS frame and haven't heard back\n\tgoAway          *http2GoAwayFrame             // if non-nil, the GoAwayFrame we received\n\tgoAwayDebug     string                        // goAway frame's debug data, retained as a string\n\tstreams         map[uint32]*http2clientStream // client-initiated\n\tnextStreamID    uint32\n\tpendingRequests int                       // requests blocked and waiting to be sent because len(streams) == maxConcurrentStreams\n\tpings           map[[8]byte]chan struct{} // in flight ping data to notification channel\n\tbw              *bufio.Writer\n\tbr              *bufio.Reader\n\tfr              *http2Framer\n\tlastActive      time.Time\n\tlastIdle        time.Time // time last idle\n\t// Settings from peer: (also guarded by mu)\n\tmaxFrameSize          uint32\n\tmaxConcurrentStreams  uint32\n\tpeerMaxHeaderListSize uint64\n\tinitialWindowSize     uint32\n\n\thbuf    bytes.Buffer // HPACK encoder writes into this\n\thenc    *hpack.Encoder\n\tfreeBuf [][]byte\n\n\twmu  sync.Mutex // held while writing; acquire AFTER mu if holding both\n\twerr error      // first write error that has occurred\n}\n```\n\nClientConn is the state of a single HTTP/2 client connection to an HTTP/2 server. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.CanTakeNewRequest",
                    "documentation": {
                      "identifier": "http2ClientConn.CanTakeNewRequest",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.CanTakeNewRequest",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) CanTakeNewRequest() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) CanTakeNewRequest() bool\n```\n\nCanTakeNewRequest reports whether the connection can take a new request, meaning it has not been closed or received or sent a GOAWAY. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.Close",
                    "documentation": {
                      "identifier": "http2ClientConn.Close",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) Close() error\n```\n\nClose closes the client connection immediately. \n\nIn-flight requests are interrupted. For a graceful shutdown, use Shutdown instead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.Ping",
                    "documentation": {
                      "identifier": "http2ClientConn.Ping",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.Ping",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) Ping(ctx context.Context) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) Ping(ctx context.Context) error\n```\n\nPing sends a PING frame to the server and waits for the ack. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.RoundTrip",
                    "documentation": {
                      "identifier": "http2ClientConn.RoundTrip",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.RoundTrip",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) RoundTrip(req *Request) (*Response, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) RoundTrip(req *Request) (*Response, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.Shutdown",
                    "documentation": {
                      "identifier": "http2ClientConn.Shutdown",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.Shutdown",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) Shutdown(ctx context.Context) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) Shutdown(ctx context.Context) error\n```\n\nShutdown gracefully close the client connection, waiting for running streams to complete. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.awaitOpenSlotForRequest",
                    "documentation": {
                      "identifier": "http2ClientConn.awaitOpenSlotForRequest",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.awaitOpenSlotForRequest",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) awaitOpenSlotForRequest(req *Request) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) awaitOpenSlotForRequest(req *Request) error\n```\n\nawaitOpenSlotForRequest waits until len(streams) < maxConcurrentStreams. Must hold cc.mu. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.canTakeNewRequestLocked",
                    "documentation": {
                      "identifier": "http2ClientConn.canTakeNewRequestLocked",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.canTakeNewRequestLocked",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) canTakeNewRequestLocked() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) canTakeNewRequestLocked() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.closeForError",
                    "documentation": {
                      "identifier": "http2ClientConn.closeForError",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.closeForError",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) closeForError(err error) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) closeForError(err error) error\n```\n\ncloses the client connection immediately. In-flight requests are interrupted. err is sent to streams. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.closeForLostPing",
                    "documentation": {
                      "identifier": "http2ClientConn.closeForLostPing",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.closeForLostPing",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) closeForLostPing() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) closeForLostPing() error\n```\n\ncloses the client connection immediately. In-flight requests are interrupted. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.closeIfIdle",
                    "documentation": {
                      "identifier": "http2ClientConn.closeIfIdle",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.closeIfIdle",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) closeIfIdle()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) closeIfIdle()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.encodeHeaders",
                    "documentation": {
                      "identifier": "http2ClientConn.encodeHeaders",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.encodeHeaders",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) encodeHeaders(req *Request, addGzipHeader bool, trailers string, contentLength int64) ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) encodeHeaders(req *Request, addGzipHeader bool, trailers string, contentLength int64) ([]byte, error)\n```\n\nrequires cc.mu be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.encodeTrailers",
                    "documentation": {
                      "identifier": "http2ClientConn.encodeTrailers",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.encodeTrailers",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) encodeTrailers(req *Request) ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) encodeTrailers(req *Request) ([]byte, error)\n```\n\nrequires cc.mu be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.forgetStreamID",
                    "documentation": {
                      "identifier": "http2ClientConn.forgetStreamID",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.forgetStreamID",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) forgetStreamID(id uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) forgetStreamID(id uint32)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.frameScratchBuffer",
                    "documentation": {
                      "identifier": "http2ClientConn.frameScratchBuffer",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.frameScratchBuffer",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) frameScratchBuffer() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) frameScratchBuffer() []byte\n```\n\nframeBuffer returns a scratch buffer suitable for writing DATA frames. They're capped at the min of the peer's max frame size or 512KB (kinda arbitrarily), but definitely capped so we don't allocate 4GB bufers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.healthCheck",
                    "documentation": {
                      "identifier": "http2ClientConn.healthCheck",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.healthCheck",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) healthCheck()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) healthCheck()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.idleState",
                    "documentation": {
                      "identifier": "http2ClientConn.idleState",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.idleState",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) idleState() http2clientConnIdleState"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) idleState() http2clientConnIdleState\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.idleStateLocked",
                    "documentation": {
                      "identifier": "http2ClientConn.idleStateLocked",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.idleStateLocked",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) idleStateLocked() (st http2clientConnIdleState)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) idleStateLocked() (st http2clientConnIdleState)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.logf",
                    "documentation": {
                      "identifier": "http2ClientConn.logf",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.logf",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) logf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) logf(format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.newStream",
                    "documentation": {
                      "identifier": "http2ClientConn.newStream",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.newStream",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) newStream() *http2clientStream"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) newStream() *http2clientStream\n```\n\nrequires cc.mu be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.onIdleTimeout",
                    "documentation": {
                      "identifier": "http2ClientConn.onIdleTimeout",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.onIdleTimeout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) onIdleTimeout()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) onIdleTimeout()\n```\n\nonIdleTimeout is called from a time.AfterFunc goroutine. It will only be called when we're idle, but because we're coming from a new goroutine, there could be a new request coming in at the same time, so this simply calls the synchronized closeIfIdle to shut down this connection. The timer could just call closeIfIdle, but this is more clear. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.putFrameScratchBuffer",
                    "documentation": {
                      "identifier": "http2ClientConn.putFrameScratchBuffer",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.putFrameScratchBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) putFrameScratchBuffer(buf []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) putFrameScratchBuffer(buf []byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.readLoop",
                    "documentation": {
                      "identifier": "http2ClientConn.readLoop",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.readLoop",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) readLoop()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) readLoop()\n```\n\nreadLoop runs in its own goroutine and reads and dispatches frames. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.responseHeaderTimeout",
                    "documentation": {
                      "identifier": "http2ClientConn.responseHeaderTimeout",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.responseHeaderTimeout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) responseHeaderTimeout() time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) responseHeaderTimeout() time.Duration\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.roundTrip",
                    "documentation": {
                      "identifier": "http2ClientConn.roundTrip",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.roundTrip",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) roundTrip(req *Request) (res *Response, gotErrAfterReqBodyWrite bool, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) roundTrip(req *Request) (res *Response, gotErrAfterReqBodyWrite bool, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.sendGoAway",
                    "documentation": {
                      "identifier": "http2ClientConn.sendGoAway",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.sendGoAway",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) sendGoAway() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) sendGoAway() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.setGoAway",
                    "documentation": {
                      "identifier": "http2ClientConn.setGoAway",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.setGoAway",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) setGoAway(f *http2GoAwayFrame)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) setGoAway(f *http2GoAwayFrame)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.streamByID",
                    "documentation": {
                      "identifier": "http2ClientConn.streamByID",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.streamByID",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) streamByID(id uint32, andRemove bool) *http2clientStream"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) streamByID(id uint32, andRemove bool) *http2clientStream\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.tooIdleLocked",
                    "documentation": {
                      "identifier": "http2ClientConn.tooIdleLocked",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.tooIdleLocked",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) tooIdleLocked() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) tooIdleLocked() bool\n```\n\ntooIdleLocked reports whether this connection has been been sitting idle for too much wall time. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.vlogf",
                    "documentation": {
                      "identifier": "http2ClientConn.vlogf",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.vlogf",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) vlogf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) vlogf(format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.writeHeader",
                    "documentation": {
                      "identifier": "http2ClientConn.writeHeader",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.writeHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) writeHeader(name, value string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) writeHeader(name, value string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.writeHeaders",
                    "documentation": {
                      "identifier": "http2ClientConn.writeHeaders",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.writeHeaders",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) writeHeaders(streamID uint32, endStream bool, maxFrameSize int, hdrs []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) writeHeaders(streamID uint32, endStream bool, maxFrameSize int, hdrs []byte) error\n```\n\nrequires cc.wmu be held \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ClientConn.writeStreamReset",
                    "documentation": {
                      "identifier": "http2ClientConn.writeStreamReset",
                      "newPage": false,
                      "searchKey": "http.http2ClientConn.writeStreamReset",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cc *http2ClientConn) writeStreamReset(streamID uint32, code http2ErrCode, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cc *http2ClientConn) writeStreamReset(streamID uint32, code http2ErrCode, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ClientConnPool",
              "documentation": {
                "identifier": "http2ClientConnPool",
                "newPage": false,
                "searchKey": "http.http2ClientConnPool",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2ClientConnPool interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2ClientConnPool interface {\n\tGetClientConn(req *Request, addr string) (*http2ClientConn, error)\n\tMarkDead(*http2ClientConn)\n}\n```\n\nClientConnPool manages a pool of HTTP/2 client connections. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ConnectionError",
              "documentation": {
                "identifier": "http2ConnectionError",
                "newPage": false,
                "searchKey": "http.http2ConnectionError",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2ConnectionError http.http2ErrCode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2ConnectionError http2ErrCode\n```\n\nConnectionError is an error that results in the termination of the entire connection. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2ConnectionError.Error",
                    "documentation": {
                      "identifier": "http2ConnectionError.Error",
                      "newPage": false,
                      "searchKey": "http.http2ConnectionError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e http2ConnectionError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e http2ConnectionError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ContinuationFrame",
              "documentation": {
                "identifier": "http2ContinuationFrame",
                "newPage": false,
                "searchKey": "http.http2ContinuationFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2ContinuationFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2ContinuationFrame struct {\n\thttp2FrameHeader\n\theaderFragBuf []byte\n}\n```\n\nA ContinuationFrame is used to continue a sequence of header block fragments. See [http://http2.github.io/http2-spec/#rfc.section.6.10](http://http2.github.io/http2-spec/#rfc.section.6.10) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2ContinuationFrame.HeaderBlockFragment",
                    "documentation": {
                      "identifier": "http2ContinuationFrame.HeaderBlockFragment",
                      "newPage": false,
                      "searchKey": "http.http2ContinuationFrame.HeaderBlockFragment",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2ContinuationFrame) HeaderBlockFragment() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2ContinuationFrame) HeaderBlockFragment() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ContinuationFrame.HeadersEnded",
                    "documentation": {
                      "identifier": "http2ContinuationFrame.HeadersEnded",
                      "newPage": false,
                      "searchKey": "http.http2ContinuationFrame.HeadersEnded",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2ContinuationFrame) HeadersEnded() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2ContinuationFrame) HeadersEnded() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2DataFrame",
              "documentation": {
                "identifier": "http2DataFrame",
                "newPage": false,
                "searchKey": "http.http2DataFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2DataFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2DataFrame struct {\n\thttp2FrameHeader\n\tdata []byte\n}\n```\n\nA DataFrame conveys arbitrary, variable-length sequences of octets associated with a stream. See [http://http2.github.io/http2-spec/#rfc.section.6.1](http://http2.github.io/http2-spec/#rfc.section.6.1) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2DataFrame.Data",
                    "documentation": {
                      "identifier": "http2DataFrame.Data",
                      "newPage": false,
                      "searchKey": "http.http2DataFrame.Data",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2DataFrame) Data() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2DataFrame) Data() []byte\n```\n\nData returns the frame's data octets, not including any padding size byte or padding suffix bytes. The caller must not retain the returned memory past the next call to ReadFrame. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2DataFrame.StreamEnded",
                    "documentation": {
                      "identifier": "http2DataFrame.StreamEnded",
                      "newPage": false,
                      "searchKey": "http.http2DataFrame.StreamEnded",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2DataFrame) StreamEnded() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2DataFrame) StreamEnded() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ErrCode",
              "documentation": {
                "identifier": "http2ErrCode",
                "newPage": false,
                "searchKey": "http.http2ErrCode",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2ErrCode uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2ErrCode uint32\n```\n\nAn ErrCode is an unsigned 32-bit error code as defined in the HTTP/2 spec. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2ErrCode.String",
                    "documentation": {
                      "identifier": "http2ErrCode.String",
                      "newPage": false,
                      "searchKey": "http.http2ErrCode.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e http2ErrCode) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e http2ErrCode) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2Flags",
              "documentation": {
                "identifier": "http2Flags",
                "newPage": false,
                "searchKey": "http.http2Flags",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2Flags uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2Flags uint8\n```\n\nFlags is a bitmask of HTTP/2 flags. The meaning of flags varies depending on the frame type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2Flags.Has",
                    "documentation": {
                      "identifier": "http2Flags.Has",
                      "newPage": false,
                      "searchKey": "http.http2Flags.Has",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f http2Flags) Has(v http2Flags) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f http2Flags) Has(v http2Flags) bool\n```\n\nHas reports whether f contains all (0 or more) flags in v. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2Frame",
              "documentation": {
                "identifier": "http2Frame",
                "newPage": false,
                "searchKey": "http.http2Frame",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2Frame interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2Frame interface {\n\tHeader() http2FrameHeader\n\n\t// invalidate is called by Framer.ReadFrame to make this\n\t// frame's buffers as being invalid, since the subsequent\n\t// frame will reuse them.\n\tinvalidate()\n}\n```\n\nA Frame is the base interface implemented by all frame types. Callers will generally type-assert the specific frame type: *HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc. \n\nFrames are only valid until the next call to Framer.ReadFrame. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2parseContinuationFrame",
                    "documentation": {
                      "identifier": "http2parseContinuationFrame",
                      "newPage": false,
                      "searchKey": "http.http2parseContinuationFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2parseContinuationFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2parseContinuationFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2parseDataFrame",
                    "documentation": {
                      "identifier": "http2parseDataFrame",
                      "newPage": false,
                      "searchKey": "http.http2parseDataFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2parseDataFrame(fc *http2frameCache, fh http2FrameHeader, payload []byte) (http2Frame, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2parseDataFrame(fc *http2frameCache, fh http2FrameHeader, payload []byte) (http2Frame, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2parseGoAwayFrame",
                    "documentation": {
                      "identifier": "http2parseGoAwayFrame",
                      "newPage": false,
                      "searchKey": "http.http2parseGoAwayFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2parseGoAwayFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2parseGoAwayFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2parseHeadersFrame",
                    "documentation": {
                      "identifier": "http2parseHeadersFrame",
                      "newPage": false,
                      "searchKey": "http.http2parseHeadersFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2parseHeadersFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (_ http2Frame, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2parseHeadersFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (_ http2Frame, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2parsePingFrame",
                    "documentation": {
                      "identifier": "http2parsePingFrame",
                      "newPage": false,
                      "searchKey": "http.http2parsePingFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2parsePingFrame(_ *http2frameCache, fh http2FrameHeader, payload []byte) (http2Frame, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2parsePingFrame(_ *http2frameCache, fh http2FrameHeader, payload []byte) (http2Frame, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2parsePriorityFrame",
                    "documentation": {
                      "identifier": "http2parsePriorityFrame",
                      "newPage": false,
                      "searchKey": "http.http2parsePriorityFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2parsePriorityFrame(_ *http2frameCache, fh http2FrameHeader, payload []byte) (http2Frame, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2parsePriorityFrame(_ *http2frameCache, fh http2FrameHeader, payload []byte) (http2Frame, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2parsePushPromise",
                    "documentation": {
                      "identifier": "http2parsePushPromise",
                      "newPage": false,
                      "searchKey": "http.http2parsePushPromise",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2parsePushPromise(_ *http2frameCache, fh http2FrameHeader, p []byte) (_ http2Frame, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2parsePushPromise(_ *http2frameCache, fh http2FrameHeader, p []byte) (_ http2Frame, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2parseRSTStreamFrame",
                    "documentation": {
                      "identifier": "http2parseRSTStreamFrame",
                      "newPage": false,
                      "searchKey": "http.http2parseRSTStreamFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2parseRSTStreamFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2parseRSTStreamFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2parseSettingsFrame",
                    "documentation": {
                      "identifier": "http2parseSettingsFrame",
                      "newPage": false,
                      "searchKey": "http.http2parseSettingsFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2parseSettingsFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2parseSettingsFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2parseUnknownFrame",
                    "documentation": {
                      "identifier": "http2parseUnknownFrame",
                      "newPage": false,
                      "searchKey": "http.http2parseUnknownFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2parseUnknownFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2parseUnknownFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2parseWindowUpdateFrame",
                    "documentation": {
                      "identifier": "http2parseWindowUpdateFrame",
                      "newPage": false,
                      "searchKey": "http.http2parseWindowUpdateFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2parseWindowUpdateFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2parseWindowUpdateFrame(_ *http2frameCache, fh http2FrameHeader, p []byte) (http2Frame, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FrameHeader",
              "documentation": {
                "identifier": "http2FrameHeader",
                "newPage": false,
                "searchKey": "http.http2FrameHeader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2FrameHeader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2FrameHeader struct {\n\tvalid bool // caller can access []byte fields in the Frame\n\n\t// Type is the 1 byte frame type. There are ten standard frame\n\t// types, but extension frame types may be written by WriteRawFrame\n\t// and will be returned by ReadFrame (as UnknownFrame).\n\tType http2FrameType\n\n\t// Flags are the 1 byte of 8 potential bit flags per frame.\n\t// They are specific to the frame type.\n\tFlags http2Flags\n\n\t// Length is the length of the frame, not including the 9 byte header.\n\t// The maximum size is one byte less than 16MB (uint24), but only\n\t// frames up to 16KB are allowed without peer agreement.\n\tLength uint32\n\n\t// StreamID is which stream this frame is for. Certain frames\n\t// are not stream-specific, in which case this field is 0.\n\tStreamID uint32\n}\n```\n\nA FrameHeader is the 9 byte header of all HTTP/2 frames. \n\nSee [http://http2.github.io/http2-spec/#FrameHeader](http://http2.github.io/http2-spec/#FrameHeader) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2ReadFrameHeader",
                    "documentation": {
                      "identifier": "http2ReadFrameHeader",
                      "newPage": false,
                      "searchKey": "http.http2ReadFrameHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2ReadFrameHeader(r io.Reader) (http2FrameHeader, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2ReadFrameHeader(r io.Reader) (http2FrameHeader, error)\n```\n\nReadFrameHeader reads 9 bytes from r and returns a FrameHeader. Most users should use Framer.ReadFrame instead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2readFrameHeader",
                    "documentation": {
                      "identifier": "http2readFrameHeader",
                      "newPage": false,
                      "searchKey": "http.http2readFrameHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2readFrameHeader(buf []byte, r io.Reader) (http2FrameHeader, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2readFrameHeader(buf []byte, r io.Reader) (http2FrameHeader, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2FrameHeader.Header",
                    "documentation": {
                      "identifier": "http2FrameHeader.Header",
                      "newPage": false,
                      "searchKey": "http.http2FrameHeader.Header",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h http2FrameHeader) Header() http2FrameHeader"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h http2FrameHeader) Header() http2FrameHeader\n```\n\nHeader returns h. It exists so FrameHeaders can be embedded in other specific frame types and implement the Frame interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2FrameHeader.String",
                    "documentation": {
                      "identifier": "http2FrameHeader.String",
                      "newPage": false,
                      "searchKey": "http.http2FrameHeader.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h http2FrameHeader) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h http2FrameHeader) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2FrameHeader.checkValid",
                    "documentation": {
                      "identifier": "http2FrameHeader.checkValid",
                      "newPage": false,
                      "searchKey": "http.http2FrameHeader.checkValid",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *http2FrameHeader) checkValid()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *http2FrameHeader) checkValid()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2FrameHeader.invalidate",
                    "documentation": {
                      "identifier": "http2FrameHeader.invalidate",
                      "newPage": false,
                      "searchKey": "http.http2FrameHeader.invalidate",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *http2FrameHeader) invalidate()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *http2FrameHeader) invalidate()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2FrameHeader.writeDebug",
                    "documentation": {
                      "identifier": "http2FrameHeader.writeDebug",
                      "newPage": false,
                      "searchKey": "http.http2FrameHeader.writeDebug",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h http2FrameHeader) writeDebug(buf *bytes.Buffer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h http2FrameHeader) writeDebug(buf *bytes.Buffer)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FrameType",
              "documentation": {
                "identifier": "http2FrameType",
                "newPage": false,
                "searchKey": "http.http2FrameType",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2FrameType uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2FrameType uint8\n```\n\nA FrameType is a registered frame type as defined in [http://http2.github.io/http2-spec/#rfc.section.11.2](http://http2.github.io/http2-spec/#rfc.section.11.2) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2FrameType.String",
                    "documentation": {
                      "identifier": "http2FrameType.String",
                      "newPage": false,
                      "searchKey": "http.http2FrameType.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t http2FrameType) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t http2FrameType) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2FrameWriteRequest",
              "documentation": {
                "identifier": "http2FrameWriteRequest",
                "newPage": false,
                "searchKey": "http.http2FrameWriteRequest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2FrameWriteRequest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2FrameWriteRequest struct {\n\t// write is the interface value that does the writing, once the\n\t// WriteScheduler has selected this frame to write. The write\n\t// functions are all defined in write.go.\n\twrite http2writeFramer\n\n\t// stream is the stream on which this frame will be written.\n\t// nil for non-stream frames like PING and SETTINGS.\n\tstream *http2stream\n\n\t// done, if non-nil, must be a buffered channel with space for\n\t// 1 message and is sent the return value from write (or an\n\t// earlier error) when the frame has been written.\n\tdone chan error\n}\n```\n\nFrameWriteRequest is a request to write a frame. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2FrameWriteRequest.Consume",
                    "documentation": {
                      "identifier": "http2FrameWriteRequest.Consume",
                      "newPage": false,
                      "searchKey": "http.http2FrameWriteRequest.Consume",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (wr http2FrameWriteRequest) Consume(n int32) (http2FrameWriteRequest, http2FrameWriteRequest, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (wr http2FrameWriteRequest) Consume(n int32) (http2FrameWriteRequest, http2FrameWriteRequest, int)\n```\n\nConsume consumes min(n, available) bytes from this frame, where available is the number of flow control bytes available on the stream. Consume returns 0, 1, or 2 frames, where the integer return value gives the number of frames returned. \n\nIf flow control prevents consuming any bytes, this returns (_, _, 0). If the entire frame was consumed, this returns (wr, _, 1). Otherwise, this returns (consumed, rest, 2), where 'consumed' contains the consumed bytes and 'rest' contains the remaining bytes. The consumed bytes are deducted from the underlying stream's flow control budget. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2FrameWriteRequest.DataSize",
                    "documentation": {
                      "identifier": "http2FrameWriteRequest.DataSize",
                      "newPage": false,
                      "searchKey": "http.http2FrameWriteRequest.DataSize",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (wr http2FrameWriteRequest) DataSize() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (wr http2FrameWriteRequest) DataSize() int\n```\n\nDataSize returns the number of flow control bytes that must be consumed to write this entire frame. This is 0 for non-DATA frames. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2FrameWriteRequest.StreamID",
                    "documentation": {
                      "identifier": "http2FrameWriteRequest.StreamID",
                      "newPage": false,
                      "searchKey": "http.http2FrameWriteRequest.StreamID",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (wr http2FrameWriteRequest) StreamID() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (wr http2FrameWriteRequest) StreamID() uint32\n```\n\nStreamID returns the id of the stream this frame will be written to. 0 is used for non-stream frames such as PING and SETTINGS. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2FrameWriteRequest.String",
                    "documentation": {
                      "identifier": "http2FrameWriteRequest.String",
                      "newPage": false,
                      "searchKey": "http.http2FrameWriteRequest.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (wr http2FrameWriteRequest) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (wr http2FrameWriteRequest) String() string\n```\n\nString is for debugging only. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2FrameWriteRequest.isControl",
                    "documentation": {
                      "identifier": "http2FrameWriteRequest.isControl",
                      "newPage": false,
                      "searchKey": "http.http2FrameWriteRequest.isControl",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (wr http2FrameWriteRequest) isControl() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (wr http2FrameWriteRequest) isControl() bool\n```\n\nisControl reports whether wr is a control frame for MaxQueuedControlFrames purposes. That includes non-stream frames and RST_STREAM frames. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2FrameWriteRequest.replyToWriter",
                    "documentation": {
                      "identifier": "http2FrameWriteRequest.replyToWriter",
                      "newPage": false,
                      "searchKey": "http.http2FrameWriteRequest.replyToWriter",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (wr *http2FrameWriteRequest) replyToWriter(err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (wr *http2FrameWriteRequest) replyToWriter(err error)\n```\n\nreplyToWriter sends err to wr.done and panics if the send must block This does nothing if wr.done is nil. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2Framer",
              "documentation": {
                "identifier": "http2Framer",
                "newPage": false,
                "searchKey": "http.http2Framer",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2Framer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2Framer struct {\n\tr         io.Reader\n\tlastFrame http2Frame\n\terrDetail error\n\n\t// lastHeaderStream is non-zero if the last frame was an\n\t// unfinished HEADERS/CONTINUATION.\n\tlastHeaderStream uint32\n\n\tmaxReadSize uint32\n\theaderBuf   [http2frameHeaderLen]byte\n\n\t// TODO: let getReadBuf be configurable, and use a less memory-pinning\n\t// allocator in server.go to minimize memory pinned for many idle conns.\n\t// Will probably also need to make frame invalidation have a hook too.\n\tgetReadBuf func(size uint32) []byte\n\treadBuf    []byte // cache for default getReadBuf\n\n\tmaxWriteSize uint32 // zero means unlimited; TODO: implement\n\n\tw    io.Writer\n\twbuf []byte\n\n\t// AllowIllegalWrites permits the Framer's Write methods to\n\t// write frames that do not conform to the HTTP/2 spec. This\n\t// permits using the Framer to test other HTTP/2\n\t// implementations' conformance to the spec.\n\t// If false, the Write methods will prefer to return an error\n\t// rather than comply.\n\tAllowIllegalWrites bool\n\n\t// AllowIllegalReads permits the Framer's ReadFrame method\n\t// to return non-compliant frames or frame orders.\n\t// This is for testing and permits using the Framer to test\n\t// other HTTP/2 implementations' conformance to the spec.\n\t// It is not compatible with ReadMetaHeaders.\n\tAllowIllegalReads bool\n\n\t// ReadMetaHeaders if non-nil causes ReadFrame to merge\n\t// HEADERS and CONTINUATION frames together and return\n\t// MetaHeadersFrame instead.\n\tReadMetaHeaders *hpack.Decoder\n\n\t// MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.\n\t// It's used only if ReadMetaHeaders is set; 0 means a sane default\n\t// (currently 16MB)\n\t// If the limit is hit, MetaHeadersFrame.Truncated is set true.\n\tMaxHeaderListSize uint32\n\n\tlogReads, logWrites bool\n\n\tdebugFramer       *http2Framer // only use for logging written writes\n\tdebugFramerBuf    *bytes.Buffer\n\tdebugReadLoggerf  func(string, ...interface{})\n\tdebugWriteLoggerf func(string, ...interface{})\n\n\tframeCache *http2frameCache // nil if frames aren't reused (default)\n}\n```\n\nA Framer reads and writes Frames. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2NewFramer",
                    "documentation": {
                      "identifier": "http2NewFramer",
                      "newPage": false,
                      "searchKey": "http.http2NewFramer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2NewFramer(w io.Writer, r io.Reader) *http2Framer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2NewFramer(w io.Writer, r io.Reader) *http2Framer\n```\n\nNewFramer returns a Framer that writes frames to w and reads them from r. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.ErrorDetail",
                    "documentation": {
                      "identifier": "http2Framer.ErrorDetail",
                      "newPage": false,
                      "searchKey": "http.http2Framer.ErrorDetail",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr *http2Framer) ErrorDetail() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr *http2Framer) ErrorDetail() error\n```\n\nErrorDetail returns a more detailed error of the last error returned by Framer.ReadFrame. For instance, if ReadFrame returns a StreamError with code PROTOCOL_ERROR, ErrorDetail will say exactly what was invalid. ErrorDetail is not guaranteed to return a non-nil value and like the rest of the http2 package, its return value is not protected by an API compatibility promise. ErrorDetail is reset after the next call to ReadFrame. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.ReadFrame",
                    "documentation": {
                      "identifier": "http2Framer.ReadFrame",
                      "newPage": false,
                      "searchKey": "http.http2Framer.ReadFrame",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr *http2Framer) ReadFrame() (http2Frame, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr *http2Framer) ReadFrame() (http2Frame, error)\n```\n\nReadFrame reads a single frame. The returned Frame is only valid until the next call to ReadFrame. \n\nIf the frame is larger than previously set with SetMaxReadFrameSize, the returned error is ErrFrameTooLarge. Other errors may be of type ConnectionError, StreamError, or anything else from the underlying reader. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.SetMaxReadFrameSize",
                    "documentation": {
                      "identifier": "http2Framer.SetMaxReadFrameSize",
                      "newPage": false,
                      "searchKey": "http.http2Framer.SetMaxReadFrameSize",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr *http2Framer) SetMaxReadFrameSize(v uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr *http2Framer) SetMaxReadFrameSize(v uint32)\n```\n\nSetMaxReadFrameSize sets the maximum size of a frame that will be read by a subsequent call to ReadFrame. It is the caller's responsibility to advertise this limit with a SETTINGS frame. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.SetReuseFrames",
                    "documentation": {
                      "identifier": "http2Framer.SetReuseFrames",
                      "newPage": false,
                      "searchKey": "http.http2Framer.SetReuseFrames",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr *http2Framer) SetReuseFrames()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr *http2Framer) SetReuseFrames()\n```\n\nSetReuseFrames allows the Framer to reuse Frames. If called on a Framer, Frames returned by calls to ReadFrame are only valid until the next call to ReadFrame. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WriteContinuation",
                    "documentation": {
                      "identifier": "http2Framer.WriteContinuation",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WriteContinuation",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error\n```\n\nWriteContinuation writes a CONTINUATION frame. \n\nIt will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WriteData",
                    "documentation": {
                      "identifier": "http2Framer.WriteData",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WriteData",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WriteData(streamID uint32, endStream bool, data []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WriteData(streamID uint32, endStream bool, data []byte) error\n```\n\nWriteData writes a DATA frame. \n\nIt will perform exactly one Write to the underlying Writer. It is the caller's responsibility not to violate the maximum frame size and to not call other Write methods concurrently. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WriteDataPadded",
                    "documentation": {
                      "identifier": "http2Framer.WriteDataPadded",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WriteDataPadded",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error\n```\n\nWriteDataPadded writes a DATA frame with optional padding. \n\nIf pad is nil, the padding bit is not sent. The length of pad must not exceed 255 bytes. The bytes of pad must all be zero, unless f.AllowIllegalWrites is set. \n\nIt will perform exactly one Write to the underlying Writer. It is the caller's responsibility not to violate the maximum frame size and to not call other Write methods concurrently. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WriteGoAway",
                    "documentation": {
                      "identifier": "http2Framer.WriteGoAway",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WriteGoAway",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WriteGoAway(maxStreamID uint32, code http2ErrCode, debugData []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WriteGoAway(maxStreamID uint32, code http2ErrCode, debugData []byte) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WriteHeaders",
                    "documentation": {
                      "identifier": "http2Framer.WriteHeaders",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WriteHeaders",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WriteHeaders(p http2HeadersFrameParam) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WriteHeaders(p http2HeadersFrameParam) error\n```\n\nWriteHeaders writes a single HEADERS frame. \n\nThis is a low-level header writing method. Encoding headers and splitting them into any necessary CONTINUATION frames is handled elsewhere. \n\nIt will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WritePing",
                    "documentation": {
                      "identifier": "http2Framer.WritePing",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WritePing",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WritePing(ack bool, data [8]byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WritePing(ack bool, data [8]byte) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WritePriority",
                    "documentation": {
                      "identifier": "http2Framer.WritePriority",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WritePriority",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WritePriority(streamID uint32, p http2PriorityParam) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WritePriority(streamID uint32, p http2PriorityParam) error\n```\n\nWritePriority writes a PRIORITY frame. \n\nIt will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WritePushPromise",
                    "documentation": {
                      "identifier": "http2Framer.WritePushPromise",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WritePushPromise",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WritePushPromise(p http2PushPromiseParam) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WritePushPromise(p http2PushPromiseParam) error\n```\n\nWritePushPromise writes a single PushPromise Frame. \n\nAs with Header Frames, This is the low level call for writing individual frames. Continuation frames are handled elsewhere. \n\nIt will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WriteRSTStream",
                    "documentation": {
                      "identifier": "http2Framer.WriteRSTStream",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WriteRSTStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WriteRSTStream(streamID uint32, code http2ErrCode) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WriteRSTStream(streamID uint32, code http2ErrCode) error\n```\n\nWriteRSTStream writes a RST_STREAM frame. \n\nIt will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WriteRawFrame",
                    "documentation": {
                      "identifier": "http2Framer.WriteRawFrame",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WriteRawFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WriteRawFrame(t http2FrameType, flags http2Flags, streamID uint32, payload []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WriteRawFrame(t http2FrameType, flags http2Flags, streamID uint32, payload []byte) error\n```\n\nWriteRawFrame writes a raw frame. This can be used to write extension frames unknown to this package. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WriteSettings",
                    "documentation": {
                      "identifier": "http2Framer.WriteSettings",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WriteSettings",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WriteSettings(settings ...http2Setting) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WriteSettings(settings ...http2Setting) error\n```\n\nWriteSettings writes a SETTINGS frame with zero or more settings specified and the ACK bit not set. \n\nIt will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WriteSettingsAck",
                    "documentation": {
                      "identifier": "http2Framer.WriteSettingsAck",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WriteSettingsAck",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WriteSettingsAck() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WriteSettingsAck() error\n```\n\nWriteSettingsAck writes an empty SETTINGS frame with the ACK bit set. \n\nIt will perform exactly one Write to the underlying Writer. It is the caller's responsibility to not call other Write methods concurrently. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.WriteWindowUpdate",
                    "documentation": {
                      "identifier": "http2Framer.WriteWindowUpdate",
                      "newPage": false,
                      "searchKey": "http.http2Framer.WriteWindowUpdate",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) WriteWindowUpdate(streamID, incr uint32) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) WriteWindowUpdate(streamID, incr uint32) error\n```\n\nWriteWindowUpdate writes a WINDOW_UPDATE frame. The increment value must be between 1 and 2,147,483,647, inclusive. If the Stream ID is zero, the window update applies to the connection as a whole. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.checkFrameOrder",
                    "documentation": {
                      "identifier": "http2Framer.checkFrameOrder",
                      "newPage": false,
                      "searchKey": "http.http2Framer.checkFrameOrder",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr *http2Framer) checkFrameOrder(f http2Frame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr *http2Framer) checkFrameOrder(f http2Frame) error\n```\n\ncheckFrameOrder reports an error if f is an invalid frame to return next from ReadFrame. Mostly it checks whether HEADERS and CONTINUATION frames are contiguous. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.connError",
                    "documentation": {
                      "identifier": "http2Framer.connError",
                      "newPage": false,
                      "searchKey": "http.http2Framer.connError",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr *http2Framer) connError(code http2ErrCode, reason string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr *http2Framer) connError(code http2ErrCode, reason string) error\n```\n\nconnError returns ConnectionError(code) but first stashes away a public reason to the caller can optionally relay it to the peer before hanging up on them. This might help others debug their implementations. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.endWrite",
                    "documentation": {
                      "identifier": "http2Framer.endWrite",
                      "newPage": false,
                      "searchKey": "http.http2Framer.endWrite",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) endWrite() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) endWrite() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.logWrite",
                    "documentation": {
                      "identifier": "http2Framer.logWrite",
                      "newPage": false,
                      "searchKey": "http.http2Framer.logWrite",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) logWrite()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) logWrite()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.maxHeaderListSize",
                    "documentation": {
                      "identifier": "http2Framer.maxHeaderListSize",
                      "newPage": false,
                      "searchKey": "http.http2Framer.maxHeaderListSize",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr *http2Framer) maxHeaderListSize() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr *http2Framer) maxHeaderListSize() uint32\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.maxHeaderStringLen",
                    "documentation": {
                      "identifier": "http2Framer.maxHeaderStringLen",
                      "newPage": false,
                      "searchKey": "http.http2Framer.maxHeaderStringLen",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr *http2Framer) maxHeaderStringLen() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr *http2Framer) maxHeaderStringLen() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.readMetaFrame",
                    "documentation": {
                      "identifier": "http2Framer.readMetaFrame",
                      "newPage": false,
                      "searchKey": "http.http2Framer.readMetaFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr *http2Framer) readMetaFrame(hf *http2HeadersFrame) (*http2MetaHeadersFrame, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr *http2Framer) readMetaFrame(hf *http2HeadersFrame) (*http2MetaHeadersFrame, error)\n```\n\nreadMetaFrame returns 0 or more CONTINUATION frames from fr and merge them into the provided hf and returns a MetaHeadersFrame with the decoded hpack values. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.startWrite",
                    "documentation": {
                      "identifier": "http2Framer.startWrite",
                      "newPage": false,
                      "searchKey": "http.http2Framer.startWrite",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) startWrite(ftype http2FrameType, flags http2Flags, streamID uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) startWrite(ftype http2FrameType, flags http2Flags, streamID uint32)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.writeByte",
                    "documentation": {
                      "identifier": "http2Framer.writeByte",
                      "newPage": false,
                      "searchKey": "http.http2Framer.writeByte",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) writeByte(v byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) writeByte(v byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.writeBytes",
                    "documentation": {
                      "identifier": "http2Framer.writeBytes",
                      "newPage": false,
                      "searchKey": "http.http2Framer.writeBytes",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) writeBytes(v []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) writeBytes(v []byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.writeUint16",
                    "documentation": {
                      "identifier": "http2Framer.writeUint16",
                      "newPage": false,
                      "searchKey": "http.http2Framer.writeUint16",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) writeUint16(v uint16)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) writeUint16(v uint16)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Framer.writeUint32",
                    "documentation": {
                      "identifier": "http2Framer.writeUint32",
                      "newPage": false,
                      "searchKey": "http.http2Framer.writeUint32",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2Framer) writeUint32(v uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2Framer) writeUint32(v uint32)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2GoAwayError",
              "documentation": {
                "identifier": "http2GoAwayError",
                "newPage": false,
                "searchKey": "http.http2GoAwayError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2GoAwayError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2GoAwayError struct {\n\tLastStreamID uint32\n\tErrCode      http2ErrCode\n\tDebugData    string\n}\n```\n\nGoAwayError is returned by the Transport when the server closes the TCP connection after sending a GOAWAY frame. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2GoAwayError.Error",
                    "documentation": {
                      "identifier": "http2GoAwayError.Error",
                      "newPage": false,
                      "searchKey": "http.http2GoAwayError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e http2GoAwayError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e http2GoAwayError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2GoAwayFrame",
              "documentation": {
                "identifier": "http2GoAwayFrame",
                "newPage": false,
                "searchKey": "http.http2GoAwayFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2GoAwayFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2GoAwayFrame struct {\n\thttp2FrameHeader\n\tLastStreamID uint32\n\tErrCode      http2ErrCode\n\tdebugData    []byte\n}\n```\n\nA GoAwayFrame informs the remote peer to stop creating streams on this connection. See [http://http2.github.io/http2-spec/#rfc.section.6.8](http://http2.github.io/http2-spec/#rfc.section.6.8) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2GoAwayFrame.DebugData",
                    "documentation": {
                      "identifier": "http2GoAwayFrame.DebugData",
                      "newPage": false,
                      "searchKey": "http.http2GoAwayFrame.DebugData",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2GoAwayFrame) DebugData() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2GoAwayFrame) DebugData() []byte\n```\n\nDebugData returns any debug data in the GOAWAY frame. Its contents are not defined. The caller must not retain the returned memory past the next call to ReadFrame. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2HeadersFrame",
              "documentation": {
                "identifier": "http2HeadersFrame",
                "newPage": false,
                "searchKey": "http.http2HeadersFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2HeadersFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2HeadersFrame struct {\n\thttp2FrameHeader\n\n\t// Priority is set if FlagHeadersPriority is set in the FrameHeader.\n\tPriority http2PriorityParam\n\n\theaderFragBuf []byte // not owned\n}\n```\n\nA HeadersFrame is used to open a stream and additionally carries a header block fragment. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2HeadersFrame.HasPriority",
                    "documentation": {
                      "identifier": "http2HeadersFrame.HasPriority",
                      "newPage": false,
                      "searchKey": "http.http2HeadersFrame.HasPriority",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2HeadersFrame) HasPriority() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2HeadersFrame) HasPriority() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2HeadersFrame.HeaderBlockFragment",
                    "documentation": {
                      "identifier": "http2HeadersFrame.HeaderBlockFragment",
                      "newPage": false,
                      "searchKey": "http.http2HeadersFrame.HeaderBlockFragment",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2HeadersFrame) HeaderBlockFragment() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2HeadersFrame) HeaderBlockFragment() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2HeadersFrame.HeadersEnded",
                    "documentation": {
                      "identifier": "http2HeadersFrame.HeadersEnded",
                      "newPage": false,
                      "searchKey": "http.http2HeadersFrame.HeadersEnded",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2HeadersFrame) HeadersEnded() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2HeadersFrame) HeadersEnded() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2HeadersFrame.StreamEnded",
                    "documentation": {
                      "identifier": "http2HeadersFrame.StreamEnded",
                      "newPage": false,
                      "searchKey": "http.http2HeadersFrame.StreamEnded",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2HeadersFrame) StreamEnded() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2HeadersFrame) StreamEnded() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2HeadersFrameParam",
              "documentation": {
                "identifier": "http2HeadersFrameParam",
                "newPage": false,
                "searchKey": "http.http2HeadersFrameParam",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2HeadersFrameParam struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2HeadersFrameParam struct {\n\t// StreamID is the required Stream ID to initiate.\n\tStreamID uint32\n\t// BlockFragment is part (or all) of a Header Block.\n\tBlockFragment []byte\n\n\t// EndStream indicates that the header block is the last that\n\t// the endpoint will send for the identified stream. Setting\n\t// this flag causes the stream to enter one of \"half closed\"\n\t// states.\n\tEndStream bool\n\n\t// EndHeaders indicates that this frame contains an entire\n\t// header block and is not followed by any\n\t// CONTINUATION frames.\n\tEndHeaders bool\n\n\t// PadLength is the optional number of bytes of zeros to add\n\t// to this frame.\n\tPadLength uint8\n\n\t// Priority, if non-zero, includes stream priority information\n\t// in the HEADER frame.\n\tPriority http2PriorityParam\n}\n```\n\nHeadersFrameParam are the parameters for writing a HEADERS frame. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2MetaHeadersFrame",
              "documentation": {
                "identifier": "http2MetaHeadersFrame",
                "newPage": false,
                "searchKey": "http.http2MetaHeadersFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2MetaHeadersFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2MetaHeadersFrame struct {\n\t*http2HeadersFrame\n\n\t// Fields are the fields contained in the HEADERS and\n\t// CONTINUATION frames. The underlying slice is owned by the\n\t// Framer and must not be retained after the next call to\n\t// ReadFrame.\n\t//\n\t// Fields are guaranteed to be in the correct http2 order and\n\t// not have unknown pseudo header fields or invalid header\n\t// field names or values. Required pseudo header fields may be\n\t// missing, however. Use the MetaHeadersFrame.Pseudo accessor\n\t// method access pseudo headers.\n\tFields []hpack.HeaderField\n\n\t// Truncated is whether the max header list size limit was hit\n\t// and Fields is incomplete. The hpack decoder state is still\n\t// valid, however.\n\tTruncated bool\n}\n```\n\nA MetaHeadersFrame is the representation of one HEADERS frame and zero or more contiguous CONTINUATION frames and the decoding of their HPACK-encoded contents. \n\nThis type of frame does not appear on the wire and is only returned by the Framer when Framer.ReadMetaHeaders is set. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2MetaHeadersFrame.PseudoFields",
                    "documentation": {
                      "identifier": "http2MetaHeadersFrame.PseudoFields",
                      "newPage": false,
                      "searchKey": "http.http2MetaHeadersFrame.PseudoFields",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mh *http2MetaHeadersFrame) PseudoFields() []hpack.HeaderField"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mh *http2MetaHeadersFrame) PseudoFields() []hpack.HeaderField\n```\n\nPseudoFields returns the pseudo header fields of mh. The caller does not own the returned slice. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2MetaHeadersFrame.PseudoValue",
                    "documentation": {
                      "identifier": "http2MetaHeadersFrame.PseudoValue",
                      "newPage": false,
                      "searchKey": "http.http2MetaHeadersFrame.PseudoValue",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mh *http2MetaHeadersFrame) PseudoValue(pseudo string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mh *http2MetaHeadersFrame) PseudoValue(pseudo string) string\n```\n\nPseudoValue returns the given pseudo header field's value. The provided pseudo field should not contain the leading colon. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2MetaHeadersFrame.RegularFields",
                    "documentation": {
                      "identifier": "http2MetaHeadersFrame.RegularFields",
                      "newPage": false,
                      "searchKey": "http.http2MetaHeadersFrame.RegularFields",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mh *http2MetaHeadersFrame) RegularFields() []hpack.HeaderField"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mh *http2MetaHeadersFrame) RegularFields() []hpack.HeaderField\n```\n\nRegularFields returns the regular (non-pseudo) header fields of mh. The caller does not own the returned slice. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2MetaHeadersFrame.checkPseudos",
                    "documentation": {
                      "identifier": "http2MetaHeadersFrame.checkPseudos",
                      "newPage": false,
                      "searchKey": "http.http2MetaHeadersFrame.checkPseudos",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mh *http2MetaHeadersFrame) checkPseudos() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mh *http2MetaHeadersFrame) checkPseudos() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2OpenStreamOptions",
              "documentation": {
                "identifier": "http2OpenStreamOptions",
                "newPage": false,
                "searchKey": "http.http2OpenStreamOptions",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2OpenStreamOptions struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2OpenStreamOptions struct {\n\t// PusherID is zero if the stream was initiated by the client. Otherwise,\n\t// PusherID names the stream that pushed the newly opened stream.\n\tPusherID uint32\n}\n```\n\nOpenStreamOptions specifies extra options for WriteScheduler.OpenStream. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2PingFrame",
              "documentation": {
                "identifier": "http2PingFrame",
                "newPage": false,
                "searchKey": "http.http2PingFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2PingFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2PingFrame struct {\n\thttp2FrameHeader\n\tData [8]byte\n}\n```\n\nA PingFrame is a mechanism for measuring a minimal round trip time from the sender, as well as determining whether an idle connection is still functional. See [http://http2.github.io/http2-spec/#rfc.section.6.7](http://http2.github.io/http2-spec/#rfc.section.6.7) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2PingFrame.IsAck",
                    "documentation": {
                      "identifier": "http2PingFrame.IsAck",
                      "newPage": false,
                      "searchKey": "http.http2PingFrame.IsAck",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2PingFrame) IsAck() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2PingFrame) IsAck() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2PriorityFrame",
              "documentation": {
                "identifier": "http2PriorityFrame",
                "newPage": false,
                "searchKey": "http.http2PriorityFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2PriorityFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2PriorityFrame struct {\n\thttp2FrameHeader\n\thttp2PriorityParam\n}\n```\n\nA PriorityFrame specifies the sender-advised priority of a stream. See [http://http2.github.io/http2-spec/#rfc.section.6.3](http://http2.github.io/http2-spec/#rfc.section.6.3) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2PriorityParam",
              "documentation": {
                "identifier": "http2PriorityParam",
                "newPage": false,
                "searchKey": "http.http2PriorityParam",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2PriorityParam struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2PriorityParam struct {\n\t// StreamDep is a 31-bit stream identifier for the\n\t// stream that this stream depends on. Zero means no\n\t// dependency.\n\tStreamDep uint32\n\n\t// Exclusive is whether the dependency is exclusive.\n\tExclusive bool\n\n\t// Weight is the stream's zero-indexed weight. It should be\n\t// set together with StreamDep, or neither should be set. Per\n\t// the spec, \"Add one to the value to obtain a weight between\n\t// 1 and 256.\"\n\tWeight uint8\n}\n```\n\nPriorityParam are the stream prioritzation parameters. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2PriorityParam.IsZero",
                    "documentation": {
                      "identifier": "http2PriorityParam.IsZero",
                      "newPage": false,
                      "searchKey": "http.http2PriorityParam.IsZero",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p http2PriorityParam) IsZero() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p http2PriorityParam) IsZero() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2PriorityWriteSchedulerConfig",
              "documentation": {
                "identifier": "http2PriorityWriteSchedulerConfig",
                "newPage": false,
                "searchKey": "http.http2PriorityWriteSchedulerConfig",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2PriorityWriteSchedulerConfig struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2PriorityWriteSchedulerConfig struct {\n\t// MaxClosedNodesInTree controls the maximum number of closed streams to\n\t// retain in the priority tree. Setting this to zero saves a small amount\n\t// of memory at the cost of performance.\n\t//\n\t// See RFC 7540, Section 5.3.4:\n\t//   \"It is possible for a stream to become closed while prioritization\n\t//   information ... is in transit. ... This potentially creates suboptimal\n\t//   prioritization, since the stream could be given a priority that is\n\t//   different from what is intended. To avoid these problems, an endpoint\n\t//   SHOULD retain stream prioritization state for a period after streams\n\t//   become closed. The longer state is retained, the lower the chance that\n\t//   streams are assigned incorrect or default priority values.\"\n\tMaxClosedNodesInTree int\n\n\t// MaxIdleNodesInTree controls the maximum number of idle streams to\n\t// retain in the priority tree. Setting this to zero saves a small amount\n\t// of memory at the cost of performance.\n\t//\n\t// See RFC 7540, Section 5.3.4:\n\t//   Similarly, streams that are in the \"idle\" state can be assigned\n\t//   priority or become a parent of other streams. This allows for the\n\t//   creation of a grouping node in the dependency tree, which enables\n\t//   more flexible expressions of priority. Idle streams begin with a\n\t//   default priority (Section 5.3.5).\n\tMaxIdleNodesInTree int\n\n\t// ThrottleOutOfOrderWrites enables write throttling to help ensure that\n\t// data is delivered in priority order. This works around a race where\n\t// stream B depends on stream A and both streams are about to call Write\n\t// to queue DATA frames. If B wins the race, a naive scheduler would eagerly\n\t// write as much data from B as possible, but this is suboptimal because A\n\t// is a higher-priority stream. With throttling enabled, we write a small\n\t// amount of data from B to minimize the amount of bandwidth that B can\n\t// steal from A.\n\tThrottleOutOfOrderWrites bool\n}\n```\n\nPriorityWriteSchedulerConfig configures a priorityWriteScheduler. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2PushPromiseFrame",
              "documentation": {
                "identifier": "http2PushPromiseFrame",
                "newPage": false,
                "searchKey": "http.http2PushPromiseFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2PushPromiseFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2PushPromiseFrame struct {\n\thttp2FrameHeader\n\tPromiseID     uint32\n\theaderFragBuf []byte // not owned\n}\n```\n\nA PushPromiseFrame is used to initiate a server stream. See [http://http2.github.io/http2-spec/#rfc.section.6.6](http://http2.github.io/http2-spec/#rfc.section.6.6) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2PushPromiseFrame.HeaderBlockFragment",
                    "documentation": {
                      "identifier": "http2PushPromiseFrame.HeaderBlockFragment",
                      "newPage": false,
                      "searchKey": "http.http2PushPromiseFrame.HeaderBlockFragment",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2PushPromiseFrame) HeaderBlockFragment() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2PushPromiseFrame) HeaderBlockFragment() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2PushPromiseFrame.HeadersEnded",
                    "documentation": {
                      "identifier": "http2PushPromiseFrame.HeadersEnded",
                      "newPage": false,
                      "searchKey": "http.http2PushPromiseFrame.HeadersEnded",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2PushPromiseFrame) HeadersEnded() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2PushPromiseFrame) HeadersEnded() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2PushPromiseParam",
              "documentation": {
                "identifier": "http2PushPromiseParam",
                "newPage": false,
                "searchKey": "http.http2PushPromiseParam",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2PushPromiseParam struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2PushPromiseParam struct {\n\t// StreamID is the required Stream ID to initiate.\n\tStreamID uint32\n\n\t// PromiseID is the required Stream ID which this\n\t// Push Promises\n\tPromiseID uint32\n\n\t// BlockFragment is part (or all) of a Header Block.\n\tBlockFragment []byte\n\n\t// EndHeaders indicates that this frame contains an entire\n\t// header block and is not followed by any\n\t// CONTINUATION frames.\n\tEndHeaders bool\n\n\t// PadLength is the optional number of bytes of zeros to add\n\t// to this frame.\n\tPadLength uint8\n}\n```\n\nPushPromiseParam are the parameters for writing a PUSH_PROMISE frame. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2RSTStreamFrame",
              "documentation": {
                "identifier": "http2RSTStreamFrame",
                "newPage": false,
                "searchKey": "http.http2RSTStreamFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2RSTStreamFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2RSTStreamFrame struct {\n\thttp2FrameHeader\n\tErrCode http2ErrCode\n}\n```\n\nA RSTStreamFrame allows for abnormal termination of a stream. See [http://http2.github.io/http2-spec/#rfc.section.6.4](http://http2.github.io/http2-spec/#rfc.section.6.4) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2RoundTripOpt",
              "documentation": {
                "identifier": "http2RoundTripOpt",
                "newPage": false,
                "searchKey": "http.http2RoundTripOpt",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2RoundTripOpt struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2RoundTripOpt struct {\n\t// OnlyCachedConn controls whether RoundTripOpt may\n\t// create a new TCP connection. If set true and\n\t// no cached connection is available, RoundTripOpt\n\t// will return ErrNoCachedConn.\n\tOnlyCachedConn bool\n}\n```\n\nRoundTripOpt are options for the Transport.RoundTripOpt method. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ServeConnOpts",
              "documentation": {
                "identifier": "http2ServeConnOpts",
                "newPage": false,
                "searchKey": "http.http2ServeConnOpts",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2ServeConnOpts struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2ServeConnOpts struct {\n\t// Context is the base context to use.\n\t// If nil, context.Background is used.\n\tContext context.Context\n\n\t// BaseConfig optionally sets the base configuration\n\t// for values. If nil, defaults are used.\n\tBaseConfig *Server\n\n\t// Handler specifies which handler to use for processing\n\t// requests. If nil, BaseConfig.Handler is used. If BaseConfig\n\t// or BaseConfig.Handler is nil, http.DefaultServeMux is used.\n\tHandler Handler\n}\n```\n\nServeConnOpts are options for the Server.ServeConn method. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2ServeConnOpts.baseConfig",
                    "documentation": {
                      "identifier": "http2ServeConnOpts.baseConfig",
                      "newPage": false,
                      "searchKey": "http.http2ServeConnOpts.baseConfig",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (o *http2ServeConnOpts) baseConfig() *Server"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (o *http2ServeConnOpts) baseConfig() *Server\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ServeConnOpts.context",
                    "documentation": {
                      "identifier": "http2ServeConnOpts.context",
                      "newPage": false,
                      "searchKey": "http.http2ServeConnOpts.context",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (o *http2ServeConnOpts) context() context.Context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (o *http2ServeConnOpts) context() context.Context\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2ServeConnOpts.handler",
                    "documentation": {
                      "identifier": "http2ServeConnOpts.handler",
                      "newPage": false,
                      "searchKey": "http.http2ServeConnOpts.handler",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (o *http2ServeConnOpts) handler() Handler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (o *http2ServeConnOpts) handler() Handler\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2Server",
              "documentation": {
                "identifier": "http2Server",
                "newPage": false,
                "searchKey": "http.http2Server",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2Server struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2Server struct {\n\t// MaxHandlers limits the number of http.Handler ServeHTTP goroutines\n\t// which may run at a time over all connections.\n\t// Negative or zero no limit.\n\t// TODO: implement\n\tMaxHandlers int\n\n\t// MaxConcurrentStreams optionally specifies the number of\n\t// concurrent streams that each client may have open at a\n\t// time. This is unrelated to the number of http.Handler goroutines\n\t// which may be active globally, which is MaxHandlers.\n\t// If zero, MaxConcurrentStreams defaults to at least 100, per\n\t// the HTTP/2 spec's recommendations.\n\tMaxConcurrentStreams uint32\n\n\t// MaxReadFrameSize optionally specifies the largest frame\n\t// this server is willing to read. A valid value is between\n\t// 16k and 16M, inclusive. If zero or otherwise invalid, a\n\t// default value is used.\n\tMaxReadFrameSize uint32\n\n\t// PermitProhibitedCipherSuites, if true, permits the use of\n\t// cipher suites prohibited by the HTTP/2 spec.\n\tPermitProhibitedCipherSuites bool\n\n\t// IdleTimeout specifies how long until idle clients should be\n\t// closed with a GOAWAY frame. PING frames are not considered\n\t// activity for the purposes of IdleTimeout.\n\tIdleTimeout time.Duration\n\n\t// MaxUploadBufferPerConnection is the size of the initial flow\n\t// control window for each connections. The HTTP/2 spec does not\n\t// allow this to be smaller than 65535 or larger than 2^32-1.\n\t// If the value is outside this range, a default value will be\n\t// used instead.\n\tMaxUploadBufferPerConnection int32\n\n\t// MaxUploadBufferPerStream is the size of the initial flow control\n\t// window for each stream. The HTTP/2 spec does not allow this to\n\t// be larger than 2^32-1. If the value is zero or larger than the\n\t// maximum, a default value will be used instead.\n\tMaxUploadBufferPerStream int32\n\n\t// NewWriteScheduler constructs a write scheduler for a connection.\n\t// If nil, a default scheduler is chosen.\n\tNewWriteScheduler func() http2WriteScheduler\n\n\t// Internal state. This is a pointer (rather than embedded directly)\n\t// so that we don't embed a Mutex in this struct, which will make the\n\t// struct non-copyable, which might break some callers.\n\tstate *http2serverInternalState\n}\n```\n\nServer is an HTTP/2 server. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2Server.ServeConn",
                    "documentation": {
                      "identifier": "http2Server.ServeConn",
                      "newPage": false,
                      "searchKey": "http.http2Server.ServeConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2Server) ServeConn(c net.Conn, opts *http2ServeConnOpts)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2Server) ServeConn(c net.Conn, opts *http2ServeConnOpts)\n```\n\nServeConn serves HTTP/2 requests on the provided connection and blocks until the connection is no longer readable. \n\nServeConn starts speaking HTTP/2 assuming that c has not had any reads or writes. It writes its initial settings frame and expects to be able to read the preface and settings frame from the client. If c has a ConnectionState method like a *tls.Conn, the ConnectionState is used to verify the TLS ciphersuite and to set the Request.TLS field in Handlers. \n\nServeConn does not support h2c by itself. Any h2c support must be implemented in terms of providing a suitably-behaving net.Conn. \n\nThe opts parameter is optional. If nil, default values are used. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Server.initialConnRecvWindowSize",
                    "documentation": {
                      "identifier": "http2Server.initialConnRecvWindowSize",
                      "newPage": false,
                      "searchKey": "http.http2Server.initialConnRecvWindowSize",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2Server) initialConnRecvWindowSize() int32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2Server) initialConnRecvWindowSize() int32\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Server.initialStreamRecvWindowSize",
                    "documentation": {
                      "identifier": "http2Server.initialStreamRecvWindowSize",
                      "newPage": false,
                      "searchKey": "http.http2Server.initialStreamRecvWindowSize",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2Server) initialStreamRecvWindowSize() int32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2Server) initialStreamRecvWindowSize() int32\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Server.maxConcurrentStreams",
                    "documentation": {
                      "identifier": "http2Server.maxConcurrentStreams",
                      "newPage": false,
                      "searchKey": "http.http2Server.maxConcurrentStreams",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2Server) maxConcurrentStreams() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2Server) maxConcurrentStreams() uint32\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Server.maxQueuedControlFrames",
                    "documentation": {
                      "identifier": "http2Server.maxQueuedControlFrames",
                      "newPage": false,
                      "searchKey": "http.http2Server.maxQueuedControlFrames",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2Server) maxQueuedControlFrames() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2Server) maxQueuedControlFrames() int\n```\n\nmaxQueuedControlFrames is the maximum number of control frames like SETTINGS, PING and RST_STREAM that will be queued for writing before the connection is closed to prevent memory exhaustion attacks. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Server.maxReadFrameSize",
                    "documentation": {
                      "identifier": "http2Server.maxReadFrameSize",
                      "newPage": false,
                      "searchKey": "http.http2Server.maxReadFrameSize",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2Server) maxReadFrameSize() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2Server) maxReadFrameSize() uint32\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2Setting",
              "documentation": {
                "identifier": "http2Setting",
                "newPage": false,
                "searchKey": "http.http2Setting",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2Setting struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2Setting struct {\n\t// ID is which setting is being set.\n\t// See http://http2.github.io/http2-spec/#SettingValues\n\tID http2SettingID\n\n\t// Val is the value.\n\tVal uint32\n}\n```\n\nSetting is a setting parameter: which setting it is, and its value. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2Setting.String",
                    "documentation": {
                      "identifier": "http2Setting.String",
                      "newPage": false,
                      "searchKey": "http.http2Setting.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s http2Setting) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s http2Setting) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Setting.Valid",
                    "documentation": {
                      "identifier": "http2Setting.Valid",
                      "newPage": false,
                      "searchKey": "http.http2Setting.Valid",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s http2Setting) Valid() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s http2Setting) Valid() error\n```\n\nValid reports whether the setting is valid. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2SettingID",
              "documentation": {
                "identifier": "http2SettingID",
                "newPage": false,
                "searchKey": "http.http2SettingID",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2SettingID uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2SettingID uint16\n```\n\nA SettingID is an HTTP/2 setting as defined in [http://http2.github.io/http2-spec/#iana-settings](http://http2.github.io/http2-spec/#iana-settings) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2SettingID.String",
                    "documentation": {
                      "identifier": "http2SettingID.String",
                      "newPage": false,
                      "searchKey": "http.http2SettingID.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s http2SettingID) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s http2SettingID) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2SettingsFrame",
              "documentation": {
                "identifier": "http2SettingsFrame",
                "newPage": false,
                "searchKey": "http.http2SettingsFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2SettingsFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2SettingsFrame struct {\n\thttp2FrameHeader\n\tp []byte\n}\n```\n\nA SettingsFrame conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior. \n\nSee [http://http2.github.io/http2-spec/#SETTINGS](http://http2.github.io/http2-spec/#SETTINGS) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2SettingsFrame.ForeachSetting",
                    "documentation": {
                      "identifier": "http2SettingsFrame.ForeachSetting",
                      "newPage": false,
                      "searchKey": "http.http2SettingsFrame.ForeachSetting",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2SettingsFrame) ForeachSetting(fn func(http2Setting) error) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2SettingsFrame) ForeachSetting(fn func(http2Setting) error) error\n```\n\nForeachSetting runs fn for each setting. It stops and returns the first error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2SettingsFrame.HasDuplicates",
                    "documentation": {
                      "identifier": "http2SettingsFrame.HasDuplicates",
                      "newPage": false,
                      "searchKey": "http.http2SettingsFrame.HasDuplicates",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2SettingsFrame) HasDuplicates() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2SettingsFrame) HasDuplicates() bool\n```\n\nHasDuplicates reports whether f contains any duplicate setting IDs. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2SettingsFrame.IsAck",
                    "documentation": {
                      "identifier": "http2SettingsFrame.IsAck",
                      "newPage": false,
                      "searchKey": "http.http2SettingsFrame.IsAck",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2SettingsFrame) IsAck() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2SettingsFrame) IsAck() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2SettingsFrame.NumSettings",
                    "documentation": {
                      "identifier": "http2SettingsFrame.NumSettings",
                      "newPage": false,
                      "searchKey": "http.http2SettingsFrame.NumSettings",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2SettingsFrame) NumSettings() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2SettingsFrame) NumSettings() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2SettingsFrame.Setting",
                    "documentation": {
                      "identifier": "http2SettingsFrame.Setting",
                      "newPage": false,
                      "searchKey": "http.http2SettingsFrame.Setting",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2SettingsFrame) Setting(i int) http2Setting"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2SettingsFrame) Setting(i int) http2Setting\n```\n\nSetting returns the setting from the frame at the given 0-based index. The index must be >= 0 and less than f.NumSettings(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2SettingsFrame.Value",
                    "documentation": {
                      "identifier": "http2SettingsFrame.Value",
                      "newPage": false,
                      "searchKey": "http.http2SettingsFrame.Value",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2SettingsFrame) Value(id http2SettingID) (v uint32, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2SettingsFrame) Value(id http2SettingID) (v uint32, ok bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2StreamError",
              "documentation": {
                "identifier": "http2StreamError",
                "newPage": false,
                "searchKey": "http.http2StreamError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2StreamError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2StreamError struct {\n\tStreamID uint32\n\tCode     http2ErrCode\n\tCause    error // optional additional detail\n}\n```\n\nStreamError is an error that only affects one stream within an HTTP/2 connection. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2streamError",
                    "documentation": {
                      "identifier": "http2streamError",
                      "newPage": false,
                      "searchKey": "http.http2streamError",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2streamError(id uint32, code http2ErrCode) http2StreamError"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2streamError(id uint32, code http2ErrCode) http2StreamError\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2StreamError.Error",
                    "documentation": {
                      "identifier": "http2StreamError.Error",
                      "newPage": false,
                      "searchKey": "http.http2StreamError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e http2StreamError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e http2StreamError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2StreamError.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2StreamError.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2StreamError.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (se http2StreamError) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (se http2StreamError) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2StreamError.writeFrame",
                    "documentation": {
                      "identifier": "http2StreamError.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2StreamError.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (se http2StreamError) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (se http2StreamError) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2Transport",
              "documentation": {
                "identifier": "http2Transport",
                "newPage": false,
                "searchKey": "http.http2Transport",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2Transport struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2Transport struct {\n\t// DialTLS specifies an optional dial function for creating\n\t// TLS connections for requests.\n\t//\n\t// If DialTLS is nil, tls.Dial is used.\n\t//\n\t// If the returned net.Conn has a ConnectionState method like tls.Conn,\n\t// it will be used to set http.Response.TLS.\n\tDialTLS func(network, addr string, cfg *tls.Config) (net.Conn, error)\n\n\t// TLSClientConfig specifies the TLS configuration to use with\n\t// tls.Client. If nil, the default configuration is used.\n\tTLSClientConfig *tls.Config\n\n\t// ConnPool optionally specifies an alternate connection pool to use.\n\t// If nil, the default is used.\n\tConnPool http2ClientConnPool\n\n\t// DisableCompression, if true, prevents the Transport from\n\t// requesting compression with an \"Accept-Encoding: gzip\"\n\t// request header when the Request contains no existing\n\t// Accept-Encoding value. If the Transport requests gzip on\n\t// its own and gets a gzipped response, it's transparently\n\t// decoded in the Response.Body. However, if the user\n\t// explicitly requested gzip it is not automatically\n\t// uncompressed.\n\tDisableCompression bool\n\n\t// AllowHTTP, if true, permits HTTP/2 requests using the insecure,\n\t// plain-text \"http\" scheme. Note that this does not enable h2c support.\n\tAllowHTTP bool\n\n\t// MaxHeaderListSize is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to\n\t// send in the initial settings frame. It is how many bytes\n\t// of response headers are allowed. Unlike the http2 spec, zero here\n\t// means to use a default limit (currently 10MB). If you actually\n\t// want to advertise an unlimited value to the peer, Transport\n\t// interprets the highest possible value here (0xffffffff or 1<<32-1)\n\t// to mean no limit.\n\tMaxHeaderListSize uint32\n\n\t// StrictMaxConcurrentStreams controls whether the server's\n\t// SETTINGS_MAX_CONCURRENT_STREAMS should be respected\n\t// globally. If false, new TCP connections are created to the\n\t// server as needed to keep each under the per-connection\n\t// SETTINGS_MAX_CONCURRENT_STREAMS limit. If true, the\n\t// server's SETTINGS_MAX_CONCURRENT_STREAMS is interpreted as\n\t// a global limit and callers of RoundTrip block when needed,\n\t// waiting for their turn.\n\tStrictMaxConcurrentStreams bool\n\n\t// ReadIdleTimeout is the timeout after which a health check using ping\n\t// frame will be carried out if no frame is received on the connection.\n\t// Note that a ping response will is considered a received frame, so if\n\t// there is no other traffic on the connection, the health check will\n\t// be performed every ReadIdleTimeout interval.\n\t// If zero, no health check is performed.\n\tReadIdleTimeout time.Duration\n\n\t// PingTimeout is the timeout after which the connection will be closed\n\t// if a response to Ping is not received.\n\t// Defaults to 15s.\n\tPingTimeout time.Duration\n\n\t// t1, if non-nil, is the standard library Transport using\n\t// this transport. Its settings are used (but not its\n\t// RoundTrip method, etc).\n\tt1 *Transport\n\n\tconnPoolOnce  sync.Once\n\tconnPoolOrDef http2ClientConnPool // non-nil version of ConnPool\n}\n```\n\nTransport is an HTTP/2 Transport. \n\nA Transport internally caches connections to servers. It is safe for concurrent use by multiple goroutines. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2ConfigureTransports",
                    "documentation": {
                      "identifier": "http2ConfigureTransports",
                      "newPage": false,
                      "searchKey": "http.http2ConfigureTransports",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2ConfigureTransports(t1 *Transport) (*http2Transport, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2ConfigureTransports(t1 *Transport) (*http2Transport, error)\n```\n\nConfigureTransports configures a net/http HTTP/1 Transport to use HTTP/2. It returns a new HTTP/2 Transport for further configuration. It returns an error if t1 has already been HTTP/2-enabled. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2configureTransports",
                    "documentation": {
                      "identifier": "http2configureTransports",
                      "newPage": false,
                      "searchKey": "http.http2configureTransports",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2configureTransports(t1 *Transport) (*http2Transport, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2configureTransports(t1 *Transport) (*http2Transport, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.CloseIdleConnections",
                    "documentation": {
                      "identifier": "http2Transport.CloseIdleConnections",
                      "newPage": false,
                      "searchKey": "http.http2Transport.CloseIdleConnections",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) CloseIdleConnections()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) CloseIdleConnections()\n```\n\nCloseIdleConnections closes any connections which were previously connected from previous requests but are now sitting idle. It does not interrupt any connections currently in use. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.NewClientConn",
                    "documentation": {
                      "identifier": "http2Transport.NewClientConn",
                      "newPage": false,
                      "searchKey": "http.http2Transport.NewClientConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) NewClientConn(c net.Conn) (*http2ClientConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) NewClientConn(c net.Conn) (*http2ClientConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.RoundTrip",
                    "documentation": {
                      "identifier": "http2Transport.RoundTrip",
                      "newPage": false,
                      "searchKey": "http.http2Transport.RoundTrip",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) RoundTrip(req *Request) (*Response, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) RoundTrip(req *Request) (*Response, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.RoundTripOpt",
                    "documentation": {
                      "identifier": "http2Transport.RoundTripOpt",
                      "newPage": false,
                      "searchKey": "http.http2Transport.RoundTripOpt",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) RoundTripOpt(req *Request, opt http2RoundTripOpt) (*Response, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) RoundTripOpt(req *Request, opt http2RoundTripOpt) (*Response, error)\n```\n\nRoundTripOpt is like RoundTrip, but takes options. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.connPool",
                    "documentation": {
                      "identifier": "http2Transport.connPool",
                      "newPage": false,
                      "searchKey": "http.http2Transport.connPool",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) connPool() http2ClientConnPool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) connPool() http2ClientConnPool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.dialClientConn",
                    "documentation": {
                      "identifier": "http2Transport.dialClientConn",
                      "newPage": false,
                      "searchKey": "http.http2Transport.dialClientConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) dialClientConn(ctx context.Context, addr string, singleUse bool) (*http2ClientConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) dialClientConn(ctx context.Context, addr string, singleUse bool) (*http2ClientConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.dialTLS",
                    "documentation": {
                      "identifier": "http2Transport.dialTLS",
                      "newPage": false,
                      "searchKey": "http.http2Transport.dialTLS",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) dialTLS(ctx context.Context) func(string, string, *tls.Config) (net.Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) dialTLS(ctx context.Context) func(string, string, *tls.Config) (net.Conn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.dialTLSWithContext",
                    "documentation": {
                      "identifier": "http2Transport.dialTLSWithContext",
                      "newPage": false,
                      "searchKey": "http.http2Transport.dialTLSWithContext",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) dialTLSWithContext(ctx context.Context, network, addr string, cfg *tls.Config) (*tls.Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) dialTLSWithContext(ctx context.Context, network, addr string, cfg *tls.Config) (*tls.Conn, error)\n```\n\ndialTLSWithContext uses tls.Dialer, added in Go 1.15, to open a TLS connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.disableCompression",
                    "documentation": {
                      "identifier": "http2Transport.disableCompression",
                      "newPage": false,
                      "searchKey": "http.http2Transport.disableCompression",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) disableCompression() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) disableCompression() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.disableKeepAlives",
                    "documentation": {
                      "identifier": "http2Transport.disableKeepAlives",
                      "newPage": false,
                      "searchKey": "http.http2Transport.disableKeepAlives",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) disableKeepAlives() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) disableKeepAlives() bool\n```\n\ndisableKeepAlives reports whether connections should be closed as soon as possible after handling the first request. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.expectContinueTimeout",
                    "documentation": {
                      "identifier": "http2Transport.expectContinueTimeout",
                      "newPage": false,
                      "searchKey": "http.http2Transport.expectContinueTimeout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) expectContinueTimeout() time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) expectContinueTimeout() time.Duration\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.getBodyWriterState",
                    "documentation": {
                      "identifier": "http2Transport.getBodyWriterState",
                      "newPage": false,
                      "searchKey": "http.http2Transport.getBodyWriterState",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) getBodyWriterState(cs *http2clientStream, body io.Reader) (s http2bodyWriterState)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) getBodyWriterState(cs *http2clientStream, body io.Reader) (s http2bodyWriterState)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.idleConnTimeout",
                    "documentation": {
                      "identifier": "http2Transport.idleConnTimeout",
                      "newPage": false,
                      "searchKey": "http.http2Transport.idleConnTimeout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) idleConnTimeout() time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) idleConnTimeout() time.Duration\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.initConnPool",
                    "documentation": {
                      "identifier": "http2Transport.initConnPool",
                      "newPage": false,
                      "searchKey": "http.http2Transport.initConnPool",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) initConnPool()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) initConnPool()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.logf",
                    "documentation": {
                      "identifier": "http2Transport.logf",
                      "newPage": false,
                      "searchKey": "http.http2Transport.logf",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) logf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) logf(format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.maxHeaderListSize",
                    "documentation": {
                      "identifier": "http2Transport.maxHeaderListSize",
                      "newPage": false,
                      "searchKey": "http.http2Transport.maxHeaderListSize",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) maxHeaderListSize() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) maxHeaderListSize() uint32\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.newClientConn",
                    "documentation": {
                      "identifier": "http2Transport.newClientConn",
                      "newPage": false,
                      "searchKey": "http.http2Transport.newClientConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) newClientConn(c net.Conn, singleUse bool) (*http2ClientConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) newClientConn(c net.Conn, singleUse bool) (*http2ClientConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.newTLSConfig",
                    "documentation": {
                      "identifier": "http2Transport.newTLSConfig",
                      "newPage": false,
                      "searchKey": "http.http2Transport.newTLSConfig",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) newTLSConfig(host string) *tls.Config"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) newTLSConfig(host string) *tls.Config\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.pingTimeout",
                    "documentation": {
                      "identifier": "http2Transport.pingTimeout",
                      "newPage": false,
                      "searchKey": "http.http2Transport.pingTimeout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) pingTimeout() time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) pingTimeout() time.Duration\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2Transport.vlogf",
                    "documentation": {
                      "identifier": "http2Transport.vlogf",
                      "newPage": false,
                      "searchKey": "http.http2Transport.vlogf",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *http2Transport) vlogf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *http2Transport) vlogf(format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2UnknownFrame",
              "documentation": {
                "identifier": "http2UnknownFrame",
                "newPage": false,
                "searchKey": "http.http2UnknownFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2UnknownFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2UnknownFrame struct {\n\thttp2FrameHeader\n\tp []byte\n}\n```\n\nAn UnknownFrame is the frame type returned when the frame type is unknown or no specific frame type parser exists. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2UnknownFrame.Payload",
                    "documentation": {
                      "identifier": "http2UnknownFrame.Payload",
                      "newPage": false,
                      "searchKey": "http.http2UnknownFrame.Payload",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2UnknownFrame) Payload() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2UnknownFrame) Payload() []byte\n```\n\nPayload returns the frame's payload (after the header).  It is not valid to call this method after a subsequent call to Framer.ReadFrame, nor is it valid to retain the returned slice. The memory is owned by the Framer and is invalidated when the next frame is read. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2WindowUpdateFrame",
              "documentation": {
                "identifier": "http2WindowUpdateFrame",
                "newPage": false,
                "searchKey": "http.http2WindowUpdateFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2WindowUpdateFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2WindowUpdateFrame struct {\n\thttp2FrameHeader\n\tIncrement uint32 // never read with high bit set\n}\n```\n\nA WindowUpdateFrame is used to implement flow control. See [http://http2.github.io/http2-spec/#rfc.section.6.9](http://http2.github.io/http2-spec/#rfc.section.6.9) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2WriteScheduler",
              "documentation": {
                "identifier": "http2WriteScheduler",
                "newPage": false,
                "searchKey": "http.http2WriteScheduler",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2WriteScheduler interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2WriteScheduler interface {\n\t// OpenStream opens a new stream in the write scheduler.\n\t// It is illegal to call this with streamID=0 or with a streamID that is\n\t// already open -- the call may panic.\n\tOpenStream(streamID uint32, options http2OpenStreamOptions)\n\n\t// CloseStream closes a stream in the write scheduler. Any frames queued on\n\t// this stream should be discarded. It is illegal to call this on a stream\n\t// that is not open -- the call may panic.\n\tCloseStream(streamID uint32)\n\n\t// AdjustStream adjusts the priority of the given stream. This may be called\n\t// on a stream that has not yet been opened or has been closed. Note that\n\t// RFC 7540 allows PRIORITY frames to be sent on streams in any state. See:\n\t// https://tools.ietf.org/html/rfc7540#section-5.1\n\tAdjustStream(streamID uint32, priority http2PriorityParam)\n\n\t// Push queues a frame in the scheduler. In most cases, this will not be\n\t// called with wr.StreamID()!=0 unless that stream is currently open. The one\n\t// exception is RST_STREAM frames, which may be sent on idle or closed streams.\n\tPush(wr http2FrameWriteRequest)\n\n\t// Pop dequeues the next frame to write. Returns false if no frames can\n\t// be written. Frames with a given wr.StreamID() are Pop'd in the same\n\t// order they are Push'd. No frames should be discarded except by CloseStream.\n\tPop() (wr http2FrameWriteRequest, ok bool)\n}\n```\n\nWriteScheduler is the interface implemented by HTTP/2 write schedulers. Methods are never called concurrently. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2NewPriorityWriteScheduler",
                    "documentation": {
                      "identifier": "http2NewPriorityWriteScheduler",
                      "newPage": false,
                      "searchKey": "http.http2NewPriorityWriteScheduler",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2NewPriorityWriteScheduler(cfg *http2PriorityWriteSchedulerConfig) http2WriteScheduler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2NewPriorityWriteScheduler(cfg *http2PriorityWriteSchedulerConfig) http2WriteScheduler\n```\n\nNewPriorityWriteScheduler constructs a WriteScheduler that schedules frames by following HTTP/2 priorities as described in RFC 7540 Section 5.3. If cfg is nil, default options are used. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2NewRandomWriteScheduler",
                    "documentation": {
                      "identifier": "http2NewRandomWriteScheduler",
                      "newPage": false,
                      "searchKey": "http.http2NewRandomWriteScheduler",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2NewRandomWriteScheduler() http2WriteScheduler"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2NewRandomWriteScheduler() http2WriteScheduler\n```\n\nNewRandomWriteScheduler constructs a WriteScheduler that ignores HTTP/2 priorities. Control frames like SETTINGS and PING are written before DATA frames, but if no control frames are queued and multiple streams have queued HEADERS or DATA frames, Pop selects a ready stream arbitrarily. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2addConnCall",
              "documentation": {
                "identifier": "http2addConnCall",
                "newPage": false,
                "searchKey": "http.http2addConnCall",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2addConnCall struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2addConnCall struct {\n\t_    http2incomparable\n\tp    *http2clientConnPool\n\tdone chan struct{} // closed when done\n\terr  error\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2addConnCall.run",
                    "documentation": {
                      "identifier": "http2addConnCall.run",
                      "newPage": false,
                      "searchKey": "http.http2addConnCall.run",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *http2addConnCall) run(t *http2Transport, key string, tc *tls.Conn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *http2addConnCall) run(t *http2Transport, key string, tc *tls.Conn)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2bodyReadMsg",
              "documentation": {
                "identifier": "http2bodyReadMsg",
                "newPage": false,
                "searchKey": "http.http2bodyReadMsg",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2bodyReadMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2bodyReadMsg struct {\n\tst *http2stream\n\tn  int\n}\n```\n\nA bodyReadMsg tells the server loop that the http.Handler read n bytes of the DATA from the client on the given stream. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2bodyWriterState",
              "documentation": {
                "identifier": "http2bodyWriterState",
                "newPage": false,
                "searchKey": "http.http2bodyWriterState",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2bodyWriterState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2bodyWriterState struct {\n\tcs     *http2clientStream\n\ttimer  *time.Timer   // if non-nil, we're doing a delayed write\n\tfnonce *sync.Once    // to call fn with\n\tfn     func()        // the code to run in the goroutine, writing the body\n\tresc   chan error    // result of fn's execution\n\tdelay  time.Duration // how long we should delay a delayed write for\n}\n```\n\nbodyWriterState encapsulates various state around the Transport's writing of the request body, particularly regarding doing delayed writes of the body when the request contains \"Expect: 100-continue\". \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2bodyWriterState.cancel",
                    "documentation": {
                      "identifier": "http2bodyWriterState.cancel",
                      "newPage": false,
                      "searchKey": "http.http2bodyWriterState.cancel",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s http2bodyWriterState) cancel()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s http2bodyWriterState) cancel()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2bodyWriterState.on100",
                    "documentation": {
                      "identifier": "http2bodyWriterState.on100",
                      "newPage": false,
                      "searchKey": "http.http2bodyWriterState.on100",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s http2bodyWriterState) on100()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s http2bodyWriterState) on100()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2bodyWriterState.scheduleBodyWrite",
                    "documentation": {
                      "identifier": "http2bodyWriterState.scheduleBodyWrite",
                      "newPage": false,
                      "searchKey": "http.http2bodyWriterState.scheduleBodyWrite",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s http2bodyWriterState) scheduleBodyWrite()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s http2bodyWriterState) scheduleBodyWrite()\n```\n\nscheduleBodyWrite starts writing the body, either immediately (in the common case) or after the delay timeout. It should not be called until after the headers have been written. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2bufferedWriter",
              "documentation": {
                "identifier": "http2bufferedWriter",
                "newPage": false,
                "searchKey": "http.http2bufferedWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2bufferedWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2bufferedWriter struct {\n\t_  http2incomparable\n\tw  io.Writer     // immutable\n\tbw *bufio.Writer // non-nil when data is buffered\n}\n```\n\nbufferedWriter is a buffered writer that writes to w. Its buffered writer is lazily allocated as needed, to minimize idle memory usage with many connections. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2newBufferedWriter",
                    "documentation": {
                      "identifier": "http2newBufferedWriter",
                      "newPage": false,
                      "searchKey": "http.http2newBufferedWriter",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2newBufferedWriter(w io.Writer) *http2bufferedWriter"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2newBufferedWriter(w io.Writer) *http2bufferedWriter\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2bufferedWriter.Available",
                    "documentation": {
                      "identifier": "http2bufferedWriter.Available",
                      "newPage": false,
                      "searchKey": "http.http2bufferedWriter.Available",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2bufferedWriter) Available() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2bufferedWriter) Available() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2bufferedWriter.Flush",
                    "documentation": {
                      "identifier": "http2bufferedWriter.Flush",
                      "newPage": false,
                      "searchKey": "http.http2bufferedWriter.Flush",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2bufferedWriter) Flush() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2bufferedWriter) Flush() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2bufferedWriter.Write",
                    "documentation": {
                      "identifier": "http2bufferedWriter.Write",
                      "newPage": false,
                      "searchKey": "http.http2bufferedWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2bufferedWriter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2bufferedWriter) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2chunkWriter",
              "documentation": {
                "identifier": "http2chunkWriter",
                "newPage": false,
                "searchKey": "http.http2chunkWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2chunkWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2chunkWriter struct{ rws *http2responseWriterState }\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2chunkWriter.Write",
                    "documentation": {
                      "identifier": "http2chunkWriter.Write",
                      "newPage": false,
                      "searchKey": "http.http2chunkWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cw http2chunkWriter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cw http2chunkWriter) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2clientConnIdleState",
              "documentation": {
                "identifier": "http2clientConnIdleState",
                "newPage": false,
                "searchKey": "http.http2clientConnIdleState",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2clientConnIdleState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2clientConnIdleState struct {\n\tcanTakeNewRequest bool\n\tfreshConn         bool // whether it's unused by any previous request\n}\n```\n\nclientConnIdleState describes the suitability of a client connection to initiate a new RoundTrip request. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2clientConnPool",
              "documentation": {
                "identifier": "http2clientConnPool",
                "newPage": false,
                "searchKey": "http.http2clientConnPool",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2clientConnPool struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2clientConnPool struct {\n\tt *http2Transport\n\n\tmu sync.Mutex // TODO: maybe switch to RWMutex\n\t// TODO: add support for sharing conns based on cert names\n\t// (e.g. share conn for googleapis.com and appspot.com)\n\tconns        map[string][]*http2ClientConn // key is host:port\n\tdialing      map[string]*http2dialCall     // currently in-flight dials\n\tkeys         map[*http2ClientConn][]string\n\taddConnCalls map[string]*http2addConnCall // in-flight addConnIfNeede calls\n}\n```\n\nTODO: use singleflight for dialing and addConnCalls? \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnPool.GetClientConn",
                    "documentation": {
                      "identifier": "http2clientConnPool.GetClientConn",
                      "newPage": false,
                      "searchKey": "http.http2clientConnPool.GetClientConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2clientConnPool) GetClientConn(req *Request, addr string) (*http2ClientConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2clientConnPool) GetClientConn(req *Request, addr string) (*http2ClientConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnPool.MarkDead",
                    "documentation": {
                      "identifier": "http2clientConnPool.MarkDead",
                      "newPage": false,
                      "searchKey": "http.http2clientConnPool.MarkDead",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2clientConnPool) MarkDead(cc *http2ClientConn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2clientConnPool) MarkDead(cc *http2ClientConn)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnPool.addConnIfNeeded",
                    "documentation": {
                      "identifier": "http2clientConnPool.addConnIfNeeded",
                      "newPage": false,
                      "searchKey": "http.http2clientConnPool.addConnIfNeeded",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2clientConnPool) addConnIfNeeded(key string, t *http2Transport, c *tls.Conn) (used bool, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2clientConnPool) addConnIfNeeded(key string, t *http2Transport, c *tls.Conn) (used bool, err error)\n```\n\naddConnIfNeeded makes a NewClientConn out of c if a connection for key doesn't already exist. It coalesces concurrent calls with the same key. This is used by the http1 Transport code when it creates a new connection. Because the http1 Transport doesn't de-dup TCP dials to outbound hosts (because it doesn't know the protocol), it can get into a situation where it has multiple TLS connections. This code decides which ones live or die. The return value used is whether c was used. c is never closed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnPool.addConnLocked",
                    "documentation": {
                      "identifier": "http2clientConnPool.addConnLocked",
                      "newPage": false,
                      "searchKey": "http.http2clientConnPool.addConnLocked",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2clientConnPool) addConnLocked(key string, cc *http2ClientConn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2clientConnPool) addConnLocked(key string, cc *http2ClientConn)\n```\n\np.mu must be held \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnPool.closeIdleConnections",
                    "documentation": {
                      "identifier": "http2clientConnPool.closeIdleConnections",
                      "newPage": false,
                      "searchKey": "http.http2clientConnPool.closeIdleConnections",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2clientConnPool) closeIdleConnections()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2clientConnPool) closeIdleConnections()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnPool.getClientConn",
                    "documentation": {
                      "identifier": "http2clientConnPool.getClientConn",
                      "newPage": false,
                      "searchKey": "http.http2clientConnPool.getClientConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2clientConnPool) getClientConn(req *Request, addr string, dialOnMiss bool) (*http2ClientConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2clientConnPool) getClientConn(req *Request, addr string, dialOnMiss bool) (*http2ClientConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnPool.getStartDialLocked",
                    "documentation": {
                      "identifier": "http2clientConnPool.getStartDialLocked",
                      "newPage": false,
                      "searchKey": "http.http2clientConnPool.getStartDialLocked",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2clientConnPool) getStartDialLocked(ctx context.Context, addr string) *http2dialCall"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2clientConnPool) getStartDialLocked(ctx context.Context, addr string) *http2dialCall\n```\n\nrequires p.mu is held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnPool.shouldTraceGetConn",
                    "documentation": {
                      "identifier": "http2clientConnPool.shouldTraceGetConn",
                      "newPage": false,
                      "searchKey": "http.http2clientConnPool.shouldTraceGetConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2clientConnPool) shouldTraceGetConn(st http2clientConnIdleState) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2clientConnPool) shouldTraceGetConn(st http2clientConnIdleState) bool\n```\n\nshouldTraceGetConn reports whether getClientConn should call any ClientTrace.GetConn hook associated with the http.Request. \n\nThis complexity is needed to avoid double calls of the GetConn hook during the back-and-forth between net/http and x/net/http2 (when the net/http.Transport is upgraded to also speak http2), as well as support the case where x/net/http2 is being used directly. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2clientConnPoolIdleCloser",
              "documentation": {
                "identifier": "http2clientConnPoolIdleCloser",
                "newPage": false,
                "searchKey": "http.http2clientConnPoolIdleCloser",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2clientConnPoolIdleCloser interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2clientConnPoolIdleCloser interface {\n\thttp2ClientConnPool\n\tcloseIdleConnections()\n}\n```\n\nclientConnPoolIdleCloser is the interface implemented by ClientConnPool implementations which can close their idle connections. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2clientConnReadLoop",
              "documentation": {
                "identifier": "http2clientConnReadLoop",
                "newPage": false,
                "searchKey": "http.http2clientConnReadLoop",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2clientConnReadLoop struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2clientConnReadLoop struct {\n\t_             http2incomparable\n\tcc            *http2ClientConn\n\tcloseWhenIdle bool\n}\n```\n\nclientConnReadLoop is the state owned by the clientConn's frame-reading readLoop. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.cleanup",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.cleanup",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.cleanup",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) cleanup()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) cleanup()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.endStream",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.endStream",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.endStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) endStream(cs *http2clientStream)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) endStream(cs *http2clientStream)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.endStreamError",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.endStreamError",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.endStreamError",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) endStreamError(cs *http2clientStream, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) endStreamError(cs *http2clientStream, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.handleResponse",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.handleResponse",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.handleResponse",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) handleResponse(cs *http2clientStream, f *http2MetaHeadersFrame) (*Response, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) handleResponse(cs *http2clientStream, f *http2MetaHeadersFrame) (*Response, error)\n```\n\nmay return error types nil, or ConnectionError. Any other error value is a StreamError of type ErrCodeProtocol. The returned error in that case is the detail. \n\nAs a special case, handleResponse may return (nil, nil) to skip the frame (currently only used for 1xx responses). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.processData",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.processData",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.processData",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) processData(f *http2DataFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) processData(f *http2DataFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.processGoAway",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.processGoAway",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.processGoAway",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) processGoAway(f *http2GoAwayFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) processGoAway(f *http2GoAwayFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.processHeaders",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.processHeaders",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.processHeaders",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) processHeaders(f *http2MetaHeadersFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) processHeaders(f *http2MetaHeadersFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.processPing",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.processPing",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.processPing",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) processPing(f *http2PingFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) processPing(f *http2PingFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.processPushPromise",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.processPushPromise",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.processPushPromise",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) processPushPromise(f *http2PushPromiseFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) processPushPromise(f *http2PushPromiseFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.processResetStream",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.processResetStream",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.processResetStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) processResetStream(f *http2RSTStreamFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) processResetStream(f *http2RSTStreamFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.processSettings",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.processSettings",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.processSettings",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) processSettings(f *http2SettingsFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) processSettings(f *http2SettingsFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.processTrailers",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.processTrailers",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.processTrailers",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) processTrailers(cs *http2clientStream, f *http2MetaHeadersFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) processTrailers(cs *http2clientStream, f *http2MetaHeadersFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.processWindowUpdate",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.processWindowUpdate",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.processWindowUpdate",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) processWindowUpdate(f *http2WindowUpdateFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) processWindowUpdate(f *http2WindowUpdateFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientConnReadLoop.run",
                    "documentation": {
                      "identifier": "http2clientConnReadLoop.run",
                      "newPage": false,
                      "searchKey": "http.http2clientConnReadLoop.run",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rl *http2clientConnReadLoop) run() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rl *http2clientConnReadLoop) run() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2clientStream",
              "documentation": {
                "identifier": "http2clientStream",
                "newPage": false,
                "searchKey": "http.http2clientStream",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2clientStream struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2clientStream struct {\n\tcc            *http2ClientConn\n\treq           *Request\n\ttrace         *httptrace.ClientTrace // or nil\n\tID            uint32\n\tresc          chan http2resAndError\n\tbufPipe       http2pipe // buffered pipe with the flow-controlled response payload\n\tstartedWrite  bool      // started request body write; guarded by cc.mu\n\trequestedGzip bool\n\ton100         func() // optional code to run if get a 100 continue response\n\n\tflow        http2flow // guarded by cc.mu\n\tinflow      http2flow // guarded by cc.mu\n\tbytesRemain int64     // -1 means unknown; owned by transportResponseBody.Read\n\treadErr     error     // sticky read error; owned by transportResponseBody.Read\n\tstopReqBody error     // if non-nil, stop writing req body; guarded by cc.mu\n\tdidReset    bool      // whether we sent a RST_STREAM to the server; guarded by cc.mu\n\n\tpeerReset chan struct{} // closed on peer reset\n\tresetErr  error         // populated before peerReset is closed\n\n\tdone chan struct{} // closed when stream remove from cc.streams map; close calls guarded by cc.mu\n\n\t// owned by clientConnReadLoop:\n\tfirstByte    bool  // got the first response byte\n\tpastHeaders  bool  // got first MetaHeadersFrame (actual headers)\n\tpastTrailers bool  // got optional second MetaHeadersFrame (trailers)\n\tnum1xx       uint8 // number of 1xx responses seen\n\n\ttrailer    Header  // accumulated trailers\n\tresTrailer *Header // client's Response.Trailer\n}\n```\n\nclientStream is the state for a single HTTP/2 stream. One of these is created for each Transport.RoundTrip call. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2clientStream.abortRequestBodyWrite",
                    "documentation": {
                      "identifier": "http2clientStream.abortRequestBodyWrite",
                      "newPage": false,
                      "searchKey": "http.http2clientStream.abortRequestBodyWrite",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cs *http2clientStream) abortRequestBodyWrite(err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cs *http2clientStream) abortRequestBodyWrite(err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientStream.awaitFlowControl",
                    "documentation": {
                      "identifier": "http2clientStream.awaitFlowControl",
                      "newPage": false,
                      "searchKey": "http.http2clientStream.awaitFlowControl",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cs *http2clientStream) awaitFlowControl(maxBytes int) (taken int32, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cs *http2clientStream) awaitFlowControl(maxBytes int) (taken int32, err error)\n```\n\nawaitFlowControl waits for [1, min(maxBytes, cc.cs.maxFrameSize)] flow control tokens from the server. It returns either the non-zero number of tokens taken or an error if the stream is dead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientStream.awaitRequestCancel",
                    "documentation": {
                      "identifier": "http2clientStream.awaitRequestCancel",
                      "newPage": false,
                      "searchKey": "http.http2clientStream.awaitRequestCancel",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cs *http2clientStream) awaitRequestCancel(req *Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cs *http2clientStream) awaitRequestCancel(req *Request)\n```\n\nawaitRequestCancel waits for the user to cancel a request, its context to expire, or for the request to be done (any way it might be removed from the cc.streams map: peer reset, successful completion, TCP connection breakage, etc). If the request is canceled, then cs will be canceled and closed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientStream.cancelStream",
                    "documentation": {
                      "identifier": "http2clientStream.cancelStream",
                      "newPage": false,
                      "searchKey": "http.http2clientStream.cancelStream",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cs *http2clientStream) cancelStream()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cs *http2clientStream) cancelStream()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientStream.checkResetOrDone",
                    "documentation": {
                      "identifier": "http2clientStream.checkResetOrDone",
                      "newPage": false,
                      "searchKey": "http.http2clientStream.checkResetOrDone",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cs *http2clientStream) checkResetOrDone() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cs *http2clientStream) checkResetOrDone() error\n```\n\ncheckResetOrDone reports any error sent in a RST_STREAM frame by the server, or errStreamClosed if the stream is complete. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientStream.copyTrailers",
                    "documentation": {
                      "identifier": "http2clientStream.copyTrailers",
                      "newPage": false,
                      "searchKey": "http.http2clientStream.copyTrailers",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cs *http2clientStream) copyTrailers()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cs *http2clientStream) copyTrailers()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientStream.get1xxTraceFunc",
                    "documentation": {
                      "identifier": "http2clientStream.get1xxTraceFunc",
                      "newPage": false,
                      "searchKey": "http.http2clientStream.get1xxTraceFunc",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cs *http2clientStream) get1xxTraceFunc() func(int, textproto.MIMEHeader) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cs *http2clientStream) get1xxTraceFunc() func(int, textproto.MIMEHeader) error\n```\n\nget1xxTraceFunc returns the value of request's httptrace.ClientTrace.Got1xxResponse func, if any. It returns nil if not set or if the Go version is too old. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientStream.getStartedWrite",
                    "documentation": {
                      "identifier": "http2clientStream.getStartedWrite",
                      "newPage": false,
                      "searchKey": "http.http2clientStream.getStartedWrite",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cs *http2clientStream) getStartedWrite() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cs *http2clientStream) getStartedWrite() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2clientStream.writeRequestBody",
                    "documentation": {
                      "identifier": "http2clientStream.writeRequestBody",
                      "newPage": false,
                      "searchKey": "http.http2clientStream.writeRequestBody",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cs *http2clientStream) writeRequestBody(body io.Reader, bodyCloser io.Closer) (err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cs *http2clientStream) writeRequestBody(body io.Reader, bodyCloser io.Closer) (err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2closeWaiter",
              "documentation": {
                "identifier": "http2closeWaiter",
                "newPage": false,
                "searchKey": "http.http2closeWaiter",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2closeWaiter chan struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2closeWaiter chan struct{}\n```\n\nA closeWaiter is like a sync.WaitGroup but only goes 1 to 0 (open to closed). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2closeWaiter.Close",
                    "documentation": {
                      "identifier": "http2closeWaiter.Close",
                      "newPage": false,
                      "searchKey": "http.http2closeWaiter.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cw http2closeWaiter) Close()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cw http2closeWaiter) Close()\n```\n\nClose marks the closeWaiter as closed and unblocks any waiters. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2closeWaiter.Init",
                    "documentation": {
                      "identifier": "http2closeWaiter.Init",
                      "newPage": false,
                      "searchKey": "http.http2closeWaiter.Init",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cw *http2closeWaiter) Init()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cw *http2closeWaiter) Init()\n```\n\nInit makes a closeWaiter usable. It exists because so a closeWaiter value can be placed inside a larger struct and have the Mutex and Cond's memory in the same allocation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2closeWaiter.Wait",
                    "documentation": {
                      "identifier": "http2closeWaiter.Wait",
                      "newPage": false,
                      "searchKey": "http.http2closeWaiter.Wait",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cw http2closeWaiter) Wait()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cw http2closeWaiter) Wait()\n```\n\nWait waits for the closeWaiter to become closed. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2connError",
              "documentation": {
                "identifier": "http2connError",
                "newPage": false,
                "searchKey": "http.http2connError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2connError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2connError struct {\n\tCode   http2ErrCode // the ConnectionError error code\n\tReason string       // additional reason\n}\n```\n\nconnError represents an HTTP/2 ConnectionError error code, along with a string (for debugging) explaining why. \n\nErrors of this type are only returned by the frame parser functions and converted into ConnectionError(Code), after stashing away the Reason into the Framer's errDetail field, accessible via the (*Framer).ErrorDetail method. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2connError.Error",
                    "documentation": {
                      "identifier": "http2connError.Error",
                      "newPage": false,
                      "searchKey": "http.http2connError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e http2connError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e http2connError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2connectionStater",
              "documentation": {
                "identifier": "http2connectionStater",
                "newPage": false,
                "searchKey": "http.http2connectionStater",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2connectionStater interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2connectionStater interface {\n\tConnectionState() tls.ConnectionState\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2dataBuffer",
              "documentation": {
                "identifier": "http2dataBuffer",
                "newPage": false,
                "searchKey": "http.http2dataBuffer",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2dataBuffer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2dataBuffer struct {\n\tchunks   [][]byte\n\tr        int   // next byte to read is chunks[0][r]\n\tw        int   // next byte to write is chunks[len(chunks)-1][w]\n\tsize     int   // total buffered bytes\n\texpected int64 // we expect at least this many bytes in future Write calls (ignored if <= 0)\n}\n```\n\ndataBuffer is an io.ReadWriter backed by a list of data chunks. Each dataBuffer is used to read DATA frames on a single stream. The buffer is divided into chunks so the server can limit the total memory used by a single connection without limiting the request body size on any single stream. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2dataBuffer.Len",
                    "documentation": {
                      "identifier": "http2dataBuffer.Len",
                      "newPage": false,
                      "searchKey": "http.http2dataBuffer.Len",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *http2dataBuffer) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *http2dataBuffer) Len() int\n```\n\nLen returns the number of bytes of the unread portion of the buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2dataBuffer.Read",
                    "documentation": {
                      "identifier": "http2dataBuffer.Read",
                      "newPage": false,
                      "searchKey": "http.http2dataBuffer.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *http2dataBuffer) Read(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *http2dataBuffer) Read(p []byte) (int, error)\n```\n\nRead copies bytes from the buffer into p. It is an error to read when no data is available. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2dataBuffer.Write",
                    "documentation": {
                      "identifier": "http2dataBuffer.Write",
                      "newPage": false,
                      "searchKey": "http.http2dataBuffer.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *http2dataBuffer) Write(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *http2dataBuffer) Write(p []byte) (int, error)\n```\n\nWrite appends p to the buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2dataBuffer.bytesFromFirstChunk",
                    "documentation": {
                      "identifier": "http2dataBuffer.bytesFromFirstChunk",
                      "newPage": false,
                      "searchKey": "http.http2dataBuffer.bytesFromFirstChunk",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *http2dataBuffer) bytesFromFirstChunk() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *http2dataBuffer) bytesFromFirstChunk() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2dataBuffer.lastChunkOrAlloc",
                    "documentation": {
                      "identifier": "http2dataBuffer.lastChunkOrAlloc",
                      "newPage": false,
                      "searchKey": "http.http2dataBuffer.lastChunkOrAlloc",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *http2dataBuffer) lastChunkOrAlloc(want int64) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *http2dataBuffer) lastChunkOrAlloc(want int64) []byte\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2dialCall",
              "documentation": {
                "identifier": "http2dialCall",
                "newPage": false,
                "searchKey": "http.http2dialCall",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2dialCall struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2dialCall struct {\n\t_ http2incomparable\n\tp *http2clientConnPool\n\t// the context associated with the request\n\t// that created this dialCall\n\tctx  context.Context\n\tdone chan struct{}    // closed when done\n\tres  *http2ClientConn // valid after done is closed\n\terr  error            // valid after done is closed\n}\n```\n\ndialCall is an in-flight Transport dial call to a host. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2dialCall.dial",
                    "documentation": {
                      "identifier": "http2dialCall.dial",
                      "newPage": false,
                      "searchKey": "http.http2dialCall.dial",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *http2dialCall) dial(ctx context.Context, addr string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *http2dialCall) dial(ctx context.Context, addr string)\n```\n\nrun in its own goroutine. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2duplicatePseudoHeaderError",
              "documentation": {
                "identifier": "http2duplicatePseudoHeaderError",
                "newPage": false,
                "searchKey": "http.http2duplicatePseudoHeaderError",
                "tags": [
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2duplicatePseudoHeaderError string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2duplicatePseudoHeaderError string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2duplicatePseudoHeaderError.Error",
                    "documentation": {
                      "identifier": "http2duplicatePseudoHeaderError.Error",
                      "newPage": false,
                      "searchKey": "http.http2duplicatePseudoHeaderError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e http2duplicatePseudoHeaderError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e http2duplicatePseudoHeaderError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2erringRoundTripper",
              "documentation": {
                "identifier": "http2erringRoundTripper",
                "newPage": false,
                "searchKey": "http.http2erringRoundTripper",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2erringRoundTripper struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2erringRoundTripper struct{ err error }\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2erringRoundTripper.RoundTrip",
                    "documentation": {
                      "identifier": "http2erringRoundTripper.RoundTrip",
                      "newPage": false,
                      "searchKey": "http.http2erringRoundTripper.RoundTrip",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rt http2erringRoundTripper) RoundTrip(*Request) (*Response, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rt http2erringRoundTripper) RoundTrip(*Request) (*Response, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2erringRoundTripper.RoundTripErr",
                    "documentation": {
                      "identifier": "http2erringRoundTripper.RoundTripErr",
                      "newPage": false,
                      "searchKey": "http.http2erringRoundTripper.RoundTripErr",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rt http2erringRoundTripper) RoundTripErr() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rt http2erringRoundTripper) RoundTripErr() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errorReader",
              "documentation": {
                "identifier": "http2errorReader",
                "newPage": false,
                "searchKey": "http.http2errorReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2errorReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2errorReader struct{ err error }\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2errorReader.Read",
                    "documentation": {
                      "identifier": "http2errorReader.Read",
                      "newPage": false,
                      "searchKey": "http.http2errorReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r http2errorReader) Read(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r http2errorReader) Read(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2flow",
              "documentation": {
                "identifier": "http2flow",
                "newPage": false,
                "searchKey": "http.http2flow",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2flow struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2flow struct {\n\t_ http2incomparable\n\n\t// n is the number of DATA bytes we're allowed to send.\n\t// A flow is kept both on a conn and a per-stream.\n\tn int32\n\n\t// conn points to the shared connection-level flow that is\n\t// shared by all streams on that conn. It is nil for the flow\n\t// that's on the conn directly.\n\tconn *http2flow\n}\n```\n\nflow is the flow control window's size. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2flow.add",
                    "documentation": {
                      "identifier": "http2flow.add",
                      "newPage": false,
                      "searchKey": "http.http2flow.add",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2flow) add(n int32) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2flow) add(n int32) bool\n```\n\nadd adds n bytes (positive or negative) to the flow control window. It returns false if the sum would exceed 2^31-1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2flow.available",
                    "documentation": {
                      "identifier": "http2flow.available",
                      "newPage": false,
                      "searchKey": "http.http2flow.available",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2flow) available() int32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2flow) available() int32\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2flow.setConnFlow",
                    "documentation": {
                      "identifier": "http2flow.setConnFlow",
                      "newPage": false,
                      "searchKey": "http.http2flow.setConnFlow",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2flow) setConnFlow(cf *http2flow)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2flow) setConnFlow(cf *http2flow)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2flow.take",
                    "documentation": {
                      "identifier": "http2flow.take",
                      "newPage": false,
                      "searchKey": "http.http2flow.take",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *http2flow) take(n int32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *http2flow) take(n int32)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2flushFrameWriter",
              "documentation": {
                "identifier": "http2flushFrameWriter",
                "newPage": false,
                "searchKey": "http.http2flushFrameWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2flushFrameWriter struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2flushFrameWriter struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2flushFrameWriter.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2flushFrameWriter.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2flushFrameWriter.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (http2flushFrameWriter) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (http2flushFrameWriter) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2flushFrameWriter.writeFrame",
                    "documentation": {
                      "identifier": "http2flushFrameWriter.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2flushFrameWriter.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (http2flushFrameWriter) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (http2flushFrameWriter) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2frameCache",
              "documentation": {
                "identifier": "http2frameCache",
                "newPage": false,
                "searchKey": "http.http2frameCache",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2frameCache struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2frameCache struct {\n\tdataFrame http2DataFrame\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2frameCache.getDataFrame",
                    "documentation": {
                      "identifier": "http2frameCache.getDataFrame",
                      "newPage": false,
                      "searchKey": "http.http2frameCache.getDataFrame",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fc *http2frameCache) getDataFrame() *http2DataFrame"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fc *http2frameCache) getDataFrame() *http2DataFrame\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2frameParser",
              "documentation": {
                "identifier": "http2frameParser",
                "newPage": false,
                "searchKey": "http.http2frameParser",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2frameParser func(fc *std/net/http.http2frameCache, fh std/net/http.http2FrameHeader, payload []byte) (std/net/http.http2Frame, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2frameParser func(fc *http2frameCache, fh http2FrameHeader, payload []byte) (http2Frame, error)\n```\n\na frameParser parses a frame given its FrameHeader and payload bytes. The length of payload will always equal fh.Length (which might be 0). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2typeFrameParser",
                    "documentation": {
                      "identifier": "http2typeFrameParser",
                      "newPage": false,
                      "searchKey": "http.http2typeFrameParser",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2typeFrameParser(t http2FrameType) http2frameParser"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2typeFrameParser(t http2FrameType) http2frameParser\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2frameWriteResult",
              "documentation": {
                "identifier": "http2frameWriteResult",
                "newPage": false,
                "searchKey": "http.http2frameWriteResult",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2frameWriteResult struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2frameWriteResult struct {\n\t_   http2incomparable\n\twr  http2FrameWriteRequest // what was written (or attempted)\n\terr error                  // result of the writeFrame call\n}\n```\n\nframeWriteResult is the message passed from writeFrameAsync to the serve goroutine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2gate",
              "documentation": {
                "identifier": "http2gate",
                "newPage": false,
                "searchKey": "http.http2gate",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2gate chan struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2gate chan struct{}\n```\n\nA gate lets two goroutines coordinate their activities. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2gate.Done",
                    "documentation": {
                      "identifier": "http2gate.Done",
                      "newPage": false,
                      "searchKey": "http.http2gate.Done",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (g http2gate) Done()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (g http2gate) Done()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2gate.Wait",
                    "documentation": {
                      "identifier": "http2gate.Wait",
                      "newPage": false,
                      "searchKey": "http.http2gate.Wait",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (g http2gate) Wait()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (g http2gate) Wait()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2goAwayFlowError",
              "documentation": {
                "identifier": "http2goAwayFlowError",
                "newPage": false,
                "searchKey": "http.http2goAwayFlowError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2goAwayFlowError struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2goAwayFlowError struct{}\n```\n\n6.9.1 The Flow Control Window \"If a sender receives a WINDOW_UPDATE that causes a flow control window to exceed this maximum it MUST terminate either the stream or the connection, as appropriate. For streams, [...]; for the connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code.\" \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2goAwayFlowError.Error",
                    "documentation": {
                      "identifier": "http2goAwayFlowError.Error",
                      "newPage": false,
                      "searchKey": "http.http2goAwayFlowError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (http2goAwayFlowError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (http2goAwayFlowError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2goroutineLock",
              "documentation": {
                "identifier": "http2goroutineLock",
                "newPage": false,
                "searchKey": "http.http2goroutineLock",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2goroutineLock uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2goroutineLock uint64\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2newGoroutineLock",
                    "documentation": {
                      "identifier": "http2newGoroutineLock",
                      "newPage": false,
                      "searchKey": "http.http2newGoroutineLock",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func http2newGoroutineLock() http2goroutineLock"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc http2newGoroutineLock() http2goroutineLock\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2goroutineLock.check",
                    "documentation": {
                      "identifier": "http2goroutineLock.check",
                      "newPage": false,
                      "searchKey": "http.http2goroutineLock.check",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (g http2goroutineLock) check()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (g http2goroutineLock) check()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2goroutineLock.checkNotOn",
                    "documentation": {
                      "identifier": "http2goroutineLock.checkNotOn",
                      "newPage": false,
                      "searchKey": "http.http2goroutineLock.checkNotOn",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (g http2goroutineLock) checkNotOn()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (g http2goroutineLock) checkNotOn()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2gzipReader",
              "documentation": {
                "identifier": "http2gzipReader",
                "newPage": false,
                "searchKey": "http.http2gzipReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2gzipReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2gzipReader struct {\n\t_    http2incomparable\n\tbody io.ReadCloser // underlying Response.Body\n\tzr   *gzip.Reader  // lazily-initialized gzip reader\n\tzerr error         // sticky error\n}\n```\n\ngzipReader wraps a response body so it can lazily call gzip.NewReader on the first call to Read \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2gzipReader.Close",
                    "documentation": {
                      "identifier": "http2gzipReader.Close",
                      "newPage": false,
                      "searchKey": "http.http2gzipReader.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (gz *http2gzipReader) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (gz *http2gzipReader) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2gzipReader.Read",
                    "documentation": {
                      "identifier": "http2gzipReader.Read",
                      "newPage": false,
                      "searchKey": "http.http2gzipReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (gz *http2gzipReader) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (gz *http2gzipReader) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2handlerPanicRST",
              "documentation": {
                "identifier": "http2handlerPanicRST",
                "newPage": false,
                "searchKey": "http.http2handlerPanicRST",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2handlerPanicRST struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2handlerPanicRST struct {\n\tStreamID uint32\n}\n```\n\nhandlerPanicRST is the message sent from handler goroutines when the handler panics. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2handlerPanicRST.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2handlerPanicRST.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2handlerPanicRST.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hp http2handlerPanicRST) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hp http2handlerPanicRST) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2handlerPanicRST.writeFrame",
                    "documentation": {
                      "identifier": "http2handlerPanicRST.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2handlerPanicRST.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hp http2handlerPanicRST) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hp http2handlerPanicRST) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2headerFieldNameError",
              "documentation": {
                "identifier": "http2headerFieldNameError",
                "newPage": false,
                "searchKey": "http.http2headerFieldNameError",
                "tags": [
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2headerFieldNameError string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2headerFieldNameError string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2headerFieldNameError.Error",
                    "documentation": {
                      "identifier": "http2headerFieldNameError.Error",
                      "newPage": false,
                      "searchKey": "http.http2headerFieldNameError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e http2headerFieldNameError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e http2headerFieldNameError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2headerFieldValueError",
              "documentation": {
                "identifier": "http2headerFieldValueError",
                "newPage": false,
                "searchKey": "http.http2headerFieldValueError",
                "tags": [
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2headerFieldValueError string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2headerFieldValueError string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2headerFieldValueError.Error",
                    "documentation": {
                      "identifier": "http2headerFieldValueError.Error",
                      "newPage": false,
                      "searchKey": "http.http2headerFieldValueError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e http2headerFieldValueError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e http2headerFieldValueError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2headersEnder",
              "documentation": {
                "identifier": "http2headersEnder",
                "newPage": false,
                "searchKey": "http.http2headersEnder",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2headersEnder interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2headersEnder interface {\n\tHeadersEnded() bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2headersOrContinuation",
              "documentation": {
                "identifier": "http2headersOrContinuation",
                "newPage": false,
                "searchKey": "http.http2headersOrContinuation",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2headersOrContinuation interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2headersOrContinuation interface {\n\thttp2headersEnder\n\tHeaderBlockFragment() []byte\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2httpError",
              "documentation": {
                "identifier": "http2httpError",
                "newPage": false,
                "searchKey": "http.http2httpError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2httpError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2httpError struct {\n\t_       http2incomparable\n\tmsg     string\n\ttimeout bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2httpError.Error",
                    "documentation": {
                      "identifier": "http2httpError.Error",
                      "newPage": false,
                      "searchKey": "http.http2httpError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *http2httpError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *http2httpError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2httpError.Temporary",
                    "documentation": {
                      "identifier": "http2httpError.Temporary",
                      "newPage": false,
                      "searchKey": "http.http2httpError.Temporary",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *http2httpError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *http2httpError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2httpError.Timeout",
                    "documentation": {
                      "identifier": "http2httpError.Timeout",
                      "newPage": false,
                      "searchKey": "http.http2httpError.Timeout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *http2httpError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *http2httpError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2incomparable",
              "documentation": {
                "identifier": "http2incomparable",
                "newPage": false,
                "searchKey": "http.http2incomparable",
                "tags": [
                  "array",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2incomparable [0]func()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2incomparable [0]func()\n```\n\nincomparable is a zero-width, non-comparable type. Adding it to a struct makes that struct also non-comparable, and generally doesn't add any size (as long as it's first). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2noCachedConnError",
              "documentation": {
                "identifier": "http2noCachedConnError",
                "newPage": false,
                "searchKey": "http.http2noCachedConnError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2noCachedConnError struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2noCachedConnError struct{}\n```\n\nnoCachedConnError is the concrete type of ErrNoCachedConn, which needs to be detected by net/http regardless of whether it's its bundled version (in h2_bundle.go with a rewritten type name) or from a user's x/net/http2. As such, as it has a unique method name (IsHTTP2NoCachedConnError) that net/http sniffs for via func isNoCachedConnError. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2noCachedConnError.Error",
                    "documentation": {
                      "identifier": "http2noCachedConnError.Error",
                      "newPage": false,
                      "searchKey": "http.http2noCachedConnError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (http2noCachedConnError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (http2noCachedConnError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2noCachedConnError.IsHTTP2NoCachedConnError",
                    "documentation": {
                      "identifier": "http2noCachedConnError.IsHTTP2NoCachedConnError",
                      "newPage": false,
                      "searchKey": "http.http2noCachedConnError.IsHTTP2NoCachedConnError",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (http2noCachedConnError) IsHTTP2NoCachedConnError()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (http2noCachedConnError) IsHTTP2NoCachedConnError()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2noDialClientConnPool",
              "documentation": {
                "identifier": "http2noDialClientConnPool",
                "newPage": false,
                "searchKey": "http.http2noDialClientConnPool",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2noDialClientConnPool struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2noDialClientConnPool struct{ *http2clientConnPool }\n```\n\nnoDialClientConnPool is an implementation of http2.ClientConnPool which never dials. We let the HTTP/1.1 client dial and use its TLS connection instead. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2noDialClientConnPool.GetClientConn",
                    "documentation": {
                      "identifier": "http2noDialClientConnPool.GetClientConn",
                      "newPage": false,
                      "searchKey": "http.http2noDialClientConnPool.GetClientConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p http2noDialClientConnPool) GetClientConn(req *Request, addr string) (*http2ClientConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p http2noDialClientConnPool) GetClientConn(req *Request, addr string) (*http2ClientConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2noDialH2RoundTripper",
              "documentation": {
                "identifier": "http2noDialH2RoundTripper",
                "newPage": false,
                "searchKey": "http.http2noDialH2RoundTripper",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2noDialH2RoundTripper struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2noDialH2RoundTripper struct{ *http2Transport }\n```\n\nnoDialH2RoundTripper is a RoundTripper which only tries to complete the request if there's already has a cached connection to the host. (The field is exported so it can be accessed via reflect from net/http; tested by TestNoDialH2RoundTripperType) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2noDialH2RoundTripper.RoundTrip",
                    "documentation": {
                      "identifier": "http2noDialH2RoundTripper.RoundTrip",
                      "newPage": false,
                      "searchKey": "http.http2noDialH2RoundTripper.RoundTrip",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rt http2noDialH2RoundTripper) RoundTrip(req *Request) (*Response, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rt http2noDialH2RoundTripper) RoundTrip(req *Request) (*Response, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2pipe",
              "documentation": {
                "identifier": "http2pipe",
                "newPage": false,
                "searchKey": "http.http2pipe",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2pipe struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2pipe struct {\n\tmu       sync.Mutex\n\tc        sync.Cond       // c.L lazily initialized to &p.mu\n\tb        http2pipeBuffer // nil when done reading\n\tunread   int             // bytes unread when done\n\terr      error           // read error once empty. non-nil means closed.\n\tbreakErr error           // immediate read error (caller doesn't see rest of b)\n\tdonec    chan struct{}   // closed on error\n\treadFn   func()          // optional code to run in Read before error\n}\n```\n\npipe is a goroutine-safe io.Reader/io.Writer pair. It's like io.Pipe except there are no PipeReader/PipeWriter halves, and the underlying buffer is an interface. (io.Pipe is always unbuffered) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2pipe.BreakWithError",
                    "documentation": {
                      "identifier": "http2pipe.BreakWithError",
                      "newPage": false,
                      "searchKey": "http.http2pipe.BreakWithError",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2pipe) BreakWithError(err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2pipe) BreakWithError(err error)\n```\n\nBreakWithError causes the next Read (waking up a current blocked Read if needed) to return the provided err immediately, without waiting for unread data. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2pipe.CloseWithError",
                    "documentation": {
                      "identifier": "http2pipe.CloseWithError",
                      "newPage": false,
                      "searchKey": "http.http2pipe.CloseWithError",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2pipe) CloseWithError(err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2pipe) CloseWithError(err error)\n```\n\nCloseWithError causes the next Read (waking up a current blocked Read if needed) to return the provided err after all data has been read. \n\nThe error must be non-nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2pipe.Done",
                    "documentation": {
                      "identifier": "http2pipe.Done",
                      "newPage": false,
                      "searchKey": "http.http2pipe.Done",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2pipe) Done() <-chan struct{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2pipe) Done() <-chan struct{}\n```\n\nDone returns a channel which is closed if and when this pipe is closed with CloseWithError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2pipe.Err",
                    "documentation": {
                      "identifier": "http2pipe.Err",
                      "newPage": false,
                      "searchKey": "http.http2pipe.Err",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2pipe) Err() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2pipe) Err() error\n```\n\nErr returns the error (if any) first set by BreakWithError or CloseWithError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2pipe.Len",
                    "documentation": {
                      "identifier": "http2pipe.Len",
                      "newPage": false,
                      "searchKey": "http.http2pipe.Len",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2pipe) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2pipe) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2pipe.Read",
                    "documentation": {
                      "identifier": "http2pipe.Read",
                      "newPage": false,
                      "searchKey": "http.http2pipe.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2pipe) Read(d []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2pipe) Read(d []byte) (n int, err error)\n```\n\nRead waits until data is available and copies bytes from the buffer into p. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2pipe.Write",
                    "documentation": {
                      "identifier": "http2pipe.Write",
                      "newPage": false,
                      "searchKey": "http.http2pipe.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2pipe) Write(d []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2pipe) Write(d []byte) (n int, err error)\n```\n\nWrite copies bytes from p into the buffer and wakes a reader. It is an error to write more data than the buffer can hold. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2pipe.closeDoneLocked",
                    "documentation": {
                      "identifier": "http2pipe.closeDoneLocked",
                      "newPage": false,
                      "searchKey": "http.http2pipe.closeDoneLocked",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2pipe) closeDoneLocked()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2pipe) closeDoneLocked()\n```\n\nrequires p.mu be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2pipe.closeWithError",
                    "documentation": {
                      "identifier": "http2pipe.closeWithError",
                      "newPage": false,
                      "searchKey": "http.http2pipe.closeWithError",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2pipe) closeWithError(dst *error, err error, fn func())"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2pipe) closeWithError(dst *error, err error, fn func())\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2pipe.closeWithErrorAndCode",
                    "documentation": {
                      "identifier": "http2pipe.closeWithErrorAndCode",
                      "newPage": false,
                      "searchKey": "http.http2pipe.closeWithErrorAndCode",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2pipe) closeWithErrorAndCode(err error, fn func())"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2pipe) closeWithErrorAndCode(err error, fn func())\n```\n\ncloseWithErrorAndCode is like CloseWithError but also sets some code to run in the caller's goroutine before returning the error. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2pipeBuffer",
              "documentation": {
                "identifier": "http2pipeBuffer",
                "newPage": false,
                "searchKey": "http.http2pipeBuffer",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2pipeBuffer interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2pipeBuffer interface {\n\tLen() int\n\tio.Writer\n\tio.Reader\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2priorityNode",
              "documentation": {
                "identifier": "http2priorityNode",
                "newPage": false,
                "searchKey": "http.http2priorityNode",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2priorityNode struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2priorityNode struct {\n\tq            http2writeQueue        // queue of pending frames to write\n\tid           uint32                 // id of the stream, or 0 for the root of the tree\n\tweight       uint8                  // the actual weight is weight+1, so the value is in [1,256]\n\tstate        http2priorityNodeState // open | closed | idle\n\tbytes        int64                  // number of bytes written by this node, or 0 if closed\n\tsubtreeBytes int64                  // sum(node.bytes) of all nodes in this subtree\n\n\t// These links form the priority tree.\n\tparent     *http2priorityNode\n\tkids       *http2priorityNode // start of the kids list\n\tprev, next *http2priorityNode // doubly-linked list of siblings\n}\n```\n\npriorityNode is a node in an HTTP/2 priority tree. Each node is associated with a single stream ID. See RFC 7540, Section 5.3. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2priorityNode.addBytes",
                    "documentation": {
                      "identifier": "http2priorityNode.addBytes",
                      "newPage": false,
                      "searchKey": "http.http2priorityNode.addBytes",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n *http2priorityNode) addBytes(b int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n *http2priorityNode) addBytes(b int64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2priorityNode.setParent",
                    "documentation": {
                      "identifier": "http2priorityNode.setParent",
                      "newPage": false,
                      "searchKey": "http.http2priorityNode.setParent",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n *http2priorityNode) setParent(parent *http2priorityNode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n *http2priorityNode) setParent(parent *http2priorityNode)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2priorityNode.walkReadyInOrder",
                    "documentation": {
                      "identifier": "http2priorityNode.walkReadyInOrder",
                      "newPage": false,
                      "searchKey": "http.http2priorityNode.walkReadyInOrder",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n *http2priorityNode) walkReadyInOrder(openParent bool, tmp *[]*http2priorityNode, f func(*http2priorityNode, bool) bool) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n *http2priorityNode) walkReadyInOrder(openParent bool, tmp *[]*http2priorityNode, f func(*http2priorityNode, bool) bool) bool\n```\n\nwalkReadyInOrder iterates over the tree in priority order, calling f for each node with a non-empty write queue. When f returns true, this function returns true and the walk halts. tmp is used as scratch space for sorting. \n\nf(n, openParent) takes two arguments: the node to visit, n, and a bool that is true if any ancestor p of n is still open (ignoring the root node). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2priorityNodeState",
              "documentation": {
                "identifier": "http2priorityNodeState",
                "newPage": false,
                "searchKey": "http.http2priorityNodeState",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2priorityNodeState int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2priorityNodeState int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2priorityWriteScheduler",
              "documentation": {
                "identifier": "http2priorityWriteScheduler",
                "newPage": false,
                "searchKey": "http.http2priorityWriteScheduler",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2priorityWriteScheduler struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2priorityWriteScheduler struct {\n\t// root is the root of the priority tree, where root.id = 0.\n\t// The root queues control frames that are not associated with any stream.\n\troot http2priorityNode\n\n\t// nodes maps stream ids to priority tree nodes.\n\tnodes map[uint32]*http2priorityNode\n\n\t// maxID is the maximum stream id in nodes.\n\tmaxID uint32\n\n\t// lists of nodes that have been closed or are idle, but are kept in\n\t// the tree for improved prioritization. When the lengths exceed either\n\t// maxClosedNodesInTree or maxIdleNodesInTree, old nodes are discarded.\n\tclosedNodes, idleNodes []*http2priorityNode\n\n\t// From the config.\n\tmaxClosedNodesInTree int\n\tmaxIdleNodesInTree   int\n\twriteThrottleLimit   int32\n\tenableWriteThrottle  bool\n\n\t// tmp is scratch space for priorityNode.walkReadyInOrder to reduce allocations.\n\ttmp []*http2priorityNode\n\n\t// pool of empty queues for reuse.\n\tqueuePool http2writeQueuePool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2priorityWriteScheduler.AdjustStream",
                    "documentation": {
                      "identifier": "http2priorityWriteScheduler.AdjustStream",
                      "newPage": false,
                      "searchKey": "http.http2priorityWriteScheduler.AdjustStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2priorityWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2priorityWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2priorityWriteScheduler.CloseStream",
                    "documentation": {
                      "identifier": "http2priorityWriteScheduler.CloseStream",
                      "newPage": false,
                      "searchKey": "http.http2priorityWriteScheduler.CloseStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2priorityWriteScheduler) CloseStream(streamID uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2priorityWriteScheduler) CloseStream(streamID uint32)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2priorityWriteScheduler.OpenStream",
                    "documentation": {
                      "identifier": "http2priorityWriteScheduler.OpenStream",
                      "newPage": false,
                      "searchKey": "http.http2priorityWriteScheduler.OpenStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2priorityWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2priorityWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2priorityWriteScheduler.Pop",
                    "documentation": {
                      "identifier": "http2priorityWriteScheduler.Pop",
                      "newPage": false,
                      "searchKey": "http.http2priorityWriteScheduler.Pop",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2priorityWriteScheduler) Pop() (wr http2FrameWriteRequest, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2priorityWriteScheduler) Pop() (wr http2FrameWriteRequest, ok bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2priorityWriteScheduler.Push",
                    "documentation": {
                      "identifier": "http2priorityWriteScheduler.Push",
                      "newPage": false,
                      "searchKey": "http.http2priorityWriteScheduler.Push",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2priorityWriteScheduler) Push(wr http2FrameWriteRequest)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2priorityWriteScheduler) Push(wr http2FrameWriteRequest)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2priorityWriteScheduler.addClosedOrIdleNode",
                    "documentation": {
                      "identifier": "http2priorityWriteScheduler.addClosedOrIdleNode",
                      "newPage": false,
                      "searchKey": "http.http2priorityWriteScheduler.addClosedOrIdleNode",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2priorityWriteScheduler) addClosedOrIdleNode(list *[]*http2priorityNode, maxSize int, n *http2priorityNode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2priorityWriteScheduler) addClosedOrIdleNode(list *[]*http2priorityNode, maxSize int, n *http2priorityNode)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2priorityWriteScheduler.removeNode",
                    "documentation": {
                      "identifier": "http2priorityWriteScheduler.removeNode",
                      "newPage": false,
                      "searchKey": "http.http2priorityWriteScheduler.removeNode",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2priorityWriteScheduler) removeNode(n *http2priorityNode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2priorityWriteScheduler) removeNode(n *http2priorityNode)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2pseudoHeaderError",
              "documentation": {
                "identifier": "http2pseudoHeaderError",
                "newPage": false,
                "searchKey": "http.http2pseudoHeaderError",
                "tags": [
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2pseudoHeaderError string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2pseudoHeaderError string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2pseudoHeaderError.Error",
                    "documentation": {
                      "identifier": "http2pseudoHeaderError.Error",
                      "newPage": false,
                      "searchKey": "http.http2pseudoHeaderError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e http2pseudoHeaderError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e http2pseudoHeaderError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2randomWriteScheduler",
              "documentation": {
                "identifier": "http2randomWriteScheduler",
                "newPage": false,
                "searchKey": "http.http2randomWriteScheduler",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2randomWriteScheduler struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2randomWriteScheduler struct {\n\t// zero are frames not associated with a specific stream.\n\tzero http2writeQueue\n\n\t// sq contains the stream-specific queues, keyed by stream ID.\n\t// When a stream is idle, closed, or emptied, it's deleted\n\t// from the map.\n\tsq map[uint32]*http2writeQueue\n\n\t// pool of empty queues for reuse.\n\tqueuePool http2writeQueuePool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2randomWriteScheduler.AdjustStream",
                    "documentation": {
                      "identifier": "http2randomWriteScheduler.AdjustStream",
                      "newPage": false,
                      "searchKey": "http.http2randomWriteScheduler.AdjustStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2randomWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2randomWriteScheduler) AdjustStream(streamID uint32, priority http2PriorityParam)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2randomWriteScheduler.CloseStream",
                    "documentation": {
                      "identifier": "http2randomWriteScheduler.CloseStream",
                      "newPage": false,
                      "searchKey": "http.http2randomWriteScheduler.CloseStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2randomWriteScheduler) CloseStream(streamID uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2randomWriteScheduler) CloseStream(streamID uint32)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2randomWriteScheduler.OpenStream",
                    "documentation": {
                      "identifier": "http2randomWriteScheduler.OpenStream",
                      "newPage": false,
                      "searchKey": "http.http2randomWriteScheduler.OpenStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2randomWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2randomWriteScheduler) OpenStream(streamID uint32, options http2OpenStreamOptions)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2randomWriteScheduler.Pop",
                    "documentation": {
                      "identifier": "http2randomWriteScheduler.Pop",
                      "newPage": false,
                      "searchKey": "http.http2randomWriteScheduler.Pop",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2randomWriteScheduler) Pop() (http2FrameWriteRequest, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2randomWriteScheduler) Pop() (http2FrameWriteRequest, bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2randomWriteScheduler.Push",
                    "documentation": {
                      "identifier": "http2randomWriteScheduler.Push",
                      "newPage": false,
                      "searchKey": "http.http2randomWriteScheduler.Push",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ws *http2randomWriteScheduler) Push(wr http2FrameWriteRequest)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ws *http2randomWriteScheduler) Push(wr http2FrameWriteRequest)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2readFrameResult",
              "documentation": {
                "identifier": "http2readFrameResult",
                "newPage": false,
                "searchKey": "http.http2readFrameResult",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2readFrameResult struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2readFrameResult struct {\n\tf   http2Frame // valid until readMore is called\n\terr error\n\n\t// readMore should be called once the consumer no longer needs or\n\t// retains f. After readMore, f is invalid and more frames can be\n\t// read.\n\treadMore func()\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2requestBody",
              "documentation": {
                "identifier": "http2requestBody",
                "newPage": false,
                "searchKey": "http.http2requestBody",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2requestBody struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2requestBody struct {\n\t_             http2incomparable\n\tstream        *http2stream\n\tconn          *http2serverConn\n\tclosed        bool       // for use by Close only\n\tsawEOF        bool       // for use by Read only\n\tpipe          *http2pipe // non-nil if we have a HTTP entity message body\n\tneedsContinue bool       // need to send a 100-continue\n}\n```\n\nrequestBody is the Handler's Request.Body type. Read and Close may be called concurrently. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2requestBody.Close",
                    "documentation": {
                      "identifier": "http2requestBody.Close",
                      "newPage": false,
                      "searchKey": "http.http2requestBody.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *http2requestBody) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *http2requestBody) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2requestBody.Read",
                    "documentation": {
                      "identifier": "http2requestBody.Read",
                      "newPage": false,
                      "searchKey": "http.http2requestBody.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *http2requestBody) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *http2requestBody) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2requestParam",
              "documentation": {
                "identifier": "http2requestParam",
                "newPage": false,
                "searchKey": "http.http2requestParam",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2requestParam struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2requestParam struct {\n\tmethod                  string\n\tscheme, authority, path string\n\theader                  Header\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2resAndError",
              "documentation": {
                "identifier": "http2resAndError",
                "newPage": false,
                "searchKey": "http.http2resAndError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2resAndError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2resAndError struct {\n\t_   http2incomparable\n\tres *Response\n\terr error\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2responseWriter",
              "documentation": {
                "identifier": "http2responseWriter",
                "newPage": false,
                "searchKey": "http.http2responseWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2responseWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2responseWriter struct {\n\trws *http2responseWriterState\n}\n```\n\nresponseWriter is the http.ResponseWriter implementation. It's intentionally small (1 pointer wide) to minimize garbage. The responseWriterState pointer inside is zeroed at the end of a request (in handlerDone) and calls on the responseWriter thereafter simply crash (caller's mistake), but the much larger responseWriterState and buffers are reused between multiple requests. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriter.CloseNotify",
                    "documentation": {
                      "identifier": "http2responseWriter.CloseNotify",
                      "newPage": false,
                      "searchKey": "http.http2responseWriter.CloseNotify",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2responseWriter) CloseNotify() <-chan bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2responseWriter) CloseNotify() <-chan bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriter.Flush",
                    "documentation": {
                      "identifier": "http2responseWriter.Flush",
                      "newPage": false,
                      "searchKey": "http.http2responseWriter.Flush",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2responseWriter) Flush()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2responseWriter) Flush()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriter.Header",
                    "documentation": {
                      "identifier": "http2responseWriter.Header",
                      "newPage": false,
                      "searchKey": "http.http2responseWriter.Header",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2responseWriter) Header() Header"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2responseWriter) Header() Header\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriter.Push",
                    "documentation": {
                      "identifier": "http2responseWriter.Push",
                      "newPage": false,
                      "searchKey": "http.http2responseWriter.Push",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2responseWriter) Push(target string, opts *PushOptions) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2responseWriter) Push(target string, opts *PushOptions) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriter.Write",
                    "documentation": {
                      "identifier": "http2responseWriter.Write",
                      "newPage": false,
                      "searchKey": "http.http2responseWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2responseWriter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2responseWriter) Write(p []byte) (n int, err error)\n```\n\nThe Life Of A Write is like this: \n\n* Handler calls w.Write or w.WriteString -> * -> rws.bw (*bufio.Writer) -> * (Handler might call Flush) * -> chunkWriter{rws} * -> responseWriterState.writeChunk(p []byte) * -> responseWriterState.writeChunk (most of the magic; see comment there) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriter.WriteHeader",
                    "documentation": {
                      "identifier": "http2responseWriter.WriteHeader",
                      "newPage": false,
                      "searchKey": "http.http2responseWriter.WriteHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2responseWriter) WriteHeader(code int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2responseWriter) WriteHeader(code int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriter.WriteString",
                    "documentation": {
                      "identifier": "http2responseWriter.WriteString",
                      "newPage": false,
                      "searchKey": "http.http2responseWriter.WriteString",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2responseWriter) WriteString(s string) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2responseWriter) WriteString(s string) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriter.handlerDone",
                    "documentation": {
                      "identifier": "http2responseWriter.handlerDone",
                      "newPage": false,
                      "searchKey": "http.http2responseWriter.handlerDone",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2responseWriter) handlerDone()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2responseWriter) handlerDone()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriter.write",
                    "documentation": {
                      "identifier": "http2responseWriter.write",
                      "newPage": false,
                      "searchKey": "http.http2responseWriter.write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2responseWriter) write(lenData int, dataB []byte, dataS string) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2responseWriter) write(lenData int, dataB []byte, dataS string) (n int, err error)\n```\n\neither dataB or dataS is non-zero. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2responseWriterState",
              "documentation": {
                "identifier": "http2responseWriterState",
                "newPage": false,
                "searchKey": "http.http2responseWriterState",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2responseWriterState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2responseWriterState struct {\n\t// immutable within a request:\n\tstream *http2stream\n\treq    *Request\n\tbody   *http2requestBody // to close at end of request, if DATA frames didn't\n\tconn   *http2serverConn\n\n\t// TODO: adjust buffer writing sizes based on server config, frame size updates from peer, etc\n\tbw *bufio.Writer // writing to a chunkWriter{this *responseWriterState}\n\n\t// mutated by http.Handler goroutine:\n\thandlerHeader Header   // nil until called\n\tsnapHeader    Header   // snapshot of handlerHeader at WriteHeader time\n\ttrailers      []string // set in writeChunk\n\tstatus        int      // status code passed to WriteHeader\n\twroteHeader   bool     // WriteHeader called (explicitly or implicitly). Not necessarily sent to user yet.\n\tsentHeader    bool     // have we sent the header frame?\n\thandlerDone   bool     // handler has finished\n\tdirty         bool     // a Write failed; don't reuse this responseWriterState\n\n\tsentContentLen int64 // non-zero if handler set a Content-Length header\n\twroteBytes     int64\n\n\tcloseNotifierMu sync.Mutex // guards closeNotifierCh\n\tcloseNotifierCh chan bool  // nil until first used\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriterState.declareTrailer",
                    "documentation": {
                      "identifier": "http2responseWriterState.declareTrailer",
                      "newPage": false,
                      "searchKey": "http.http2responseWriterState.declareTrailer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rws *http2responseWriterState) declareTrailer(k string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rws *http2responseWriterState) declareTrailer(k string)\n```\n\ndeclareTrailer is called for each Trailer header when the response header is written. It notes that a header will need to be written in the trailers at the end of the response. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriterState.hasNonemptyTrailers",
                    "documentation": {
                      "identifier": "http2responseWriterState.hasNonemptyTrailers",
                      "newPage": false,
                      "searchKey": "http.http2responseWriterState.hasNonemptyTrailers",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rws *http2responseWriterState) hasNonemptyTrailers() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rws *http2responseWriterState) hasNonemptyTrailers() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriterState.hasTrailers",
                    "documentation": {
                      "identifier": "http2responseWriterState.hasTrailers",
                      "newPage": false,
                      "searchKey": "http.http2responseWriterState.hasTrailers",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rws *http2responseWriterState) hasTrailers() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rws *http2responseWriterState) hasTrailers() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriterState.promoteUndeclaredTrailers",
                    "documentation": {
                      "identifier": "http2responseWriterState.promoteUndeclaredTrailers",
                      "newPage": false,
                      "searchKey": "http.http2responseWriterState.promoteUndeclaredTrailers",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rws *http2responseWriterState) promoteUndeclaredTrailers()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rws *http2responseWriterState) promoteUndeclaredTrailers()\n```\n\npromoteUndeclaredTrailers permits http.Handlers to set trailers after the header has already been flushed. Because the Go ResponseWriter interface has no way to set Trailers (only the Header), and because we didn't want to expand the ResponseWriter interface, and because nobody used trailers, and because RFC 7230 says you SHOULD (but not must) predeclare any trailers in the header, the official ResponseWriter rules said trailers in Go must be predeclared, and then we reuse the same ResponseWriter.Header() map to mean both Headers and Trailers. When it's time to write the Trailers, we pick out the fields of Headers that were declared as trailers. That worked for a while, until we found the first major user of Trailers in the wild: gRPC (using them only over http2), and gRPC libraries permit setting trailers mid-stream without predeclaring them. So: change of plans. We still permit the old way, but we also permit this hack: if a Header() key begins with \"Trailer:\", the suffix of that key is a Trailer. Because ':' is an invalid token byte anyway, there is no ambiguity. (And it's already filtered out) It's mildly hacky, but not terrible. \n\nThis method runs after the Handler is done and promotes any Header fields to be trailers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriterState.writeChunk",
                    "documentation": {
                      "identifier": "http2responseWriterState.writeChunk",
                      "newPage": false,
                      "searchKey": "http.http2responseWriterState.writeChunk",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rws *http2responseWriterState) writeChunk(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rws *http2responseWriterState) writeChunk(p []byte) (n int, err error)\n```\n\nwriteChunk writes chunks from the bufio.Writer. But because bufio.Writer may bypass its chunking, sometimes p may be arbitrarily large. \n\nwriteChunk is also responsible (on the first chunk) for sending the HEADER response. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2responseWriterState.writeHeader",
                    "documentation": {
                      "identifier": "http2responseWriterState.writeHeader",
                      "newPage": false,
                      "searchKey": "http.http2responseWriterState.writeHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rws *http2responseWriterState) writeHeader(code int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rws *http2responseWriterState) writeHeader(code int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2serverConn",
              "documentation": {
                "identifier": "http2serverConn",
                "newPage": false,
                "searchKey": "http.http2serverConn",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2serverConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2serverConn struct {\n\t// Immutable:\n\tsrv              *http2Server\n\ths               *Server\n\tconn             net.Conn\n\tbw               *http2bufferedWriter // writing to conn\n\thandler          Handler\n\tbaseCtx          context.Context\n\tframer           *http2Framer\n\tdoneServing      chan struct{}               // closed when serverConn.serve ends\n\treadFrameCh      chan http2readFrameResult   // written by serverConn.readFrames\n\twantWriteFrameCh chan http2FrameWriteRequest // from handlers -> serve\n\twroteFrameCh     chan http2frameWriteResult  // from writeFrameAsync -> serve, tickles more frame writes\n\tbodyReadCh       chan http2bodyReadMsg       // from handlers -> serve\n\tserveMsgCh       chan interface{}            // misc messages & code to send to / run on the serve loop\n\tflow             http2flow                   // conn-wide (not stream-specific) outbound flow control\n\tinflow           http2flow                   // conn-wide inbound flow control\n\ttlsState         *tls.ConnectionState        // shared by all handlers, like net/http\n\tremoteAddrStr    string\n\twriteSched       http2WriteScheduler\n\n\t// Everything following is owned by the serve loop; use serveG.check():\n\tserveG                      http2goroutineLock // used to verify funcs are on serve()\n\tpushEnabled                 bool\n\tsawFirstSettings            bool // got the initial SETTINGS frame after the preface\n\tneedToSendSettingsAck       bool\n\tunackedSettings             int    // how many SETTINGS have we sent without ACKs?\n\tqueuedControlFrames         int    // control frames in the writeSched queue\n\tclientMaxStreams            uint32 // SETTINGS_MAX_CONCURRENT_STREAMS from client (our PUSH_PROMISE limit)\n\tadvMaxStreams               uint32 // our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client\n\tcurClientStreams            uint32 // number of open streams initiated by the client\n\tcurPushedStreams            uint32 // number of open streams initiated by server push\n\tmaxClientStreamID           uint32 // max ever seen from client (odd), or 0 if there have been no client requests\n\tmaxPushPromiseID            uint32 // ID of the last push promise (even), or 0 if there have been no pushes\n\tstreams                     map[uint32]*http2stream\n\tinitialStreamSendWindowSize int32\n\tmaxFrameSize                int32\n\theaderTableSize             uint32\n\tpeerMaxHeaderListSize       uint32            // zero means unknown (default)\n\tcanonHeader                 map[string]string // http2-lower-case -> Go-Canonical-Case\n\twritingFrame                bool              // started writing a frame (on serve goroutine or separate)\n\twritingFrameAsync           bool              // started a frame on its own goroutine but haven't heard back on wroteFrameCh\n\tneedsFrameFlush             bool              // last frame write wasn't a flush\n\tinGoAway                    bool              // we've started to or sent GOAWAY\n\tinFrameScheduleLoop         bool              // whether we're in the scheduleFrameWrite loop\n\tneedToSendGoAway            bool              // we need to schedule a GOAWAY frame write\n\tgoAwayCode                  http2ErrCode\n\tshutdownTimer               *time.Timer // nil until used\n\tidleTimer                   *time.Timer // nil if unused\n\n\t// Owned by the writeFrameAsync goroutine:\n\theaderWriteBuf bytes.Buffer\n\thpackEncoder   *hpack.Encoder\n\n\t// Used by startGracefulShutdown.\n\tshutdownOnce sync.Once\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.CloseConn",
                    "documentation": {
                      "identifier": "http2serverConn.CloseConn",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.CloseConn",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) CloseConn() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) CloseConn() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.Flush",
                    "documentation": {
                      "identifier": "http2serverConn.Flush",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.Flush",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) Flush() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) Flush() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.Framer",
                    "documentation": {
                      "identifier": "http2serverConn.Framer",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.Framer",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) Framer() *http2Framer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) Framer() *http2Framer\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.HeaderEncoder",
                    "documentation": {
                      "identifier": "http2serverConn.HeaderEncoder",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.HeaderEncoder",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.awaitGracefulShutdown",
                    "documentation": {
                      "identifier": "http2serverConn.awaitGracefulShutdown",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.awaitGracefulShutdown",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) awaitGracefulShutdown(sharedCh <-chan struct{}, privateCh chan struct{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) awaitGracefulShutdown(sharedCh <-chan struct{}, privateCh chan struct{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.canonicalHeader",
                    "documentation": {
                      "identifier": "http2serverConn.canonicalHeader",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.canonicalHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) canonicalHeader(v string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) canonicalHeader(v string) string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.closeAllStreamsOnConnClose",
                    "documentation": {
                      "identifier": "http2serverConn.closeAllStreamsOnConnClose",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.closeAllStreamsOnConnClose",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) closeAllStreamsOnConnClose()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) closeAllStreamsOnConnClose()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.closeStream",
                    "documentation": {
                      "identifier": "http2serverConn.closeStream",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.closeStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) closeStream(st *http2stream, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) closeStream(st *http2stream, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.condlogf",
                    "documentation": {
                      "identifier": "http2serverConn.condlogf",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.condlogf",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) condlogf(err error, format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) condlogf(err error, format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.curOpenStreams",
                    "documentation": {
                      "identifier": "http2serverConn.curOpenStreams",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.curOpenStreams",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) curOpenStreams() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) curOpenStreams() uint32\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.goAway",
                    "documentation": {
                      "identifier": "http2serverConn.goAway",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.goAway",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) goAway(code http2ErrCode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) goAway(code http2ErrCode)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.logf",
                    "documentation": {
                      "identifier": "http2serverConn.logf",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.logf",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) logf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) logf(format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.maxHeaderListSize",
                    "documentation": {
                      "identifier": "http2serverConn.maxHeaderListSize",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.maxHeaderListSize",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) maxHeaderListSize() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) maxHeaderListSize() uint32\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.newStream",
                    "documentation": {
                      "identifier": "http2serverConn.newStream",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.newStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) newStream(id, pusherID uint32, state http2streamState) *http2stream"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) newStream(id, pusherID uint32, state http2streamState) *http2stream\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.newWriterAndRequest",
                    "documentation": {
                      "identifier": "http2serverConn.newWriterAndRequest",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.newWriterAndRequest",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) newWriterAndRequest(st *http2stream, f *http2MetaHeadersFrame) (*http2responseWriter, *Request, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) newWriterAndRequest(st *http2stream, f *http2MetaHeadersFrame) (*http2responseWriter, *Request, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.newWriterAndRequestNoBody",
                    "documentation": {
                      "identifier": "http2serverConn.newWriterAndRequestNoBody",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.newWriterAndRequestNoBody",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) newWriterAndRequestNoBody(st *http2stream, rp http2requestParam) (*http2responseWriter, *Request, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) newWriterAndRequestNoBody(st *http2stream, rp http2requestParam) (*http2responseWriter, *Request, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.noteBodyRead",
                    "documentation": {
                      "identifier": "http2serverConn.noteBodyRead",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.noteBodyRead",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) noteBodyRead(st *http2stream, n int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) noteBodyRead(st *http2stream, n int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.noteBodyReadFromHandler",
                    "documentation": {
                      "identifier": "http2serverConn.noteBodyReadFromHandler",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.noteBodyReadFromHandler",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) noteBodyReadFromHandler(st *http2stream, n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) noteBodyReadFromHandler(st *http2stream, n int, err error)\n```\n\ncalled from handler goroutines. Notes that the handler for the given stream ID read n bytes of its body and schedules flow control tokens to be sent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.notePanic",
                    "documentation": {
                      "identifier": "http2serverConn.notePanic",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.notePanic",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) notePanic()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) notePanic()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.onIdleTimer",
                    "documentation": {
                      "identifier": "http2serverConn.onIdleTimer",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.onIdleTimer",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) onIdleTimer()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) onIdleTimer()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.onSettingsTimer",
                    "documentation": {
                      "identifier": "http2serverConn.onSettingsTimer",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.onSettingsTimer",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) onSettingsTimer()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) onSettingsTimer()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.onShutdownTimer",
                    "documentation": {
                      "identifier": "http2serverConn.onShutdownTimer",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.onShutdownTimer",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) onShutdownTimer()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) onShutdownTimer()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processData",
                    "documentation": {
                      "identifier": "http2serverConn.processData",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processData",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processData(f *http2DataFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processData(f *http2DataFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processFrame",
                    "documentation": {
                      "identifier": "http2serverConn.processFrame",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processFrame(f http2Frame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processFrame(f http2Frame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processFrameFromReader",
                    "documentation": {
                      "identifier": "http2serverConn.processFrameFromReader",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processFrameFromReader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processFrameFromReader(res http2readFrameResult) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processFrameFromReader(res http2readFrameResult) bool\n```\n\nprocessFrameFromReader processes the serve loop's read from readFrameCh from the frame-reading goroutine. processFrameFromReader returns whether the connection should be kept open. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processGoAway",
                    "documentation": {
                      "identifier": "http2serverConn.processGoAway",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processGoAway",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processGoAway(f *http2GoAwayFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processGoAway(f *http2GoAwayFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processHeaders",
                    "documentation": {
                      "identifier": "http2serverConn.processHeaders",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processHeaders",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processHeaders(f *http2MetaHeadersFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processHeaders(f *http2MetaHeadersFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processPing",
                    "documentation": {
                      "identifier": "http2serverConn.processPing",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processPing",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processPing(f *http2PingFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processPing(f *http2PingFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processPriority",
                    "documentation": {
                      "identifier": "http2serverConn.processPriority",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processPriority",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processPriority(f *http2PriorityFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processPriority(f *http2PriorityFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processResetStream",
                    "documentation": {
                      "identifier": "http2serverConn.processResetStream",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processResetStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processResetStream(f *http2RSTStreamFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processResetStream(f *http2RSTStreamFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processSetting",
                    "documentation": {
                      "identifier": "http2serverConn.processSetting",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processSetting",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processSetting(s http2Setting) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processSetting(s http2Setting) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processSettingInitialWindowSize",
                    "documentation": {
                      "identifier": "http2serverConn.processSettingInitialWindowSize",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processSettingInitialWindowSize",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processSettingInitialWindowSize(val uint32) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processSettingInitialWindowSize(val uint32) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processSettings",
                    "documentation": {
                      "identifier": "http2serverConn.processSettings",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processSettings",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processSettings(f *http2SettingsFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processSettings(f *http2SettingsFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.processWindowUpdate",
                    "documentation": {
                      "identifier": "http2serverConn.processWindowUpdate",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.processWindowUpdate",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) processWindowUpdate(f *http2WindowUpdateFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) processWindowUpdate(f *http2WindowUpdateFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.readFrames",
                    "documentation": {
                      "identifier": "http2serverConn.readFrames",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.readFrames",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) readFrames()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) readFrames()\n```\n\nreadFrames is the loop that reads incoming frames. It takes care to only read one frame at a time, blocking until the consumer is done with the frame. It's run on its own goroutine. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.readPreface",
                    "documentation": {
                      "identifier": "http2serverConn.readPreface",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.readPreface",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) readPreface() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) readPreface() error\n```\n\nreadPreface reads the ClientPreface greeting from the peer or returns errPrefaceTimeout on timeout, or an error if the greeting is invalid. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.rejectConn",
                    "documentation": {
                      "identifier": "http2serverConn.rejectConn",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.rejectConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) rejectConn(err http2ErrCode, debug string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) rejectConn(err http2ErrCode, debug string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.resetStream",
                    "documentation": {
                      "identifier": "http2serverConn.resetStream",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.resetStream",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) resetStream(se http2StreamError)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) resetStream(se http2StreamError)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.runHandler",
                    "documentation": {
                      "identifier": "http2serverConn.runHandler",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.runHandler",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) runHandler(rw *http2responseWriter, req *Request, handler func(ResponseWriter, *Request))"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) runHandler(rw *http2responseWriter, req *Request, handler func(ResponseWriter, *Request))\n```\n\nRun on its own goroutine. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.scheduleFrameWrite",
                    "documentation": {
                      "identifier": "http2serverConn.scheduleFrameWrite",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.scheduleFrameWrite",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) scheduleFrameWrite()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) scheduleFrameWrite()\n```\n\nscheduleFrameWrite tickles the frame writing scheduler. \n\nIf a frame is already being written, nothing happens. This will be called again when the frame is done being written. \n\nIf a frame isn't being written and we need to send one, the best frame to send is selected by writeSched. \n\nIf a frame isn't being written and there's nothing else to send, we flush the write buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.sendServeMsg",
                    "documentation": {
                      "identifier": "http2serverConn.sendServeMsg",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.sendServeMsg",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) sendServeMsg(msg interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) sendServeMsg(msg interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.sendWindowUpdate",
                    "documentation": {
                      "identifier": "http2serverConn.sendWindowUpdate",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.sendWindowUpdate",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) sendWindowUpdate(st *http2stream, n int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) sendWindowUpdate(st *http2stream, n int)\n```\n\nst may be nil for conn-level \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.sendWindowUpdate32",
                    "documentation": {
                      "identifier": "http2serverConn.sendWindowUpdate32",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.sendWindowUpdate32",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) sendWindowUpdate32(st *http2stream, n int32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) sendWindowUpdate32(st *http2stream, n int32)\n```\n\nst may be nil for conn-level \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.serve",
                    "documentation": {
                      "identifier": "http2serverConn.serve",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.serve",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) serve()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) serve()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.setConnState",
                    "documentation": {
                      "identifier": "http2serverConn.setConnState",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.setConnState",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) setConnState(state ConnState)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) setConnState(state ConnState)\n```\n\nsetConnState calls the net/http ConnState hook for this connection, if configured. Note that the net/http package does StateNew and StateClosed for us. There is currently no plan for StateHijacked or hijacking HTTP/2 connections. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.shutDownIn",
                    "documentation": {
                      "identifier": "http2serverConn.shutDownIn",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.shutDownIn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) shutDownIn(d time.Duration)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) shutDownIn(d time.Duration)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.startFrameWrite",
                    "documentation": {
                      "identifier": "http2serverConn.startFrameWrite",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.startFrameWrite",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) startFrameWrite(wr http2FrameWriteRequest)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) startFrameWrite(wr http2FrameWriteRequest)\n```\n\nstartFrameWrite starts a goroutine to write wr (in a separate goroutine since that might block on the network), and updates the serve goroutine's state about the world, updated from info in wr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.startGracefulShutdown",
                    "documentation": {
                      "identifier": "http2serverConn.startGracefulShutdown",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.startGracefulShutdown",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) startGracefulShutdown()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) startGracefulShutdown()\n```\n\nstartGracefulShutdown gracefully shuts down a connection. This sends GOAWAY with ErrCodeNo to tell the client we're gracefully shutting down. The connection isn't closed until all current streams are done. \n\nstartGracefulShutdown returns immediately; it does not wait until the connection has shut down. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.startGracefulShutdownInternal",
                    "documentation": {
                      "identifier": "http2serverConn.startGracefulShutdownInternal",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.startGracefulShutdownInternal",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) startGracefulShutdownInternal()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) startGracefulShutdownInternal()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.startPush",
                    "documentation": {
                      "identifier": "http2serverConn.startPush",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.startPush",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) startPush(msg *http2startPushRequest)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) startPush(msg *http2startPushRequest)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.state",
                    "documentation": {
                      "identifier": "http2serverConn.state",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.state",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) state(streamID uint32) (http2streamState, *http2stream)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) state(streamID uint32) (http2streamState, *http2stream)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.stopShutdownTimer",
                    "documentation": {
                      "identifier": "http2serverConn.stopShutdownTimer",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.stopShutdownTimer",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) stopShutdownTimer()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) stopShutdownTimer()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.vlogf",
                    "documentation": {
                      "identifier": "http2serverConn.vlogf",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.vlogf",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) vlogf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) vlogf(format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.write100ContinueHeaders",
                    "documentation": {
                      "identifier": "http2serverConn.write100ContinueHeaders",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.write100ContinueHeaders",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) write100ContinueHeaders(st *http2stream)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) write100ContinueHeaders(st *http2stream)\n```\n\ncalled from handler goroutines. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.writeDataFromHandler",
                    "documentation": {
                      "identifier": "http2serverConn.writeDataFromHandler",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.writeDataFromHandler",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) writeDataFromHandler(stream *http2stream, data []byte, endStream bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) writeDataFromHandler(stream *http2stream, data []byte, endStream bool) error\n```\n\nwriteDataFromHandler writes DATA response frames from a handler on the given stream. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.writeFrame",
                    "documentation": {
                      "identifier": "http2serverConn.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) writeFrame(wr http2FrameWriteRequest)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) writeFrame(wr http2FrameWriteRequest)\n```\n\nwriteFrame schedules a frame to write and sends it if there's nothing already being written. \n\nThere is no pushback here (the serve goroutine never blocks). It's the http.Handlers that block, waiting for their previous frames to make it onto the wire \n\nIf you're not on the serve goroutine, use writeFrameFromHandler instead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.writeFrameAsync",
                    "documentation": {
                      "identifier": "http2serverConn.writeFrameAsync",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.writeFrameAsync",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) writeFrameAsync(wr http2FrameWriteRequest)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) writeFrameAsync(wr http2FrameWriteRequest)\n```\n\nwriteFrameAsync runs in its own goroutine and writes a single frame and then reports when it's done. At most one goroutine can be running writeFrameAsync at a time per serverConn. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.writeFrameFromHandler",
                    "documentation": {
                      "identifier": "http2serverConn.writeFrameFromHandler",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.writeFrameFromHandler",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) writeFrameFromHandler(wr http2FrameWriteRequest) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) writeFrameFromHandler(wr http2FrameWriteRequest) error\n```\n\nwriteFrameFromHandler sends wr to sc.wantWriteFrameCh, but aborts if the connection has gone away. \n\nThis must not be run from the serve goroutine itself, else it might deadlock writing to sc.wantWriteFrameCh (which is only mildly buffered and is read by serve itself). If you're on the serve goroutine, call writeFrame instead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.writeHeaders",
                    "documentation": {
                      "identifier": "http2serverConn.writeHeaders",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.writeHeaders",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) writeHeaders(st *http2stream, headerData *http2writeResHeaders) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) writeHeaders(st *http2stream, headerData *http2writeResHeaders) error\n```\n\ncalled from handler goroutines. h may be nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverConn.wroteFrame",
                    "documentation": {
                      "identifier": "http2serverConn.wroteFrame",
                      "newPage": false,
                      "searchKey": "http.http2serverConn.wroteFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc *http2serverConn) wroteFrame(res http2frameWriteResult)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc *http2serverConn) wroteFrame(res http2frameWriteResult)\n```\n\nwroteFrame is called on the serve goroutine with the result of whatever happened on writeFrameAsync. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2serverInternalState",
              "documentation": {
                "identifier": "http2serverInternalState",
                "newPage": false,
                "searchKey": "http.http2serverInternalState",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2serverInternalState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2serverInternalState struct {\n\tmu          sync.Mutex\n\tactiveConns map[*http2serverConn]struct{}\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2serverInternalState.registerConn",
                    "documentation": {
                      "identifier": "http2serverInternalState.registerConn",
                      "newPage": false,
                      "searchKey": "http.http2serverInternalState.registerConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2serverInternalState) registerConn(sc *http2serverConn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2serverInternalState) registerConn(sc *http2serverConn)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverInternalState.startGracefulShutdown",
                    "documentation": {
                      "identifier": "http2serverInternalState.startGracefulShutdown",
                      "newPage": false,
                      "searchKey": "http.http2serverInternalState.startGracefulShutdown",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2serverInternalState) startGracefulShutdown()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2serverInternalState) startGracefulShutdown()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2serverInternalState.unregisterConn",
                    "documentation": {
                      "identifier": "http2serverInternalState.unregisterConn",
                      "newPage": false,
                      "searchKey": "http.http2serverInternalState.unregisterConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2serverInternalState) unregisterConn(sc *http2serverConn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2serverInternalState) unregisterConn(sc *http2serverConn)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2serverMessage",
              "documentation": {
                "identifier": "http2serverMessage",
                "newPage": false,
                "searchKey": "http.http2serverMessage",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2serverMessage int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2serverMessage int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2sortPriorityNodeSiblings",
              "documentation": {
                "identifier": "http2sortPriorityNodeSiblings",
                "newPage": false,
                "searchKey": "http.http2sortPriorityNodeSiblings",
                "tags": [
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2sortPriorityNodeSiblings []*http.http2priorityNode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2sortPriorityNodeSiblings []*http2priorityNode\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2sortPriorityNodeSiblings.Len",
                    "documentation": {
                      "identifier": "http2sortPriorityNodeSiblings.Len",
                      "newPage": false,
                      "searchKey": "http.http2sortPriorityNodeSiblings.Len",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z http2sortPriorityNodeSiblings) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z http2sortPriorityNodeSiblings) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2sortPriorityNodeSiblings.Less",
                    "documentation": {
                      "identifier": "http2sortPriorityNodeSiblings.Less",
                      "newPage": false,
                      "searchKey": "http.http2sortPriorityNodeSiblings.Less",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z http2sortPriorityNodeSiblings) Less(i, k int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z http2sortPriorityNodeSiblings) Less(i, k int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2sortPriorityNodeSiblings.Swap",
                    "documentation": {
                      "identifier": "http2sortPriorityNodeSiblings.Swap",
                      "newPage": false,
                      "searchKey": "http.http2sortPriorityNodeSiblings.Swap",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z http2sortPriorityNodeSiblings) Swap(i, k int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z http2sortPriorityNodeSiblings) Swap(i, k int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2sorter",
              "documentation": {
                "identifier": "http2sorter",
                "newPage": false,
                "searchKey": "http.http2sorter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2sorter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2sorter struct {\n\tv []string // owned by sorter\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2sorter.Keys",
                    "documentation": {
                      "identifier": "http2sorter.Keys",
                      "newPage": false,
                      "searchKey": "http.http2sorter.Keys",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2sorter) Keys(h Header) []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2sorter) Keys(h Header) []string\n```\n\nKeys returns the sorted keys of h. \n\nThe returned slice is only valid until s used again or returned to its pool. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2sorter.Len",
                    "documentation": {
                      "identifier": "http2sorter.Len",
                      "newPage": false,
                      "searchKey": "http.http2sorter.Len",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2sorter) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2sorter) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2sorter.Less",
                    "documentation": {
                      "identifier": "http2sorter.Less",
                      "newPage": false,
                      "searchKey": "http.http2sorter.Less",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2sorter) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2sorter) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2sorter.SortStrings",
                    "documentation": {
                      "identifier": "http2sorter.SortStrings",
                      "newPage": false,
                      "searchKey": "http.http2sorter.SortStrings",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2sorter) SortStrings(ss []string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2sorter) SortStrings(ss []string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2sorter.Swap",
                    "documentation": {
                      "identifier": "http2sorter.Swap",
                      "newPage": false,
                      "searchKey": "http.http2sorter.Swap",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *http2sorter) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *http2sorter) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2startPushRequest",
              "documentation": {
                "identifier": "http2startPushRequest",
                "newPage": false,
                "searchKey": "http.http2startPushRequest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2startPushRequest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2startPushRequest struct {\n\tparent *http2stream\n\tmethod string\n\turl    *url.URL\n\theader Header\n\tdone   chan error\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2stickyErrWriter",
              "documentation": {
                "identifier": "http2stickyErrWriter",
                "newPage": false,
                "searchKey": "http.http2stickyErrWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2stickyErrWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2stickyErrWriter struct {\n\tw   io.Writer\n\terr *error\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2stickyErrWriter.Write",
                    "documentation": {
                      "identifier": "http2stickyErrWriter.Write",
                      "newPage": false,
                      "searchKey": "http.http2stickyErrWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sew http2stickyErrWriter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sew http2stickyErrWriter) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2stream",
              "documentation": {
                "identifier": "http2stream",
                "newPage": false,
                "searchKey": "http.http2stream",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2stream struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2stream struct {\n\t// immutable:\n\tsc        *http2serverConn\n\tid        uint32\n\tbody      *http2pipe       // non-nil if expecting DATA frames\n\tcw        http2closeWaiter // closed wait stream transitions to closed state\n\tctx       context.Context\n\tcancelCtx func()\n\n\t// owned by serverConn's serve loop:\n\tbodyBytes        int64     // body bytes seen so far\n\tdeclBodyBytes    int64     // or -1 if undeclared\n\tflow             http2flow // limits writing from Handler to client\n\tinflow           http2flow // what the client is allowed to POST/etc to us\n\tstate            http2streamState\n\tresetQueued      bool        // RST_STREAM queued for write; set by sc.resetStream\n\tgotTrailerHeader bool        // HEADER frame for trailers was seen\n\twroteHeaders     bool        // whether we wrote headers (not status 100)\n\twriteDeadline    *time.Timer // nil if unused\n\n\ttrailer    Header // accumulated trailers\n\treqTrailer Header // handler's Request.Trailer\n}\n```\n\nstream represents a stream. This is the minimal metadata needed by the serve goroutine. Most of the actual stream state is owned by the http.Handler's goroutine in the responseWriter. Because the responseWriter's responseWriterState is recycled at the end of a handler, this struct intentionally has no pointer to the *responseWriter{,State} itself, as the Handler ending nils out the responseWriter's state field. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2stream.copyTrailersToHandlerRequest",
                    "documentation": {
                      "identifier": "http2stream.copyTrailersToHandlerRequest",
                      "newPage": false,
                      "searchKey": "http.http2stream.copyTrailersToHandlerRequest",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (st *http2stream) copyTrailersToHandlerRequest()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (st *http2stream) copyTrailersToHandlerRequest()\n```\n\ncopyTrailersToHandlerRequest is run in the Handler's goroutine in its Request.Body.Read just before it gets io.EOF. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2stream.endStream",
                    "documentation": {
                      "identifier": "http2stream.endStream",
                      "newPage": false,
                      "searchKey": "http.http2stream.endStream",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (st *http2stream) endStream()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (st *http2stream) endStream()\n```\n\nendStream closes a Request.Body's pipe. It is called when a DATA frame says a request body is over (or after trailers). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2stream.isPushed",
                    "documentation": {
                      "identifier": "http2stream.isPushed",
                      "newPage": false,
                      "searchKey": "http.http2stream.isPushed",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (st *http2stream) isPushed() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (st *http2stream) isPushed() bool\n```\n\nisPushed reports whether the stream is server-initiated. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2stream.onWriteTimeout",
                    "documentation": {
                      "identifier": "http2stream.onWriteTimeout",
                      "newPage": false,
                      "searchKey": "http.http2stream.onWriteTimeout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (st *http2stream) onWriteTimeout()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (st *http2stream) onWriteTimeout()\n```\n\nonWriteTimeout is run on its own goroutine (from time.AfterFunc) when the stream's WriteTimeout has fired. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2stream.processTrailerHeaders",
                    "documentation": {
                      "identifier": "http2stream.processTrailerHeaders",
                      "newPage": false,
                      "searchKey": "http.http2stream.processTrailerHeaders",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (st *http2stream) processTrailerHeaders(f *http2MetaHeadersFrame) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (st *http2stream) processTrailerHeaders(f *http2MetaHeadersFrame) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2streamEnder",
              "documentation": {
                "identifier": "http2streamEnder",
                "newPage": false,
                "searchKey": "http.http2streamEnder",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2streamEnder interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2streamEnder interface {\n\tStreamEnded() bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2streamState",
              "documentation": {
                "identifier": "http2streamState",
                "newPage": false,
                "searchKey": "http.http2streamState",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2streamState int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2streamState int\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2streamState.String",
                    "documentation": {
                      "identifier": "http2streamState.String",
                      "newPage": false,
                      "searchKey": "http.http2streamState.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (st http2streamState) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (st http2streamState) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2stringWriter",
              "documentation": {
                "identifier": "http2stringWriter",
                "newPage": false,
                "searchKey": "http.http2stringWriter",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2stringWriter interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2stringWriter interface {\n\tWriteString(s string) (n int, err error)\n}\n```\n\nfrom pkg io \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2transportResponseBody",
              "documentation": {
                "identifier": "http2transportResponseBody",
                "newPage": false,
                "searchKey": "http.http2transportResponseBody",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2transportResponseBody struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2transportResponseBody struct {\n\tcs *http2clientStream\n}\n```\n\ntransportResponseBody is the concrete type of Transport.RoundTrip's Response.Body. It is an io.ReadCloser. On Read, it reads from cs.body. On Close it sends RST_STREAM if EOF wasn't already seen. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2transportResponseBody.Close",
                    "documentation": {
                      "identifier": "http2transportResponseBody.Close",
                      "newPage": false,
                      "searchKey": "http.http2transportResponseBody.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b http2transportResponseBody) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b http2transportResponseBody) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2transportResponseBody.Read",
                    "documentation": {
                      "identifier": "http2transportResponseBody.Read",
                      "newPage": false,
                      "searchKey": "http.http2transportResponseBody.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b http2transportResponseBody) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b http2transportResponseBody) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2write100ContinueHeadersFrame",
              "documentation": {
                "identifier": "http2write100ContinueHeadersFrame",
                "newPage": false,
                "searchKey": "http.http2write100ContinueHeadersFrame",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2write100ContinueHeadersFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2write100ContinueHeadersFrame struct {\n\tstreamID uint32\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2write100ContinueHeadersFrame.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2write100ContinueHeadersFrame.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2write100ContinueHeadersFrame.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w http2write100ContinueHeadersFrame) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w http2write100ContinueHeadersFrame) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2write100ContinueHeadersFrame.writeFrame",
                    "documentation": {
                      "identifier": "http2write100ContinueHeadersFrame.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2write100ContinueHeadersFrame.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w http2write100ContinueHeadersFrame) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w http2write100ContinueHeadersFrame) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeContext",
              "documentation": {
                "identifier": "http2writeContext",
                "newPage": false,
                "searchKey": "http.http2writeContext",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writeContext interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writeContext interface {\n\tFramer() *http2Framer\n\tFlush() error\n\tCloseConn() error\n\t// HeaderEncoder returns an HPACK encoder that writes to the\n\t// returned buffer.\n\tHeaderEncoder() (*hpack.Encoder, *bytes.Buffer)\n}\n```\n\nwriteContext is the interface needed by the various frame writer types below. All the writeFrame methods below are scheduled via the frame writing scheduler (see writeScheduler in writesched.go). \n\nThis interface is implemented by *serverConn. \n\nTODO: decide whether to a) use this in the client code (which didn't end up using this yet, because it has a simpler design, not currently implementing priorities), or b) delete this and make the server code a bit more concrete. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeData",
              "documentation": {
                "identifier": "http2writeData",
                "newPage": false,
                "searchKey": "http.http2writeData",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writeData struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writeData struct {\n\tstreamID  uint32\n\tp         []byte\n\tendStream bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2writeData.String",
                    "documentation": {
                      "identifier": "http2writeData.String",
                      "newPage": false,
                      "searchKey": "http.http2writeData.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2writeData) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2writeData) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeData.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2writeData.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2writeData.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2writeData) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2writeData) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeData.writeFrame",
                    "documentation": {
                      "identifier": "http2writeData.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2writeData.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2writeData) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2writeData) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeFramer",
              "documentation": {
                "identifier": "http2writeFramer",
                "newPage": false,
                "searchKey": "http.http2writeFramer",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writeFramer interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writeFramer interface {\n\twriteFrame(http2writeContext) error\n\n\t// staysWithinBuffer reports whether this writer promises that\n\t// it will only write less than or equal to size bytes, and it\n\t// won't Flush the write context.\n\tstaysWithinBuffer(size int) bool\n}\n```\n\nwriteFramer is implemented by any type that is used to write frames. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeGoAway",
              "documentation": {
                "identifier": "http2writeGoAway",
                "newPage": false,
                "searchKey": "http.http2writeGoAway",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writeGoAway struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writeGoAway struct {\n\tmaxStreamID uint32\n\tcode        http2ErrCode\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2writeGoAway.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2writeGoAway.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2writeGoAway.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*http2writeGoAway) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*http2writeGoAway) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeGoAway.writeFrame",
                    "documentation": {
                      "identifier": "http2writeGoAway.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2writeGoAway.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2writeGoAway) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2writeGoAway) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writePingAck",
              "documentation": {
                "identifier": "http2writePingAck",
                "newPage": false,
                "searchKey": "http.http2writePingAck",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writePingAck struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writePingAck struct{ pf *http2PingFrame }\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2writePingAck.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2writePingAck.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2writePingAck.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w http2writePingAck) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w http2writePingAck) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writePingAck.writeFrame",
                    "documentation": {
                      "identifier": "http2writePingAck.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2writePingAck.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w http2writePingAck) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w http2writePingAck) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writePushPromise",
              "documentation": {
                "identifier": "http2writePushPromise",
                "newPage": false,
                "searchKey": "http.http2writePushPromise",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writePushPromise struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writePushPromise struct {\n\tstreamID uint32   // pusher stream\n\tmethod   string   // for :method\n\turl      *url.URL // for :scheme, :authority, :path\n\th        Header\n\n\t// Creates an ID for a pushed stream. This runs on serveG just before\n\t// the frame is written. The returned ID is copied to promisedID.\n\tallocatePromisedID func() (uint32, error)\n\tpromisedID         uint32\n}\n```\n\nwritePushPromise is a request to write a PUSH_PROMISE and 0+ CONTINUATION frames. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2writePushPromise.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2writePushPromise.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2writePushPromise.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2writePushPromise) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2writePushPromise) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writePushPromise.writeFrame",
                    "documentation": {
                      "identifier": "http2writePushPromise.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2writePushPromise.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2writePushPromise) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2writePushPromise) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writePushPromise.writeHeaderBlock",
                    "documentation": {
                      "identifier": "http2writePushPromise.writeHeaderBlock",
                      "newPage": false,
                      "searchKey": "http.http2writePushPromise.writeHeaderBlock",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2writePushPromise) writeHeaderBlock(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2writePushPromise) writeHeaderBlock(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeQueue",
              "documentation": {
                "identifier": "http2writeQueue",
                "newPage": false,
                "searchKey": "http.http2writeQueue",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writeQueue struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writeQueue struct {\n\ts []http2FrameWriteRequest\n}\n```\n\nwriteQueue is used by implementations of WriteScheduler. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2writeQueue.consume",
                    "documentation": {
                      "identifier": "http2writeQueue.consume",
                      "newPage": false,
                      "searchKey": "http.http2writeQueue.consume",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *http2writeQueue) consume(n int32) (http2FrameWriteRequest, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *http2writeQueue) consume(n int32) (http2FrameWriteRequest, bool)\n```\n\nconsume consumes up to n bytes from q.s[0]. If the frame is entirely consumed, it is removed from the queue. If the frame is partially consumed, the frame is kept with the consumed bytes removed. Returns true iff any bytes were consumed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeQueue.empty",
                    "documentation": {
                      "identifier": "http2writeQueue.empty",
                      "newPage": false,
                      "searchKey": "http.http2writeQueue.empty",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *http2writeQueue) empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *http2writeQueue) empty() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeQueue.push",
                    "documentation": {
                      "identifier": "http2writeQueue.push",
                      "newPage": false,
                      "searchKey": "http.http2writeQueue.push",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *http2writeQueue) push(wr http2FrameWriteRequest)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *http2writeQueue) push(wr http2FrameWriteRequest)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeQueue.shift",
                    "documentation": {
                      "identifier": "http2writeQueue.shift",
                      "newPage": false,
                      "searchKey": "http.http2writeQueue.shift",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *http2writeQueue) shift() http2FrameWriteRequest"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *http2writeQueue) shift() http2FrameWriteRequest\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeQueuePool",
              "documentation": {
                "identifier": "http2writeQueuePool",
                "newPage": false,
                "searchKey": "http.http2writeQueuePool",
                "tags": [
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writeQueuePool []*http.http2writeQueue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writeQueuePool []*http2writeQueue\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2writeQueuePool.get",
                    "documentation": {
                      "identifier": "http2writeQueuePool.get",
                      "newPage": false,
                      "searchKey": "http.http2writeQueuePool.get",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2writeQueuePool) get() *http2writeQueue"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2writeQueuePool) get() *http2writeQueue\n```\n\nget returns an empty writeQueue. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeQueuePool.put",
                    "documentation": {
                      "identifier": "http2writeQueuePool.put",
                      "newPage": false,
                      "searchKey": "http.http2writeQueuePool.put",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *http2writeQueuePool) put(q *http2writeQueue)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *http2writeQueuePool) put(q *http2writeQueue)\n```\n\nput inserts an unused writeQueue into the pool. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeResHeaders",
              "documentation": {
                "identifier": "http2writeResHeaders",
                "newPage": false,
                "searchKey": "http.http2writeResHeaders",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writeResHeaders struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writeResHeaders struct {\n\tstreamID    uint32\n\thttpResCode int      // 0 means no \":status\" line\n\th           Header   // may be nil\n\ttrailers    []string // if non-nil, which keys of h to write. nil means all.\n\tendStream   bool\n\n\tdate          string\n\tcontentType   string\n\tcontentLength string\n}\n```\n\nwriteResHeaders is a request to write a HEADERS and 0+ CONTINUATION frames for HTTP response headers or trailers from a server handler. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2writeResHeaders.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2writeResHeaders.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2writeResHeaders.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2writeResHeaders) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2writeResHeaders) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeResHeaders.writeFrame",
                    "documentation": {
                      "identifier": "http2writeResHeaders.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2writeResHeaders.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2writeResHeaders) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2writeResHeaders) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeResHeaders.writeHeaderBlock",
                    "documentation": {
                      "identifier": "http2writeResHeaders.writeHeaderBlock",
                      "newPage": false,
                      "searchKey": "http.http2writeResHeaders.writeHeaderBlock",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *http2writeResHeaders) writeHeaderBlock(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *http2writeResHeaders) writeHeaderBlock(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeSettings",
              "documentation": {
                "identifier": "http2writeSettings",
                "newPage": false,
                "searchKey": "http.http2writeSettings",
                "tags": [
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writeSettings []http.http2Setting"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writeSettings []http2Setting\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2writeSettings.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2writeSettings.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2writeSettings.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s http2writeSettings) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s http2writeSettings) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeSettings.writeFrame",
                    "documentation": {
                      "identifier": "http2writeSettings.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2writeSettings.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s http2writeSettings) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s http2writeSettings) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeSettingsAck",
              "documentation": {
                "identifier": "http2writeSettingsAck",
                "newPage": false,
                "searchKey": "http.http2writeSettingsAck",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writeSettingsAck struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writeSettingsAck struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2writeSettingsAck.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2writeSettingsAck.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2writeSettingsAck.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (http2writeSettingsAck) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (http2writeSettingsAck) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeSettingsAck.writeFrame",
                    "documentation": {
                      "identifier": "http2writeSettingsAck.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2writeSettingsAck.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (http2writeSettingsAck) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (http2writeSettingsAck) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeWindowUpdate",
              "documentation": {
                "identifier": "http2writeWindowUpdate",
                "newPage": false,
                "searchKey": "http.http2writeWindowUpdate",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type http2writeWindowUpdate struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype http2writeWindowUpdate struct {\n\tstreamID uint32 // or 0 for conn-level\n\tn        uint32\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#http2writeWindowUpdate.staysWithinBuffer",
                    "documentation": {
                      "identifier": "http2writeWindowUpdate.staysWithinBuffer",
                      "newPage": false,
                      "searchKey": "http.http2writeWindowUpdate.staysWithinBuffer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (wu http2writeWindowUpdate) staysWithinBuffer(max int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (wu http2writeWindowUpdate) staysWithinBuffer(max int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#http2writeWindowUpdate.writeFrame",
                    "documentation": {
                      "identifier": "http2writeWindowUpdate.writeFrame",
                      "newPage": false,
                      "searchKey": "http.http2writeWindowUpdate.writeFrame",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (wu http2writeWindowUpdate) writeFrame(ctx http2writeContext) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (wu http2writeWindowUpdate) writeFrame(ctx http2writeContext) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#httpError",
              "documentation": {
                "identifier": "httpError",
                "newPage": false,
                "searchKey": "http.httpError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type httpError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype httpError struct {\n\terr     string\n\ttimeout bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#httpError.Error",
                    "documentation": {
                      "identifier": "httpError.Error",
                      "newPage": false,
                      "searchKey": "http.httpError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *httpError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *httpError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#httpError.Temporary",
                    "documentation": {
                      "identifier": "httpError.Temporary",
                      "newPage": false,
                      "searchKey": "http.httpError.Temporary",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *httpError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *httpError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#httpError.Timeout",
                    "documentation": {
                      "identifier": "httpError.Timeout",
                      "newPage": false,
                      "searchKey": "http.httpError.Timeout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *httpError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *httpError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#httpRange",
              "documentation": {
                "identifier": "httpRange",
                "newPage": false,
                "searchKey": "http.httpRange",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type httpRange struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype httpRange struct {\n\tstart, length int64\n}\n```\n\nhttpRange specifies the byte range to be sent to the client. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#httpRange.contentRange",
                    "documentation": {
                      "identifier": "httpRange.contentRange",
                      "newPage": false,
                      "searchKey": "http.httpRange.contentRange",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r httpRange) contentRange(size int64) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r httpRange) contentRange(size int64) string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#httpRange.mimeHeader",
                    "documentation": {
                      "identifier": "httpRange.mimeHeader",
                      "newPage": false,
                      "searchKey": "http.httpRange.mimeHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r httpRange) mimeHeader(contentType string, size int64) textproto.MIMEHeader"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r httpRange) mimeHeader(contentType string, size int64) textproto.MIMEHeader\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#incomparable",
              "documentation": {
                "identifier": "incomparable",
                "newPage": false,
                "searchKey": "http.incomparable",
                "tags": [
                  "array",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type incomparable [0]func()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype incomparable [0]func()\n```\n\nincomparable is a zero-width, non-comparable type. Adding it to a struct makes that struct also non-comparable, and generally doesn't add any size (as long as it's first). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#initALPNRequest",
              "documentation": {
                "identifier": "initALPNRequest",
                "newPage": false,
                "searchKey": "http.initALPNRequest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type initALPNRequest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype initALPNRequest struct {\n\tctx context.Context\n\tc   *tls.Conn\n\th   serverHandler\n}\n```\n\ninitALPNRequest is an HTTP handler that initializes certain uninitialized fields in its *Request. Such partially-initialized Requests come from ALPN protocol handlers. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#initALPNRequest.BaseContext",
                    "documentation": {
                      "identifier": "initALPNRequest.BaseContext",
                      "newPage": false,
                      "searchKey": "http.initALPNRequest.BaseContext",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h initALPNRequest) BaseContext() context.Context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h initALPNRequest) BaseContext() context.Context\n```\n\nBaseContext is an exported but unadvertised http.Handler method recognized by x/net/http2 to pass down a context; the TLSNextProto API predates context support so we shoehorn through the only interface we have available. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#initALPNRequest.ServeHTTP",
                    "documentation": {
                      "identifier": "initALPNRequest.ServeHTTP",
                      "newPage": false,
                      "searchKey": "http.initALPNRequest.ServeHTTP",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h initALPNRequest) ServeHTTP(rw ResponseWriter, req *Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h initALPNRequest) ServeHTTP(rw ResponseWriter, req *Request)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#ioFS",
              "documentation": {
                "identifier": "ioFS",
                "newPage": false,
                "searchKey": "http.ioFS",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ioFS struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ioFS struct {\n\tfsys fs.FS\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#ioFS.Open",
                    "documentation": {
                      "identifier": "ioFS.Open",
                      "newPage": false,
                      "searchKey": "http.ioFS.Open",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f ioFS) Open(name string) (File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f ioFS) Open(name string) (File, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#ioFile",
              "documentation": {
                "identifier": "ioFile",
                "newPage": false,
                "searchKey": "http.ioFile",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ioFile struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ioFile struct {\n\tfile fs.File\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#ioFile.Close",
                    "documentation": {
                      "identifier": "ioFile.Close",
                      "newPage": false,
                      "searchKey": "http.ioFile.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f ioFile) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f ioFile) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ioFile.Read",
                    "documentation": {
                      "identifier": "ioFile.Read",
                      "newPage": false,
                      "searchKey": "http.ioFile.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f ioFile) Read(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f ioFile) Read(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ioFile.ReadDir",
                    "documentation": {
                      "identifier": "ioFile.ReadDir",
                      "newPage": false,
                      "searchKey": "http.ioFile.ReadDir",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f ioFile) ReadDir(count int) ([]fs.DirEntry, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f ioFile) ReadDir(count int) ([]fs.DirEntry, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ioFile.Readdir",
                    "documentation": {
                      "identifier": "ioFile.Readdir",
                      "newPage": false,
                      "searchKey": "http.ioFile.Readdir",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f ioFile) Readdir(count int) ([]fs.FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f ioFile) Readdir(count int) ([]fs.FileInfo, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ioFile.Seek",
                    "documentation": {
                      "identifier": "ioFile.Seek",
                      "newPage": false,
                      "searchKey": "http.ioFile.Seek",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f ioFile) Seek(offset int64, whence int) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f ioFile) Seek(offset int64, whence int) (int64, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#ioFile.Stat",
                    "documentation": {
                      "identifier": "ioFile.Stat",
                      "newPage": false,
                      "searchKey": "http.ioFile.Stat",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f ioFile) Stat() (fs.FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f ioFile) Stat() (fs.FileInfo, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#issue22091Error",
              "documentation": {
                "identifier": "issue22091Error",
                "newPage": false,
                "searchKey": "http.issue22091Error",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type issue22091Error struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype issue22091Error struct{}\n```\n\nissue22091Error acts like a golang.org/x/net/http2.ErrNoCachedConn. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#issue22091Error.Error",
                    "documentation": {
                      "identifier": "issue22091Error.Error",
                      "newPage": false,
                      "searchKey": "http.issue22091Error.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (issue22091Error) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (issue22091Error) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#issue22091Error.IsHTTP2NoCachedConnError",
                    "documentation": {
                      "identifier": "issue22091Error.IsHTTP2NoCachedConnError",
                      "newPage": false,
                      "searchKey": "http.issue22091Error.IsHTTP2NoCachedConnError",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (issue22091Error) IsHTTP2NoCachedConnError()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (issue22091Error) IsHTTP2NoCachedConnError()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#keyValues",
              "documentation": {
                "identifier": "keyValues",
                "newPage": false,
                "searchKey": "http.keyValues",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type keyValues struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype keyValues struct {\n\tkey    string\n\tvalues []string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#loggingConn",
              "documentation": {
                "identifier": "loggingConn",
                "newPage": false,
                "searchKey": "http.loggingConn",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type loggingConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype loggingConn struct {\n\tname string\n\tnet.Conn\n}\n```\n\nloggingConn is used for debugging. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#loggingConn.Close",
                    "documentation": {
                      "identifier": "loggingConn.Close",
                      "newPage": false,
                      "searchKey": "http.loggingConn.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *loggingConn) Close() (err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *loggingConn) Close() (err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#loggingConn.Read",
                    "documentation": {
                      "identifier": "loggingConn.Read",
                      "newPage": false,
                      "searchKey": "http.loggingConn.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *loggingConn) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *loggingConn) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#loggingConn.Write",
                    "documentation": {
                      "identifier": "loggingConn.Write",
                      "newPage": false,
                      "searchKey": "http.loggingConn.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *loggingConn) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *loggingConn) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#maskedSig",
              "documentation": {
                "identifier": "maskedSig",
                "newPage": false,
                "searchKey": "http.maskedSig",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type maskedSig struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype maskedSig struct {\n\tmask, pat []byte\n\tskipWS    bool\n\tct        string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#maskedSig.match",
                    "documentation": {
                      "identifier": "maskedSig.match",
                      "newPage": false,
                      "searchKey": "http.maskedSig.match",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *maskedSig) match(data []byte, firstNonWS int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *maskedSig) match(data []byte, firstNonWS int) string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#maxBytesReader",
              "documentation": {
                "identifier": "maxBytesReader",
                "newPage": false,
                "searchKey": "http.maxBytesReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type maxBytesReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype maxBytesReader struct {\n\tw   ResponseWriter\n\tr   io.ReadCloser // underlying reader\n\tn   int64         // max bytes remaining\n\terr error         // sticky error\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#maxBytesReader.Close",
                    "documentation": {
                      "identifier": "maxBytesReader.Close",
                      "newPage": false,
                      "searchKey": "http.maxBytesReader.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *maxBytesReader) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *maxBytesReader) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#maxBytesReader.Read",
                    "documentation": {
                      "identifier": "maxBytesReader.Read",
                      "newPage": false,
                      "searchKey": "http.maxBytesReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *maxBytesReader) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *maxBytesReader) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#mockTransferWriter",
              "documentation": {
                "identifier": "mockTransferWriter",
                "newPage": false,
                "searchKey": "http.mockTransferWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type mockTransferWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mockTransferWriter struct {\n\tCalledReader io.Reader\n\tWriteCalled  bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#mockTransferWriter.ReadFrom",
                    "documentation": {
                      "identifier": "mockTransferWriter.ReadFrom",
                      "newPage": false,
                      "searchKey": "http.mockTransferWriter.ReadFrom",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *mockTransferWriter) ReadFrom(r io.Reader) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *mockTransferWriter) ReadFrom(r io.Reader) (int64, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#mockTransferWriter.Write",
                    "documentation": {
                      "identifier": "mockTransferWriter.Write",
                      "newPage": false,
                      "searchKey": "http.mockTransferWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *mockTransferWriter) Write(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *mockTransferWriter) Write(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#mp4Sig",
              "documentation": {
                "identifier": "mp4Sig",
                "newPage": false,
                "searchKey": "http.mp4Sig",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type mp4Sig struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mp4Sig struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#mp4Sig.match",
                    "documentation": {
                      "identifier": "mp4Sig.match",
                      "newPage": false,
                      "searchKey": "http.mp4Sig.match",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mp4Sig) match(data []byte, firstNonWS int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mp4Sig) match(data []byte, firstNonWS int) string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#muxEntry",
              "documentation": {
                "identifier": "muxEntry",
                "newPage": false,
                "searchKey": "http.muxEntry",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type muxEntry struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype muxEntry struct {\n\th       Handler\n\tpattern string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#noBody",
              "documentation": {
                "identifier": "noBody",
                "newPage": false,
                "searchKey": "http.noBody",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type noBody struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype noBody struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#noBody.Close",
                    "documentation": {
                      "identifier": "noBody.Close",
                      "newPage": false,
                      "searchKey": "http.noBody.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (noBody) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (noBody) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#noBody.Read",
                    "documentation": {
                      "identifier": "noBody.Read",
                      "newPage": false,
                      "searchKey": "http.noBody.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (noBody) Read([]byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (noBody) Read([]byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#noBody.WriteTo",
                    "documentation": {
                      "identifier": "noBody.WriteTo",
                      "newPage": false,
                      "searchKey": "http.noBody.WriteTo",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (noBody) WriteTo(io.Writer) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (noBody) WriteTo(io.Writer) (int64, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#nothingWrittenError",
              "documentation": {
                "identifier": "nothingWrittenError",
                "newPage": false,
                "searchKey": "http.nothingWrittenError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type nothingWrittenError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nothingWrittenError struct {\n\terror\n}\n```\n\nnothingWrittenError wraps a write errors which ended up writing zero bytes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#onceCloseListener",
              "documentation": {
                "identifier": "onceCloseListener",
                "newPage": false,
                "searchKey": "http.onceCloseListener",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type onceCloseListener struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype onceCloseListener struct {\n\tnet.Listener\n\tonce     sync.Once\n\tcloseErr error\n}\n```\n\nonceCloseListener wraps a net.Listener, protecting it from multiple Close calls. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#onceCloseListener.Close",
                    "documentation": {
                      "identifier": "onceCloseListener.Close",
                      "newPage": false,
                      "searchKey": "http.onceCloseListener.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (oc *onceCloseListener) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (oc *onceCloseListener) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#onceCloseListener.close",
                    "documentation": {
                      "identifier": "onceCloseListener.close",
                      "newPage": false,
                      "searchKey": "http.onceCloseListener.close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (oc *onceCloseListener) close()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (oc *onceCloseListener) close()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#persistConn",
              "documentation": {
                "identifier": "persistConn",
                "newPage": false,
                "searchKey": "http.persistConn",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type persistConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype persistConn struct {\n\t// alt optionally specifies the TLS NextProto RoundTripper.\n\t// This is used for HTTP/2 today and future protocols later.\n\t// If it's non-nil, the rest of the fields are unused.\n\talt RoundTripper\n\n\tt         *Transport\n\tcacheKey  connectMethodKey\n\tconn      net.Conn\n\ttlsState  *tls.ConnectionState\n\tbr        *bufio.Reader       // from conn\n\tbw        *bufio.Writer       // to conn\n\tnwrite    int64               // bytes written\n\treqch     chan requestAndChan // written by roundTrip; read by readLoop\n\twritech   chan writeRequest   // written by roundTrip; read by writeLoop\n\tclosech   chan struct{}       // closed when conn closed\n\tisProxy   bool\n\tsawEOF    bool  // whether we've seen EOF from conn; owned by readLoop\n\treadLimit int64 // bytes allowed to be read; owned by readLoop\n\t// writeErrCh passes the request write error (usually nil)\n\t// from the writeLoop goroutine to the readLoop which passes\n\t// it off to the res.Body reader, which then uses it to decide\n\t// whether or not a connection can be reused. Issue 7569.\n\twriteErrCh chan error\n\n\twriteLoopDone chan struct{} // closed when write loop ends\n\n\t// Both guarded by Transport.idleMu:\n\tidleAt    time.Time   // time it last become idle\n\tidleTimer *time.Timer // holding an AfterFunc to close it\n\n\tmu                   sync.Mutex // guards following fields\n\tnumExpectedResponses int\n\tclosed               error // set non-nil when conn is closed, before closech is closed\n\tcanceledErr          error // set non-nil if conn is canceled\n\tbroken               bool  // an error has happened on this connection; marked broken so it's not reused.\n\treused               bool  // whether conn has had successful request/response and is being reused.\n\t// mutateHeaderFunc is an optional func to modify extra\n\t// headers on each outbound request before it's written. (the\n\t// original Request given to RoundTrip is not modified)\n\tmutateHeaderFunc func(Header)\n}\n```\n\npersistConn wraps a connection, usually a persistent one (but may be used for non-keep-alive requests as well) \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#persistConn.Read",
                    "documentation": {
                      "identifier": "persistConn.Read",
                      "newPage": false,
                      "searchKey": "http.persistConn.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.addTLS",
                    "documentation": {
                      "identifier": "persistConn.addTLS",
                      "newPage": false,
                      "searchKey": "http.persistConn.addTLS",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pconn *persistConn) addTLS(ctx context.Context, name string, trace *httptrace.ClientTrace) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pconn *persistConn) addTLS(ctx context.Context, name string, trace *httptrace.ClientTrace) error\n```\n\nAdd TLS to a persistent connection, i.e. negotiate a TLS session. If pconn is already a TLS tunnel, this function establishes a nested TLS session inside the encrypted channel. The remote endpoint's name may be overridden by TLSClientConfig.ServerName. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.cancelRequest",
                    "documentation": {
                      "identifier": "persistConn.cancelRequest",
                      "newPage": false,
                      "searchKey": "http.persistConn.cancelRequest",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) cancelRequest(err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) cancelRequest(err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.canceled",
                    "documentation": {
                      "identifier": "persistConn.canceled",
                      "newPage": false,
                      "searchKey": "http.persistConn.canceled",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) canceled() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) canceled() error\n```\n\ncanceled returns non-nil if the connection was closed due to CancelRequest or due to context cancellation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.close",
                    "documentation": {
                      "identifier": "persistConn.close",
                      "newPage": false,
                      "searchKey": "http.persistConn.close",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) close(err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) close(err error)\n```\n\nclose closes the underlying TCP connection and closes the pc.closech channel. \n\nThe provided err is only for testing and debugging; in normal circumstances it should never be seen by users. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.closeConnIfStillIdle",
                    "documentation": {
                      "identifier": "persistConn.closeConnIfStillIdle",
                      "newPage": false,
                      "searchKey": "http.persistConn.closeConnIfStillIdle",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) closeConnIfStillIdle()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) closeConnIfStillIdle()\n```\n\ncloseConnIfStillIdle closes the connection if it's still sitting idle. This is what's called by the persistConn's idleTimer, and is run in its own goroutine. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.closeLocked",
                    "documentation": {
                      "identifier": "persistConn.closeLocked",
                      "newPage": false,
                      "searchKey": "http.persistConn.closeLocked",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) closeLocked(err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) closeLocked(err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.gotIdleConnTrace",
                    "documentation": {
                      "identifier": "persistConn.gotIdleConnTrace",
                      "newPage": false,
                      "searchKey": "http.persistConn.gotIdleConnTrace",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) gotIdleConnTrace(idleAt time.Time) (t httptrace.GotConnInfo)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) gotIdleConnTrace(idleAt time.Time) (t httptrace.GotConnInfo)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.isBroken",
                    "documentation": {
                      "identifier": "persistConn.isBroken",
                      "newPage": false,
                      "searchKey": "http.persistConn.isBroken",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) isBroken() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) isBroken() bool\n```\n\nisBroken reports whether this connection is in a known broken state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.isReused",
                    "documentation": {
                      "identifier": "persistConn.isReused",
                      "newPage": false,
                      "searchKey": "http.persistConn.isReused",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) isReused() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) isReused() bool\n```\n\nisReused reports whether this connection has been used before. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.mapRoundTripError",
                    "documentation": {
                      "identifier": "persistConn.mapRoundTripError",
                      "newPage": false,
                      "searchKey": "http.persistConn.mapRoundTripError",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) mapRoundTripError(req *transportRequest, startBytesWritten int64, err error) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) mapRoundTripError(req *transportRequest, startBytesWritten int64, err error) error\n```\n\nmapRoundTripError returns the appropriate error value for persistConn.roundTrip. \n\nThe provided err is the first error that (*persistConn).roundTrip happened to receive from its select statement. \n\nThe startBytesWritten value should be the value of pc.nwrite before the roundTrip started writing the request. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.markReused",
                    "documentation": {
                      "identifier": "persistConn.markReused",
                      "newPage": false,
                      "searchKey": "http.persistConn.markReused",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) markReused()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) markReused()\n```\n\nmarkReused marks this connection as having been successfully used for a request and response. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.maxHeaderResponseSize",
                    "documentation": {
                      "identifier": "persistConn.maxHeaderResponseSize",
                      "newPage": false,
                      "searchKey": "http.persistConn.maxHeaderResponseSize",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) maxHeaderResponseSize() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) maxHeaderResponseSize() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.readLoop",
                    "documentation": {
                      "identifier": "persistConn.readLoop",
                      "newPage": false,
                      "searchKey": "http.persistConn.readLoop",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) readLoop()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) readLoop()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.readLoopPeekFailLocked",
                    "documentation": {
                      "identifier": "persistConn.readLoopPeekFailLocked",
                      "newPage": false,
                      "searchKey": "http.persistConn.readLoopPeekFailLocked",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) readLoopPeekFailLocked(peekErr error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) readLoopPeekFailLocked(peekErr error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.readResponse",
                    "documentation": {
                      "identifier": "persistConn.readResponse",
                      "newPage": false,
                      "searchKey": "http.persistConn.readResponse",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) readResponse(rc requestAndChan, trace *httptrace.ClientTrace) (resp *Response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) readResponse(rc requestAndChan, trace *httptrace.ClientTrace) (resp *Response, err error)\n```\n\nreadResponse reads an HTTP response (or two, in the case of \"Expect: 100-continue\") from the server. It returns the final non-100 one. trace is optional. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.roundTrip",
                    "documentation": {
                      "identifier": "persistConn.roundTrip",
                      "newPage": false,
                      "searchKey": "http.persistConn.roundTrip",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) roundTrip(req *transportRequest) (resp *Response, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.shouldRetryRequest",
                    "documentation": {
                      "identifier": "persistConn.shouldRetryRequest",
                      "newPage": false,
                      "searchKey": "http.persistConn.shouldRetryRequest",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) shouldRetryRequest(req *Request, err error) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) shouldRetryRequest(req *Request, err error) bool\n```\n\nshouldRetryRequest reports whether we should retry sending a failed HTTP request on a new connection. The non-nil input error is the error from roundTrip. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.waitForContinue",
                    "documentation": {
                      "identifier": "persistConn.waitForContinue",
                      "newPage": false,
                      "searchKey": "http.persistConn.waitForContinue",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) waitForContinue(continueCh <-chan struct{}) func() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) waitForContinue(continueCh <-chan struct{}) func() bool\n```\n\nwaitForContinue returns the function to block until any response, timeout or connection close. After any of them, the function returns a bool which indicates if the body should be sent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.writeLoop",
                    "documentation": {
                      "identifier": "persistConn.writeLoop",
                      "newPage": false,
                      "searchKey": "http.persistConn.writeLoop",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) writeLoop()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) writeLoop()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConn.wroteRequest",
                    "documentation": {
                      "identifier": "persistConn.wroteRequest",
                      "newPage": false,
                      "searchKey": "http.persistConn.wroteRequest",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pc *persistConn) wroteRequest() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pc *persistConn) wroteRequest() bool\n```\n\nwroteRequest is a check before recycling a connection that the previous write (from writeLoop above) happened and was successful. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#persistConnWriter",
              "documentation": {
                "identifier": "persistConnWriter",
                "newPage": false,
                "searchKey": "http.persistConnWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type persistConnWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype persistConnWriter struct {\n\tpc *persistConn\n}\n```\n\npersistConnWriter is the io.Writer written to by pc.bw. It accumulates the number of bytes written to the underlying conn, so the retry logic can determine whether any bytes made it across the wire. This is exactly 1 pointer field wide so it can go into an interface without allocation. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#persistConnWriter.ReadFrom",
                    "documentation": {
                      "identifier": "persistConnWriter.ReadFrom",
                      "newPage": false,
                      "searchKey": "http.persistConnWriter.ReadFrom",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w persistConnWriter) ReadFrom(r io.Reader) (n int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w persistConnWriter) ReadFrom(r io.Reader) (n int64, err error)\n```\n\nReadFrom exposes persistConnWriter's underlying Conn to io.Copy and if the Conn implements io.ReaderFrom, it can take advantage of optimizations such as sendfile. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#persistConnWriter.Write",
                    "documentation": {
                      "identifier": "persistConnWriter.Write",
                      "newPage": false,
                      "searchKey": "http.persistConnWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w persistConnWriter) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w persistConnWriter) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#populateResponse",
              "documentation": {
                "identifier": "populateResponse",
                "newPage": false,
                "searchKey": "http.populateResponse",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type populateResponse struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype populateResponse struct {\n\tres          *Response\n\tch           chan *Response\n\twroteHeader  bool\n\thasContent   bool\n\tsentResponse bool\n\tpw           *io.PipeWriter\n}\n```\n\npopulateResponse is a ResponseWriter that populates the *Response in res, and writes its body to a pipe connected to the response body. Once writes begin or finish() is called, the response is sent on ch. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#newPopulateResponseWriter",
                    "documentation": {
                      "identifier": "newPopulateResponseWriter",
                      "newPage": false,
                      "searchKey": "http.newPopulateResponseWriter",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newPopulateResponseWriter() (*populateResponse, <-chan *Response)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newPopulateResponseWriter() (*populateResponse, <-chan *Response)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#populateResponse.Header",
                    "documentation": {
                      "identifier": "populateResponse.Header",
                      "newPage": false,
                      "searchKey": "http.populateResponse.Header",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pr *populateResponse) Header() Header"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pr *populateResponse) Header() Header\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#populateResponse.Write",
                    "documentation": {
                      "identifier": "populateResponse.Write",
                      "newPage": false,
                      "searchKey": "http.populateResponse.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pr *populateResponse) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pr *populateResponse) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#populateResponse.WriteHeader",
                    "documentation": {
                      "identifier": "populateResponse.WriteHeader",
                      "newPage": false,
                      "searchKey": "http.populateResponse.WriteHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pr *populateResponse) WriteHeader(code int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pr *populateResponse) WriteHeader(code int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#populateResponse.finish",
                    "documentation": {
                      "identifier": "populateResponse.finish",
                      "newPage": false,
                      "searchKey": "http.populateResponse.finish",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pr *populateResponse) finish()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pr *populateResponse) finish()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#populateResponse.sendResponse",
                    "documentation": {
                      "identifier": "populateResponse.sendResponse",
                      "newPage": false,
                      "searchKey": "http.populateResponse.sendResponse",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pr *populateResponse) sendResponse()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pr *populateResponse) sendResponse()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#readResult",
              "documentation": {
                "identifier": "readResult",
                "newPage": false,
                "searchKey": "http.readResult",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type readResult struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype readResult struct {\n\t_   incomparable\n\tn   int\n\terr error\n\tb   byte // byte read, if n == 1\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#readTrackingBody",
              "documentation": {
                "identifier": "readTrackingBody",
                "newPage": false,
                "searchKey": "http.readTrackingBody",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type readTrackingBody struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype readTrackingBody struct {\n\tio.ReadCloser\n\tdidRead  bool\n\tdidClose bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#readTrackingBody.Close",
                    "documentation": {
                      "identifier": "readTrackingBody.Close",
                      "newPage": false,
                      "searchKey": "http.readTrackingBody.Close",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *readTrackingBody) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *readTrackingBody) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#readTrackingBody.Read",
                    "documentation": {
                      "identifier": "readTrackingBody.Read",
                      "newPage": false,
                      "searchKey": "http.readTrackingBody.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *readTrackingBody) Read(data []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *readTrackingBody) Read(data []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#readWriteCloserBody",
              "documentation": {
                "identifier": "readWriteCloserBody",
                "newPage": false,
                "searchKey": "http.readWriteCloserBody",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type readWriteCloserBody struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype readWriteCloserBody struct {\n\t_  incomparable\n\tbr *bufio.Reader // used until empty\n\tio.ReadWriteCloser\n}\n```\n\nreadWriteCloserBody is the Response.Body type used when we want to give users write access to the Body through the underlying connection (TCP, unless using custom dialers). This is then the concrete type for a Response.Body on the 101 Switching Protocols response, as used by WebSockets, h2c, etc. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#readWriteCloserBody.Read",
                    "documentation": {
                      "identifier": "readWriteCloserBody.Read",
                      "newPage": false,
                      "searchKey": "http.readWriteCloserBody.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *readWriteCloserBody) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *readWriteCloserBody) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#readerAndCloser",
              "documentation": {
                "identifier": "readerAndCloser",
                "newPage": false,
                "searchKey": "http.readerAndCloser",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type readerAndCloser struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype readerAndCloser struct {\n\tio.Reader\n\tio.Closer\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#redirectHandler",
              "documentation": {
                "identifier": "redirectHandler",
                "newPage": false,
                "searchKey": "http.redirectHandler",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type redirectHandler struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype redirectHandler struct {\n\turl  string\n\tcode int\n}\n```\n\nRedirect to a fixed URL \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#redirectHandler.ServeHTTP",
                    "documentation": {
                      "identifier": "redirectHandler.ServeHTTP",
                      "newPage": false,
                      "searchKey": "http.redirectHandler.ServeHTTP",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rh *redirectHandler) ServeHTTP(w ResponseWriter, r *Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rh *redirectHandler) ServeHTTP(w ResponseWriter, r *Request)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#reqTest",
              "documentation": {
                "identifier": "reqTest",
                "newPage": false,
                "searchKey": "http.reqTest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type reqTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype reqTest struct {\n\tRaw     string\n\tReq     *Request\n\tBody    string\n\tTrailer Header\n\tError   string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#reqWriteTest",
              "documentation": {
                "identifier": "reqWriteTest",
                "newPage": false,
                "searchKey": "http.reqWriteTest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type reqWriteTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype reqWriteTest struct {\n\tReq  Request\n\tBody interface{} // optional []byte or func() io.ReadCloser to populate Req.Body\n\n\t// Any of these three may be empty to skip that test.\n\tWantWrite string // Request.Write\n\tWantProxy string // Request.WriteProxy\n\n\tWantError error // wanted error from Request.Write\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#requestAndChan",
              "documentation": {
                "identifier": "requestAndChan",
                "newPage": false,
                "searchKey": "http.requestAndChan",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type requestAndChan struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype requestAndChan struct {\n\t_         incomparable\n\treq       *Request\n\tcancelKey cancelKey\n\tch        chan responseAndError // unbuffered; always send in select on callerGone\n\n\t// whether the Transport (as opposed to the user client code)\n\t// added the Accept-Encoding gzip header. If the Transport\n\t// set it, only then do we transparently decode the gzip.\n\taddedGzip bool\n\n\t// Optional blocking chan for Expect: 100-continue (for send).\n\t// If the request has an \"Expect: 100-continue\" header and\n\t// the server responds 100 Continue, readLoop send a value\n\t// to writeLoop via this chan.\n\tcontinueCh chan<- struct{}\n\n\tcallerGone <-chan struct{} // closed when roundTrip caller has returned\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#requestBodyReadError",
              "documentation": {
                "identifier": "requestBodyReadError",
                "newPage": false,
                "searchKey": "http.requestBodyReadError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type requestBodyReadError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype requestBodyReadError struct{ error }\n```\n\nrequestBodyReadError wraps an error from (*Request).write to indicate that the error came from a Read call on the Request.Body. This error type should not escape the net/http package to users. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#respTest",
              "documentation": {
                "identifier": "respTest",
                "newPage": false,
                "searchKey": "http.respTest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type respTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype respTest struct {\n\tRaw  string\n\tResp Response\n\tBody string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#respWriteTest",
              "documentation": {
                "identifier": "respWriteTest",
                "newPage": false,
                "searchKey": "http.respWriteTest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type respWriteTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype respWriteTest struct {\n\tResp Response\n\tRaw  string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#response",
              "documentation": {
                "identifier": "response",
                "newPage": false,
                "searchKey": "http.response",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type response struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype response struct {\n\tconn             *conn\n\treq              *Request // request for this response\n\treqBody          io.ReadCloser\n\tcancelCtx        context.CancelFunc // when ServeHTTP exits\n\twroteHeader      bool               // reply header has been (logically) written\n\twroteContinue    bool               // 100 Continue response was written\n\twants10KeepAlive bool               // HTTP/1.0 w/ Connection \"keep-alive\"\n\twantsClose       bool               // HTTP request has Connection \"close\"\n\n\t// canWriteContinue is a boolean value accessed as an atomic int32\n\t// that says whether or not a 100 Continue header can be written\n\t// to the connection.\n\t// writeContinueMu must be held while writing the header.\n\t// These two fields together synchronize the body reader\n\t// (the expectContinueReader, which wants to write 100 Continue)\n\t// against the main writer.\n\tcanWriteContinue atomicBool\n\twriteContinueMu  sync.Mutex\n\n\tw  *bufio.Writer // buffers output in chunks to chunkWriter\n\tcw chunkWriter\n\n\t// handlerHeader is the Header that Handlers get access to,\n\t// which may be retained and mutated even after WriteHeader.\n\t// handlerHeader is copied into cw.header at WriteHeader\n\t// time, and privately mutated thereafter.\n\thandlerHeader Header\n\tcalledHeader  bool // handler accessed handlerHeader via Header\n\n\twritten       int64 // number of bytes written in body\n\tcontentLength int64 // explicitly-declared Content-Length; or -1\n\tstatus        int   // status code passed to WriteHeader\n\n\t// close connection after this reply.  set on request and\n\t// updated after response from handler if there's a\n\t// \"Connection: keep-alive\" response header and a\n\t// Content-Length.\n\tcloseAfterReply bool\n\n\t// requestBodyLimitHit is set by requestTooLarge when\n\t// maxBytesReader hits its max size. It is checked in\n\t// WriteHeader, to make sure we don't consume the\n\t// remaining request body to try to advance to the next HTTP\n\t// request. Instead, when this is set, we stop reading\n\t// subsequent requests on this connection and stop reading\n\t// input from it.\n\trequestBodyLimitHit bool\n\n\t// trailers are the headers to be sent after the handler\n\t// finishes writing the body. This field is initialized from\n\t// the Trailer response header when the response header is\n\t// written.\n\ttrailers []string\n\n\thandlerDone atomicBool // set true when the handler exits\n\n\t// Buffers for Date, Content-Length, and status code\n\tdateBuf   [len(TimeFormat)]byte\n\tclenBuf   [10]byte\n\tstatusBuf [3]byte\n\n\t// closeNotifyCh is the channel returned by CloseNotify.\n\t// TODO(bradfitz): this is currently (for Go 1.8) always\n\t// non-nil. Make this lazily-created again as it used to be?\n\tcloseNotifyCh  chan bool\n\tdidCloseNotify int32 // atomic (only 0->1 winner should send)\n}\n```\n\nA response represents the server side of an HTTP response. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#response.CloseNotify",
                    "documentation": {
                      "identifier": "response.CloseNotify",
                      "newPage": false,
                      "searchKey": "http.response.CloseNotify",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) CloseNotify() <-chan bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) CloseNotify() <-chan bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.Flush",
                    "documentation": {
                      "identifier": "response.Flush",
                      "newPage": false,
                      "searchKey": "http.response.Flush",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) Flush()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) Flush()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.Header",
                    "documentation": {
                      "identifier": "response.Header",
                      "newPage": false,
                      "searchKey": "http.response.Header",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) Header() Header"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) Header() Header\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.Hijack",
                    "documentation": {
                      "identifier": "response.Hijack",
                      "newPage": false,
                      "searchKey": "http.response.Hijack",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err error)\n```\n\nHijack implements the Hijacker.Hijack method. Our response is both a ResponseWriter and a Hijacker. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.ReadFrom",
                    "documentation": {
                      "identifier": "response.ReadFrom",
                      "newPage": false,
                      "searchKey": "http.response.ReadFrom",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) ReadFrom(src io.Reader) (n int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) ReadFrom(src io.Reader) (n int64, err error)\n```\n\nReadFrom is here to optimize copying from an *os.File regular file to a *net.TCPConn with sendfile, or from a supported src type such as a *net.TCPConn on Linux with splice. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.Write",
                    "documentation": {
                      "identifier": "response.Write",
                      "newPage": false,
                      "searchKey": "http.response.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) Write(data []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) Write(data []byte) (n int, err error)\n```\n\nThe Life Of A Write is like this: \n\nHandler starts. No header has been sent. The handler can either write a header, or just start writing. Writing before sending a header sends an implicitly empty 200 OK header. \n\nIf the handler didn't declare a Content-Length up front, we either go into chunking mode or, if the handler finishes running before the chunking buffer size, we compute a Content-Length and send that in the header instead. \n\nLikewise, if the handler didn't set a Content-Type, we sniff that from the initial chunk of output. \n\nThe Writers are wired together like: \n\n1. *response (the ResponseWriter) -> 2. (*response).w, a *bufio.Writer of bufferBeforeChunkingSize bytes -> 3. chunkWriter.Writer (whose writeHeader finalizes Content-Length/Type) \n\n```\nand which writes the chunk headers, if needed ->\n\n```\n4. conn.bufw, a *bufio.Writer of default (4kB) bytes, writing to -> 5. checkConnErrorWriter{c}, which notes any non-nil error on Write \n\n```\nand populates c.werr with it if so, but otherwise writes to ->\n\n```\n6. the rwc, the net.Conn. \n\nTODO(bradfitz): short-circuit some of the buffering when the initial header contains both a Content-Type and Content-Length. Also short-circuit in (1) when the header's been sent and not in chunking mode, writing directly to (4) instead, if (2) has no buffered data. More generally, we could short-circuit from (1) to (3) even in chunking mode if the write size from (1) is over some threshold and nothing is in (2).  The answer might be mostly making bufferBeforeChunkingSize smaller and having bufio's fast-paths deal with this instead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.WriteHeader",
                    "documentation": {
                      "identifier": "response.WriteHeader",
                      "newPage": false,
                      "searchKey": "http.response.WriteHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) WriteHeader(code int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) WriteHeader(code int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.WriteString",
                    "documentation": {
                      "identifier": "response.WriteString",
                      "newPage": false,
                      "searchKey": "http.response.WriteString",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) WriteString(data string) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) WriteString(data string) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.bodyAllowed",
                    "documentation": {
                      "identifier": "response.bodyAllowed",
                      "newPage": false,
                      "searchKey": "http.response.bodyAllowed",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) bodyAllowed() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) bodyAllowed() bool\n```\n\nbodyAllowed reports whether a Write is allowed for this response type. It's illegal to call this before the header has been flushed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.closedRequestBodyEarly",
                    "documentation": {
                      "identifier": "response.closedRequestBodyEarly",
                      "newPage": false,
                      "searchKey": "http.response.closedRequestBodyEarly",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) closedRequestBodyEarly() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) closedRequestBodyEarly() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.declareTrailer",
                    "documentation": {
                      "identifier": "response.declareTrailer",
                      "newPage": false,
                      "searchKey": "http.response.declareTrailer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) declareTrailer(k string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) declareTrailer(k string)\n```\n\ndeclareTrailer is called for each Trailer header when the response header is written. It notes that a header will need to be written in the trailers at the end of the response. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.finalTrailers",
                    "documentation": {
                      "identifier": "response.finalTrailers",
                      "newPage": false,
                      "searchKey": "http.response.finalTrailers",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) finalTrailers() Header"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) finalTrailers() Header\n```\n\nfinalTrailers is called after the Handler exits and returns a non-nil value if the Handler set any trailers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.finishRequest",
                    "documentation": {
                      "identifier": "response.finishRequest",
                      "newPage": false,
                      "searchKey": "http.response.finishRequest",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) finishRequest()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) finishRequest()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.needsSniff",
                    "documentation": {
                      "identifier": "response.needsSniff",
                      "newPage": false,
                      "searchKey": "http.response.needsSniff",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) needsSniff() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) needsSniff() bool\n```\n\nneedsSniff reports whether a Content-Type still needs to be sniffed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.requestTooLarge",
                    "documentation": {
                      "identifier": "response.requestTooLarge",
                      "newPage": false,
                      "searchKey": "http.response.requestTooLarge",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) requestTooLarge()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) requestTooLarge()\n```\n\nrequestTooLarge is called by maxBytesReader when too much input has been read from the client. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.sendExpectationFailed",
                    "documentation": {
                      "identifier": "response.sendExpectationFailed",
                      "newPage": false,
                      "searchKey": "http.response.sendExpectationFailed",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) sendExpectationFailed()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) sendExpectationFailed()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.shouldReuseConnection",
                    "documentation": {
                      "identifier": "response.shouldReuseConnection",
                      "newPage": false,
                      "searchKey": "http.response.shouldReuseConnection",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) shouldReuseConnection() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) shouldReuseConnection() bool\n```\n\nshouldReuseConnection reports whether the underlying TCP connection can be reused. It must only be called after the handler is done executing. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#response.write",
                    "documentation": {
                      "identifier": "response.write",
                      "newPage": false,
                      "searchKey": "http.response.write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *response) write(lenData int, dataB []byte, dataS string) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *response) write(lenData int, dataB []byte, dataS string) (n int, err error)\n```\n\neither dataB or dataS is non-zero. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#responseAndError",
              "documentation": {
                "identifier": "responseAndError",
                "newPage": false,
                "searchKey": "http.responseAndError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type responseAndError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype responseAndError struct {\n\t_   incomparable\n\tres *Response // else use this response (see res method)\n\terr error\n}\n```\n\nresponseAndError is how the goroutine reading from an HTTP/1 server communicates with the goroutine doing the RoundTrip. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#responseLocationTest",
              "documentation": {
                "identifier": "responseLocationTest",
                "newPage": false,
                "searchKey": "http.responseLocationTest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type responseLocationTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype responseLocationTest struct {\n\tlocation string // Response's Location header or \"\"\n\trequrl   string // Response.Request.URL or \"\"\n\twant     string\n\twantErr  error\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#roundTripFunc",
              "documentation": {
                "identifier": "roundTripFunc",
                "newPage": false,
                "searchKey": "http.roundTripFunc",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type roundTripFunc func(r *std/net/http.Request) (*std/net/http.Response, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype roundTripFunc func(r *Request) (*Response, error)\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#roundTripFunc.RoundTrip",
                    "documentation": {
                      "identifier": "roundTripFunc.RoundTrip",
                      "newPage": false,
                      "searchKey": "http.roundTripFunc.RoundTrip",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f roundTripFunc) RoundTrip(r *Request) (*Response, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f roundTripFunc) RoundTrip(r *Request) (*Response, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#serverHandler",
              "documentation": {
                "identifier": "serverHandler",
                "newPage": false,
                "searchKey": "http.serverHandler",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type serverHandler struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype serverHandler struct {\n\tsrv *Server\n}\n```\n\nserverHandler delegates to either the server's Handler or DefaultServeMux and also handles \"OPTIONS *\" requests. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#serverHandler.ServeHTTP",
                    "documentation": {
                      "identifier": "serverHandler.ServeHTTP",
                      "newPage": false,
                      "searchKey": "http.serverHandler.ServeHTTP",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#sniffSig",
              "documentation": {
                "identifier": "sniffSig",
                "newPage": false,
                "searchKey": "http.sniffSig",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type sniffSig interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sniffSig interface {\n\t// match returns the MIME type of the data, or \"\" if unknown.\n\tmatch(data []byte, firstNonWS int) string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksAddr",
              "documentation": {
                "identifier": "socksAddr",
                "newPage": false,
                "searchKey": "http.socksAddr",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type socksAddr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype socksAddr struct {\n\tName string // fully-qualified domain name\n\tIP   net.IP\n\tPort int\n}\n```\n\nAn Addr represents a SOCKS-specific address. Either Name or IP is used exclusively. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#socksAddr.Network",
                    "documentation": {
                      "identifier": "socksAddr.Network",
                      "newPage": false,
                      "searchKey": "http.socksAddr.Network",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *socksAddr) Network() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *socksAddr) Network() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#socksAddr.String",
                    "documentation": {
                      "identifier": "socksAddr.String",
                      "newPage": false,
                      "searchKey": "http.socksAddr.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *socksAddr) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *socksAddr) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksAuthMethod",
              "documentation": {
                "identifier": "socksAuthMethod",
                "newPage": false,
                "searchKey": "http.socksAuthMethod",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type socksAuthMethod int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype socksAuthMethod int\n```\n\nAn AuthMethod represents a SOCKS authentication method. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksCommand",
              "documentation": {
                "identifier": "socksCommand",
                "newPage": false,
                "searchKey": "http.socksCommand",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type socksCommand int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype socksCommand int\n```\n\nA Command represents a SOCKS command. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#socksCommand.String",
                    "documentation": {
                      "identifier": "socksCommand.String",
                      "newPage": false,
                      "searchKey": "http.socksCommand.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cmd socksCommand) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cmd socksCommand) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksConn",
              "documentation": {
                "identifier": "socksConn",
                "newPage": false,
                "searchKey": "http.socksConn",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type socksConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype socksConn struct {\n\tnet.Conn\n\n\tboundAddr net.Addr\n}\n```\n\nA Conn represents a forward proxy connection. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#socksConn.BoundAddr",
                    "documentation": {
                      "identifier": "socksConn.BoundAddr",
                      "newPage": false,
                      "searchKey": "http.socksConn.BoundAddr",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *socksConn) BoundAddr() net.Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *socksConn) BoundAddr() net.Addr\n```\n\nBoundAddr returns the address assigned by the proxy server for connecting to the command target address from the proxy server. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksDialer",
              "documentation": {
                "identifier": "socksDialer",
                "newPage": false,
                "searchKey": "http.socksDialer",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type socksDialer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype socksDialer struct {\n\tcmd          socksCommand // either CmdConnect or cmdBind\n\tproxyNetwork string       // network between a proxy server and a client\n\tproxyAddress string       // proxy server address\n\n\t// ProxyDial specifies the optional dial function for\n\t// establishing the transport connection.\n\tProxyDial func(context.Context, string, string) (net.Conn, error)\n\n\t// AuthMethods specifies the list of request authentication\n\t// methods.\n\t// If empty, SOCKS client requests only AuthMethodNotRequired.\n\tAuthMethods []socksAuthMethod\n\n\t// Authenticate specifies the optional authentication\n\t// function. It must be non-nil when AuthMethods is not empty.\n\t// It must return an error when the authentication is failed.\n\tAuthenticate func(context.Context, io.ReadWriter, socksAuthMethod) error\n}\n```\n\nA Dialer holds SOCKS-specific options. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#socksNewDialer",
                    "documentation": {
                      "identifier": "socksNewDialer",
                      "newPage": false,
                      "searchKey": "http.socksNewDialer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func socksNewDialer(network, address string) *socksDialer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc socksNewDialer(network, address string) *socksDialer\n```\n\nNewDialer returns a new Dialer that dials through the provided proxy server's network and address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#socksDialer.Dial",
                    "documentation": {
                      "identifier": "socksDialer.Dial",
                      "newPage": false,
                      "searchKey": "http.socksDialer.Dial",
                      "tags": [
                        "method",
                        "private",
                        "deprecated"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *socksDialer) Dial(network, address string) (net.Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *socksDialer) Dial(network, address string) (net.Conn, error)\n```\n\nDial connects to the provided address on the provided network. \n\nUnlike DialContext, it returns a raw transport connection instead of a forward proxy connection. \n\nDeprecated: Use DialContext or DialWithConn instead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#socksDialer.DialContext",
                    "documentation": {
                      "identifier": "socksDialer.DialContext",
                      "newPage": false,
                      "searchKey": "http.socksDialer.DialContext",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *socksDialer) DialContext(ctx context.Context, network, address string) (net.Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *socksDialer) DialContext(ctx context.Context, network, address string) (net.Conn, error)\n```\n\nDialContext connects to the provided address on the provided network. \n\nThe returned error value may be a net.OpError. When the Op field of net.OpError contains \"socks\", the Source field contains a proxy server address and the Addr field contains a command target address. \n\nSee func Dial of the net package of standard library for a description of the network and address parameters. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#socksDialer.DialWithConn",
                    "documentation": {
                      "identifier": "socksDialer.DialWithConn",
                      "newPage": false,
                      "searchKey": "http.socksDialer.DialWithConn",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *socksDialer) DialWithConn(ctx context.Context, c net.Conn, network, address string) (net.Addr, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *socksDialer) DialWithConn(ctx context.Context, c net.Conn, network, address string) (net.Addr, error)\n```\n\nDialWithConn initiates a connection from SOCKS server to the target network and address using the connection c that is already connected to the SOCKS server. \n\nIt returns the connection's local address assigned by the SOCKS server. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#socksDialer.connect",
                    "documentation": {
                      "identifier": "socksDialer.connect",
                      "newPage": false,
                      "searchKey": "http.socksDialer.connect",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *socksDialer) connect(ctx context.Context, c net.Conn, address string) (_ net.Addr, ctxErr error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *socksDialer) connect(ctx context.Context, c net.Conn, address string) (_ net.Addr, ctxErr error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#socksDialer.pathAddrs",
                    "documentation": {
                      "identifier": "socksDialer.pathAddrs",
                      "newPage": false,
                      "searchKey": "http.socksDialer.pathAddrs",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *socksDialer) pathAddrs(address string) (proxy, dst net.Addr, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *socksDialer) pathAddrs(address string) (proxy, dst net.Addr, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#socksDialer.validateTarget",
                    "documentation": {
                      "identifier": "socksDialer.validateTarget",
                      "newPage": false,
                      "searchKey": "http.socksDialer.validateTarget",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *socksDialer) validateTarget(network, address string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *socksDialer) validateTarget(network, address string) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksReply",
              "documentation": {
                "identifier": "socksReply",
                "newPage": false,
                "searchKey": "http.socksReply",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type socksReply int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype socksReply int\n```\n\nA Reply represents a SOCKS command reply code. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#socksReply.String",
                    "documentation": {
                      "identifier": "socksReply.String",
                      "newPage": false,
                      "searchKey": "http.socksReply.String",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (code socksReply) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (code socksReply) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#socksUsernamePassword",
              "documentation": {
                "identifier": "socksUsernamePassword",
                "newPage": false,
                "searchKey": "http.socksUsernamePassword",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type socksUsernamePassword struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype socksUsernamePassword struct {\n\tUsername string\n\tPassword string\n}\n```\n\nUsernamePassword are the credentials for the username/password authentication method. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#socksUsernamePassword.Authenticate",
                    "documentation": {
                      "identifier": "socksUsernamePassword.Authenticate",
                      "newPage": false,
                      "searchKey": "http.socksUsernamePassword.Authenticate",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (up *socksUsernamePassword) Authenticate(ctx context.Context, rw io.ReadWriter, auth socksAuthMethod) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (up *socksUsernamePassword) Authenticate(ctx context.Context, rw io.ReadWriter, auth socksAuthMethod) error\n```\n\nAuthenticate authenticates a pair of username and password with the proxy server. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#statusError",
              "documentation": {
                "identifier": "statusError",
                "newPage": false,
                "searchKey": "http.statusError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type statusError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype statusError struct {\n\tcode int\n\ttext string\n}\n```\n\nstatusError is an error used to respond to a request with an HTTP status. The text should be plain text without user info or other embedded errors. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#statusError.Error",
                    "documentation": {
                      "identifier": "statusError.Error",
                      "newPage": false,
                      "searchKey": "http.statusError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e statusError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e statusError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#stringWriter",
              "documentation": {
                "identifier": "stringWriter",
                "newPage": false,
                "searchKey": "http.stringWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type stringWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stringWriter struct {\n\tw io.Writer\n}\n```\n\nstringWriter implements WriteString on a Writer. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#stringWriter.WriteString",
                    "documentation": {
                      "identifier": "stringWriter.WriteString",
                      "newPage": false,
                      "searchKey": "http.stringWriter.WriteString",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w stringWriter) WriteString(s string) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w stringWriter) WriteString(s string) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#tLogKey",
              "documentation": {
                "identifier": "tLogKey",
                "newPage": false,
                "searchKey": "http.tLogKey",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type tLogKey struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype tLogKey struct{}\n```\n\ntLogKey is a context WithValue key for test debugging contexts containing a t.Logf func. See export_test.go's Request.WithT method. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#textSig",
              "documentation": {
                "identifier": "textSig",
                "newPage": false,
                "searchKey": "http.textSig",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type textSig struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype textSig struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#textSig.match",
                    "documentation": {
                      "identifier": "textSig.match",
                      "newPage": false,
                      "searchKey": "http.textSig.match",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (textSig) match(data []byte, firstNonWS int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (textSig) match(data []byte, firstNonWS int) string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#timeoutHandler",
              "documentation": {
                "identifier": "timeoutHandler",
                "newPage": false,
                "searchKey": "http.timeoutHandler",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type timeoutHandler struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype timeoutHandler struct {\n\thandler Handler\n\tbody    string\n\tdt      time.Duration\n\n\t// When set, no context will be created and this context will\n\t// be used instead.\n\ttestContext context.Context\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#timeoutHandler.ServeHTTP",
                    "documentation": {
                      "identifier": "timeoutHandler.ServeHTTP",
                      "newPage": false,
                      "searchKey": "http.timeoutHandler.ServeHTTP",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *timeoutHandler) ServeHTTP(w ResponseWriter, r *Request)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *timeoutHandler) ServeHTTP(w ResponseWriter, r *Request)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#timeoutHandler.errorBody",
                    "documentation": {
                      "identifier": "timeoutHandler.errorBody",
                      "newPage": false,
                      "searchKey": "http.timeoutHandler.errorBody",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *timeoutHandler) errorBody() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *timeoutHandler) errorBody() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#timeoutWriter",
              "documentation": {
                "identifier": "timeoutWriter",
                "newPage": false,
                "searchKey": "http.timeoutWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type timeoutWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype timeoutWriter struct {\n\tw    ResponseWriter\n\th    Header\n\twbuf bytes.Buffer\n\treq  *Request\n\n\tmu          sync.Mutex\n\ttimedOut    bool\n\twroteHeader bool\n\tcode        int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#timeoutWriter.Header",
                    "documentation": {
                      "identifier": "timeoutWriter.Header",
                      "newPage": false,
                      "searchKey": "http.timeoutWriter.Header",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *timeoutWriter) Header() Header"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *timeoutWriter) Header() Header\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#timeoutWriter.Push",
                    "documentation": {
                      "identifier": "timeoutWriter.Push",
                      "newPage": false,
                      "searchKey": "http.timeoutWriter.Push",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *timeoutWriter) Push(target string, opts *PushOptions) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *timeoutWriter) Push(target string, opts *PushOptions) error\n```\n\nPush implements the Pusher interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#timeoutWriter.Write",
                    "documentation": {
                      "identifier": "timeoutWriter.Write",
                      "newPage": false,
                      "searchKey": "http.timeoutWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *timeoutWriter) Write(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *timeoutWriter) Write(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#timeoutWriter.WriteHeader",
                    "documentation": {
                      "identifier": "timeoutWriter.WriteHeader",
                      "newPage": false,
                      "searchKey": "http.timeoutWriter.WriteHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *timeoutWriter) WriteHeader(code int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *timeoutWriter) WriteHeader(code int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#timeoutWriter.writeHeaderLocked",
                    "documentation": {
                      "identifier": "timeoutWriter.writeHeaderLocked",
                      "newPage": false,
                      "searchKey": "http.timeoutWriter.writeHeaderLocked",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *timeoutWriter) writeHeaderLocked(code int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *timeoutWriter) writeHeaderLocked(code int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#tlsHandshakeTimeoutError",
              "documentation": {
                "identifier": "tlsHandshakeTimeoutError",
                "newPage": false,
                "searchKey": "http.tlsHandshakeTimeoutError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type tlsHandshakeTimeoutError struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype tlsHandshakeTimeoutError struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#tlsHandshakeTimeoutError.Error",
                    "documentation": {
                      "identifier": "tlsHandshakeTimeoutError.Error",
                      "newPage": false,
                      "searchKey": "http.tlsHandshakeTimeoutError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tlsHandshakeTimeoutError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tlsHandshakeTimeoutError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#tlsHandshakeTimeoutError.Temporary",
                    "documentation": {
                      "identifier": "tlsHandshakeTimeoutError.Temporary",
                      "newPage": false,
                      "searchKey": "http.tlsHandshakeTimeoutError.Temporary",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tlsHandshakeTimeoutError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tlsHandshakeTimeoutError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#tlsHandshakeTimeoutError.Timeout",
                    "documentation": {
                      "identifier": "tlsHandshakeTimeoutError.Timeout",
                      "newPage": false,
                      "searchKey": "http.tlsHandshakeTimeoutError.Timeout",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tlsHandshakeTimeoutError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tlsHandshakeTimeoutError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#transferReader",
              "documentation": {
                "identifier": "transferReader",
                "newPage": false,
                "searchKey": "http.transferReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type transferReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype transferReader struct {\n\t// Input\n\tHeader        Header\n\tStatusCode    int\n\tRequestMethod string\n\tProtoMajor    int\n\tProtoMinor    int\n\t// Output\n\tBody          io.ReadCloser\n\tContentLength int64\n\tChunked       bool\n\tClose         bool\n\tTrailer       Header\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#transferReader.parseTransferEncoding",
                    "documentation": {
                      "identifier": "transferReader.parseTransferEncoding",
                      "newPage": false,
                      "searchKey": "http.transferReader.parseTransferEncoding",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *transferReader) parseTransferEncoding() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *transferReader) parseTransferEncoding() error\n```\n\nparseTransferEncoding sets t.Chunked based on the Transfer-Encoding header. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#transferReader.protoAtLeast",
                    "documentation": {
                      "identifier": "transferReader.protoAtLeast",
                      "newPage": false,
                      "searchKey": "http.transferReader.protoAtLeast",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *transferReader) protoAtLeast(m, n int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *transferReader) protoAtLeast(m, n int) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#transferWriter",
              "documentation": {
                "identifier": "transferWriter",
                "newPage": false,
                "searchKey": "http.transferWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type transferWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype transferWriter struct {\n\tMethod           string\n\tBody             io.Reader\n\tBodyCloser       io.Closer\n\tResponseToHEAD   bool\n\tContentLength    int64 // -1 means unknown, 0 means exactly none\n\tClose            bool\n\tTransferEncoding []string\n\tHeader           Header\n\tTrailer          Header\n\tIsResponse       bool\n\tbodyReadError    error // any non-EOF error from reading Body\n\n\tFlushHeaders bool            // flush headers to network before body\n\tByteReadCh   chan readResult // non-nil if probeRequestBody called\n}\n```\n\ntransferWriter inspects the fields of a user-supplied Request or Response, sanitizes them without changing the user object and provides methods for writing the respective header, body and trailer in wire format. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#newTransferWriter",
                    "documentation": {
                      "identifier": "newTransferWriter",
                      "newPage": false,
                      "searchKey": "http.newTransferWriter",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newTransferWriter(r interface{}) (t *transferWriter, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newTransferWriter(r interface{}) (t *transferWriter, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#transferWriter.doBodyCopy",
                    "documentation": {
                      "identifier": "transferWriter.doBodyCopy",
                      "newPage": false,
                      "searchKey": "http.transferWriter.doBodyCopy",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *transferWriter) doBodyCopy(dst io.Writer, src io.Reader) (n int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *transferWriter) doBodyCopy(dst io.Writer, src io.Reader) (n int64, err error)\n```\n\ndoBodyCopy wraps a copy operation, with any resulting error also being saved in bodyReadError. \n\nThis function is only intended for use in writeBody. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#transferWriter.probeRequestBody",
                    "documentation": {
                      "identifier": "transferWriter.probeRequestBody",
                      "newPage": false,
                      "searchKey": "http.transferWriter.probeRequestBody",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *transferWriter) probeRequestBody()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *transferWriter) probeRequestBody()\n```\n\nprobeRequestBody reads a byte from t.Body to see whether it's empty (returns io.EOF right away). \n\nBut because we've had problems with this blocking users in the past (issue 17480) when the body is a pipe (perhaps waiting on the response headers before the pipe is fed data), we need to be careful and bound how long we wait for it. This delay will only affect users if all the following are true: \n\n```\n* the request body blocks\n* the content length is not set (or set to -1)\n* the method doesn't usually have a body (GET, HEAD, DELETE, ...)\n* there is no transfer-encoding=chunked already set.\n\n```\nIn other words, this delay will not normally affect anybody, and there are workarounds if it does. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#transferWriter.shouldSendChunkedRequestBody",
                    "documentation": {
                      "identifier": "transferWriter.shouldSendChunkedRequestBody",
                      "newPage": false,
                      "searchKey": "http.transferWriter.shouldSendChunkedRequestBody",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *transferWriter) shouldSendChunkedRequestBody() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *transferWriter) shouldSendChunkedRequestBody() bool\n```\n\nshouldSendChunkedRequestBody reports whether we should try to send a chunked request body to the server. In particular, the case we really want to prevent is sending a GET or other typically-bodyless request to a server with a chunked body when the body has zero bytes, since GETs with bodies (while acceptable according to specs), even zero-byte chunked bodies, are approximately never seen in the wild and confuse most servers. See Issue 18257, as one example. \n\nThe only reason we'd send such a request is if the user set the Body to a non-nil value (say, io.NopCloser(bytes.NewReader(nil))) and didn't set ContentLength, or NewRequest set it to -1 (unknown), so then we assume there's bytes to send. \n\nThis code tries to read a byte from the Request.Body in such cases to see whether the body actually has content (super rare) or is actually just a non-nil content-less ReadCloser (the more common case). In that more common case, we act as if their Body were nil instead, and don't send a body. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#transferWriter.shouldSendContentLength",
                    "documentation": {
                      "identifier": "transferWriter.shouldSendContentLength",
                      "newPage": false,
                      "searchKey": "http.transferWriter.shouldSendContentLength",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *transferWriter) shouldSendContentLength() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *transferWriter) shouldSendContentLength() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#transferWriter.unwrapBody",
                    "documentation": {
                      "identifier": "transferWriter.unwrapBody",
                      "newPage": false,
                      "searchKey": "http.transferWriter.unwrapBody",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *transferWriter) unwrapBody() io.Reader"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *transferWriter) unwrapBody() io.Reader\n```\n\nunwrapBodyReader unwraps the body's inner reader if it's a nopCloser. This is to ensure that body writes sourced from local files (*os.File types) are properly optimized. \n\nThis function is only intended for use in writeBody. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#transferWriter.writeBody",
                    "documentation": {
                      "identifier": "transferWriter.writeBody",
                      "newPage": false,
                      "searchKey": "http.transferWriter.writeBody",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *transferWriter) writeBody(w io.Writer) (err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *transferWriter) writeBody(w io.Writer) (err error)\n```\n\nalways closes t.BodyCloser \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#transferWriter.writeHeader",
                    "documentation": {
                      "identifier": "transferWriter.writeHeader",
                      "newPage": false,
                      "searchKey": "http.transferWriter.writeHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *transferWriter) writeHeader(w io.Writer, trace *httptrace.ClientTrace) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *transferWriter) writeHeader(w io.Writer, trace *httptrace.ClientTrace) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#transportReadFromServerError",
              "documentation": {
                "identifier": "transportReadFromServerError",
                "newPage": false,
                "searchKey": "http.transportReadFromServerError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type transportReadFromServerError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype transportReadFromServerError struct {\n\terr error\n}\n```\n\ntransportReadFromServerError is used by Transport.readLoop when the 1 byte peek read fails and we're actually anticipating a response. Usually this is just due to the inherent keep-alive shut down race, where the server closed the connection at the same time the client wrote. The underlying err field is usually io.EOF or some ECONNRESET sort of thing which varies by platform. But it might be the user's custom net.Conn.Read error too, so we carry it along for them to return from Transport.RoundTrip. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#transportReadFromServerError.Error",
                    "documentation": {
                      "identifier": "transportReadFromServerError.Error",
                      "newPage": false,
                      "searchKey": "http.transportReadFromServerError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e transportReadFromServerError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e transportReadFromServerError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#transportReadFromServerError.Unwrap",
                    "documentation": {
                      "identifier": "transportReadFromServerError.Unwrap",
                      "newPage": false,
                      "searchKey": "http.transportReadFromServerError.Unwrap",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e transportReadFromServerError) Unwrap() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e transportReadFromServerError) Unwrap() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#transportRequest",
              "documentation": {
                "identifier": "transportRequest",
                "newPage": false,
                "searchKey": "http.transportRequest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type transportRequest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype transportRequest struct {\n\t*Request                         // original request, not to be mutated\n\textra     Header                 // extra headers to write, or nil\n\ttrace     *httptrace.ClientTrace // optional\n\tcancelKey cancelKey\n\n\tmu  sync.Mutex // guards err\n\terr error      // first setError value for mapRoundTripError to consider\n}\n```\n\ntransportRequest is a wrapper around a *Request that adds optional extra headers to write and stores any error to return from roundTrip. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#transportRequest.extraHeaders",
                    "documentation": {
                      "identifier": "transportRequest.extraHeaders",
                      "newPage": false,
                      "searchKey": "http.transportRequest.extraHeaders",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *transportRequest) extraHeaders() Header"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *transportRequest) extraHeaders() Header\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#transportRequest.logf",
                    "documentation": {
                      "identifier": "transportRequest.logf",
                      "newPage": false,
                      "searchKey": "http.transportRequest.logf",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *transportRequest) logf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *transportRequest) logf(format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#transportRequest.setError",
                    "documentation": {
                      "identifier": "transportRequest.setError",
                      "newPage": false,
                      "searchKey": "http.transportRequest.setError",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *transportRequest) setError(err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *transportRequest) setError(err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#unsupportedTEError",
              "documentation": {
                "identifier": "unsupportedTEError",
                "newPage": false,
                "searchKey": "http.unsupportedTEError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type unsupportedTEError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype unsupportedTEError struct {\n\terr string\n}\n```\n\nunsupportedTEError reports unsupported transfer-encodings. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#unsupportedTEError.Error",
                    "documentation": {
                      "identifier": "unsupportedTEError.Error",
                      "newPage": false,
                      "searchKey": "http.unsupportedTEError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (uste *unsupportedTEError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (uste *unsupportedTEError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#wantConn",
              "documentation": {
                "identifier": "wantConn",
                "newPage": false,
                "searchKey": "http.wantConn",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type wantConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype wantConn struct {\n\tcm    connectMethod\n\tkey   connectMethodKey // cm.key()\n\tctx   context.Context  // context for dial\n\tready chan struct{}    // closed when pc, err pair is delivered\n\n\t// hooks for testing to know when dials are done\n\t// beforeDial is called in the getConn goroutine when the dial is queued.\n\t// afterDial is called when the dial is completed or canceled.\n\tbeforeDial func()\n\tafterDial  func()\n\n\tmu  sync.Mutex // protects pc, err, close(ready)\n\tpc  *persistConn\n\terr error\n}\n```\n\nA wantConn records state about a wanted connection (that is, an active call to getConn). The conn may be gotten by dialing or by finding an idle connection, or a cancellation may make the conn no longer wanted. These three options are racing against each other and use wantConn to coordinate and agree about the winning outcome. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#wantConn.cancel",
                    "documentation": {
                      "identifier": "wantConn.cancel",
                      "newPage": false,
                      "searchKey": "http.wantConn.cancel",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *wantConn) cancel(t *Transport, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *wantConn) cancel(t *Transport, err error)\n```\n\ncancel marks w as no longer wanting a result (for example, due to cancellation). If a connection has been delivered already, cancel returns it with t.putOrCloseIdleConn. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#wantConn.tryDeliver",
                    "documentation": {
                      "identifier": "wantConn.tryDeliver",
                      "newPage": false,
                      "searchKey": "http.wantConn.tryDeliver",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *wantConn) tryDeliver(pc *persistConn, err error) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *wantConn) tryDeliver(pc *persistConn, err error) bool\n```\n\ntryDeliver attempts to deliver pc, err to w and reports whether it succeeded. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#wantConn.waiting",
                    "documentation": {
                      "identifier": "wantConn.waiting",
                      "newPage": false,
                      "searchKey": "http.wantConn.waiting",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *wantConn) waiting() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *wantConn) waiting() bool\n```\n\nwaiting reports whether w is still waiting for an answer (connection or error). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#wantConnQueue",
              "documentation": {
                "identifier": "wantConnQueue",
                "newPage": false,
                "searchKey": "http.wantConnQueue",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type wantConnQueue struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype wantConnQueue struct {\n\t// This is a queue, not a deque.\n\t// It is split into two stages - head[headPos:] and tail.\n\t// popFront is trivial (headPos++) on the first stage, and\n\t// pushBack is trivial (append) on the second stage.\n\t// If the first stage is empty, popFront can swap the\n\t// first and second stages to remedy the situation.\n\t//\n\t// This two-stage split is analogous to the use of two lists\n\t// in Okasaki's purely functional queue but without the\n\t// overhead of reversing the list when swapping stages.\n\thead    []*wantConn\n\theadPos int\n\ttail    []*wantConn\n}\n```\n\nA wantConnQueue is a queue of wantConns. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#wantConnQueue.cleanFront",
                    "documentation": {
                      "identifier": "wantConnQueue.cleanFront",
                      "newPage": false,
                      "searchKey": "http.wantConnQueue.cleanFront",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *wantConnQueue) cleanFront() (cleaned bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *wantConnQueue) cleanFront() (cleaned bool)\n```\n\ncleanFront pops any wantConns that are no longer waiting from the head of the queue, reporting whether any were popped. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#wantConnQueue.len",
                    "documentation": {
                      "identifier": "wantConnQueue.len",
                      "newPage": false,
                      "searchKey": "http.wantConnQueue.len",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *wantConnQueue) len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *wantConnQueue) len() int\n```\n\nlen returns the number of items in the queue. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#wantConnQueue.peekFront",
                    "documentation": {
                      "identifier": "wantConnQueue.peekFront",
                      "newPage": false,
                      "searchKey": "http.wantConnQueue.peekFront",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *wantConnQueue) peekFront() *wantConn"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *wantConnQueue) peekFront() *wantConn\n```\n\npeekFront returns the wantConn at the front of the queue without removing it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#wantConnQueue.popFront",
                    "documentation": {
                      "identifier": "wantConnQueue.popFront",
                      "newPage": false,
                      "searchKey": "http.wantConnQueue.popFront",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *wantConnQueue) popFront() *wantConn"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *wantConnQueue) popFront() *wantConn\n```\n\npopFront removes and returns the wantConn at the front of the queue. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/net/http#wantConnQueue.pushBack",
                    "documentation": {
                      "identifier": "wantConnQueue.pushBack",
                      "newPage": false,
                      "searchKey": "http.wantConnQueue.pushBack",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *wantConnQueue) pushBack(w *wantConn)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *wantConnQueue) pushBack(w *wantConn)\n```\n\npushBack adds w to the back of the queue. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#writeRequest",
              "documentation": {
                "identifier": "writeRequest",
                "newPage": false,
                "searchKey": "http.writeRequest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type writeRequest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype writeRequest struct {\n\treq *transportRequest\n\tch  chan<- error\n\n\t// Optional blocking chan for Expect: 100-continue (for receive).\n\t// If not nil, writeLoop blocks sending request body until\n\t// it receives from this chan.\n\tcontinueCh <-chan struct{}\n}\n```\n\nA writeRequest is sent by the readLoop's goroutine to the writeLoop's goroutine to write a request while the read loop concurrently waits on both the write response and the server's reply. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#writerFunc",
              "documentation": {
                "identifier": "writerFunc",
                "newPage": false,
                "searchKey": "http.writerFunc",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type writerFunc func([]byte) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype writerFunc func([]byte) (int, error)\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/net/http#writerFunc.Write",
                    "documentation": {
                      "identifier": "writerFunc.Write",
                      "newPage": false,
                      "searchKey": "http.writerFunc.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f writerFunc) Write(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f writerFunc) Write(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/net/http#writerOnly",
              "documentation": {
                "identifier": "writerOnly",
                "newPage": false,
                "searchKey": "http.writerOnly",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type writerOnly struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype writerOnly struct {\n\tio.Writer\n}\n```\n\nwriterOnly hides an io.Writer value's optional ReadFrom method from io.Copy. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/net/http#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/net/http#BenchmarkCookieString",
              "documentation": {
                "identifier": "BenchmarkCookieString",
                "newPage": false,
                "searchKey": "http.BenchmarkCookieString",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkCookieString(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkCookieString(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#BenchmarkCopyValues",
              "documentation": {
                "identifier": "BenchmarkCopyValues",
                "newPage": false,
                "searchKey": "http.BenchmarkCopyValues",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkCopyValues(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkCopyValues(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#BenchmarkHeaderWriteSubset",
              "documentation": {
                "identifier": "BenchmarkHeaderWriteSubset",
                "newPage": false,
                "searchKey": "http.BenchmarkHeaderWriteSubset",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkHeaderWriteSubset(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkHeaderWriteSubset(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#BenchmarkReadCookies",
              "documentation": {
                "identifier": "BenchmarkReadCookies",
                "newPage": false,
                "searchKey": "http.BenchmarkReadCookies",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkReadCookies(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkReadCookies(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#BenchmarkReadSetCookies",
              "documentation": {
                "identifier": "BenchmarkReadSetCookies",
                "newPage": false,
                "searchKey": "http.BenchmarkReadSetCookies",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkReadSetCookies(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkReadSetCookies(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#BenchmarkServerMatch",
              "documentation": {
                "identifier": "BenchmarkServerMatch",
                "newPage": false,
                "searchKey": "http.BenchmarkServerMatch",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkServerMatch(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkServerMatch(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#CanonicalHeaderKey",
              "documentation": {
                "identifier": "CanonicalHeaderKey",
                "newPage": false,
                "searchKey": "http.CanonicalHeaderKey",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func CanonicalHeaderKey(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc CanonicalHeaderKey(s string) string\n```\n\nCanonicalHeaderKey returns the canonical format of the header key s. The canonicalization converts the first letter and any letter following a hyphen to upper case; the rest are converted to lowercase. For example, the canonical key for \"accept-encoding\" is \"Accept-Encoding\". If s contains a space or invalid header field bytes, it is returned without modifications. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#CondSkipHTTP2",
              "documentation": {
                "identifier": "CondSkipHTTP2",
                "newPage": false,
                "searchKey": "http.CondSkipHTTP2",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func CondSkipHTTP2(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc CondSkipHTTP2(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#DetectContentType",
              "documentation": {
                "identifier": "DetectContentType",
                "newPage": false,
                "searchKey": "http.DetectContentType",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func DetectContentType(data []byte) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc DetectContentType(data []byte) string\n```\n\nDetectContentType implements the algorithm described at [https://mimesniff.spec.whatwg.org/](https://mimesniff.spec.whatwg.org/) to determine the Content-Type of the given data. It considers at most the first 512 bytes of data. DetectContentType always returns a valid MIME type: if it cannot determine a more specific one, it returns \"application/octet-stream\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#Error",
              "documentation": {
                "identifier": "Error",
                "newPage": false,
                "searchKey": "http.Error",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Error(w ResponseWriter, error string, code int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Error(w ResponseWriter, error string, code int)\n```\n\nError replies to the request with the specified error message and HTTP code. It does not otherwise end the request; the caller should ensure no further writes are done to w. The error message should be plain text. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportCloseTransportConnsAbruptly",
              "documentation": {
                "identifier": "ExportCloseTransportConnsAbruptly",
                "newPage": false,
                "searchKey": "http.ExportCloseTransportConnsAbruptly",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ExportCloseTransportConnsAbruptly(tr *Transport)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ExportCloseTransportConnsAbruptly(tr *Transport)\n```\n\nExportCloseTransportConnsAbruptly closes all idle connections from tr in an abrupt way, just reaching into the underlying Conns and closing them, without telling the Transport or its persistConns that it's doing so. This is to simulate the server closing connections on the Transport. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportHttp2ConfigureTransport",
              "documentation": {
                "identifier": "ExportHttp2ConfigureTransport",
                "newPage": false,
                "searchKey": "http.ExportHttp2ConfigureTransport",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ExportHttp2ConfigureTransport(t *Transport) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ExportHttp2ConfigureTransport(t *Transport) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ExportSetH2GoawayTimeout",
              "documentation": {
                "identifier": "ExportSetH2GoawayTimeout",
                "newPage": false,
                "searchKey": "http.ExportSetH2GoawayTimeout",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ExportSetH2GoawayTimeout(d time.Duration) (restore func())"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ExportSetH2GoawayTimeout(d time.Duration) (restore func())\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#Handle",
              "documentation": {
                "identifier": "Handle",
                "newPage": false,
                "searchKey": "http.Handle",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Handle(pattern string, handler Handler)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Handle(pattern string, handler Handler)\n```\n\nHandle registers the handler for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#HandleFunc",
              "documentation": {
                "identifier": "HandleFunc",
                "newPage": false,
                "searchKey": "http.HandleFunc",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func HandleFunc(pattern string, handler func(ResponseWriter, *Request))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request))\n```\n\nHandleFunc registers the handler function for the given pattern in the DefaultServeMux. The documentation for ServeMux explains how patterns are matched. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ListenAndServe",
              "documentation": {
                "identifier": "ListenAndServe",
                "newPage": false,
                "searchKey": "http.ListenAndServe",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ListenAndServe(addr string, handler Handler) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ListenAndServe(addr string, handler Handler) error\n```\n\nListenAndServe listens on the TCP network address addr and then calls Serve with handler to handle requests on incoming connections. Accepted connections are configured to enable TCP keep-alives. \n\nThe handler is typically nil, in which case the DefaultServeMux is used. \n\nListenAndServe always returns a non-nil error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ListenAndServeTLS",
              "documentation": {
                "identifier": "ListenAndServeTLS",
                "newPage": false,
                "searchKey": "http.ListenAndServeTLS",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error\n```\n\nListenAndServeTLS acts identically to ListenAndServe, except that it expects HTTPS connections. Additionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#MaxBytesReader",
              "documentation": {
                "identifier": "MaxBytesReader",
                "newPage": false,
                "searchKey": "http.MaxBytesReader",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser\n```\n\nMaxBytesReader is similar to io.LimitReader but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-EOF error for a Read beyond the limit, and closes the underlying reader when its Close method is called. \n\nMaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#NotFound",
              "documentation": {
                "identifier": "NotFound",
                "newPage": false,
                "searchKey": "http.NotFound",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func NotFound(w ResponseWriter, r *Request)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc NotFound(w ResponseWriter, r *Request)\n```\n\nNotFound replies to the request with an HTTP 404 not found error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ParseHTTPVersion",
              "documentation": {
                "identifier": "ParseHTTPVersion",
                "newPage": false,
                "searchKey": "http.ParseHTTPVersion",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ParseHTTPVersion(vers string) (major, minor int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ParseHTTPVersion(vers string) (major, minor int, ok bool)\n```\n\nParseHTTPVersion parses an HTTP version string. \"HTTP/1.0\" returns (1, 0, true). Note that strings without a minor version, such as \"HTTP/2\", are not valid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ParseTime",
              "documentation": {
                "identifier": "ParseTime",
                "newPage": false,
                "searchKey": "http.ParseTime",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ParseTime(text string) (t time.Time, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ParseTime(text string) (t time.Time, err error)\n```\n\nParseTime parses a time header (such as the Date: header), trying each of the three formats allowed by HTTP/1.1: TimeFormat, time.RFC850, and time.ANSIC. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ProxyFromEnvironment",
              "documentation": {
                "identifier": "ProxyFromEnvironment",
                "newPage": false,
                "searchKey": "http.ProxyFromEnvironment",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ProxyFromEnvironment(req *Request) (*url.URL, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ProxyFromEnvironment(req *Request) (*url.URL, error)\n```\n\nProxyFromEnvironment returns the URL of the proxy to use for a given request, as indicated by the environment variables HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions thereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https requests. \n\nThe environment values may be either a complete URL or a \"host[:port]\", in which case the \"http\" scheme is assumed. An error is returned if the value is a different form. \n\nA nil URL and nil error are returned if no proxy is defined in the environment, or a proxy should not be used for the given request, as defined by NO_PROXY. \n\nAs a special case, if req.URL.Host is \"localhost\" (with or without a port number), then a nil URL and nil error will be returned. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ProxyURL",
              "documentation": {
                "identifier": "ProxyURL",
                "newPage": false,
                "searchKey": "http.ProxyURL",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)\n```\n\nProxyURL returns a proxy function (for use in a Transport) that always returns the same URL. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#Redirect",
              "documentation": {
                "identifier": "Redirect",
                "newPage": false,
                "searchKey": "http.Redirect",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Redirect(w ResponseWriter, r *Request, url string, code int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Redirect(w ResponseWriter, r *Request, url string, code int)\n```\n\nRedirect replies to the request with a redirect to url, which may be a path relative to the request path. \n\nThe provided code should be in the 3xx range and is usually StatusMovedPermanently, StatusFound or StatusSeeOther. \n\nIf the Content-Type header has not been set, Redirect sets it to \"text/html; charset=utf-8\" and writes a small HTML body. Setting the Content-Type header to any value, including nil, disables that behavior. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ResetCachedEnvironment",
              "documentation": {
                "identifier": "ResetCachedEnvironment",
                "newPage": false,
                "searchKey": "http.ResetCachedEnvironment",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ResetCachedEnvironment()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ResetCachedEnvironment()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ResetProxyEnv",
              "documentation": {
                "identifier": "ResetProxyEnv",
                "newPage": false,
                "searchKey": "http.ResetProxyEnv",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ResetProxyEnv()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ResetProxyEnv()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#Serve",
              "documentation": {
                "identifier": "Serve",
                "newPage": false,
                "searchKey": "http.Serve",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Serve(l net.Listener, handler Handler) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Serve(l net.Listener, handler Handler) error\n```\n\nServe accepts incoming HTTP connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them. \n\nThe handler is typically nil, in which case the DefaultServeMux is used. \n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn connections and they were configured with \"h2\" in the TLS Config.NextProtos. \n\nServe always returns a non-nil error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ServeContent",
              "documentation": {
                "identifier": "ServeContent",
                "newPage": false,
                "searchKey": "http.ServeContent",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)\n```\n\nServeContent replies to the request using the content in the provided ReadSeeker. The main benefit of ServeContent over io.Copy is that it handles Range requests properly, sets the MIME type, and handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since, and If-Range requests. \n\nIf the response's Content-Type header is not set, ServeContent first tries to deduce the type from name's file extension and, if that fails, falls back to reading the first block of the content and passing it to DetectContentType. The name is otherwise unused; in particular it can be empty and is never sent in the response. \n\nIf modtime is not the zero time or Unix epoch, ServeContent includes it in a Last-Modified header in the response. If the request includes an If-Modified-Since header, ServeContent uses modtime to decide whether the content needs to be sent at all. \n\nThe content's Seek method must work: ServeContent uses a seek to the end of the content to determine its size. \n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3, ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range. \n\nNote that *os.File implements the io.ReadSeeker interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ServeFile",
              "documentation": {
                "identifier": "ServeFile",
                "newPage": false,
                "searchKey": "http.ServeFile",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ServeFile(w ResponseWriter, r *Request, name string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ServeFile(w ResponseWriter, r *Request, name string)\n```\n\nServeFile replies to the request with the contents of the named file or directory. \n\nIf the provided file or directory name is a relative path, it is interpreted relative to the current directory and may ascend to parent directories. If the provided name is constructed from user input, it should be sanitized before calling ServeFile. \n\nAs a precaution, ServeFile will reject requests where r.URL.Path contains a \"..\" path element; this protects against callers who might unsafely use filepath.Join on r.URL.Path without sanitizing it and then use that filepath.Join result as the name argument. \n\nAs another special case, ServeFile redirects any request where r.URL.Path ends in \"/index.html\" to the same path, without the final \"index.html\". To avoid such redirects either modify the path or use ServeContent. \n\nOutside of those two special cases, ServeFile does not use r.URL.Path for selecting the file or directory to serve; only the file or directory provided in the name argument is used. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#ServeTLS",
              "documentation": {
                "identifier": "ServeTLS",
                "newPage": false,
                "searchKey": "http.ServeTLS",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error\n```\n\nServeTLS accepts incoming HTTPS connections on the listener l, creating a new service goroutine for each. The service goroutines read requests and then call handler to reply to them. \n\nThe handler is typically nil, in which case the DefaultServeMux is used. \n\nAdditionally, files containing a certificate and matching private key for the server must be provided. If the certificate is signed by a certificate authority, the certFile should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. \n\nServeTLS always returns a non-nil error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#SetCookie",
              "documentation": {
                "identifier": "SetCookie",
                "newPage": false,
                "searchKey": "http.SetCookie",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetCookie(w ResponseWriter, cookie *Cookie)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetCookie(w ResponseWriter, cookie *Cookie)\n```\n\nSetCookie adds a Set-Cookie header to the provided ResponseWriter's headers. The provided cookie must have a valid Name. Invalid cookies may be silently dropped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#SetPendingDialHooks",
              "documentation": {
                "identifier": "SetPendingDialHooks",
                "newPage": false,
                "searchKey": "http.SetPendingDialHooks",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetPendingDialHooks(before, after func())"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetPendingDialHooks(before, after func())\n```\n\nSetPendingDialHooks sets the hooks that run before and after handling pending dials. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#SetReadLoopBeforeNextReadHook",
              "documentation": {
                "identifier": "SetReadLoopBeforeNextReadHook",
                "newPage": false,
                "searchKey": "http.SetReadLoopBeforeNextReadHook",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetReadLoopBeforeNextReadHook(f func())"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetReadLoopBeforeNextReadHook(f func())\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#SetTestHookServerServe",
              "documentation": {
                "identifier": "SetTestHookServerServe",
                "newPage": false,
                "searchKey": "http.SetTestHookServerServe",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetTestHookServerServe(fn func(*Server, net.Listener))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetTestHookServerServe(fn func(*Server, net.Listener))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#StatusText",
              "documentation": {
                "identifier": "StatusText",
                "newPage": false,
                "searchKey": "http.StatusText",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func StatusText(code int) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc StatusText(code int) string\n```\n\nStatusText returns a text for the HTTP status code. It returns the empty string if the code is unknown. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestAddCookie",
              "documentation": {
                "identifier": "TestAddCookie",
                "newPage": false,
                "searchKey": "http.TestAddCookie",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAddCookie(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAddCookie(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestBodyReadBadTrailer",
              "documentation": {
                "identifier": "TestBodyReadBadTrailer",
                "newPage": false,
                "searchKey": "http.TestBodyReadBadTrailer",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBodyReadBadTrailer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBodyReadBadTrailer(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestCacheKeys",
              "documentation": {
                "identifier": "TestCacheKeys",
                "newPage": false,
                "searchKey": "http.TestCacheKeys",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCacheKeys(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCacheKeys(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestCleanHost",
              "documentation": {
                "identifier": "TestCleanHost",
                "newPage": false,
                "searchKey": "http.TestCleanHost",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCleanHost(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCleanHost(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestCloneOrMakeHeader",
              "documentation": {
                "identifier": "TestCloneOrMakeHeader",
                "newPage": false,
                "searchKey": "http.TestCloneOrMakeHeader",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloneOrMakeHeader(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloneOrMakeHeader(t *testing.T)\n```\n\nIssue 34878: test that every call to cloneOrMakeHeader never returns a nil Header. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestCmdGoNoHTTPServer",
              "documentation": {
                "identifier": "TestCmdGoNoHTTPServer",
                "newPage": false,
                "searchKey": "http.TestCmdGoNoHTTPServer",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCmdGoNoHTTPServer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCmdGoNoHTTPServer(t *testing.T)\n```\n\nTest that cmd/go doesn't link in the HTTP server. \n\nThis catches accidental dependencies between the HTTP transport and server code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestCookieSanitizePath",
              "documentation": {
                "identifier": "TestCookieSanitizePath",
                "newPage": false,
                "searchKey": "http.TestCookieSanitizePath",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCookieSanitizePath(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCookieSanitizePath(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestCookieSanitizeValue",
              "documentation": {
                "identifier": "TestCookieSanitizeValue",
                "newPage": false,
                "searchKey": "http.TestCookieSanitizeValue",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCookieSanitizeValue(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCookieSanitizeValue(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestDetectInMemoryReaders",
              "documentation": {
                "identifier": "TestDetectInMemoryReaders",
                "newPage": false,
                "searchKey": "http.TestDetectInMemoryReaders",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDetectInMemoryReaders(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDetectInMemoryReaders(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestFileTransport",
              "documentation": {
                "identifier": "TestFileTransport",
                "newPage": false,
                "searchKey": "http.TestFileTransport",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFileTransport(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFileTransport(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestFinalChunkedBodyReadEOF",
              "documentation": {
                "identifier": "TestFinalChunkedBodyReadEOF",
                "newPage": false,
                "searchKey": "http.TestFinalChunkedBodyReadEOF",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFinalChunkedBodyReadEOF(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFinalChunkedBodyReadEOF(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestForeachHeaderElement",
              "documentation": {
                "identifier": "TestForeachHeaderElement",
                "newPage": false,
                "searchKey": "http.TestForeachHeaderElement",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestForeachHeaderElement(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestForeachHeaderElement(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestHasToken",
              "documentation": {
                "identifier": "TestHasToken",
                "newPage": false,
                "searchKey": "http.TestHasToken",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHasToken(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHasToken(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestHeaderWrite",
              "documentation": {
                "identifier": "TestHeaderWrite",
                "newPage": false,
                "searchKey": "http.TestHeaderWrite",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHeaderWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHeaderWrite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestHeaderWriteSubsetAllocs",
              "documentation": {
                "identifier": "TestHeaderWriteSubsetAllocs",
                "newPage": false,
                "searchKey": "http.TestHeaderWriteSubsetAllocs",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHeaderWriteSubsetAllocs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHeaderWriteSubsetAllocs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestLocationResponse",
              "documentation": {
                "identifier": "TestLocationResponse",
                "newPage": false,
                "searchKey": "http.TestLocationResponse",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLocationResponse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLocationResponse(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestNeedsSniff",
              "documentation": {
                "identifier": "TestNeedsSniff",
                "newPage": false,
                "searchKey": "http.TestNeedsSniff",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNeedsSniff(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNeedsSniff(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestNilHeaderClone",
              "documentation": {
                "identifier": "TestNilHeaderClone",
                "newPage": false,
                "searchKey": "http.TestNilHeaderClone",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNilHeaderClone(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNilHeaderClone(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestNoUnicodeStrings",
              "documentation": {
                "identifier": "TestNoUnicodeStrings",
                "newPage": false,
                "searchKey": "http.TestNoUnicodeStrings",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNoUnicodeStrings(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNoUnicodeStrings(t *testing.T)\n```\n\nTestNoUnicodeStrings checks that nothing in net/http uses the Unicode-aware strings and bytes package functions. HTTP is mostly ASCII based, and doing Unicode-aware case folding or space stripping can introduce vulnerabilities. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestOmitHTTP2",
              "documentation": {
                "identifier": "TestOmitHTTP2",
                "newPage": false,
                "searchKey": "http.TestOmitHTTP2",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestOmitHTTP2(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestOmitHTTP2(t *testing.T)\n```\n\nTests that the nethttpomithttp2 build tag doesn't rot too much, even if there's not a regular builder on it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestOmitHTTP2Vet",
              "documentation": {
                "identifier": "TestOmitHTTP2Vet",
                "newPage": false,
                "searchKey": "http.TestOmitHTTP2Vet",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestOmitHTTP2Vet(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestOmitHTTP2Vet(t *testing.T)\n```\n\nTests that the nethttpomithttp2 build tag at least type checks in short mode. The TestOmitHTTP2 test above actually runs tests (in long mode). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestParseContentLength",
              "documentation": {
                "identifier": "TestParseContentLength",
                "newPage": false,
                "searchKey": "http.TestParseContentLength",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseContentLength(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseContentLength(t *testing.T)\n```\n\nissue 39017 - disallow Content-Length values such as \"+3\" \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestParseRange",
              "documentation": {
                "identifier": "TestParseRange",
                "newPage": false,
                "searchKey": "http.TestParseRange",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseRange(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseRange(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestParseTime",
              "documentation": {
                "identifier": "TestParseTime",
                "newPage": false,
                "searchKey": "http.TestParseTime",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseTime(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseTime(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestParseTransferEncoding",
              "documentation": {
                "identifier": "TestParseTransferEncoding",
                "newPage": false,
                "searchKey": "http.TestParseTransferEncoding",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseTransferEncoding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseTransferEncoding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestReadCookies",
              "documentation": {
                "identifier": "TestReadCookies",
                "newPage": false,
                "searchKey": "http.TestReadCookies",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadCookies(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadCookies(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestReadRequest",
              "documentation": {
                "identifier": "TestReadRequest",
                "newPage": false,
                "searchKey": "http.TestReadRequest",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadRequest(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadRequest(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestReadRequest_Bad",
              "documentation": {
                "identifier": "TestReadRequest_Bad",
                "newPage": false,
                "searchKey": "http.TestReadRequest_Bad",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadRequest_Bad(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadRequest_Bad(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestReadResponse",
              "documentation": {
                "identifier": "TestReadResponse",
                "newPage": false,
                "searchKey": "http.TestReadResponse",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadResponse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadResponse(t *testing.T)\n```\n\ntests successful calls to ReadResponse, and inspects the returned Response. For error cases, see TestReadResponseErrors below. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestReadResponseCloseInMiddle",
              "documentation": {
                "identifier": "TestReadResponseCloseInMiddle",
                "newPage": false,
                "searchKey": "http.TestReadResponseCloseInMiddle",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadResponseCloseInMiddle(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadResponseCloseInMiddle(t *testing.T)\n```\n\nTestReadResponseCloseInMiddle tests that closing a body after reading only part of its contents advances the read to the end of the request, right up until the next request. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestReadResponseErrors",
              "documentation": {
                "identifier": "TestReadResponseErrors",
                "newPage": false,
                "searchKey": "http.TestReadResponseErrors",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadResponseErrors(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadResponseErrors(t *testing.T)\n```\n\nTest various ReadResponse error cases. (also tests success cases, but mostly it's about errors).  This does not test anything involving the bodies. Only the return value from ReadResponse itself. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestReadSetCookies",
              "documentation": {
                "identifier": "TestReadSetCookies",
                "newPage": false,
                "searchKey": "http.TestReadSetCookies",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadSetCookies(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadSetCookies(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestRequestWrite",
              "documentation": {
                "identifier": "TestRequestWrite",
                "newPage": false,
                "searchKey": "http.TestRequestWrite",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRequestWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRequestWrite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestRequestWriteClosesBody",
              "documentation": {
                "identifier": "TestRequestWriteClosesBody",
                "newPage": false,
                "searchKey": "http.TestRequestWriteClosesBody",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRequestWriteClosesBody(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRequestWriteClosesBody(t *testing.T)\n```\n\nTestRequestWriteClosesBody tests that Request.Write closes its request.Body. It also indirectly tests NewRequest and that it doesn't wrap an existing Closer inside a NopCloser, and that it serializes it correctly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestRequestWriteError",
              "documentation": {
                "identifier": "TestRequestWriteError",
                "newPage": false,
                "searchKey": "http.TestRequestWriteError",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRequestWriteError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRequestWriteError(t *testing.T)\n```\n\nTestRequestWriteError tests the Write err != nil checks in (*Request).write. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestRequestWriteTransport",
              "documentation": {
                "identifier": "TestRequestWriteTransport",
                "newPage": false,
                "searchKey": "http.TestRequestWriteTransport",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRequestWriteTransport(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRequestWriteTransport(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestResponseContentLengthShortBody",
              "documentation": {
                "identifier": "TestResponseContentLengthShortBody",
                "newPage": false,
                "searchKey": "http.TestResponseContentLengthShortBody",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResponseContentLengthShortBody(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResponseContentLengthShortBody(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestResponseStatusStutter",
              "documentation": {
                "identifier": "TestResponseStatusStutter",
                "newPage": false,
                "searchKey": "http.TestResponseStatusStutter",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResponseStatusStutter(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResponseStatusStutter(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestResponseWrite",
              "documentation": {
                "identifier": "TestResponseWrite",
                "newPage": false,
                "searchKey": "http.TestResponseWrite",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResponseWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResponseWrite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestResponseWritesOnlySingleConnectionClose",
              "documentation": {
                "identifier": "TestResponseWritesOnlySingleConnectionClose",
                "newPage": false,
                "searchKey": "http.TestResponseWritesOnlySingleConnectionClose",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResponseWritesOnlySingleConnectionClose(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResponseWritesOnlySingleConnectionClose(t *testing.T)\n```\n\nA response should only write out single Connection: close header. Tests #19499. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestSetCookie",
              "documentation": {
                "identifier": "TestSetCookie",
                "newPage": false,
                "searchKey": "http.TestSetCookie",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSetCookie(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSetCookie(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestSetCookieDoubleQuotes",
              "documentation": {
                "identifier": "TestSetCookieDoubleQuotes",
                "newPage": false,
                "searchKey": "http.TestSetCookieDoubleQuotes",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSetCookieDoubleQuotes(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSetCookieDoubleQuotes(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestTransferWriterWriteBodyReaderTypes",
              "documentation": {
                "identifier": "TestTransferWriterWriteBodyReaderTypes",
                "newPage": false,
                "searchKey": "http.TestTransferWriterWriteBodyReaderTypes",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTransferWriterWriteBodyReaderTypes(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTransferWriterWriteBodyReaderTypes(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestTransportBodyAltRewind",
              "documentation": {
                "identifier": "TestTransportBodyAltRewind",
                "newPage": false,
                "searchKey": "http.TestTransportBodyAltRewind",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTransportBodyAltRewind(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTransportBodyAltRewind(t *testing.T)\n```\n\nIssue 25009 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestTransportPersistConnReadLoopEOF",
              "documentation": {
                "identifier": "TestTransportPersistConnReadLoopEOF",
                "newPage": false,
                "searchKey": "http.TestTransportPersistConnReadLoopEOF",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTransportPersistConnReadLoopEOF(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTransportPersistConnReadLoopEOF(t *testing.T)\n```\n\nIssue 15446: incorrect wrapping of errors when server closes an idle connection. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestTransportShouldRetryRequest",
              "documentation": {
                "identifier": "TestTransportShouldRetryRequest",
                "newPage": false,
                "searchKey": "http.TestTransportShouldRetryRequest",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTransportShouldRetryRequest(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTransportShouldRetryRequest(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestWriteResponse",
              "documentation": {
                "identifier": "TestWriteResponse",
                "newPage": false,
                "searchKey": "http.TestWriteResponse",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriteResponse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriteResponse(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#TestWriteSetCookies",
              "documentation": {
                "identifier": "TestWriteSetCookies",
                "newPage": false,
                "searchKey": "http.TestWriteSetCookies",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriteSetCookies(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriteSetCookies(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#alwaysFalse",
              "documentation": {
                "identifier": "alwaysFalse",
                "newPage": false,
                "searchKey": "http.alwaysFalse",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func alwaysFalse() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc alwaysFalse() bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#appendSorted",
              "documentation": {
                "identifier": "appendSorted",
                "newPage": false,
                "searchKey": "http.appendSorted",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendSorted(es []muxEntry, e muxEntry) []muxEntry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendSorted(es []muxEntry, e muxEntry) []muxEntry\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#appendTime",
              "documentation": {
                "identifier": "appendTime",
                "newPage": false,
                "searchKey": "http.appendTime",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendTime(b []byte, t time.Time) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendTime(b []byte, t time.Time) []byte\n```\n\nappendTime is a non-allocating version of []byte(t.UTC().Format(TimeFormat)) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#badRequestError",
              "documentation": {
                "identifier": "badRequestError",
                "newPage": false,
                "searchKey": "http.badRequestError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func badRequestError(e string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badRequestError(e string) error\n```\n\nbadRequestError is a literal string (used by in the server in HTML, unescaped) to tell the user why their request was bad. It should be plain text without user info or other embedded errors. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#badStringError",
              "documentation": {
                "identifier": "badStringError",
                "newPage": false,
                "searchKey": "http.badStringError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func badStringError(what, val string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badStringError(what, val string) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#basicAuth",
              "documentation": {
                "identifier": "basicAuth",
                "newPage": false,
                "searchKey": "http.basicAuth",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func basicAuth(username, password string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc basicAuth(username, password string) string\n```\n\nSee 2 (end of page 4) [https://www.ietf.org/rfc/rfc2617.txt](https://www.ietf.org/rfc/rfc2617.txt) \"To receive authorization, the client sends the userid and password, separated by a single colon (\":\") character, within a base64 encoded string in the credentials.\" It is not meant to be urlencoded. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#bodyAllowedForStatus",
              "documentation": {
                "identifier": "bodyAllowedForStatus",
                "newPage": false,
                "searchKey": "http.bodyAllowedForStatus",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func bodyAllowedForStatus(status int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bodyAllowedForStatus(status int) bool\n```\n\nbodyAllowedForStatus reports whether a given response status code permits a body. See RFC 7230, section 3.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#bufioWriterPool",
              "documentation": {
                "identifier": "bufioWriterPool",
                "newPage": false,
                "searchKey": "http.bufioWriterPool",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func bufioWriterPool(size int) *sync.Pool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bufioWriterPool(size int) *sync.Pool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#canonicalAddr",
              "documentation": {
                "identifier": "canonicalAddr",
                "newPage": false,
                "searchKey": "http.canonicalAddr",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func canonicalAddr(url *url.URL) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc canonicalAddr(url *url.URL) string\n```\n\ncanonicalAddr returns url.Host but always with a \":port\" suffix \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#checkPreconditions",
              "documentation": {
                "identifier": "checkPreconditions",
                "newPage": false,
                "searchKey": "http.checkPreconditions",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkPreconditions(w ResponseWriter, r *Request, modtime time.Time) (done bool, rangeHeader string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkPreconditions(w ResponseWriter, r *Request, modtime time.Time) (done bool, rangeHeader string)\n```\n\ncheckPreconditions evaluates request preconditions and reports whether a precondition resulted in sending StatusNotModified or StatusPreconditionFailed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#checkWriteHeaderCode",
              "documentation": {
                "identifier": "checkWriteHeaderCode",
                "newPage": false,
                "searchKey": "http.checkWriteHeaderCode",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkWriteHeaderCode(code int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkWriteHeaderCode(code int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#checker",
              "documentation": {
                "identifier": "checker",
                "newPage": false,
                "searchKey": "http.checker",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func checker(t *testing.T) func(string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checker(t *testing.T) func(string, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#chunk",
              "documentation": {
                "identifier": "chunk",
                "newPage": false,
                "searchKey": "http.chunk",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func chunk(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chunk(s string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#chunked",
              "documentation": {
                "identifier": "chunked",
                "newPage": false,
                "searchKey": "http.chunked",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func chunked(te []string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chunked(te []string) bool\n```\n\nChecks whether chunked is part of the encodings stack \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#cleanHost",
              "documentation": {
                "identifier": "cleanHost",
                "newPage": false,
                "searchKey": "http.cleanHost",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func cleanHost(in string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cleanHost(in string) string\n```\n\ncleanHost cleans up the host sent in request's Host header. \n\nIt both strips anything after '/' or ' ', and puts the value into Punycode form, if necessary. \n\nIdeally we'd clean the Host header according to the spec: \n\n```\n[https://tools.ietf.org/html/rfc7230#section-5.4](https://tools.ietf.org/html/rfc7230#section-5.4) (Host = uri-host [ \":\" port ]\")\n[https://tools.ietf.org/html/rfc7230#section-2.7](https://tools.ietf.org/html/rfc7230#section-2.7) (uri-host -> rfc3986's host)\n[https://tools.ietf.org/html/rfc3986#section-3.2.2](https://tools.ietf.org/html/rfc3986#section-3.2.2) (definition of host)\n\n```\nBut practically, what we are trying to avoid is the situation in issue 11206, where a malformed Host header used in the proxy context would create a bad request. So it is enough to just truncate at the first offending character. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#cleanPath",
              "documentation": {
                "identifier": "cleanPath",
                "newPage": false,
                "searchKey": "http.cleanPath",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func cleanPath(p string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cleanPath(p string) string\n```\n\ncleanPath returns the canonical path for p, eliminating . and .. elements. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#cloneMultipartFileHeader",
              "documentation": {
                "identifier": "cloneMultipartFileHeader",
                "newPage": false,
                "searchKey": "http.cloneMultipartFileHeader",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func cloneMultipartFileHeader(fh *multipart.FileHeader) *multipart.FileHeader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cloneMultipartFileHeader(fh *multipart.FileHeader) *multipart.FileHeader\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#cloneMultipartForm",
              "documentation": {
                "identifier": "cloneMultipartForm",
                "newPage": false,
                "searchKey": "http.cloneMultipartForm",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func cloneMultipartForm(f *multipart.Form) *multipart.Form"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cloneMultipartForm(f *multipart.Form) *multipart.Form\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#cloneTLSConfig",
              "documentation": {
                "identifier": "cloneTLSConfig",
                "newPage": false,
                "searchKey": "http.cloneTLSConfig",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func cloneTLSConfig(cfg *tls.Config) *tls.Config"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cloneTLSConfig(cfg *tls.Config) *tls.Config\n```\n\ncloneTLSConfig returns a shallow clone of cfg, or a new zero tls.Config if cfg is nil. This is safe to call even if cfg is in active use by a TLS client or server. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#cloneURL",
              "documentation": {
                "identifier": "cloneURL",
                "newPage": false,
                "searchKey": "http.cloneURL",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func cloneURL(u *url.URL) *url.URL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cloneURL(u *url.URL) *url.URL\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#cloneURLValues",
              "documentation": {
                "identifier": "cloneURLValues",
                "newPage": false,
                "searchKey": "http.cloneURLValues",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func cloneURLValues(v url.Values) url.Values"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cloneURLValues(v url.Values) url.Values\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#containsDotDot",
              "documentation": {
                "identifier": "containsDotDot",
                "newPage": false,
                "searchKey": "http.containsDotDot",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func containsDotDot(v string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc containsDotDot(v string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#copyValues",
              "documentation": {
                "identifier": "copyValues",
                "newPage": false,
                "searchKey": "http.copyValues",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func copyValues(dst, src url.Values)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc copyValues(dst, src url.Values)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#defaultCheckRedirect",
              "documentation": {
                "identifier": "defaultCheckRedirect",
                "newPage": false,
                "searchKey": "http.defaultCheckRedirect",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func defaultCheckRedirect(req *Request, via []*Request) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc defaultCheckRedirect(req *Request, via []*Request) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#diff",
              "documentation": {
                "identifier": "diff",
                "newPage": false,
                "searchKey": "http.diff",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func diff(t *testing.T, prefix string, have, want interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc diff(t *testing.T, prefix string, have, want interface{})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#dirList",
              "documentation": {
                "identifier": "dirList",
                "newPage": false,
                "searchKey": "http.dirList",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func dirList(w ResponseWriter, r *Request, f File)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dirList(w ResponseWriter, r *Request, f File)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#dumpRequestOut",
              "documentation": {
                "identifier": "dumpRequestOut",
                "newPage": false,
                "searchKey": "http.dumpRequestOut",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpRequestOut(req *Request, onReadHeaders func()) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpRequestOut(req *Request, onReadHeaders func()) ([]byte, error)\n```\n\ndumpRequestOut is a modified copy of net/http/httputil.DumpRequestOut. Unlike the original, this version doesn't mutate the req.Body and try to restore it. It always dumps the whole body. And it doesn't support https. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#envProxyFunc",
              "documentation": {
                "identifier": "envProxyFunc",
                "newPage": false,
                "searchKey": "http.envProxyFunc",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func envProxyFunc() func(*url.URL) (*url.URL, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc envProxyFunc() func(*url.URL) (*url.URL, error)\n```\n\ndefaultProxyConfig returns a ProxyConfig value looked up from the environment. This mitigates expensive lookups on some platforms (e.g. Windows). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#etagStrongMatch",
              "documentation": {
                "identifier": "etagStrongMatch",
                "newPage": false,
                "searchKey": "http.etagStrongMatch",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func etagStrongMatch(a, b string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc etagStrongMatch(a, b string) bool\n```\n\netagStrongMatch reports whether a and b match using strong ETag comparison. Assumes a and b are valid ETags. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#etagWeakMatch",
              "documentation": {
                "identifier": "etagWeakMatch",
                "newPage": false,
                "searchKey": "http.etagWeakMatch",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func etagWeakMatch(a, b string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc etagWeakMatch(a, b string) bool\n```\n\netagWeakMatch reports whether a and b match using weak ETag comparison. Assumes a and b are valid ETags. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#fixLength",
              "documentation": {
                "identifier": "fixLength",
                "newPage": false,
                "searchKey": "http.fixLength",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fixLength(isResponse bool, status int, requestMethod string, header Header, chunked bool) (int64, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fixLength(isResponse bool, status int, requestMethod string, header Header, chunked bool) (int64, error)\n```\n\nDetermine the expected body length, using RFC 7230 Section 3.3. This function is not a method, because ultimately it should be shared by ReadResponse and ReadRequest. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#fixPragmaCacheControl",
              "documentation": {
                "identifier": "fixPragmaCacheControl",
                "newPage": false,
                "searchKey": "http.fixPragmaCacheControl",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fixPragmaCacheControl(header Header)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fixPragmaCacheControl(header Header)\n```\n\nRFC 7234, section 5.4: Should treat \n\n```\nPragma: no-cache\n\n```\nlike \n\n```\nCache-Control: no-cache\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#foreachHeaderElement",
              "documentation": {
                "identifier": "foreachHeaderElement",
                "newPage": false,
                "searchKey": "http.foreachHeaderElement",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func foreachHeaderElement(v string, fn func(string))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc foreachHeaderElement(v string, fn func(string))\n```\n\nforeachHeaderElement splits v according to the \"#rule\" construction in RFC 7230 section 7 and calls fn for each non-empty element. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#hasPort",
              "documentation": {
                "identifier": "hasPort",
                "newPage": false,
                "searchKey": "http.hasPort",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func hasPort(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hasPort(s string) bool\n```\n\nGiven a string of the form \"host\", \"host:port\", or \"[ipv6::address]:port\", return true if the string includes a port. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#hasToken",
              "documentation": {
                "identifier": "hasToken",
                "newPage": false,
                "searchKey": "http.hasToken",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func hasToken(v, token string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hasToken(v, token string) bool\n```\n\nhasToken reports whether token appears with v, ASCII case-insensitive, with space or comma boundaries. token must be all lowercase. v may contain mixed cased. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#hexEscapeNonASCII",
              "documentation": {
                "identifier": "hexEscapeNonASCII",
                "newPage": false,
                "searchKey": "http.hexEscapeNonASCII",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func hexEscapeNonASCII(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hexEscapeNonASCII(s string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#hookSetter",
              "documentation": {
                "identifier": "hookSetter",
                "newPage": false,
                "searchKey": "http.hookSetter",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func hookSetter(dst *func()) func(func())"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hookSetter(dst *func()) func(func())\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#htmlEscape",
              "documentation": {
                "identifier": "htmlEscape",
                "newPage": false,
                "searchKey": "http.htmlEscape",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func htmlEscape(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc htmlEscape(s string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http1ServerSupportsRequest",
              "documentation": {
                "identifier": "http1ServerSupportsRequest",
                "newPage": false,
                "searchKey": "http.http1ServerSupportsRequest",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http1ServerSupportsRequest(req *Request) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http1ServerSupportsRequest(req *Request) bool\n```\n\nhttp1ServerSupportsRequest reports whether Go's HTTP/1.x server supports the given request. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ConfigureServer",
              "documentation": {
                "identifier": "http2ConfigureServer",
                "newPage": false,
                "searchKey": "http.http2ConfigureServer",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2ConfigureServer(s *Server, conf *http2Server) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2ConfigureServer(s *Server, conf *http2Server) error\n```\n\nConfigureServer adds HTTP/2 support to a net/http Server. \n\nThe configuration conf may be nil. \n\nConfigureServer must be called before s begins serving. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2ConfigureTransport",
              "documentation": {
                "identifier": "http2ConfigureTransport",
                "newPage": false,
                "searchKey": "http.http2ConfigureTransport",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2ConfigureTransport(t1 *Transport) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2ConfigureTransport(t1 *Transport) error\n```\n\nConfigureTransport configures a net/http HTTP/1 Transport to use HTTP/2. It returns an error if t1 has already been HTTP/2-enabled. \n\nUse ConfigureTransports instead to configure the HTTP/2 Transport. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2actualContentLength",
              "documentation": {
                "identifier": "http2actualContentLength",
                "newPage": false,
                "searchKey": "http.http2actualContentLength",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2actualContentLength(req *Request) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2actualContentLength(req *Request) int64\n```\n\nactualContentLength returns a sanitized version of req.ContentLength, where 0 actually means zero (not unknown) and -1 means unknown. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2asciiEqualFold",
              "documentation": {
                "identifier": "http2asciiEqualFold",
                "newPage": false,
                "searchKey": "http.http2asciiEqualFold",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2asciiEqualFold(s, t string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2asciiEqualFold(s, t string) bool\n```\n\nasciiEqualFold is strings.EqualFold, ASCII only. It reports whether s and t are equal, ASCII-case-insensitively. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2asciiToLower",
              "documentation": {
                "identifier": "http2asciiToLower",
                "newPage": false,
                "searchKey": "http.http2asciiToLower",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2asciiToLower(s string) (lower string, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2asciiToLower(s string) (lower string, ok bool)\n```\n\nasciiToLower returns the lowercase version of s if s is ASCII and printable, and whether or not it was. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2authorityAddr",
              "documentation": {
                "identifier": "http2authorityAddr",
                "newPage": false,
                "searchKey": "http.http2authorityAddr",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2authorityAddr(scheme string, authority string) (addr string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2authorityAddr(scheme string, authority string) (addr string)\n```\n\nauthorityAddr returns a given authority (a host/IP, or host:port / ip:port) and returns a host:port. The port 443 is added if needed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2awaitRequestCancel",
              "documentation": {
                "identifier": "http2awaitRequestCancel",
                "newPage": false,
                "searchKey": "http.http2awaitRequestCancel",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2awaitRequestCancel(req *Request, done <-chan struct{}) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2awaitRequestCancel(req *Request, done <-chan struct{}) error\n```\n\nawaitRequestCancel waits for the user to cancel a request or for the done channel to be signaled. A non-nil error is returned only if the request was canceled. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2bodyAllowedForStatus",
              "documentation": {
                "identifier": "http2bodyAllowedForStatus",
                "newPage": false,
                "searchKey": "http.http2bodyAllowedForStatus",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2bodyAllowedForStatus(status int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2bodyAllowedForStatus(status int) bool\n```\n\nbodyAllowedForStatus reports whether a given response status code permits a body. See RFC 7230, section 3.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2buildCommonHeaderMaps",
              "documentation": {
                "identifier": "http2buildCommonHeaderMaps",
                "newPage": false,
                "searchKey": "http.http2buildCommonHeaderMaps",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2buildCommonHeaderMaps()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2buildCommonHeaderMaps()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2buildCommonHeaderMapsOnce",
              "documentation": {
                "identifier": "http2buildCommonHeaderMapsOnce",
                "newPage": false,
                "searchKey": "http.http2buildCommonHeaderMapsOnce",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2buildCommonHeaderMapsOnce()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2buildCommonHeaderMapsOnce()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2canRetryError",
              "documentation": {
                "identifier": "http2canRetryError",
                "newPage": false,
                "searchKey": "http.http2canRetryError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2canRetryError(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2canRetryError(err error) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2checkConnHeaders",
              "documentation": {
                "identifier": "http2checkConnHeaders",
                "newPage": false,
                "searchKey": "http.http2checkConnHeaders",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2checkConnHeaders(req *Request) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2checkConnHeaders(req *Request) error\n```\n\ncheckConnHeaders checks whether req has any invalid connection-level headers. per RFC 7540 section 8.1.2.2: Connection-Specific Header Fields. Certain headers are special-cased as okay but not transmitted later. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2checkPriority",
              "documentation": {
                "identifier": "http2checkPriority",
                "newPage": false,
                "searchKey": "http.http2checkPriority",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2checkPriority(streamID uint32, p http2PriorityParam) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2checkPriority(streamID uint32, p http2PriorityParam) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2checkValidHTTP2RequestHeaders",
              "documentation": {
                "identifier": "http2checkValidHTTP2RequestHeaders",
                "newPage": false,
                "searchKey": "http.http2checkValidHTTP2RequestHeaders",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2checkValidHTTP2RequestHeaders(h Header) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2checkValidHTTP2RequestHeaders(h Header) error\n```\n\ncheckValidHTTP2RequestHeaders checks whether h is a valid HTTP/2 request, per RFC 7540 Section 8.1.2.2. The returned error is reported to users. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2checkWriteHeaderCode",
              "documentation": {
                "identifier": "http2checkWriteHeaderCode",
                "newPage": false,
                "searchKey": "http.http2checkWriteHeaderCode",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2checkWriteHeaderCode(code int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2checkWriteHeaderCode(code int)\n```\n\ncheckWriteHeaderCode is a copy of net/http's checkWriteHeaderCode. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2commaSeparatedTrailers",
              "documentation": {
                "identifier": "http2commaSeparatedTrailers",
                "newPage": false,
                "searchKey": "http.http2commaSeparatedTrailers",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2commaSeparatedTrailers(req *Request) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2commaSeparatedTrailers(req *Request) (string, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2curGoroutineID",
              "documentation": {
                "identifier": "http2curGoroutineID",
                "newPage": false,
                "searchKey": "http.http2curGoroutineID",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2curGoroutineID() uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2curGoroutineID() uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2cutoff64",
              "documentation": {
                "identifier": "http2cutoff64",
                "newPage": false,
                "searchKey": "http.http2cutoff64",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2cutoff64(base int) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2cutoff64(base int) uint64\n```\n\nReturn the first number n such that n*base >= 1<<64. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2encKV",
              "documentation": {
                "identifier": "http2encKV",
                "newPage": false,
                "searchKey": "http.http2encKV",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2encKV(enc *hpack.Encoder, k, v string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2encKV(enc *hpack.Encoder, k, v string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2encodeHeaders",
              "documentation": {
                "identifier": "http2encodeHeaders",
                "newPage": false,
                "searchKey": "http.http2encodeHeaders",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2encodeHeaders(enc *hpack.Encoder, h Header, keys []string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2encodeHeaders(enc *hpack.Encoder, h Header, keys []string)\n```\n\nencodeHeaders encodes an http.Header. If keys is not nil, then (k, h[k]) is encoded only if k is in keys. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2errno",
              "documentation": {
                "identifier": "http2errno",
                "newPage": false,
                "searchKey": "http.http2errno",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2errno(v error) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2errno(v error) uintptr\n```\n\nerrno returns v's underlying uintptr, else 0. \n\nTODO: remove this helper function once http2 can use build tags. See comment in isClosedConnError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2filterOutClientConn",
              "documentation": {
                "identifier": "http2filterOutClientConn",
                "newPage": false,
                "searchKey": "http.http2filterOutClientConn",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2filterOutClientConn(in []*http2ClientConn, exclude *http2ClientConn) []*http2ClientConn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2filterOutClientConn(in []*http2ClientConn, exclude *http2ClientConn) []*http2ClientConn\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2foreachHeaderElement",
              "documentation": {
                "identifier": "http2foreachHeaderElement",
                "newPage": false,
                "searchKey": "http.http2foreachHeaderElement",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2foreachHeaderElement(v string, fn func(string))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2foreachHeaderElement(v string, fn func(string))\n```\n\nforeachHeaderElement splits v according to the \"#rule\" construction in RFC 7230 section 7 and calls fn for each non-empty element. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2getDataBufferChunk",
              "documentation": {
                "identifier": "http2getDataBufferChunk",
                "newPage": false,
                "searchKey": "http.http2getDataBufferChunk",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2getDataBufferChunk(size int64) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2getDataBufferChunk(size int64) []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2h1ServerKeepAlivesDisabled",
              "documentation": {
                "identifier": "http2h1ServerKeepAlivesDisabled",
                "newPage": false,
                "searchKey": "http.http2h1ServerKeepAlivesDisabled",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2h1ServerKeepAlivesDisabled(hs *Server) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2h1ServerKeepAlivesDisabled(hs *Server) bool\n```\n\nh1ServerKeepAlivesDisabled reports whether hs has its keep-alives disabled. See comments on h1ServerShutdownChan above for why the code is written this way. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2handleHeaderListTooLong",
              "documentation": {
                "identifier": "http2handleHeaderListTooLong",
                "newPage": false,
                "searchKey": "http.http2handleHeaderListTooLong",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2handleHeaderListTooLong(w ResponseWriter, r *Request)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2handleHeaderListTooLong(w ResponseWriter, r *Request)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2httpCodeString",
              "documentation": {
                "identifier": "http2httpCodeString",
                "newPage": false,
                "searchKey": "http.http2httpCodeString",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2httpCodeString(code int) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2httpCodeString(code int) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2isASCIIPrint",
              "documentation": {
                "identifier": "http2isASCIIPrint",
                "newPage": false,
                "searchKey": "http.http2isASCIIPrint",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2isASCIIPrint(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2isASCIIPrint(s string) bool\n```\n\nisASCIIPrint returns whether s is ASCII and printable according to [https://tools.ietf.org/html/rfc20#section-4.2](https://tools.ietf.org/html/rfc20#section-4.2). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2isBadCipher",
              "documentation": {
                "identifier": "http2isBadCipher",
                "newPage": false,
                "searchKey": "http.http2isBadCipher",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2isBadCipher(cipher uint16) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2isBadCipher(cipher uint16) bool\n```\n\nisBadCipher reports whether the cipher is blacklisted by the HTTP/2 spec. References: [https://tools.ietf.org/html/rfc7540#appendix-A](https://tools.ietf.org/html/rfc7540#appendix-A) Reject cipher suites from Appendix A. \"This list includes those cipher suites that do not offer an ephemeral key exchange and those that are based on the TLS null, stream or block cipher type\" \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2isClosedConnError",
              "documentation": {
                "identifier": "http2isClosedConnError",
                "newPage": false,
                "searchKey": "http.http2isClosedConnError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2isClosedConnError(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2isClosedConnError(err error) bool\n```\n\nisClosedConnError reports whether err is an error from use of a closed network connection. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2isConnectionCloseRequest",
              "documentation": {
                "identifier": "http2isConnectionCloseRequest",
                "newPage": false,
                "searchKey": "http.http2isConnectionCloseRequest",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2isConnectionCloseRequest(req *Request) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2isConnectionCloseRequest(req *Request) bool\n```\n\nisConnectionCloseRequest reports whether req should use its own connection for a single request and then close the connection. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2isEOFOrNetReadError",
              "documentation": {
                "identifier": "http2isEOFOrNetReadError",
                "newPage": false,
                "searchKey": "http.http2isEOFOrNetReadError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2isEOFOrNetReadError(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2isEOFOrNetReadError(err error) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2isNoCachedConnError",
              "documentation": {
                "identifier": "http2isNoCachedConnError",
                "newPage": false,
                "searchKey": "http.http2isNoCachedConnError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2isNoCachedConnError(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2isNoCachedConnError(err error) bool\n```\n\nisNoCachedConnError reports whether err is of type noCachedConnError or its equivalent renamed type in net/http2's h2_bundle.go. Both types may coexist in the same running program. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2lower",
              "documentation": {
                "identifier": "http2lower",
                "newPage": false,
                "searchKey": "http.http2lower",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2lower(b byte) byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2lower(b byte) byte\n```\n\nlower returns the ASCII lowercase version of b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2lowerHeader",
              "documentation": {
                "identifier": "http2lowerHeader",
                "newPage": false,
                "searchKey": "http.http2lowerHeader",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2lowerHeader(v string) (lower string, ascii bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2lowerHeader(v string) (lower string, ascii bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2mustUint31",
              "documentation": {
                "identifier": "http2mustUint31",
                "newPage": false,
                "searchKey": "http.http2mustUint31",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2mustUint31(v int32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2mustUint31(v int32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2parseUintBytes",
              "documentation": {
                "identifier": "http2parseUintBytes",
                "newPage": false,
                "searchKey": "http.http2parseUintBytes",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2parseUintBytes(s []byte, base int, bitSize int) (n uint64, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2parseUintBytes(s []byte, base int, bitSize int) (n uint64, err error)\n```\n\nparseUintBytes is like strconv.ParseUint, but using a []byte. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2putDataBufferChunk",
              "documentation": {
                "identifier": "http2putDataBufferChunk",
                "newPage": false,
                "searchKey": "http.http2putDataBufferChunk",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2putDataBufferChunk(p []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2putDataBufferChunk(p []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2readByte",
              "documentation": {
                "identifier": "http2readByte",
                "newPage": false,
                "searchKey": "http.http2readByte",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2readByte(p []byte) (remain []byte, b byte, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2readByte(p []byte) (remain []byte, b byte, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2readUint32",
              "documentation": {
                "identifier": "http2readUint32",
                "newPage": false,
                "searchKey": "http.http2readUint32",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2readUint32(p []byte) (remain []byte, v uint32, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2readUint32(p []byte) (remain []byte, v uint32, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2registerHTTPSProtocol",
              "documentation": {
                "identifier": "http2registerHTTPSProtocol",
                "newPage": false,
                "searchKey": "http.http2registerHTTPSProtocol",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2registerHTTPSProtocol(t *Transport, rt http2noDialH2RoundTripper) (err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2registerHTTPSProtocol(t *Transport, rt http2noDialH2RoundTripper) (err error)\n```\n\nregisterHTTPSProtocol calls Transport.RegisterProtocol but converting panics into errors. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2serverConnBaseContext",
              "documentation": {
                "identifier": "http2serverConnBaseContext",
                "newPage": false,
                "searchKey": "http.http2serverConnBaseContext",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2serverConnBaseContext(c net.Conn, opts *http2ServeConnOpts) (ctx context.Context, cancel func())"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2serverConnBaseContext(c net.Conn, opts *http2ServeConnOpts) (ctx context.Context, cancel func())\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2shouldRetryDial",
              "documentation": {
                "identifier": "http2shouldRetryDial",
                "newPage": false,
                "searchKey": "http.http2shouldRetryDial",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2shouldRetryDial(call *http2dialCall, req *Request) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2shouldRetryDial(call *http2dialCall, req *Request) bool\n```\n\nshouldRetryDial reports whether the current request should retry dialing after the call finished unsuccessfully, for example if the dial was canceled because of a context cancellation or deadline expiry. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2shouldSendReqContentLength",
              "documentation": {
                "identifier": "http2shouldSendReqContentLength",
                "newPage": false,
                "searchKey": "http.http2shouldSendReqContentLength",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2shouldSendReqContentLength(method string, contentLength int64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2shouldSendReqContentLength(method string, contentLength int64) bool\n```\n\nshouldSendReqContentLength reports whether the http2.Transport should send a \"content-length\" request header. This logic is basically a copy of the net/http transferWriter.shouldSendContentLength. The contentLength is the corrected contentLength (so 0 means actually 0, not unknown). -1 means unknown. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2splitHeaderBlock",
              "documentation": {
                "identifier": "http2splitHeaderBlock",
                "newPage": false,
                "searchKey": "http.http2splitHeaderBlock",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2splitHeaderBlock(ctx http2writeContext, headerBlock []byte, fn func(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2splitHeaderBlock(ctx http2writeContext, headerBlock []byte, fn func(ctx http2writeContext, frag []byte, firstFrag, lastFrag bool) error) error\n```\n\nsplitHeaderBlock splits headerBlock into fragments so that each fragment fits in a single frame, then calls fn for each fragment. firstFrag/lastFrag are true for the first/last fragment, respectively. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2strSliceContains",
              "documentation": {
                "identifier": "http2strSliceContains",
                "newPage": false,
                "searchKey": "http.http2strSliceContains",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2strSliceContains(ss []string, s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2strSliceContains(ss []string, s string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2summarizeFrame",
              "documentation": {
                "identifier": "http2summarizeFrame",
                "newPage": false,
                "searchKey": "http.http2summarizeFrame",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2summarizeFrame(f http2Frame) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2summarizeFrame(f http2Frame) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2terminalReadFrameError",
              "documentation": {
                "identifier": "http2terminalReadFrameError",
                "newPage": false,
                "searchKey": "http.http2terminalReadFrameError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2terminalReadFrameError(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2terminalReadFrameError(err error) bool\n```\n\nterminalReadFrameError reports whether err is an unrecoverable error from ReadFrame and no other frames should be read. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2traceFirstResponseByte",
              "documentation": {
                "identifier": "http2traceFirstResponseByte",
                "newPage": false,
                "searchKey": "http.http2traceFirstResponseByte",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2traceFirstResponseByte(trace *httptrace.ClientTrace)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2traceFirstResponseByte(trace *httptrace.ClientTrace)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2traceGetConn",
              "documentation": {
                "identifier": "http2traceGetConn",
                "newPage": false,
                "searchKey": "http.http2traceGetConn",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2traceGetConn(req *Request, hostPort string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2traceGetConn(req *Request, hostPort string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2traceGot100Continue",
              "documentation": {
                "identifier": "http2traceGot100Continue",
                "newPage": false,
                "searchKey": "http.http2traceGot100Continue",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2traceGot100Continue(trace *httptrace.ClientTrace)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2traceGot100Continue(trace *httptrace.ClientTrace)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2traceGot1xxResponseFunc",
              "documentation": {
                "identifier": "http2traceGot1xxResponseFunc",
                "newPage": false,
                "searchKey": "http.http2traceGot1xxResponseFunc",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2traceGot1xxResponseFunc(trace *httptrace.ClientTrace) func(int, textproto.MIMEHeader) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2traceGot1xxResponseFunc(trace *httptrace.ClientTrace) func(int, textproto.MIMEHeader) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2traceGotConn",
              "documentation": {
                "identifier": "http2traceGotConn",
                "newPage": false,
                "searchKey": "http.http2traceGotConn",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2traceGotConn(req *Request, cc *http2ClientConn, reused bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2traceGotConn(req *Request, cc *http2ClientConn, reused bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2traceHasWroteHeaderField",
              "documentation": {
                "identifier": "http2traceHasWroteHeaderField",
                "newPage": false,
                "searchKey": "http.http2traceHasWroteHeaderField",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2traceHasWroteHeaderField(trace *httptrace.ClientTrace) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2traceHasWroteHeaderField(trace *httptrace.ClientTrace) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2traceWait100Continue",
              "documentation": {
                "identifier": "http2traceWait100Continue",
                "newPage": false,
                "searchKey": "http.http2traceWait100Continue",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2traceWait100Continue(trace *httptrace.ClientTrace)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2traceWait100Continue(trace *httptrace.ClientTrace)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2traceWroteHeaderField",
              "documentation": {
                "identifier": "http2traceWroteHeaderField",
                "newPage": false,
                "searchKey": "http.http2traceWroteHeaderField",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2traceWroteHeaderField(trace *httptrace.ClientTrace, k, v string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2traceWroteHeaderField(trace *httptrace.ClientTrace, k, v string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2traceWroteHeaders",
              "documentation": {
                "identifier": "http2traceWroteHeaders",
                "newPage": false,
                "searchKey": "http.http2traceWroteHeaders",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2traceWroteHeaders(trace *httptrace.ClientTrace)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2traceWroteHeaders(trace *httptrace.ClientTrace)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2traceWroteRequest",
              "documentation": {
                "identifier": "http2traceWroteRequest",
                "newPage": false,
                "searchKey": "http.http2traceWroteRequest",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2traceWroteRequest(trace *httptrace.ClientTrace, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2traceWroteRequest(trace *httptrace.ClientTrace, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2validPseudoPath",
              "documentation": {
                "identifier": "http2validPseudoPath",
                "newPage": false,
                "searchKey": "http.http2validPseudoPath",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2validPseudoPath(v string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2validPseudoPath(v string) bool\n```\n\nvalidPseudoPath reports whether v is a valid :path pseudo-header value. It must be either: \n\n```\n*) a non-empty string starting with '/'\n*) the string '*', for OPTIONS requests.\n\n```\nFor now this is only used a quick check for deciding when to clean up Opaque URLs before sending requests from the Transport. See golang.org/issue/16847 \n\nWe used to enforce that the path also didn't start with \"//\", but Google's GFE accepts such paths and Chrome sends them, so ignore that part of the spec. See golang.org/issue/19103. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2validStreamID",
              "documentation": {
                "identifier": "http2validStreamID",
                "newPage": false,
                "searchKey": "http.http2validStreamID",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2validStreamID(streamID uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2validStreamID(streamID uint32) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2validStreamIDOrZero",
              "documentation": {
                "identifier": "http2validStreamIDOrZero",
                "newPage": false,
                "searchKey": "http.http2validStreamIDOrZero",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2validStreamIDOrZero(streamID uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2validStreamIDOrZero(streamID uint32) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2validWireHeaderFieldName",
              "documentation": {
                "identifier": "http2validWireHeaderFieldName",
                "newPage": false,
                "searchKey": "http.http2validWireHeaderFieldName",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2validWireHeaderFieldName(v string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2validWireHeaderFieldName(v string) bool\n```\n\nvalidWireHeaderFieldName reports whether v is a valid header field name (key). See httpguts.ValidHeaderName for the base rules. \n\nFurther, http2 says: \n\n```\n\"Just as in HTTP/1.x, header field names are strings of ASCII\ncharacters that are compared in a case-insensitive\nfashion. However, header field names MUST be converted to\nlowercase prior to their encoding in HTTP/2. \"\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#http2writeEndsStream",
              "documentation": {
                "identifier": "http2writeEndsStream",
                "newPage": false,
                "searchKey": "http.http2writeEndsStream",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2writeEndsStream(w http2writeFramer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2writeEndsStream(w http2writeFramer) bool\n```\n\nwriteEndsStream reports whether w writes a frame that will transition the stream to a half-closed local state. This returns false for RST_STREAM, which closes the entire stream (not just the local half). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#idnaASCII",
              "documentation": {
                "identifier": "idnaASCII",
                "newPage": false,
                "searchKey": "http.idnaASCII",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func idnaASCII(v string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc idnaASCII(v string) (string, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#init.export_test.go",
              "documentation": {
                "identifier": "init.export_test.go",
                "newPage": false,
                "searchKey": "http.init",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#init.h2_bundle.go",
              "documentation": {
                "identifier": "init.h2_bundle.go",
                "newPage": false,
                "searchKey": "http.init",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#is408Message",
              "documentation": {
                "identifier": "is408Message",
                "newPage": false,
                "searchKey": "http.is408Message",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func is408Message(buf []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc is408Message(buf []byte) bool\n```\n\nis408Message reports whether buf has the prefix of an HTTP 408 Request Timeout response. See golang.org/issue/32310. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isCommonNetReadError",
              "documentation": {
                "identifier": "isCommonNetReadError",
                "newPage": false,
                "searchKey": "http.isCommonNetReadError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isCommonNetReadError(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isCommonNetReadError(err error) bool\n```\n\nisCommonNetReadError reports whether err is a common error encountered during reading a request off the network when the client has gone away or had its read fail somehow. This is used to determine which logs are interesting enough to log about. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isCookieDomainName",
              "documentation": {
                "identifier": "isCookieDomainName",
                "newPage": false,
                "searchKey": "http.isCookieDomainName",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isCookieDomainName(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isCookieDomainName(s string) bool\n```\n\nisCookieDomainName reports whether s is a valid domain name or a valid domain name with a leading dot '.'.  It is almost a direct copy of package net's isDomainName. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isCookieNameValid",
              "documentation": {
                "identifier": "isCookieNameValid",
                "newPage": false,
                "searchKey": "http.isCookieNameValid",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isCookieNameValid(raw string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isCookieNameValid(raw string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isDomainOrSubdomain",
              "documentation": {
                "identifier": "isDomainOrSubdomain",
                "newPage": false,
                "searchKey": "http.isDomainOrSubdomain",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isDomainOrSubdomain(sub, parent string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isDomainOrSubdomain(sub, parent string) bool\n```\n\nisDomainOrSubdomain reports whether sub is a subdomain (or exact match) of the parent domain. \n\nBoth domains must already be in canonical form. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isIdentity",
              "documentation": {
                "identifier": "isIdentity",
                "newPage": false,
                "searchKey": "http.isIdentity",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isIdentity(te []string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isIdentity(te []string) bool\n```\n\nChecks whether the encoding is explicitly \"identity\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isKnownInMemoryReader",
              "documentation": {
                "identifier": "isKnownInMemoryReader",
                "newPage": false,
                "searchKey": "http.isKnownInMemoryReader",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isKnownInMemoryReader(r io.Reader) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isKnownInMemoryReader(r io.Reader) bool\n```\n\nisKnownInMemoryReader reports whether r is a type known to not block on Read. Its caller uses this as an optional optimization to send fewer TCP packets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isNotToken",
              "documentation": {
                "identifier": "isNotToken",
                "newPage": false,
                "searchKey": "http.isNotToken",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isNotToken(r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isNotToken(r rune) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isProtocolSwitchHeader",
              "documentation": {
                "identifier": "isProtocolSwitchHeader",
                "newPage": false,
                "searchKey": "http.isProtocolSwitchHeader",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isProtocolSwitchHeader(h Header) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isProtocolSwitchHeader(h Header) bool\n```\n\nisProtocolSwitchHeader reports whether the request or response header is for a protocol switch. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isProtocolSwitchResponse",
              "documentation": {
                "identifier": "isProtocolSwitchResponse",
                "newPage": false,
                "searchKey": "http.isProtocolSwitchResponse",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isProtocolSwitchResponse(code int, h Header) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isProtocolSwitchResponse(code int, h Header) bool\n```\n\nisProtocolSwitchResponse reports whether the response code and response header indicate a successful protocol upgrade response. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isSlashRune",
              "documentation": {
                "identifier": "isSlashRune",
                "newPage": false,
                "searchKey": "http.isSlashRune",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isSlashRune(r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isSlashRune(r rune) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isTT",
              "documentation": {
                "identifier": "isTT",
                "newPage": false,
                "searchKey": "http.isTT",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isTT(b byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isTT(b byte) bool\n```\n\nisTT reports whether the provided byte is a tag-terminating byte (0xTT) as defined in [https://mimesniff.spec.whatwg.org/#terminology](https://mimesniff.spec.whatwg.org/#terminology). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isTokenBoundary",
              "documentation": {
                "identifier": "isTokenBoundary",
                "newPage": false,
                "searchKey": "http.isTokenBoundary",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isTokenBoundary(b byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isTokenBoundary(b byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isTransportReadFromServerError",
              "documentation": {
                "identifier": "isTransportReadFromServerError",
                "newPage": false,
                "searchKey": "http.isTransportReadFromServerError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isTransportReadFromServerError(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isTransportReadFromServerError(err error) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isUnsupportedTEError",
              "documentation": {
                "identifier": "isUnsupportedTEError",
                "newPage": false,
                "searchKey": "http.isUnsupportedTEError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isUnsupportedTEError(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isUnsupportedTEError(err error) bool\n```\n\nisUnsupportedTEError checks if the error is of type unsupportedTEError. It is usually invoked with a non-nil err. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isWS",
              "documentation": {
                "identifier": "isWS",
                "newPage": false,
                "searchKey": "http.isWS",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isWS(b byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isWS(b byte) bool\n```\n\nisWS reports whether the provided byte is a whitespace byte (0xWS) as defined in [https://mimesniff.spec.whatwg.org/#terminology](https://mimesniff.spec.whatwg.org/#terminology). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#isZeroTime",
              "documentation": {
                "identifier": "isZeroTime",
                "newPage": false,
                "searchKey": "http.isZeroTime",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isZeroTime(t time.Time) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isZeroTime(t time.Time) bool\n```\n\nisZeroTime reports whether t is obviously unspecified (either zero or Unix()=0). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#knownRoundTripperImpl",
              "documentation": {
                "identifier": "knownRoundTripperImpl",
                "newPage": false,
                "searchKey": "http.knownRoundTripperImpl",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func knownRoundTripperImpl(rt RoundTripper, req *Request) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc knownRoundTripperImpl(rt RoundTripper, req *Request) bool\n```\n\nknownRoundTripperImpl reports whether rt is a RoundTripper that's maintained by the Go team and known to implement the latest optional semantics (notably contexts). The Request is used to check whether this particular request is using an alternate protocol, in which case we need to check the RoundTripper for that protocol. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#localRedirect",
              "documentation": {
                "identifier": "localRedirect",
                "newPage": false,
                "searchKey": "http.localRedirect",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func localRedirect(w ResponseWriter, r *Request, newPath string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc localRedirect(w ResponseWriter, r *Request, newPath string)\n```\n\nlocalRedirect gives a Moved Permanently response. It does not convert relative paths to absolute paths like Redirect does. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#logf",
              "documentation": {
                "identifier": "logf",
                "newPage": false,
                "searchKey": "http.logf",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func logf(r *Request, format string, args ...interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc logf(r *Request, format string, args ...interface{})\n```\n\nlogf prints to the ErrorLog of the *Server associated with request r via ServerContextKey. If there's no associated server, or if ErrorLog is nil, logging is done via the log package's standard logger. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#mapDirOpenError",
              "documentation": {
                "identifier": "mapDirOpenError",
                "newPage": false,
                "searchKey": "http.mapDirOpenError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapDirOpenError(originalErr error, name string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapDirOpenError(originalErr error, name string) error\n```\n\nmapDirOpenError maps the provided non-nil error from opening name to a possibly better non-nil error. In particular, it turns OS-specific errors about opening files in non-directories into fs.ErrNotExist. See Issue 18984. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#matchErr",
              "documentation": {
                "identifier": "matchErr",
                "newPage": false,
                "searchKey": "http.matchErr",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func matchErr(err error, wantErr interface{}) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc matchErr(err error, wantErr interface{}) error\n```\n\nwantErr can be nil, an error value to match exactly, or type string to match a substring. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#mergeSetHeader",
              "documentation": {
                "identifier": "mergeSetHeader",
                "newPage": false,
                "searchKey": "http.mergeSetHeader",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func mergeSetHeader(dst *Header, src Header)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mergeSetHeader(dst *Header, src Header)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#mustParseURL",
              "documentation": {
                "identifier": "mustParseURL",
                "newPage": false,
                "searchKey": "http.mustParseURL",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func mustParseURL(s string) *url.URL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mustParseURL(s string) *url.URL\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#newBufioReader",
              "documentation": {
                "identifier": "newBufioReader",
                "newPage": false,
                "searchKey": "http.newBufioReader",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func newBufioReader(r io.Reader) *bufio.Reader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newBufioReader(r io.Reader) *bufio.Reader\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#newBufioWriterSize",
              "documentation": {
                "identifier": "newBufioWriterSize",
                "newPage": false,
                "searchKey": "http.newBufioWriterSize",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func newBufioWriterSize(w io.Writer, size int) *bufio.Writer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newBufioWriterSize(w io.Writer, size int) *bufio.Writer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#newLocalListener",
              "documentation": {
                "identifier": "newLocalListener",
                "newPage": false,
                "searchKey": "http.newLocalListener",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func newLocalListener(t *testing.T) net.Listener"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newLocalListener(t *testing.T) net.Listener\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#newLoggingConn",
              "documentation": {
                "identifier": "newLoggingConn",
                "newPage": false,
                "searchKey": "http.newLoggingConn",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func newLoggingConn(baseName string, c net.Conn) net.Conn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newLoggingConn(baseName string, c net.Conn) net.Conn\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#newReadWriteCloserBody",
              "documentation": {
                "identifier": "newReadWriteCloserBody",
                "newPage": false,
                "searchKey": "http.newReadWriteCloserBody",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func newReadWriteCloserBody(br *bufio.Reader, rwc io.ReadWriteCloser) io.ReadWriteCloser"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newReadWriteCloserBody(br *bufio.Reader, rwc io.ReadWriteCloser) io.ReadWriteCloser\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#newTextprotoReader",
              "documentation": {
                "identifier": "newTextprotoReader",
                "newPage": false,
                "searchKey": "http.newTextprotoReader",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func newTextprotoReader(br *bufio.Reader) *textproto.Reader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newTextprotoReader(br *bufio.Reader) *textproto.Reader\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#noResponseBodyExpected",
              "documentation": {
                "identifier": "noResponseBodyExpected",
                "newPage": false,
                "searchKey": "http.noResponseBodyExpected",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func noResponseBodyExpected(requestMethod string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc noResponseBodyExpected(requestMethod string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#nop",
              "documentation": {
                "identifier": "nop",
                "newPage": false,
                "searchKey": "http.nop",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func nop()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nop()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#numLeadingCRorLF",
              "documentation": {
                "identifier": "numLeadingCRorLF",
                "newPage": false,
                "searchKey": "http.numLeadingCRorLF",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func numLeadingCRorLF(v []byte) (n int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc numLeadingCRorLF(v []byte) (n int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#parseBasicAuth",
              "documentation": {
                "identifier": "parseBasicAuth",
                "newPage": false,
                "searchKey": "http.parseBasicAuth",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseBasicAuth(auth string) (username, password string, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseBasicAuth(auth string) (username, password string, ok bool)\n```\n\nparseBasicAuth parses an HTTP Basic Authentication string. \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\" returns (\"Aladdin\", \"open sesame\", true). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#parseContentLength",
              "documentation": {
                "identifier": "parseContentLength",
                "newPage": false,
                "searchKey": "http.parseContentLength",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseContentLength(cl string) (int64, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseContentLength(cl string) (int64, error)\n```\n\nparseContentLength trims whitespace from s and returns -1 if no value is set, or the value if it's >= 0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#parseCookieValue",
              "documentation": {
                "identifier": "parseCookieValue",
                "newPage": false,
                "searchKey": "http.parseCookieValue",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseCookieValue(raw string, allowDoubleQuote bool) (string, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseCookieValue(raw string, allowDoubleQuote bool) (string, bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#parsePostForm",
              "documentation": {
                "identifier": "parsePostForm",
                "newPage": false,
                "searchKey": "http.parsePostForm",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parsePostForm(r *Request) (vs url.Values, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parsePostForm(r *Request) (vs url.Values, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#parseRange",
              "documentation": {
                "identifier": "parseRange",
                "newPage": false,
                "searchKey": "http.parseRange",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseRange(s string, size int64) ([]httpRange, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseRange(s string, size int64) ([]httpRange, error)\n```\n\nparseRange parses a Range header string as per RFC 7233. errNoOverlap is returned if none of the ranges overlap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#parseRequestLine",
              "documentation": {
                "identifier": "parseRequestLine",
                "newPage": false,
                "searchKey": "http.parseRequestLine",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseRequestLine(line string) (method, requestURI, proto string, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseRequestLine(line string) (method, requestURI, proto string, ok bool)\n```\n\nparseRequestLine parses \"GET /foo HTTP/1.1\" into its three parts. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#putBufioReader",
              "documentation": {
                "identifier": "putBufioReader",
                "newPage": false,
                "searchKey": "http.putBufioReader",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func putBufioReader(br *bufio.Reader)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc putBufioReader(br *bufio.Reader)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#putBufioWriter",
              "documentation": {
                "identifier": "putBufioWriter",
                "newPage": false,
                "searchKey": "http.putBufioWriter",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func putBufioWriter(bw *bufio.Writer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc putBufioWriter(bw *bufio.Writer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#putTextprotoReader",
              "documentation": {
                "identifier": "putTextprotoReader",
                "newPage": false,
                "searchKey": "http.putTextprotoReader",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func putTextprotoReader(r *textproto.Reader)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc putTextprotoReader(r *textproto.Reader)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#rangesMIMESize",
              "documentation": {
                "identifier": "rangesMIMESize",
                "newPage": false,
                "searchKey": "http.rangesMIMESize",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func rangesMIMESize(ranges []httpRange, contentType string, contentSize int64) (encSize int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rangesMIMESize(ranges []httpRange, contentType string, contentSize int64) (encSize int64)\n```\n\nrangesMIMESize returns the number of bytes it takes to encode the provided ranges as a multipart response. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#readCookies",
              "documentation": {
                "identifier": "readCookies",
                "newPage": false,
                "searchKey": "http.readCookies",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func readCookies(h Header, filter string) []*Cookie"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readCookies(h Header, filter string) []*Cookie\n```\n\nreadCookies parses all \"Cookie\" values from the header h and returns the successfully parsed Cookies. \n\nif filter isn't empty, only cookies of that name are returned \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#readSetCookies",
              "documentation": {
                "identifier": "readSetCookies",
                "newPage": false,
                "searchKey": "http.readSetCookies",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func readSetCookies(h Header) []*Cookie"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readSetCookies(h Header) []*Cookie\n```\n\nreadSetCookies parses all \"Set-Cookie\" values from the header h and returns the successfully parsed Cookies. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#readTransfer",
              "documentation": {
                "identifier": "readTransfer",
                "newPage": false,
                "searchKey": "http.readTransfer",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func readTransfer(msg interface{}, r *bufio.Reader) (err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readTransfer(msg interface{}, r *bufio.Reader) (err error)\n```\n\nmsg is *Request or *Response. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#redirectBehavior",
              "documentation": {
                "identifier": "redirectBehavior",
                "newPage": false,
                "searchKey": "http.redirectBehavior",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func redirectBehavior(reqMethod string, resp *Response, ireq *Request) (redirectMethod string, shouldRedirect, includeBody bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc redirectBehavior(reqMethod string, resp *Response, ireq *Request) (redirectMethod string, shouldRedirect, includeBody bool)\n```\n\nredirectBehavior describes what should happen when the client encounters a 3xx status code from the server \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#refererForURL",
              "documentation": {
                "identifier": "refererForURL",
                "newPage": false,
                "searchKey": "http.refererForURL",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func refererForURL(lastReq, newReq *url.URL) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc refererForURL(lastReq, newReq *url.URL) string\n```\n\nrefererForURL returns a referer without any authentication info or an empty string if lastReq scheme is https and newReq scheme is http. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#registerOnHitEOF",
              "documentation": {
                "identifier": "registerOnHitEOF",
                "newPage": false,
                "searchKey": "http.registerOnHitEOF",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func registerOnHitEOF(rc io.ReadCloser, fn func())"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc registerOnHitEOF(rc io.ReadCloser, fn func())\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#relevantCaller",
              "documentation": {
                "identifier": "relevantCaller",
                "newPage": false,
                "searchKey": "http.relevantCaller",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func relevantCaller() runtime.Frame"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc relevantCaller() runtime.Frame\n```\n\nrelevantCaller searches the call stack for the first function outside of net/http. The purpose of this function is to provide more helpful error messages. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#removeEmptyPort",
              "documentation": {
                "identifier": "removeEmptyPort",
                "newPage": false,
                "searchKey": "http.removeEmptyPort",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func removeEmptyPort(host string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc removeEmptyPort(host string) string\n```\n\nremoveEmptyPort strips the empty port in \":port\" to \"\" as mandated by RFC 3986 Section 6.2.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#removeZone",
              "documentation": {
                "identifier": "removeZone",
                "newPage": false,
                "searchKey": "http.removeZone",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func removeZone(host string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc removeZone(host string) string\n```\n\nremoveZone removes IPv6 zone identifier from host. E.g., \"[fe80::1%en0]:8080\" to \"[fe80::1]:8080\" \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#reqBytes",
              "documentation": {
                "identifier": "reqBytes",
                "newPage": false,
                "searchKey": "http.reqBytes",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func reqBytes(req string) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reqBytes(req string) []byte\n```\n\nreqBytes treats req as a request (with \\n delimiters) and returns it with \\r\\n delimiters, ending in \\r\\n\\r\\n \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#requestBodyRemains",
              "documentation": {
                "identifier": "requestBodyRemains",
                "newPage": false,
                "searchKey": "http.requestBodyRemains",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func requestBodyRemains(rc io.ReadCloser) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc requestBodyRemains(rc io.ReadCloser) bool\n```\n\nrequestBodyRemains reports whether future calls to Read on rc might yield more data. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#requestMethodUsuallyLacksBody",
              "documentation": {
                "identifier": "requestMethodUsuallyLacksBody",
                "newPage": false,
                "searchKey": "http.requestMethodUsuallyLacksBody",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func requestMethodUsuallyLacksBody(method string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc requestMethodUsuallyLacksBody(method string) bool\n```\n\nrequestMethodUsuallyLacksBody reports whether the given request method is one that typically does not involve a request body. This is used by the Transport (via transferWriter.shouldSendChunkedRequestBody) to determine whether we try to test-read a byte from a non-nil Request.Body when Request.outgoingLength() returns -1. See the comments in shouldSendChunkedRequestBody. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#resetProxyConfig",
              "documentation": {
                "identifier": "resetProxyConfig",
                "newPage": false,
                "searchKey": "http.resetProxyConfig",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func resetProxyConfig()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resetProxyConfig()\n```\n\nresetProxyConfig is used by tests. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#sanitizeCookieName",
              "documentation": {
                "identifier": "sanitizeCookieName",
                "newPage": false,
                "searchKey": "http.sanitizeCookieName",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sanitizeCookieName(n string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sanitizeCookieName(n string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#sanitizeCookiePath",
              "documentation": {
                "identifier": "sanitizeCookiePath",
                "newPage": false,
                "searchKey": "http.sanitizeCookiePath",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sanitizeCookiePath(v string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sanitizeCookiePath(v string) string\n```\n\npath-av           = \"Path=\" path-value path-value        = <any CHAR except CTLs or \";\"> \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#sanitizeCookieValue",
              "documentation": {
                "identifier": "sanitizeCookieValue",
                "newPage": false,
                "searchKey": "http.sanitizeCookieValue",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sanitizeCookieValue(v string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sanitizeCookieValue(v string) string\n```\n\nsanitizeCookieValue produces a suitable cookie-value from v. [https://tools.ietf.org/html/rfc6265#section-4.1.1](https://tools.ietf.org/html/rfc6265#section-4.1.1) cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E \n\n```\n; US-ASCII characters excluding CTLs,\n; whitespace DQUOTE, comma, semicolon,\n; and backslash\n\n```\nWe loosen this as spaces and commas are common in cookie values but we produce a quoted cookie-value if and only if v contains commas or spaces. See [https://golang.org/issue/7243](https://golang.org/issue/7243) for the discussion. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#sanitizeOrWarn",
              "documentation": {
                "identifier": "sanitizeOrWarn",
                "newPage": false,
                "searchKey": "http.sanitizeOrWarn",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sanitizeOrWarn(fieldName string, valid func(byte) bool, v string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sanitizeOrWarn(fieldName string, valid func(byte) bool, v string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#scanETag",
              "documentation": {
                "identifier": "scanETag",
                "newPage": false,
                "searchKey": "http.scanETag",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func scanETag(s string) (etag string, remain string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc scanETag(s string) (etag string, remain string)\n```\n\nscanETag determines if a syntactically valid ETag is present at s. If so, the ETag and remaining text after consuming ETag is returned. Otherwise, it returns \"\", \"\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#seeUpcomingDoubleCRLF",
              "documentation": {
                "identifier": "seeUpcomingDoubleCRLF",
                "newPage": false,
                "searchKey": "http.seeUpcomingDoubleCRLF",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func seeUpcomingDoubleCRLF(r *bufio.Reader) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc seeUpcomingDoubleCRLF(r *bufio.Reader) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#serveContent",
              "documentation": {
                "identifier": "serveContent",
                "newPage": false,
                "searchKey": "http.serveContent",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func serveContent(w ResponseWriter, r *Request, name string, modtime time.Time, sizeFunc func() (int64, error), content io.ReadSeeker)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc serveContent(w ResponseWriter, r *Request, name string, modtime time.Time, sizeFunc func() (int64, error), content io.ReadSeeker)\n```\n\nif name is empty, filename is unknown. (used for mime type, before sniffing) if modtime.IsZero(), modtime is unknown. content must be seeked to the beginning of the file. The sizeFunc is called at most once. Its error, if any, is sent in the HTTP response. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#serveFile",
              "documentation": {
                "identifier": "serveFile",
                "newPage": false,
                "searchKey": "http.serveFile",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirect bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc serveFile(w ResponseWriter, r *Request, fs FileSystem, name string, redirect bool)\n```\n\nname is '/'-separated, not filepath.Separator. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#setLastModified",
              "documentation": {
                "identifier": "setLastModified",
                "newPage": false,
                "searchKey": "http.setLastModified",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func setLastModified(w ResponseWriter, modtime time.Time)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setLastModified(w ResponseWriter, modtime time.Time)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#setRequestCancel",
              "documentation": {
                "identifier": "setRequestCancel",
                "newPage": false,
                "searchKey": "http.setRequestCancel",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func setRequestCancel(req *Request, rt RoundTripper, deadline time.Time) (stopTimer func(), didTimeout func() bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setRequestCancel(req *Request, rt RoundTripper, deadline time.Time) (stopTimer func(), didTimeout func() bool)\n```\n\nsetRequestCancel sets req.Cancel and adds a deadline context to req if deadline is non-zero. The RoundTripper's type is used to determine whether the legacy CancelRequest behavior should be used. \n\nAs background, there are three ways to cancel a request: First was Transport.CancelRequest. (deprecated) Second was Request.Cancel. Third was Request.Context. This function populates the second and third, and uses the first if it really needs to. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#shouldClose",
              "documentation": {
                "identifier": "shouldClose",
                "newPage": false,
                "searchKey": "http.shouldClose",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func shouldClose(major, minor int, header Header, removeCloseHeader bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc shouldClose(major, minor int, header Header, removeCloseHeader bool) bool\n```\n\nDetermine whether to hang up after sending a request and body, or receiving a response and body 'header' is the request headers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#shouldCopyHeaderOnRedirect",
              "documentation": {
                "identifier": "shouldCopyHeaderOnRedirect",
                "newPage": false,
                "searchKey": "http.shouldCopyHeaderOnRedirect",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func shouldCopyHeaderOnRedirect(headerKey string, initial, dest *url.URL) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc shouldCopyHeaderOnRedirect(headerKey string, initial, dest *url.URL) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#sockssplitHostPort",
              "documentation": {
                "identifier": "sockssplitHostPort",
                "newPage": false,
                "searchKey": "http.sockssplitHostPort",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sockssplitHostPort(address string) (string, int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sockssplitHostPort(address string) (string, int, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#strSliceContains",
              "documentation": {
                "identifier": "strSliceContains",
                "newPage": false,
                "searchKey": "http.strSliceContains",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func strSliceContains(ss []string, s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc strSliceContains(ss []string, s string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#stringContainsCTLByte",
              "documentation": {
                "identifier": "stringContainsCTLByte",
                "newPage": false,
                "searchKey": "http.stringContainsCTLByte",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringContainsCTLByte(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringContainsCTLByte(s string) bool\n```\n\nstringContainsCTLByte reports whether s contains any ASCII control character. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#stripHostPort",
              "documentation": {
                "identifier": "stripHostPort",
                "newPage": false,
                "searchKey": "http.stripHostPort",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func stripHostPort(h string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stripHostPort(h string) string\n```\n\nstripHostPort returns h without any trailing \":<port>\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#stripPassword",
              "documentation": {
                "identifier": "stripPassword",
                "newPage": false,
                "searchKey": "http.stripPassword",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func stripPassword(u *url.URL) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stripPassword(u *url.URL) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#sumRangesSize",
              "documentation": {
                "identifier": "sumRangesSize",
                "newPage": false,
                "searchKey": "http.sumRangesSize",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sumRangesSize(ranges []httpRange) (size int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sumRangesSize(ranges []httpRange) (size int64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#suppressedHeaders",
              "documentation": {
                "identifier": "suppressedHeaders",
                "newPage": false,
                "searchKey": "http.suppressedHeaders",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func suppressedHeaders(status int) []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc suppressedHeaders(status int) []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#timeBeforeContextDeadline",
              "documentation": {
                "identifier": "timeBeforeContextDeadline",
                "newPage": false,
                "searchKey": "http.timeBeforeContextDeadline",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func timeBeforeContextDeadline(t time.Time, ctx context.Context) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc timeBeforeContextDeadline(t time.Time, ctx context.Context) bool\n```\n\ntimeBeforeContextDeadline reports whether the non-zero Time t is before ctx's deadline, if any. If ctx does not have a deadline, it always reports true (the deadline is considered infinite). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#tlsRecordHeaderLooksLikeHTTP",
              "documentation": {
                "identifier": "tlsRecordHeaderLooksLikeHTTP",
                "newPage": false,
                "searchKey": "http.tlsRecordHeaderLooksLikeHTTP",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func tlsRecordHeaderLooksLikeHTTP(hdr [5]byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tlsRecordHeaderLooksLikeHTTP(hdr [5]byte) bool\n```\n\ntlsRecordHeaderLooksLikeHTTP reports whether a TLS record header looks like it might've been a misdirected plaintext HTTP request. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#toHTTPError",
              "documentation": {
                "identifier": "toHTTPError",
                "newPage": false,
                "searchKey": "http.toHTTPError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func toHTTPError(err error) (msg string, httpStatus int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc toHTTPError(err error) (msg string, httpStatus int)\n```\n\ntoHTTPError returns a non-specific HTTP error message and status code for a given non-nil error value. It's important that toHTTPError does not actually return err.Error(), since msg and httpStatus are returned to users, and historically Go's ServeContent always returned just \"404 Not Found\" for all errors. We don't want to start leaking information in error messages. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#toJSON",
              "documentation": {
                "identifier": "toJSON",
                "newPage": false,
                "searchKey": "http.toJSON",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func toJSON(v interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc toJSON(v interface{}) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#unnilTestHook",
              "documentation": {
                "identifier": "unnilTestHook",
                "newPage": false,
                "searchKey": "http.unnilTestHook",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func unnilTestHook(f *func())"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unnilTestHook(f *func())\n```\n\nAll test hooks must be non-nil so they can be called directly, but the tests use nil to mean hook disabled. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#urlErrorOp",
              "documentation": {
                "identifier": "urlErrorOp",
                "newPage": false,
                "searchKey": "http.urlErrorOp",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func urlErrorOp(method string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc urlErrorOp(method string) string\n```\n\nurlErrorOp returns the (*url.Error).Op value to use for the provided (*Request).Method value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#validCookieDomain",
              "documentation": {
                "identifier": "validCookieDomain",
                "newPage": false,
                "searchKey": "http.validCookieDomain",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validCookieDomain(v string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validCookieDomain(v string) bool\n```\n\nvalidCookieDomain reports whether v is a valid cookie domain-value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#validCookieExpires",
              "documentation": {
                "identifier": "validCookieExpires",
                "newPage": false,
                "searchKey": "http.validCookieExpires",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validCookieExpires(t time.Time) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validCookieExpires(t time.Time) bool\n```\n\nvalidCookieExpires reports whether v is a valid cookie expires-value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#validCookiePathByte",
              "documentation": {
                "identifier": "validCookiePathByte",
                "newPage": false,
                "searchKey": "http.validCookiePathByte",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validCookiePathByte(b byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validCookiePathByte(b byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#validCookieValueByte",
              "documentation": {
                "identifier": "validCookieValueByte",
                "newPage": false,
                "searchKey": "http.validCookieValueByte",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validCookieValueByte(b byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validCookieValueByte(b byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#validMethod",
              "documentation": {
                "identifier": "validMethod",
                "newPage": false,
                "searchKey": "http.validMethod",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validMethod(method string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validMethod(method string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#validNextProto",
              "documentation": {
                "identifier": "validNextProto",
                "newPage": false,
                "searchKey": "http.validNextProto",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validNextProto(proto string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validNextProto(proto string) bool\n```\n\nvalidNextProto reports whether the proto is a valid ALPN protocol name. Everything is valid except the empty string and built-in protocol types, so that those can't be overridden with alternate implementations. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#valueOrDefault",
              "documentation": {
                "identifier": "valueOrDefault",
                "newPage": false,
                "searchKey": "http.valueOrDefault",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func valueOrDefault(value, def string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc valueOrDefault(value, def string) string\n```\n\nReturn value if nonempty, def otherwise. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#writeNotModified",
              "documentation": {
                "identifier": "writeNotModified",
                "newPage": false,
                "searchKey": "http.writeNotModified",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeNotModified(w ResponseWriter)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeNotModified(w ResponseWriter)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/net/http#writeStatusLine",
              "documentation": {
                "identifier": "writeStatusLine",
                "newPage": false,
                "searchKey": "http.writeStatusLine",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeStatusLine(bw *bufio.Writer, is11 bool, code int, scratch []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeStatusLine(bw *bufio.Writer, is11 bool, code int, scratch []byte)\n```\n\nwriteStatusLine writes an HTTP/1.x Status-Line (RFC 7230 Section 3.1.2) to bw. is11 is whether the HTTP request is HTTP/1.1. false means HTTP/1.0. code is the response status code. scratch is an optional scratch buffer. If it has at least capacity 3, it's used. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "pathID": "/net/http/cgi"
    },
    {
      "pathID": "/net/http/cookiejar"
    },
    {
      "pathID": "/net/http/cookiejar_test"
    },
    {
      "pathID": "/net/http/fcgi"
    },
    {
      "pathID": "/net/http/httptest"
    },
    {
      "pathID": "/net/http/httptest_test"
    },
    {
      "pathID": "/net/http/httptrace"
    },
    {
      "pathID": "/net/http/httptrace_test"
    },
    {
      "pathID": "/net/http/httputil"
    },
    {
      "pathID": "/net/http/httputil_test"
    },
    {
      "pathID": "/net/http/internal"
    },
    {
      "pathID": "/net/http/pprof"
    }
  ]
}
