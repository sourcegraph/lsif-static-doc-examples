{
  "pathID": "/regexp",
  "documentation": {
    "identifier": "regexp",
    "newPage": true,
    "searchKey": "regexp",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package regexp"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package regexp implements regular expression search. \n\nThe syntax of the regular expressions accepted is the same general syntax used by Perl, Python, and other languages. More precisely, it is the syntax accepted by RE2 and described at [https://golang.org/s/re2syntax](https://golang.org/s/re2syntax), except for \\C. For an overview of the syntax, run \n\n```\ngo doc regexp/syntax\n\n```\nThe regexp implementation provided by this package is guaranteed to run in time linear in the size of the input. (This is a property not guaranteed by most open source implementations of regular expressions.) For more information about this property, see \n\n```\n[https://swtch.com/~rsc/regexp/regexp1.html](https://swtch.com/~rsc/regexp/regexp1.html)\n\n```\nor any book about automata theory. \n\nAll characters are UTF-8-encoded code points. \n\nThere are 16 methods of Regexp that match a regular expression and identify the matched text. Their names are matched by this regular expression: \n\n```\nFind(All)?(String)?(Submatch)?(Index)?\n\n```\nIf 'All' is present, the routine matches successive non-overlapping matches of the entire expression. Empty matches abutting a preceding match are ignored. The return value is a slice containing the successive return values of the corresponding non-'All' routine. These routines take an extra integer argument, n. If n >= 0, the function returns at most n matches/submatches; otherwise, it returns all of them. \n\nIf 'String' is present, the argument is a string; otherwise it is a slice of bytes; return values are adjusted as appropriate. \n\nIf 'Submatch' is present, the return value is a slice identifying the successive submatches of the expression. Submatches are matches of parenthesized subexpressions (also known as capturing groups) within the regular expression, numbered from left to right in order of opening parenthesis. Submatch 0 is the match of the entire expression, submatch 1 the match of the first parenthesized subexpression, and so on. \n\nIf 'Index' is present, matches and submatches are identified by byte index pairs within the input string: result[2*n:2*n+1] identifies the indexes of the nth submatch. The pair for n==0 identifies the match of the entire expression. If 'Index' is not present, the match is identified by the text of the match/submatch. If an index is negative or text is nil, it means that subexpression did not match any string in the input. For 'String' versions an empty string means either no match or an empty match. \n\nThere is also a subset of the methods that can be applied to text read from a RuneReader: \n\n```\nMatchReader, FindReaderIndex, FindReaderSubmatchIndex\n\n```\nThis set may grow. Note that regular expression matches may need to examine text beyond the text returned by a match, so the methods that match text from a RuneReader may read arbitrarily far into the input before returning. \n\n(There are a few other methods that do not match this pattern.) \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/regexp#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/regexp#visitedBits",
              "documentation": {
                "identifier": "visitedBits",
                "newPage": false,
                "searchKey": "regexp.visitedBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const visitedBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst visitedBits = 32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#maxBacktrackProg",
              "documentation": {
                "identifier": "maxBacktrackProg",
                "newPage": false,
                "searchKey": "regexp.maxBacktrackProg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxBacktrackProg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxBacktrackProg = 500 // len(prog.Inst) <= max\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#maxBacktrackVector",
              "documentation": {
                "identifier": "maxBacktrackVector",
                "newPage": false,
                "searchKey": "regexp.maxBacktrackVector",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxBacktrackVector"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxBacktrackVector = 256 * 1024 // bit vector size <= max (bits)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#mergeFailed",
              "documentation": {
                "identifier": "mergeFailed",
                "newPage": false,
                "searchKey": "regexp.mergeFailed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mergeFailed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mergeFailed = uint32(0xffffffff)\n```\n\nmergeRuneSets merges two non-intersecting runesets, and returns the merged result, and a NextIp array. The idea is that if a rune matches the OnePassRunes at index i, NextIp[i/2] is the target. If the input sets intersect, an empty runeset and a NextIp array with the single element mergeFailed is returned. The code assumes that both inputs contain ordered and non-intersecting rune pairs. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#endOfText",
              "documentation": {
                "identifier": "endOfText",
                "newPage": false,
                "searchKey": "regexp.endOfText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const endOfText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst endOfText rune = -1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#startSize",
              "documentation": {
                "identifier": "startSize",
                "newPage": false,
                "searchKey": "regexp.startSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const startSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst startSize = 10 // The size at which to start a slice in the 'All' routines.\n\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/regexp#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/regexp#bitStatePool",
              "documentation": {
                "identifier": "bitStatePool",
                "newPage": false,
                "searchKey": "regexp.bitStatePool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bitStatePool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bitStatePool sync.Pool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#onePassPool",
              "documentation": {
                "identifier": "onePassPool",
                "newPage": false,
                "searchKey": "regexp.onePassPool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var onePassPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar onePassPool sync.Pool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#arrayNoInts",
              "documentation": {
                "identifier": "arrayNoInts",
                "newPage": false,
                "searchKey": "regexp.arrayNoInts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var arrayNoInts"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar arrayNoInts [0]int\n```\n\narrayNoInts is returned by doExecute match if nil dstCap is passed to it with ncap=0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#noRune",
              "documentation": {
                "identifier": "noRune",
                "newPage": false,
                "searchKey": "regexp.noRune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var noRune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar noRune = []rune{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#noNext",
              "documentation": {
                "identifier": "noNext",
                "newPage": false,
                "searchKey": "regexp.noNext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var noNext"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar noNext = []uint32{mergeFailed}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#anyRuneNotNL",
              "documentation": {
                "identifier": "anyRuneNotNL",
                "newPage": false,
                "searchKey": "regexp.anyRuneNotNL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var anyRuneNotNL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar anyRuneNotNL = []rune{0, '\\n' - 1, '\\n' + 1, unicode.MaxRune}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#anyRune",
              "documentation": {
                "identifier": "anyRune",
                "newPage": false,
                "searchKey": "regexp.anyRune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var anyRune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar anyRune = []rune{0, unicode.MaxRune}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#matchSize",
              "documentation": {
                "identifier": "matchSize",
                "newPage": false,
                "searchKey": "regexp.matchSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var matchSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar matchSize = [...]int{128, 512, 2048, 16384, 0}\n```\n\nPools of *machine for use during (*Regexp).doExecute, split up by the size of the execution queues. matchPool[i] machines have queue size matchSize[i]. On a 64-bit system each queue entry is 16 bytes, so matchPool[0] has 16*2*128 = 4kB queues, etc. The final matchPool is a catch-all for very large queues. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#matchPool",
              "documentation": {
                "identifier": "matchPool",
                "newPage": false,
                "searchKey": "regexp.matchPool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var matchPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar matchPool [len(matchSize)]sync.Pool\n```\n\nPools of *machine for use during (*Regexp).doExecute, split up by the size of the execution queues. matchPool[i] machines have queue size matchSize[i]. On a 64-bit system each queue entry is 16 bytes, so matchPool[0] has 16*2*128 = 4kB queues, etc. The final matchPool is a catch-all for very large queues. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#specialBytes",
              "documentation": {
                "identifier": "specialBytes",
                "newPage": false,
                "searchKey": "regexp.specialBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var specialBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar specialBytes [16]byte\n```\n\nBitmap used by func special to check whether a character needs to be escaped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#goodRe",
              "documentation": {
                "identifier": "goodRe",
                "newPage": false,
                "searchKey": "regexp.goodRe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var goodRe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar goodRe = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#badRe",
              "documentation": {
                "identifier": "badRe",
                "newPage": false,
                "searchKey": "regexp.badRe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var badRe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badRe = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#replaceTests",
              "documentation": {
                "identifier": "replaceTests",
                "newPage": false,
                "searchKey": "regexp.replaceTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var replaceTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar replaceTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#replaceLiteralTests",
              "documentation": {
                "identifier": "replaceLiteralTests",
                "newPage": false,
                "searchKey": "regexp.replaceLiteralTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var replaceLiteralTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar replaceLiteralTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#replaceFuncTests",
              "documentation": {
                "identifier": "replaceFuncTests",
                "newPage": false,
                "searchKey": "regexp.replaceFuncTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var replaceFuncTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar replaceFuncTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#metaTests",
              "documentation": {
                "identifier": "metaTests",
                "newPage": false,
                "searchKey": "regexp.metaTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var metaTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar metaTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#literalPrefixTests",
              "documentation": {
                "identifier": "literalPrefixTests",
                "newPage": false,
                "searchKey": "regexp.literalPrefixTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var literalPrefixTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar literalPrefixTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#emptySubexpIndices",
              "documentation": {
                "identifier": "emptySubexpIndices",
                "newPage": false,
                "searchKey": "regexp.emptySubexpIndices",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var emptySubexpIndices"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar emptySubexpIndices = []subexpIndex{{\"\", -1}, {\"missing\", -1}}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#subexpCases",
              "documentation": {
                "identifier": "subexpCases",
                "newPage": false,
                "searchKey": "regexp.subexpCases",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var subexpCases"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar subexpCases = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#splitTests",
              "documentation": {
                "identifier": "splitTests",
                "newPage": false,
                "searchKey": "regexp.splitTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var splitTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar splitTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#sink",
              "documentation": {
                "identifier": "sink",
                "newPage": false,
                "searchKey": "regexp.sink",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sink"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sink string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#compileBenchData",
              "documentation": {
                "identifier": "compileBenchData",
                "newPage": false,
                "searchKey": "regexp.compileBenchData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var compileBenchData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar compileBenchData = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#minInputLenTests",
              "documentation": {
                "identifier": "minInputLenTests",
                "newPage": false,
                "searchKey": "regexp.minInputLenTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var minInputLenTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar minInputLenTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#run",
              "documentation": {
                "identifier": "run",
                "newPage": false,
                "searchKey": "regexp.run",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var run"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar run = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#match",
              "documentation": {
                "identifier": "match",
                "newPage": false,
                "searchKey": "regexp.match",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var match"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar match = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#notab",
              "documentation": {
                "identifier": "notab",
                "newPage": false,
                "searchKey": "regexp.notab",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var notab"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar notab = MustCompilePOSIX(`[^\\t]+`)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#text",
              "documentation": {
                "identifier": "text",
                "newPage": false,
                "searchKey": "regexp.text",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var text"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar text []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#benchData",
              "documentation": {
                "identifier": "benchData",
                "newPage": false,
                "searchKey": "regexp.benchData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var benchData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar benchData = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#benchSizes",
              "documentation": {
                "identifier": "benchSizes",
                "newPage": false,
                "searchKey": "regexp.benchSizes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var benchSizes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar benchSizes = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#findTests",
              "documentation": {
                "identifier": "findTests",
                "newPage": false,
                "searchKey": "regexp.findTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var findTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar findTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#runeMergeTests",
              "documentation": {
                "identifier": "runeMergeTests",
                "newPage": false,
                "searchKey": "regexp.runeMergeTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var runeMergeTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar runeMergeTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#onePassTests",
              "documentation": {
                "identifier": "onePassTests",
                "newPage": false,
                "searchKey": "regexp.onePassTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var onePassTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar onePassTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#onePassTests1",
              "documentation": {
                "identifier": "onePassTests1",
                "newPage": false,
                "searchKey": "regexp.onePassTests1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var onePassTests1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar onePassTests1 = []struct {\n\tre    string\n\tmatch string\n}{\n\t{`^a(/b+(#c+)*)*$`, \"a/b#c\"},\n}\n```\n\nTODO(cespare): Unify with onePassTests and rationalize one-pass test cases. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/regexp#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/regexp#job",
              "documentation": {
                "identifier": "job",
                "newPage": false,
                "searchKey": "regexp.job",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type job struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype job struct {\n\tpc  uint32\n\targ bool\n\tpos int\n}\n```\n\nA job is an entry on the backtracker's job stack. It holds the instruction pc and the position in the input. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#bitState",
              "documentation": {
                "identifier": "bitState",
                "newPage": false,
                "searchKey": "regexp.bitState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type bitState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bitState struct {\n\tend      int\n\tcap      []int\n\tmatchcap []int\n\tjobs     []job\n\tvisited  []uint32\n\n\tinputs inputs\n}\n```\n\nbitState holds state for the backtracker. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#newBitState",
                    "documentation": {
                      "identifier": "newBitState",
                      "newPage": false,
                      "searchKey": "regexp.newBitState",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newBitState() *bitState"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newBitState() *bitState\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#bitState.reset",
                    "documentation": {
                      "identifier": "bitState.reset",
                      "newPage": false,
                      "searchKey": "regexp.bitState.reset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *bitState) reset(prog *syntax.Prog, end int, ncap int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *bitState) reset(prog *syntax.Prog, end int, ncap int)\n```\n\nreset resets the state of the backtracker. end is the end position in the input. ncap is the number of captures. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#bitState.shouldVisit",
                    "documentation": {
                      "identifier": "bitState.shouldVisit",
                      "newPage": false,
                      "searchKey": "regexp.bitState.shouldVisit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *bitState) shouldVisit(pc uint32, pos int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *bitState) shouldVisit(pc uint32, pos int) bool\n```\n\nshouldVisit reports whether the combination of (pc, pos) has not been visited yet. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#bitState.push",
                    "documentation": {
                      "identifier": "bitState.push",
                      "newPage": false,
                      "searchKey": "regexp.bitState.push",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *bitState) push(re *Regexp, pc uint32, pos int, arg bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *bitState) push(re *Regexp, pc uint32, pos int, arg bool)\n```\n\npush pushes (pc, pos, arg) onto the job stack if it should be visited. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#queue",
              "documentation": {
                "identifier": "queue",
                "newPage": false,
                "searchKey": "regexp.queue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type queue struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype queue struct {\n\tsparse []uint32\n\tdense  []entry\n}\n```\n\nA queue is a 'sparse array' holding pending threads of execution. See [https://research.swtch.com/2008/03/using-uninitialized-memory-for-fun-and.html](https://research.swtch.com/2008/03/using-uninitialized-memory-for-fun-and.html) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#entry",
              "documentation": {
                "identifier": "entry",
                "newPage": false,
                "searchKey": "regexp.entry",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type entry struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype entry struct {\n\tpc uint32\n\tt  *thread\n}\n```\n\nAn entry is an entry on a queue. It holds both the instruction pc and the actual thread. Some queue entries are just place holders so that the machine knows it has considered that pc. Such entries have t == nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#thread",
              "documentation": {
                "identifier": "thread",
                "newPage": false,
                "searchKey": "regexp.thread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type thread struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype thread struct {\n\tinst *syntax.Inst\n\tcap  []int\n}\n```\n\nA thread is the state of a single path through the machine: an instruction and a corresponding capture array. See [https://swtch.com/~rsc/regexp/regexp2.html](https://swtch.com/~rsc/regexp/regexp2.html) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#machine",
              "documentation": {
                "identifier": "machine",
                "newPage": false,
                "searchKey": "regexp.machine",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type machine struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype machine struct {\n\tre       *Regexp      // corresponding Regexp\n\tp        *syntax.Prog // compiled program\n\tq0, q1   queue        // two queues for runq, nextq\n\tpool     []*thread    // pool of available threads\n\tmatched  bool         // whether a match was found\n\tmatchcap []int        // capture information for the match\n\n\tinputs inputs\n}\n```\n\nA machine holds all the state during an NFA simulation for p. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#machine.init",
                    "documentation": {
                      "identifier": "machine.init",
                      "newPage": false,
                      "searchKey": "regexp.machine.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *machine) init(ncap int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *machine) init(ncap int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#machine.alloc",
                    "documentation": {
                      "identifier": "machine.alloc",
                      "newPage": false,
                      "searchKey": "regexp.machine.alloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *machine) alloc(i *syntax.Inst) *thread"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *machine) alloc(i *syntax.Inst) *thread\n```\n\nalloc allocates a new thread with the given instruction. It uses the free pool if possible. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#machine.match",
                    "documentation": {
                      "identifier": "machine.match",
                      "newPage": false,
                      "searchKey": "regexp.machine.match",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *machine) match(i input, pos int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *machine) match(i input, pos int) bool\n```\n\nmatch runs the machine over the input starting at pos. It reports whether a match was found. If so, m.matchcap holds the submatch information. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#machine.clear",
                    "documentation": {
                      "identifier": "machine.clear",
                      "newPage": false,
                      "searchKey": "regexp.machine.clear",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *machine) clear(q *queue)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *machine) clear(q *queue)\n```\n\nclear frees all threads on the thread queue. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#machine.step",
                    "documentation": {
                      "identifier": "machine.step",
                      "newPage": false,
                      "searchKey": "regexp.machine.step",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *machine) step(runq, nextq *queue, pos, nextPos int, c rune, nextCond *lazyFlag)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *machine) step(runq, nextq *queue, pos, nextPos int, c rune, nextCond *lazyFlag)\n```\n\nstep executes one step of the machine, running each of the threads on runq and appending new threads to nextq. The step processes the rune c (which may be endOfText), which starts at position pos and ends at nextPos. nextCond gives the setting for the empty-width flags after c. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#machine.add",
                    "documentation": {
                      "identifier": "machine.add",
                      "newPage": false,
                      "searchKey": "regexp.machine.add",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *machine) add(q *queue, pc uint32, pos int, cap []int, cond *lazyFlag, t *thread) *thread"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *machine) add(q *queue, pc uint32, pos int, cap []int, cond *lazyFlag, t *thread) *thread\n```\n\nadd adds an entry to q for pc, unless the q already has such an entry. It also recursively adds an entry for all instructions reachable from pc by following empty-width conditions satisfied by cond.  pos gives the current position in the input. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#inputs",
              "documentation": {
                "identifier": "inputs",
                "newPage": false,
                "searchKey": "regexp.inputs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type inputs struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype inputs struct {\n\t// cached inputs, to avoid allocation\n\tbytes  inputBytes\n\tstring inputString\n\treader inputReader\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#inputs.newBytes",
                    "documentation": {
                      "identifier": "inputs.newBytes",
                      "newPage": false,
                      "searchKey": "regexp.inputs.newBytes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputs) newBytes(b []byte) input"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputs) newBytes(b []byte) input\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputs.newString",
                    "documentation": {
                      "identifier": "inputs.newString",
                      "newPage": false,
                      "searchKey": "regexp.inputs.newString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputs) newString(s string) input"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputs) newString(s string) input\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputs.newReader",
                    "documentation": {
                      "identifier": "inputs.newReader",
                      "newPage": false,
                      "searchKey": "regexp.inputs.newReader",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputs) newReader(r io.RuneReader) input"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputs) newReader(r io.RuneReader) input\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputs.clear",
                    "documentation": {
                      "identifier": "inputs.clear",
                      "newPage": false,
                      "searchKey": "regexp.inputs.clear",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputs) clear()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputs) clear()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputs.init",
                    "documentation": {
                      "identifier": "inputs.init",
                      "newPage": false,
                      "searchKey": "regexp.inputs.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputs) init(r io.RuneReader, b []byte, s string) (input, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputs) init(r io.RuneReader, b []byte, s string) (input, int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#lazyFlag",
              "documentation": {
                "identifier": "lazyFlag",
                "newPage": false,
                "searchKey": "regexp.lazyFlag",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type lazyFlag uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype lazyFlag uint64\n```\n\nA lazyFlag is a lazily-evaluated syntax.EmptyOp, for checking zero-width flags like ^ $ \\A \\z \\B \\b. It records the pair of relevant runes and does not determine the implied flags until absolutely necessary (most of the time, that means never). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#newLazyFlag",
                    "documentation": {
                      "identifier": "newLazyFlag",
                      "newPage": false,
                      "searchKey": "regexp.newLazyFlag",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newLazyFlag(r1, r2 rune) lazyFlag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newLazyFlag(r1, r2 rune) lazyFlag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#lazyFlag.match",
                    "documentation": {
                      "identifier": "lazyFlag.match",
                      "newPage": false,
                      "searchKey": "regexp.lazyFlag.match",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f lazyFlag) match(op syntax.EmptyOp) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f lazyFlag) match(op syntax.EmptyOp) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#onePassMachine",
              "documentation": {
                "identifier": "onePassMachine",
                "newPage": false,
                "searchKey": "regexp.onePassMachine",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type onePassMachine struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype onePassMachine struct {\n\tinputs   inputs\n\tmatchcap []int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#newOnePassMachine",
                    "documentation": {
                      "identifier": "newOnePassMachine",
                      "newPage": false,
                      "searchKey": "regexp.newOnePassMachine",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newOnePassMachine() *onePassMachine"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newOnePassMachine() *onePassMachine\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#onePassProg",
              "documentation": {
                "identifier": "onePassProg",
                "newPage": false,
                "searchKey": "regexp.onePassProg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type onePassProg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype onePassProg struct {\n\tInst   []onePassInst\n\tStart  int // index of start instruction\n\tNumCap int // number of InstCapture insts in re\n}\n```\n\nA onePassProg is a compiled one-pass regular expression program. It is the same as syntax.Prog except for the use of onePassInst. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#onePassCopy",
                    "documentation": {
                      "identifier": "onePassCopy",
                      "newPage": false,
                      "searchKey": "regexp.onePassCopy",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func onePassCopy(prog *syntax.Prog) *onePassProg"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc onePassCopy(prog *syntax.Prog) *onePassProg\n```\n\nonePassCopy creates a copy of the original Prog, as we'll be modifying it \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#makeOnePass",
                    "documentation": {
                      "identifier": "makeOnePass",
                      "newPage": false,
                      "searchKey": "regexp.makeOnePass",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeOnePass(p *onePassProg) *onePassProg"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeOnePass(p *onePassProg) *onePassProg\n```\n\nmakeOnePass creates a onepass Prog, if possible. It is possible if at any alt, the match engine can always tell which branch to take. The routine may modify p if it is turned into a onepass Prog. If it isn't possible for this to be a onepass Prog, the Prog nil is returned. makeOnePass is recursive to the size of the Prog. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#compileOnePass",
                    "documentation": {
                      "identifier": "compileOnePass",
                      "newPage": false,
                      "searchKey": "regexp.compileOnePass",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func compileOnePass(prog *syntax.Prog) (p *onePassProg)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc compileOnePass(prog *syntax.Prog) (p *onePassProg)\n```\n\ncompileOnePass returns a new *syntax.Prog suitable for onePass execution if the original Prog can be recharacterized as a one-pass regexp program, or syntax.nil if the Prog cannot be converted. For a one pass prog, the fundamental condition that must be true is: at any InstAlt, there must be no ambiguity about what branch to  take. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#onePassInst",
              "documentation": {
                "identifier": "onePassInst",
                "newPage": false,
                "searchKey": "regexp.onePassInst",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type onePassInst struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype onePassInst struct {\n\tsyntax.Inst\n\tNext []uint32\n}\n```\n\nA onePassInst is a single instruction in a one-pass regular expression program. It is the same as syntax.Inst except for the new 'Next' field. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#queueOnePass",
              "documentation": {
                "identifier": "queueOnePass",
                "newPage": false,
                "searchKey": "regexp.queueOnePass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type queueOnePass struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype queueOnePass struct {\n\tsparse          []uint32\n\tdense           []uint32\n\tsize, nextIndex uint32\n}\n```\n\nSparse Array implementation is used as a queueOnePass. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#newQueue",
                    "documentation": {
                      "identifier": "newQueue",
                      "newPage": false,
                      "searchKey": "regexp.newQueue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newQueue(size int) (q *queueOnePass)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newQueue(size int) (q *queueOnePass)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#queueOnePass.empty",
                    "documentation": {
                      "identifier": "queueOnePass.empty",
                      "newPage": false,
                      "searchKey": "regexp.queueOnePass.empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *queueOnePass) empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *queueOnePass) empty() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#queueOnePass.next",
                    "documentation": {
                      "identifier": "queueOnePass.next",
                      "newPage": false,
                      "searchKey": "regexp.queueOnePass.next",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *queueOnePass) next() (n uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *queueOnePass) next() (n uint32)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#queueOnePass.clear",
                    "documentation": {
                      "identifier": "queueOnePass.clear",
                      "newPage": false,
                      "searchKey": "regexp.queueOnePass.clear",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *queueOnePass) clear()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *queueOnePass) clear()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#queueOnePass.contains",
                    "documentation": {
                      "identifier": "queueOnePass.contains",
                      "newPage": false,
                      "searchKey": "regexp.queueOnePass.contains",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *queueOnePass) contains(u uint32) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *queueOnePass) contains(u uint32) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#queueOnePass.insert",
                    "documentation": {
                      "identifier": "queueOnePass.insert",
                      "newPage": false,
                      "searchKey": "regexp.queueOnePass.insert",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *queueOnePass) insert(u uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *queueOnePass) insert(u uint32)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#queueOnePass.insertNew",
                    "documentation": {
                      "identifier": "queueOnePass.insertNew",
                      "newPage": false,
                      "searchKey": "regexp.queueOnePass.insertNew",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *queueOnePass) insertNew(u uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *queueOnePass) insertNew(u uint32)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#runeSlice",
              "documentation": {
                "identifier": "runeSlice",
                "newPage": false,
                "searchKey": "regexp.runeSlice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type runeSlice []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype runeSlice []rune\n```\n\nruneSlice exists to permit sorting the case-folded rune sets. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#runeSlice.Len",
                    "documentation": {
                      "identifier": "runeSlice.Len",
                      "newPage": false,
                      "searchKey": "regexp.runeSlice.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p runeSlice) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p runeSlice) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#runeSlice.Less",
                    "documentation": {
                      "identifier": "runeSlice.Less",
                      "newPage": false,
                      "searchKey": "regexp.runeSlice.Less",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p runeSlice) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p runeSlice) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#runeSlice.Swap",
                    "documentation": {
                      "identifier": "runeSlice.Swap",
                      "newPage": false,
                      "searchKey": "regexp.runeSlice.Swap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p runeSlice) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p runeSlice) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#Regexp",
              "documentation": {
                "identifier": "Regexp",
                "newPage": false,
                "searchKey": "regexp.Regexp",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Regexp struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Regexp struct {\n\texpr           string       // as passed to Compile\n\tprog           *syntax.Prog // compiled program\n\tonepass        *onePassProg // onepass program or nil\n\tnumSubexp      int\n\tmaxBitStateLen int\n\tsubexpNames    []string\n\tprefix         string         // required prefix in unanchored matches\n\tprefixBytes    []byte         // prefix, as a []byte\n\tprefixRune     rune           // first rune in prefix\n\tprefixEnd      uint32         // pc for last rune in prefix\n\tmpool          int            // pool for machines\n\tmatchcap       int            // size of recorded match lengths\n\tprefixComplete bool           // prefix is the entire regexp\n\tcond           syntax.EmptyOp // empty-width conditions required at start of match\n\tminInputLen    int            // minimum length of the input in bytes\n\n\t// This field can be modified by the Longest method,\n\t// but it is otherwise read-only.\n\tlongest bool // whether regexp prefers leftmost-longest match\n}\n```\n\nRegexp is the representation of a compiled regular expression. A Regexp is safe for concurrent use by multiple goroutines, except for configuration methods, such as Longest. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#Compile",
                    "documentation": {
                      "identifier": "Compile",
                      "newPage": false,
                      "searchKey": "regexp.Compile",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Compile(expr string) (*Regexp, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Compile(expr string) (*Regexp, error)\n```\n\nCompile parses a regular expression and returns, if successful, a Regexp object that can be used to match against text. \n\nWhen matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses the one that a backtracking search would have found first. This so-called leftmost-first matching is the same semantics that Perl, Python, and other implementations use, although this package implements it without the expense of backtracking. For POSIX leftmost-longest matching, see CompilePOSIX. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#CompilePOSIX",
                    "documentation": {
                      "identifier": "CompilePOSIX",
                      "newPage": false,
                      "searchKey": "regexp.CompilePOSIX",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func CompilePOSIX(expr string) (*Regexp, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc CompilePOSIX(expr string) (*Regexp, error)\n```\n\nCompilePOSIX is like Compile but restricts the regular expression to POSIX ERE (egrep) syntax and changes the match semantics to leftmost-longest. \n\nThat is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This so-called leftmost-longest matching is the same semantics that early regular expression implementations used and that POSIX specifies. \n\nHowever, there can be multiple leftmost-longest matches, with different submatch choices, and here this package diverges from POSIX. Among the possible leftmost-longest matches, this package chooses the one that a backtracking search would have found first, while POSIX specifies that the match be chosen to maximize the length of the first subexpression, then the second, and so on from left to right. The POSIX rule is computationally prohibitive and not even well-defined. See [https://swtch.com/~rsc/regexp/regexp2.html#posix](https://swtch.com/~rsc/regexp/regexp2.html#posix) for details. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#compile",
                    "documentation": {
                      "identifier": "compile",
                      "newPage": false,
                      "searchKey": "regexp.compile",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func compile(expr string, mode syntax.Flags, longest bool) (*Regexp, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc compile(expr string, mode syntax.Flags, longest bool) (*Regexp, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#MustCompile",
                    "documentation": {
                      "identifier": "MustCompile",
                      "newPage": false,
                      "searchKey": "regexp.MustCompile",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MustCompile(str string) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MustCompile(str string) *Regexp\n```\n\nMustCompile is like Compile but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#MustCompilePOSIX",
                    "documentation": {
                      "identifier": "MustCompilePOSIX",
                      "newPage": false,
                      "searchKey": "regexp.MustCompilePOSIX",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MustCompilePOSIX(str string) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MustCompilePOSIX(str string) *Regexp\n```\n\nMustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed. It simplifies safe initialization of global variables holding compiled regular expressions. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#compileTest",
                    "documentation": {
                      "identifier": "compileTest",
                      "newPage": false,
                      "searchKey": "regexp.compileTest",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func compileTest(t *testing.T, expr string, error string) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc compileTest(t *testing.T, expr string, error string) *Regexp\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#tryCompile",
                    "documentation": {
                      "identifier": "tryCompile",
                      "newPage": false,
                      "searchKey": "regexp.tryCompile",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tryCompile(s string) (re *Regexp, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tryCompile(s string) (re *Regexp, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.tryBacktrack",
                    "documentation": {
                      "identifier": "Regexp.tryBacktrack",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.tryBacktrack",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) tryBacktrack(b *bitState, i input, pc uint32, pos int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) tryBacktrack(b *bitState, i input, pc uint32, pos int) bool\n```\n\ntryBacktrack runs a backtracking search starting at pos. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.backtrack",
                    "documentation": {
                      "identifier": "Regexp.backtrack",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.backtrack",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) backtrack(ib []byte, is string, pos int, ncap int, dstCap []int) []int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) backtrack(ib []byte, is string, pos int, ncap int, dstCap []int) []int\n```\n\nbacktrack runs a backtracking search of prog on the input starting at pos. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.doOnePass",
                    "documentation": {
                      "identifier": "Regexp.doOnePass",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.doOnePass",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) doOnePass(ir io.RuneReader, ib []byte, is string, pos, ncap int, dstCap []int) []int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) doOnePass(ir io.RuneReader, ib []byte, is string, pos, ncap int, dstCap []int) []int\n```\n\ndoOnePass implements r.doExecute using the one-pass execution engine. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.doMatch",
                    "documentation": {
                      "identifier": "Regexp.doMatch",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.doMatch",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) doMatch(r io.RuneReader, b []byte, s string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) doMatch(r io.RuneReader, b []byte, s string) bool\n```\n\ndoMatch reports whether either r, b or s match the regexp. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.doExecute",
                    "documentation": {
                      "identifier": "Regexp.doExecute",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.doExecute",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) doExecute(r io.RuneReader, b []byte, s string, pos int, ncap int, dstCap []int) []int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) doExecute(r io.RuneReader, b []byte, s string, pos int, ncap int, dstCap []int) []int\n```\n\ndoExecute finds the leftmost match in the input, appends the position of its subexpressions to dstCap and returns dstCap. \n\nnil is returned if no matches are found and non-nil if matches are found. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.String",
                    "documentation": {
                      "identifier": "Regexp.String",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) String() string\n```\n\nString returns the source text used to compile the regular expression. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.Copy",
                    "documentation": {
                      "identifier": "Regexp.Copy",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.Copy",
                      "tags": [
                        "exported",
                        "deprecated"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) Copy() *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) Copy() *Regexp\n```\n\nCopy returns a new Regexp object copied from re. Calling Longest on one copy does not affect another. \n\nDeprecated: In earlier releases, when using a Regexp in multiple goroutines, giving each goroutine its own copy helped to avoid lock contention. As of Go 1.12, using Copy is no longer necessary to avoid lock contention. Copy may still be appropriate if the reason for its use is to make two copies with different Longest settings. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.Longest",
                    "documentation": {
                      "identifier": "Regexp.Longest",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.Longest",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) Longest()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) Longest()\n```\n\nLongest makes future searches prefer the leftmost-longest match. That is, when matching against text, the regexp returns a match that begins as early as possible in the input (leftmost), and among those it chooses a match that is as long as possible. This method modifies the Regexp and may not be called concurrently with any other methods. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.get",
                    "documentation": {
                      "identifier": "Regexp.get",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.get",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) get() *machine"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) get() *machine\n```\n\nget returns a machine to use for matching re. It uses the re's machine cache if possible, to avoid unnecessary allocation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.put",
                    "documentation": {
                      "identifier": "Regexp.put",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.put",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) put(m *machine)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) put(m *machine)\n```\n\nput returns a machine to the correct machine pool. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.NumSubexp",
                    "documentation": {
                      "identifier": "Regexp.NumSubexp",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.NumSubexp",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) NumSubexp() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) NumSubexp() int\n```\n\nNumSubexp returns the number of parenthesized subexpressions in this Regexp. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.SubexpNames",
                    "documentation": {
                      "identifier": "Regexp.SubexpNames",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.SubexpNames",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) SubexpNames() []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) SubexpNames() []string\n```\n\nSubexpNames returns the names of the parenthesized subexpressions in this Regexp. The name for the first sub-expression is names[1], so that if m is a match slice, the name for m[i] is SubexpNames()[i]. Since the Regexp as a whole cannot be named, names[0] is always the empty string. The slice should not be modified. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.SubexpIndex",
                    "documentation": {
                      "identifier": "Regexp.SubexpIndex",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.SubexpIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) SubexpIndex(name string) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) SubexpIndex(name string) int\n```\n\nSubexpIndex returns the index of the first subexpression with the given name, or -1 if there is no subexpression with that name. \n\nNote that multiple subexpressions can be written using the same name, as in (?P<bob>a+)(?P<bob>b+), which declares two subexpressions named \"bob\". In this case, SubexpIndex returns the index of the leftmost such subexpression in the regular expression. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.LiteralPrefix",
                    "documentation": {
                      "identifier": "Regexp.LiteralPrefix",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.LiteralPrefix",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) LiteralPrefix() (prefix string, complete bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) LiteralPrefix() (prefix string, complete bool)\n```\n\nLiteralPrefix returns a literal string that must begin any match of the regular expression re. It returns the boolean true if the literal string comprises the entire regular expression. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.MatchReader",
                    "documentation": {
                      "identifier": "Regexp.MatchReader",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.MatchReader",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) MatchReader(r io.RuneReader) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) MatchReader(r io.RuneReader) bool\n```\n\nMatchReader reports whether the text returned by the RuneReader contains any match of the regular expression re. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.MatchString",
                    "documentation": {
                      "identifier": "Regexp.MatchString",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.MatchString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) MatchString(s string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) MatchString(s string) bool\n```\n\nMatchString reports whether the string s contains any match of the regular expression re. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.Match",
                    "documentation": {
                      "identifier": "Regexp.Match",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.Match",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) Match(b []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) Match(b []byte) bool\n```\n\nMatch reports whether the byte slice b contains any match of the regular expression re. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.ReplaceAllString",
                    "documentation": {
                      "identifier": "Regexp.ReplaceAllString",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.ReplaceAllString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) ReplaceAllString(src, repl string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) ReplaceAllString(src, repl string) string\n```\n\nReplaceAllString returns a copy of src, replacing matches of the Regexp with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.ReplaceAllLiteralString",
                    "documentation": {
                      "identifier": "Regexp.ReplaceAllLiteralString",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.ReplaceAllLiteralString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) ReplaceAllLiteralString(src, repl string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) ReplaceAllLiteralString(src, repl string) string\n```\n\nReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp with the replacement string repl. The replacement repl is substituted directly, without using Expand. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.ReplaceAllStringFunc",
                    "documentation": {
                      "identifier": "Regexp.ReplaceAllStringFunc",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.ReplaceAllStringFunc",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string\n```\n\nReplaceAllStringFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched substring. The replacement returned by repl is substituted directly, without using Expand. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.replaceAll",
                    "documentation": {
                      "identifier": "Regexp.replaceAll",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.replaceAll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) replaceAll(bsrc []byte, src string, nmatch int, repl func(dst []byte, m []int) []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) replaceAll(bsrc []byte, src string, nmatch int, repl func(dst []byte, m []int) []byte) []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.ReplaceAll",
                    "documentation": {
                      "identifier": "Regexp.ReplaceAll",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.ReplaceAll",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) ReplaceAll(src, repl []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) ReplaceAll(src, repl []byte) []byte\n```\n\nReplaceAll returns a copy of src, replacing matches of the Regexp with the replacement text repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.ReplaceAllLiteral",
                    "documentation": {
                      "identifier": "Regexp.ReplaceAllLiteral",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.ReplaceAllLiteral",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte\n```\n\nReplaceAllLiteral returns a copy of src, replacing matches of the Regexp with the replacement bytes repl. The replacement repl is substituted directly, without using Expand. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.ReplaceAllFunc",
                    "documentation": {
                      "identifier": "Regexp.ReplaceAllFunc",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.ReplaceAllFunc",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte\n```\n\nReplaceAllFunc returns a copy of src in which all matches of the Regexp have been replaced by the return value of function repl applied to the matched byte slice. The replacement returned by repl is substituted directly, without using Expand. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.pad",
                    "documentation": {
                      "identifier": "Regexp.pad",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.pad",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) pad(a []int) []int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) pad(a []int) []int\n```\n\nThe number of capture values in the program may correspond to fewer capturing expressions than are in the regexp. For example, \"(a){0}\" turns into an empty program, so the maximum capture in the program is 0 but we need to return an expression for \\1.  Pad appends -1s to the slice a as needed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.allMatches",
                    "documentation": {
                      "identifier": "Regexp.allMatches",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.allMatches",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) allMatches(s string, b []byte, n int, deliver func([]int))"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) allMatches(s string, b []byte, n int, deliver func([]int))\n```\n\nallMatches calls deliver at most n times with the location of successive matches in the input text. The input text is b if non-nil, otherwise s. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.Find",
                    "documentation": {
                      "identifier": "Regexp.Find",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.Find",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) Find(b []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) Find(b []byte) []byte\n```\n\nFind returns a slice holding the text of the leftmost match in b of the regular expression. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindIndex",
                    "documentation": {
                      "identifier": "Regexp.FindIndex",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindIndex(b []byte) (loc []int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindIndex(b []byte) (loc []int)\n```\n\nFindIndex returns a two-element slice of integers defining the location of the leftmost match in b of the regular expression. The match itself is at b[loc[0]:loc[1]]. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindString",
                    "documentation": {
                      "identifier": "Regexp.FindString",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindString(s string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindString(s string) string\n```\n\nFindString returns a string holding the text of the leftmost match in s of the regular expression. If there is no match, the return value is an empty string, but it will also be empty if the regular expression successfully matches an empty string. Use FindStringIndex or FindStringSubmatch if it is necessary to distinguish these cases. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindStringIndex",
                    "documentation": {
                      "identifier": "Regexp.FindStringIndex",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindStringIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindStringIndex(s string) (loc []int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindStringIndex(s string) (loc []int)\n```\n\nFindStringIndex returns a two-element slice of integers defining the location of the leftmost match in s of the regular expression. The match itself is at s[loc[0]:loc[1]]. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindReaderIndex",
                    "documentation": {
                      "identifier": "Regexp.FindReaderIndex",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindReaderIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)\n```\n\nFindReaderIndex returns a two-element slice of integers defining the location of the leftmost match of the regular expression in text read from the RuneReader. The match text was found in the input stream at byte offset loc[0] through loc[1]-1. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindSubmatch",
                    "documentation": {
                      "identifier": "Regexp.FindSubmatch",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindSubmatch",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindSubmatch(b []byte) [][]byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindSubmatch(b []byte) [][]byte\n```\n\nFindSubmatch returns a slice of slices holding the text of the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' descriptions in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.Expand",
                    "documentation": {
                      "identifier": "Regexp.Expand",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.Expand",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte\n```\n\nExpand appends template to dst and returns the result; during the append, Expand replaces variables in the template with corresponding matches drawn from src. The match slice should have been returned by FindSubmatchIndex. \n\nIn the template, a variable is denoted by a substring of the form $name or ${name}, where name is a non-empty sequence of letters, digits, and underscores. A purely numeric name like $1 refers to the submatch with the corresponding index; other names refer to capturing parentheses named with the (?P<name>...) syntax. A reference to an out of range or unmatched index or a name that is not present in the regular expression is replaced with an empty slice. \n\nIn the $name form, name is taken to be as long as possible: $1x is equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0. \n\nTo insert a literal $ in the output, use $$ in the template. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.ExpandString",
                    "documentation": {
                      "identifier": "Regexp.ExpandString",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.ExpandString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte\n```\n\nExpandString is like Expand but the template and source are strings. It appends to and returns a byte slice in order to give the calling code control over allocation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.expand",
                    "documentation": {
                      "identifier": "Regexp.expand",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.expand",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src string, match []int) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) expand(dst []byte, template string, bsrc []byte, src string, match []int) []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindSubmatchIndex",
                    "documentation": {
                      "identifier": "Regexp.FindSubmatchIndex",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindSubmatchIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindSubmatchIndex(b []byte) []int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindSubmatchIndex(b []byte) []int\n```\n\nFindSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in b and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindStringSubmatch",
                    "documentation": {
                      "identifier": "Regexp.FindStringSubmatch",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindStringSubmatch",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindStringSubmatch(s string) []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindStringSubmatch(s string) []string\n```\n\nFindStringSubmatch returns a slice of strings holding the text of the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' description in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindStringSubmatchIndex",
                    "documentation": {
                      "identifier": "Regexp.FindStringSubmatchIndex",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindStringSubmatchIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindStringSubmatchIndex(s string) []int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindStringSubmatchIndex(s string) []int\n```\n\nFindStringSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression in s and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindReaderSubmatchIndex",
                    "documentation": {
                      "identifier": "Regexp.FindReaderSubmatchIndex",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindReaderSubmatchIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int\n```\n\nFindReaderSubmatchIndex returns a slice holding the index pairs identifying the leftmost match of the regular expression of text read by the RuneReader, and the matches, if any, of its subexpressions, as defined by the 'Submatch' and 'Index' descriptions in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindAll",
                    "documentation": {
                      "identifier": "Regexp.FindAll",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindAll",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindAll(b []byte, n int) [][]byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindAll(b []byte, n int) [][]byte\n```\n\nFindAll is the 'All' version of Find; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindAllIndex",
                    "documentation": {
                      "identifier": "Regexp.FindAllIndex",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindAllIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindAllIndex(b []byte, n int) [][]int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindAllIndex(b []byte, n int) [][]int\n```\n\nFindAllIndex is the 'All' version of FindIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindAllString",
                    "documentation": {
                      "identifier": "Regexp.FindAllString",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindAllString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindAllString(s string, n int) []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindAllString(s string, n int) []string\n```\n\nFindAllString is the 'All' version of FindString; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindAllStringIndex",
                    "documentation": {
                      "identifier": "Regexp.FindAllStringIndex",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindAllStringIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindAllStringIndex(s string, n int) [][]int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindAllStringIndex(s string, n int) [][]int\n```\n\nFindAllStringIndex is the 'All' version of FindStringIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindAllSubmatch",
                    "documentation": {
                      "identifier": "Regexp.FindAllSubmatch",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindAllSubmatch",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte\n```\n\nFindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindAllSubmatchIndex",
                    "documentation": {
                      "identifier": "Regexp.FindAllSubmatchIndex",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindAllSubmatchIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int\n```\n\nFindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindAllStringSubmatch",
                    "documentation": {
                      "identifier": "Regexp.FindAllStringSubmatch",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindAllStringSubmatch",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string\n```\n\nFindAllStringSubmatch is the 'All' version of FindStringSubmatch; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.FindAllStringSubmatchIndex",
                    "documentation": {
                      "identifier": "Regexp.FindAllStringSubmatchIndex",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.FindAllStringSubmatchIndex",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int\n```\n\nFindAllStringSubmatchIndex is the 'All' version of FindStringSubmatchIndex; it returns a slice of all successive matches of the expression, as defined by the 'All' description in the package comment. A return value of nil indicates no match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#Regexp.Split",
                    "documentation": {
                      "identifier": "Regexp.Split",
                      "newPage": false,
                      "searchKey": "regexp.Regexp.Split",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) Split(s string, n int) []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) Split(s string, n int) []string\n```\n\nSplit slices s into substrings separated by the expression and returns a slice of the substrings between those expression matches. \n\nThe slice returned by this method consists of all the substrings of s not contained in the slice returned by FindAllString. When called on an expression that contains no metacharacters, it is equivalent to strings.SplitN. \n\nExample: \n\n```\ns := regexp.MustCompile(\"a*\").Split(\"abaabaccadaaae\", 5)\n// s: [\"\", \"b\", \"b\", \"c\", \"cadaaae\"]\n\n```\nThe count determines the number of substrings to return: \n\n```\nn > 0: at most n substrings; the last substring will be the unsplit remainder.\nn == 0: the result is nil (zero substrings)\nn < 0: all substrings\n\n```\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#input",
              "documentation": {
                "identifier": "input",
                "newPage": false,
                "searchKey": "regexp.input",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type input interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype input interface {\n\tstep(pos int) (r rune, width int) // advance one rune\n\tcanCheckPrefix() bool             // can we look ahead without losing info?\n\thasPrefix(re *Regexp) bool\n\tindex(re *Regexp, pos int) int\n\tcontext(pos int) lazyFlag\n}\n```\n\ninput abstracts different representations of the input text. It provides one-character lookahead. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#inputString",
              "documentation": {
                "identifier": "inputString",
                "newPage": false,
                "searchKey": "regexp.inputString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type inputString struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype inputString struct {\n\tstr string\n}\n```\n\ninputString scans a string. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#inputString.step",
                    "documentation": {
                      "identifier": "inputString.step",
                      "newPage": false,
                      "searchKey": "regexp.inputString.step",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputString) step(pos int) (rune, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputString) step(pos int) (rune, int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputString.canCheckPrefix",
                    "documentation": {
                      "identifier": "inputString.canCheckPrefix",
                      "newPage": false,
                      "searchKey": "regexp.inputString.canCheckPrefix",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputString) canCheckPrefix() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputString) canCheckPrefix() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputString.hasPrefix",
                    "documentation": {
                      "identifier": "inputString.hasPrefix",
                      "newPage": false,
                      "searchKey": "regexp.inputString.hasPrefix",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputString) hasPrefix(re *Regexp) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputString) hasPrefix(re *Regexp) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputString.index",
                    "documentation": {
                      "identifier": "inputString.index",
                      "newPage": false,
                      "searchKey": "regexp.inputString.index",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputString) index(re *Regexp, pos int) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputString) index(re *Regexp, pos int) int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputString.context",
                    "documentation": {
                      "identifier": "inputString.context",
                      "newPage": false,
                      "searchKey": "regexp.inputString.context",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputString) context(pos int) lazyFlag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputString) context(pos int) lazyFlag\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#inputBytes",
              "documentation": {
                "identifier": "inputBytes",
                "newPage": false,
                "searchKey": "regexp.inputBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type inputBytes struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype inputBytes struct {\n\tstr []byte\n}\n```\n\ninputBytes scans a byte slice. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#inputBytes.step",
                    "documentation": {
                      "identifier": "inputBytes.step",
                      "newPage": false,
                      "searchKey": "regexp.inputBytes.step",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputBytes) step(pos int) (rune, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputBytes) step(pos int) (rune, int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputBytes.canCheckPrefix",
                    "documentation": {
                      "identifier": "inputBytes.canCheckPrefix",
                      "newPage": false,
                      "searchKey": "regexp.inputBytes.canCheckPrefix",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputBytes) canCheckPrefix() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputBytes) canCheckPrefix() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputBytes.hasPrefix",
                    "documentation": {
                      "identifier": "inputBytes.hasPrefix",
                      "newPage": false,
                      "searchKey": "regexp.inputBytes.hasPrefix",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputBytes) hasPrefix(re *Regexp) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputBytes) hasPrefix(re *Regexp) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputBytes.index",
                    "documentation": {
                      "identifier": "inputBytes.index",
                      "newPage": false,
                      "searchKey": "regexp.inputBytes.index",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputBytes) index(re *Regexp, pos int) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputBytes) index(re *Regexp, pos int) int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputBytes.context",
                    "documentation": {
                      "identifier": "inputBytes.context",
                      "newPage": false,
                      "searchKey": "regexp.inputBytes.context",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputBytes) context(pos int) lazyFlag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputBytes) context(pos int) lazyFlag\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#inputReader",
              "documentation": {
                "identifier": "inputReader",
                "newPage": false,
                "searchKey": "regexp.inputReader",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type inputReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype inputReader struct {\n\tr     io.RuneReader\n\tatEOT bool\n\tpos   int\n}\n```\n\ninputReader scans a RuneReader. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#inputReader.step",
                    "documentation": {
                      "identifier": "inputReader.step",
                      "newPage": false,
                      "searchKey": "regexp.inputReader.step",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputReader) step(pos int) (rune, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputReader) step(pos int) (rune, int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputReader.canCheckPrefix",
                    "documentation": {
                      "identifier": "inputReader.canCheckPrefix",
                      "newPage": false,
                      "searchKey": "regexp.inputReader.canCheckPrefix",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputReader) canCheckPrefix() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputReader) canCheckPrefix() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputReader.hasPrefix",
                    "documentation": {
                      "identifier": "inputReader.hasPrefix",
                      "newPage": false,
                      "searchKey": "regexp.inputReader.hasPrefix",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputReader) hasPrefix(re *Regexp) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputReader) hasPrefix(re *Regexp) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputReader.index",
                    "documentation": {
                      "identifier": "inputReader.index",
                      "newPage": false,
                      "searchKey": "regexp.inputReader.index",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputReader) index(re *Regexp, pos int) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputReader) index(re *Regexp, pos int) int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/regexp#inputReader.context",
                    "documentation": {
                      "identifier": "inputReader.context",
                      "newPage": false,
                      "searchKey": "regexp.inputReader.context",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *inputReader) context(pos int) lazyFlag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *inputReader) context(pos int) lazyFlag\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/regexp#stringError",
              "documentation": {
                "identifier": "stringError",
                "newPage": false,
                "searchKey": "regexp.stringError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stringError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stringError struct {\n\tre  string\n\terr string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#ReplaceTest",
              "documentation": {
                "identifier": "ReplaceTest",
                "newPage": false,
                "searchKey": "regexp.ReplaceTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ReplaceTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ReplaceTest struct {\n\tpattern, replacement, input, output string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#ReplaceFuncTest",
              "documentation": {
                "identifier": "ReplaceFuncTest",
                "newPage": false,
                "searchKey": "regexp.ReplaceFuncTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ReplaceFuncTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ReplaceFuncTest struct {\n\tpattern       string\n\treplacement   func(string) string\n\tinput, output string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#MetaTest",
              "documentation": {
                "identifier": "MetaTest",
                "newPage": false,
                "searchKey": "regexp.MetaTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type MetaTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype MetaTest struct {\n\tpattern, output, literal string\n\tisLiteral                bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#subexpIndex",
              "documentation": {
                "identifier": "subexpIndex",
                "newPage": false,
                "searchKey": "regexp.subexpIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type subexpIndex struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype subexpIndex struct {\n\tname  string\n\tindex int\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#subexpCase",
              "documentation": {
                "identifier": "subexpCase",
                "newPage": false,
                "searchKey": "regexp.subexpCase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type subexpCase struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype subexpCase struct {\n\tinput   string\n\tnum     int\n\tnames   []string\n\tindices []subexpIndex\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#FindTest",
              "documentation": {
                "identifier": "FindTest",
                "newPage": false,
                "searchKey": "regexp.FindTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type FindTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FindTest struct {\n\tpat     string\n\ttext    string\n\tmatches [][]int\n}\n```\n\nFor each pattern/text pair, what is the expected output of each function? We can derive the textual results from the indexed results, the non-submatch results from the submatched results, the single results from the 'all' results, and the byte results from the string results. Therefore the table includes only the FindAllStringSubmatchIndex result. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/regexp#FindTest.String",
                    "documentation": {
                      "identifier": "FindTest.String",
                      "newPage": false,
                      "searchKey": "regexp.FindTest.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t FindTest) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t FindTest) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/regexp#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/regexp#freeBitState",
              "documentation": {
                "identifier": "freeBitState",
                "newPage": false,
                "searchKey": "regexp.freeBitState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func freeBitState(b *bitState)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc freeBitState(b *bitState)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#maxBitStateLen",
              "documentation": {
                "identifier": "maxBitStateLen",
                "newPage": false,
                "searchKey": "regexp.maxBitStateLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func maxBitStateLen(prog *syntax.Prog) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc maxBitStateLen(prog *syntax.Prog) int\n```\n\nmaxBitStateLen returns the maximum length of a string to search with the backtracker using prog. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#shouldBacktrack",
              "documentation": {
                "identifier": "shouldBacktrack",
                "newPage": false,
                "searchKey": "regexp.shouldBacktrack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func shouldBacktrack(prog *syntax.Prog) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc shouldBacktrack(prog *syntax.Prog) bool\n```\n\nshouldBacktrack reports whether the program is too long for the backtracker to run. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#freeOnePassMachine",
              "documentation": {
                "identifier": "freeOnePassMachine",
                "newPage": false,
                "searchKey": "regexp.freeOnePassMachine",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func freeOnePassMachine(m *onePassMachine)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc freeOnePassMachine(m *onePassMachine)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#onePassPrefix",
              "documentation": {
                "identifier": "onePassPrefix",
                "newPage": false,
                "searchKey": "regexp.onePassPrefix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func onePassPrefix(p *syntax.Prog) (prefix string, complete bool, pc uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc onePassPrefix(p *syntax.Prog) (prefix string, complete bool, pc uint32)\n```\n\nOnePassPrefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match. Pc is the index of the last rune instruction in the string. The OnePassPrefix skips over the mandatory EmptyBeginText \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#onePassNext",
              "documentation": {
                "identifier": "onePassNext",
                "newPage": false,
                "searchKey": "regexp.onePassNext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func onePassNext(i *onePassInst, r rune) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc onePassNext(i *onePassInst, r rune) uint32\n```\n\nOnePassNext selects the next actionable state of the prog, based on the input character. It should only be called when i.Op == InstAlt or InstAltMatch, and from the one-pass machine. One of the alternates may ultimately lead without input to end of line. If the instruction is InstAltMatch the path to the InstMatch is in i.Out, the normal node in i.Next. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#iop",
              "documentation": {
                "identifier": "iop",
                "newPage": false,
                "searchKey": "regexp.iop",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func iop(i *syntax.Inst) syntax.InstOp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc iop(i *syntax.Inst) syntax.InstOp\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#mergeRuneSets",
              "documentation": {
                "identifier": "mergeRuneSets",
                "newPage": false,
                "searchKey": "regexp.mergeRuneSets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mergeRuneSets(leftRunes, rightRunes *[]rune, leftPC, rightPC uint32) ([]rune, []uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mergeRuneSets(leftRunes, rightRunes *[]rune, leftPC, rightPC uint32) ([]rune, []uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#cleanupOnePass",
              "documentation": {
                "identifier": "cleanupOnePass",
                "newPage": false,
                "searchKey": "regexp.cleanupOnePass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cleanupOnePass(prog *onePassProg, original *syntax.Prog)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cleanupOnePass(prog *onePassProg, original *syntax.Prog)\n```\n\ncleanupOnePass drops working memory, and restores certain shortcut instructions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#minInputLen",
              "documentation": {
                "identifier": "minInputLen",
                "newPage": false,
                "searchKey": "regexp.minInputLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func minInputLen(re *syntax.Regexp) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc minInputLen(re *syntax.Regexp) int\n```\n\nminInputLen walks the regexp to find the minimum length of any matchable input \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#quote",
              "documentation": {
                "identifier": "quote",
                "newPage": false,
                "searchKey": "regexp.quote",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func quote(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc quote(s string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#MatchReader",
              "documentation": {
                "identifier": "MatchReader",
                "newPage": false,
                "searchKey": "regexp.MatchReader",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MatchReader(pattern string, r io.RuneReader) (matched bool, err error)\n```\n\nMatchReader reports whether the text returned by the RuneReader contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#MatchString",
              "documentation": {
                "identifier": "MatchString",
                "newPage": false,
                "searchKey": "regexp.MatchString",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func MatchString(pattern string, s string) (matched bool, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MatchString(pattern string, s string) (matched bool, err error)\n```\n\nMatchString reports whether the string s contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#Match",
              "documentation": {
                "identifier": "Match",
                "newPage": false,
                "searchKey": "regexp.Match",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Match(pattern string, b []byte) (matched bool, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Match(pattern string, b []byte) (matched bool, err error)\n```\n\nMatch reports whether the byte slice b contains any match of the regular expression pattern. More complicated queries need to use Compile and the full Regexp interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#special",
              "documentation": {
                "identifier": "special",
                "newPage": false,
                "searchKey": "regexp.special",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func special(b byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc special(b byte) bool\n```\n\nspecial reports whether byte b needs to be escaped by QuoteMeta. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "regexp.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#QuoteMeta",
              "documentation": {
                "identifier": "QuoteMeta",
                "newPage": false,
                "searchKey": "regexp.QuoteMeta",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func QuoteMeta(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc QuoteMeta(s string) string\n```\n\nQuoteMeta returns a string that escapes all regular expression metacharacters inside the argument text; the returned string is a regular expression matching the literal text. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#extract",
              "documentation": {
                "identifier": "extract",
                "newPage": false,
                "searchKey": "regexp.extract",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func extract(str string) (name string, num int, rest string, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc extract(str string) (name string, num int, rest string, ok bool)\n```\n\nextract returns the name from a leading \"$name\" or \"${name}\" in str. If it is a number, extract returns num set to that number; otherwise num = -1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestGoodCompile",
              "documentation": {
                "identifier": "TestGoodCompile",
                "newPage": false,
                "searchKey": "regexp.TestGoodCompile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGoodCompile(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGoodCompile(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestBadCompile",
              "documentation": {
                "identifier": "TestBadCompile",
                "newPage": false,
                "searchKey": "regexp.TestBadCompile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBadCompile(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBadCompile(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#matchTest",
              "documentation": {
                "identifier": "matchTest",
                "newPage": false,
                "searchKey": "regexp.matchTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func matchTest(t *testing.T, test *FindTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc matchTest(t *testing.T, test *FindTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestMatch",
              "documentation": {
                "identifier": "TestMatch",
                "newPage": false,
                "searchKey": "regexp.TestMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMatch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMatch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#matchFunctionTest",
              "documentation": {
                "identifier": "matchFunctionTest",
                "newPage": false,
                "searchKey": "regexp.matchFunctionTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func matchFunctionTest(t *testing.T, test *FindTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc matchFunctionTest(t *testing.T, test *FindTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestMatchFunction",
              "documentation": {
                "identifier": "TestMatchFunction",
                "newPage": false,
                "searchKey": "regexp.TestMatchFunction",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMatchFunction(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMatchFunction(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#copyMatchTest",
              "documentation": {
                "identifier": "copyMatchTest",
                "newPage": false,
                "searchKey": "regexp.copyMatchTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func copyMatchTest(t *testing.T, test *FindTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc copyMatchTest(t *testing.T, test *FindTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestCopyMatch",
              "documentation": {
                "identifier": "TestCopyMatch",
                "newPage": false,
                "searchKey": "regexp.TestCopyMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCopyMatch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCopyMatch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestReplaceAll",
              "documentation": {
                "identifier": "TestReplaceAll",
                "newPage": false,
                "searchKey": "regexp.TestReplaceAll",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReplaceAll(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReplaceAll(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestReplaceAllLiteral",
              "documentation": {
                "identifier": "TestReplaceAllLiteral",
                "newPage": false,
                "searchKey": "regexp.TestReplaceAllLiteral",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReplaceAllLiteral(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReplaceAllLiteral(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestReplaceAllFunc",
              "documentation": {
                "identifier": "TestReplaceAllFunc",
                "newPage": false,
                "searchKey": "regexp.TestReplaceAllFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReplaceAllFunc(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReplaceAllFunc(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestQuoteMeta",
              "documentation": {
                "identifier": "TestQuoteMeta",
                "newPage": false,
                "searchKey": "regexp.TestQuoteMeta",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestQuoteMeta(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestQuoteMeta(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestLiteralPrefix",
              "documentation": {
                "identifier": "TestLiteralPrefix",
                "newPage": false,
                "searchKey": "regexp.TestLiteralPrefix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLiteralPrefix(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLiteralPrefix(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestSubexp",
              "documentation": {
                "identifier": "TestSubexp",
                "newPage": false,
                "searchKey": "regexp.TestSubexp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSubexp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSubexp(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestSplit",
              "documentation": {
                "identifier": "TestSplit",
                "newPage": false,
                "searchKey": "regexp.TestSplit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSplit(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSplit(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestParseAndCompile",
              "documentation": {
                "identifier": "TestParseAndCompile",
                "newPage": false,
                "searchKey": "regexp.TestParseAndCompile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseAndCompile(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseAndCompile(t *testing.T)\n```\n\nThe following sequence of Match calls used to panic. See issue #12980. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestOnePassCutoff",
              "documentation": {
                "identifier": "TestOnePassCutoff",
                "newPage": false,
                "searchKey": "regexp.TestOnePassCutoff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestOnePassCutoff(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestOnePassCutoff(t *testing.T)\n```\n\nCheck that one-pass cutoff does trigger. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestSwitchBacktrack",
              "documentation": {
                "identifier": "TestSwitchBacktrack",
                "newPage": false,
                "searchKey": "regexp.TestSwitchBacktrack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSwitchBacktrack(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSwitchBacktrack(t *testing.T)\n```\n\nCheck that the same machine can be used with the standard matcher and then the backtracker when there are no captures. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkFind",
              "documentation": {
                "identifier": "BenchmarkFind",
                "newPage": false,
                "searchKey": "regexp.BenchmarkFind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkFind(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkFind(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkFindAllNoMatches",
              "documentation": {
                "identifier": "BenchmarkFindAllNoMatches",
                "newPage": false,
                "searchKey": "regexp.BenchmarkFindAllNoMatches",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkFindAllNoMatches(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkFindAllNoMatches(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkFindString",
              "documentation": {
                "identifier": "BenchmarkFindString",
                "newPage": false,
                "searchKey": "regexp.BenchmarkFindString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkFindString(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkFindString(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkFindSubmatch",
              "documentation": {
                "identifier": "BenchmarkFindSubmatch",
                "newPage": false,
                "searchKey": "regexp.BenchmarkFindSubmatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkFindSubmatch(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkFindSubmatch(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkFindStringSubmatch",
              "documentation": {
                "identifier": "BenchmarkFindStringSubmatch",
                "newPage": false,
                "searchKey": "regexp.BenchmarkFindStringSubmatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkFindStringSubmatch(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkFindStringSubmatch(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkLiteral",
              "documentation": {
                "identifier": "BenchmarkLiteral",
                "newPage": false,
                "searchKey": "regexp.BenchmarkLiteral",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkLiteral(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkLiteral(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkNotLiteral",
              "documentation": {
                "identifier": "BenchmarkNotLiteral",
                "newPage": false,
                "searchKey": "regexp.BenchmarkNotLiteral",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkNotLiteral(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkNotLiteral(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkMatchClass",
              "documentation": {
                "identifier": "BenchmarkMatchClass",
                "newPage": false,
                "searchKey": "regexp.BenchmarkMatchClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkMatchClass(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkMatchClass(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkMatchClass_InRange",
              "documentation": {
                "identifier": "BenchmarkMatchClass_InRange",
                "newPage": false,
                "searchKey": "regexp.BenchmarkMatchClass_InRange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkMatchClass_InRange(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkMatchClass_InRange(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkReplaceAll",
              "documentation": {
                "identifier": "BenchmarkReplaceAll",
                "newPage": false,
                "searchKey": "regexp.BenchmarkReplaceAll",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkReplaceAll(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkReplaceAll(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkAnchoredLiteralShortNonMatch",
              "documentation": {
                "identifier": "BenchmarkAnchoredLiteralShortNonMatch",
                "newPage": false,
                "searchKey": "regexp.BenchmarkAnchoredLiteralShortNonMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkAnchoredLiteralShortNonMatch(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkAnchoredLiteralShortNonMatch(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkAnchoredLiteralLongNonMatch",
              "documentation": {
                "identifier": "BenchmarkAnchoredLiteralLongNonMatch",
                "newPage": false,
                "searchKey": "regexp.BenchmarkAnchoredLiteralLongNonMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkAnchoredLiteralLongNonMatch(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkAnchoredLiteralLongNonMatch(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkAnchoredShortMatch",
              "documentation": {
                "identifier": "BenchmarkAnchoredShortMatch",
                "newPage": false,
                "searchKey": "regexp.BenchmarkAnchoredShortMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkAnchoredShortMatch(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkAnchoredShortMatch(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkAnchoredLongMatch",
              "documentation": {
                "identifier": "BenchmarkAnchoredLongMatch",
                "newPage": false,
                "searchKey": "regexp.BenchmarkAnchoredLongMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkAnchoredLongMatch(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkAnchoredLongMatch(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkOnePassShortA",
              "documentation": {
                "identifier": "BenchmarkOnePassShortA",
                "newPage": false,
                "searchKey": "regexp.BenchmarkOnePassShortA",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkOnePassShortA(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkOnePassShortA(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkNotOnePassShortA",
              "documentation": {
                "identifier": "BenchmarkNotOnePassShortA",
                "newPage": false,
                "searchKey": "regexp.BenchmarkNotOnePassShortA",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkNotOnePassShortA(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkNotOnePassShortA(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkOnePassShortB",
              "documentation": {
                "identifier": "BenchmarkOnePassShortB",
                "newPage": false,
                "searchKey": "regexp.BenchmarkOnePassShortB",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkOnePassShortB(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkOnePassShortB(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkNotOnePassShortB",
              "documentation": {
                "identifier": "BenchmarkNotOnePassShortB",
                "newPage": false,
                "searchKey": "regexp.BenchmarkNotOnePassShortB",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkNotOnePassShortB(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkNotOnePassShortB(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkOnePassLongPrefix",
              "documentation": {
                "identifier": "BenchmarkOnePassLongPrefix",
                "newPage": false,
                "searchKey": "regexp.BenchmarkOnePassLongPrefix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkOnePassLongPrefix(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkOnePassLongPrefix(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkOnePassLongNotPrefix",
              "documentation": {
                "identifier": "BenchmarkOnePassLongNotPrefix",
                "newPage": false,
                "searchKey": "regexp.BenchmarkOnePassLongNotPrefix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkOnePassLongNotPrefix(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkOnePassLongNotPrefix(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkMatchParallelShared",
              "documentation": {
                "identifier": "BenchmarkMatchParallelShared",
                "newPage": false,
                "searchKey": "regexp.BenchmarkMatchParallelShared",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkMatchParallelShared(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkMatchParallelShared(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkMatchParallelCopied",
              "documentation": {
                "identifier": "BenchmarkMatchParallelCopied",
                "newPage": false,
                "searchKey": "regexp.BenchmarkMatchParallelCopied",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkMatchParallelCopied(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkMatchParallelCopied(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkQuoteMetaAll",
              "documentation": {
                "identifier": "BenchmarkQuoteMetaAll",
                "newPage": false,
                "searchKey": "regexp.BenchmarkQuoteMetaAll",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkQuoteMetaAll(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkQuoteMetaAll(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkQuoteMetaNone",
              "documentation": {
                "identifier": "BenchmarkQuoteMetaNone",
                "newPage": false,
                "searchKey": "regexp.BenchmarkQuoteMetaNone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkQuoteMetaNone(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkQuoteMetaNone(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkCompile",
              "documentation": {
                "identifier": "BenchmarkCompile",
                "newPage": false,
                "searchKey": "regexp.BenchmarkCompile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkCompile(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkCompile(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestDeepEqual",
              "documentation": {
                "identifier": "TestDeepEqual",
                "newPage": false,
                "searchKey": "regexp.TestDeepEqual",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDeepEqual(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDeepEqual(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestMinInputLen",
              "documentation": {
                "identifier": "TestMinInputLen",
                "newPage": false,
                "searchKey": "regexp.TestMinInputLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMinInputLen(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMinInputLen(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestRE2Exhaustive",
              "documentation": {
                "identifier": "TestRE2Exhaustive",
                "newPage": false,
                "searchKey": "regexp.TestRE2Exhaustive",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRE2Exhaustive(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRE2Exhaustive(t *testing.T)\n```\n\nThis test is excluded when running under the race detector because it is a very expensive test and takes too long. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestRE2Search",
              "documentation": {
                "identifier": "TestRE2Search",
                "newPage": false,
                "searchKey": "regexp.TestRE2Search",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRE2Search(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRE2Search(t *testing.T)\n```\n\nTestRE2 tests this package's regexp API against test cases considered during RE2's exhaustive tests, which run all possible regexps over a given set of atoms and operators, up to a given complexity, over all possible strings over a given alphabet, up to a given size. Rather than try to link with RE2, we read a log file containing the test cases and the expected matches. The log file, re2-exhaustive.txt, is generated by running 'make log' in the open source RE2 distribution [https://github.com/google/re2/](https://github.com/google/re2/). \n\nThe test file format is a sequence of stanzas like: \n\n```\nstrings\n\"abc\"\n\"123x\"\nregexps\n\"[a-z]+\"\n0-3;0-3\n-;-\n\"([0-9])([0-9])([0-9])\"\n-;-\n-;0-3 0-1 1-2 2-3\n\n```\nThe stanza begins by defining a set of strings, quoted using Go double-quote syntax, one per line. Then the regexps section gives a sequence of regexps to run on the strings. In the block that follows a regexp, each line gives the semicolon-separated match results of running the regexp on the corresponding string. Each match result is either a single -, meaning no match, or a space-separated sequence of pairs giving the match and submatch indices. An unmatched subexpression formats its pair as a single - (not illustrated above).  For now each regexp run produces two match results, one for a `full match' that restricts the regexp to matching the entire string or nothing, and one for a `partial match' that gives the leftmost first match found in the string. \n\nLines beginning with # are comments. Lines beginning with a capital letter are test names printed during RE2's test suite and are echoed into t but otherwise ignored. \n\nAt time of writing, re2-exhaustive.txt is 59 MB but compresses to 385 kB, so we store re2-exhaustive.txt.bz2 in the repository and decompress it on the fly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#testRE2",
              "documentation": {
                "identifier": "testRE2",
                "newPage": false,
                "searchKey": "regexp.testRE2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testRE2(t *testing.T, file string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testRE2(t *testing.T, file string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#runFull",
              "documentation": {
                "identifier": "runFull",
                "newPage": false,
                "searchKey": "regexp.runFull",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runFull(re, refull *Regexp, text string) ([]int, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runFull(re, refull *Regexp, text string) ([]int, string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#runPartial",
              "documentation": {
                "identifier": "runPartial",
                "newPage": false,
                "searchKey": "regexp.runPartial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runPartial(re, refull *Regexp, text string) ([]int, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runPartial(re, refull *Regexp, text string) ([]int, string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#runFullLongest",
              "documentation": {
                "identifier": "runFullLongest",
                "newPage": false,
                "searchKey": "regexp.runFullLongest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runFullLongest(re, refull *Regexp, text string) ([]int, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runFullLongest(re, refull *Regexp, text string) ([]int, string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#runPartialLongest",
              "documentation": {
                "identifier": "runPartialLongest",
                "newPage": false,
                "searchKey": "regexp.runPartialLongest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runPartialLongest(re, refull *Regexp, text string) ([]int, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runPartialLongest(re, refull *Regexp, text string) ([]int, string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#matchFull",
              "documentation": {
                "identifier": "matchFull",
                "newPage": false,
                "searchKey": "regexp.matchFull",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func matchFull(re, refull *Regexp, text string) (bool, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc matchFull(re, refull *Regexp, text string) (bool, string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#matchPartial",
              "documentation": {
                "identifier": "matchPartial",
                "newPage": false,
                "searchKey": "regexp.matchPartial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func matchPartial(re, refull *Regexp, text string) (bool, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc matchPartial(re, refull *Regexp, text string) (bool, string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#matchFullLongest",
              "documentation": {
                "identifier": "matchFullLongest",
                "newPage": false,
                "searchKey": "regexp.matchFullLongest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func matchFullLongest(re, refull *Regexp, text string) (bool, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc matchFullLongest(re, refull *Regexp, text string) (bool, string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#matchPartialLongest",
              "documentation": {
                "identifier": "matchPartialLongest",
                "newPage": false,
                "searchKey": "regexp.matchPartialLongest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func matchPartialLongest(re, refull *Regexp, text string) (bool, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc matchPartialLongest(re, refull *Regexp, text string) (bool, string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#isSingleBytes",
              "documentation": {
                "identifier": "isSingleBytes",
                "newPage": false,
                "searchKey": "regexp.isSingleBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isSingleBytes(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isSingleBytes(s string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#parseResult",
              "documentation": {
                "identifier": "parseResult",
                "newPage": false,
                "searchKey": "regexp.parseResult",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseResult(t *testing.T, file string, lineno int, res string) []int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseResult(t *testing.T, file string, lineno int, res string) []int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#same",
              "documentation": {
                "identifier": "same",
                "newPage": false,
                "searchKey": "regexp.same",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func same(x, y []int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc same(x, y []int) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFowler",
              "documentation": {
                "identifier": "TestFowler",
                "newPage": false,
                "searchKey": "regexp.TestFowler",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFowler(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFowler(t *testing.T)\n```\n\nTestFowler runs this package's regexp API against the POSIX regular expression tests collected by Glenn Fowler at [http://www2.research.att.com/~astopen/testregex/testregex.html](http://www2.research.att.com/~astopen/testregex/testregex.html). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#testFowler",
              "documentation": {
                "identifier": "testFowler",
                "newPage": false,
                "searchKey": "regexp.testFowler",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFowler(t *testing.T, file string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFowler(t *testing.T, file string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#parseFowlerResult",
              "documentation": {
                "identifier": "parseFowlerResult",
                "newPage": false,
                "searchKey": "regexp.parseFowlerResult",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseFowlerResult(s string) (ok, compiled, matched bool, pos []int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseFowlerResult(s string) (ok, compiled, matched bool, pos []int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#makeText",
              "documentation": {
                "identifier": "makeText",
                "newPage": false,
                "searchKey": "regexp.makeText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makeText(n int) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makeText(n int) []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkMatch",
              "documentation": {
                "identifier": "BenchmarkMatch",
                "newPage": false,
                "searchKey": "regexp.BenchmarkMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkMatch(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkMatch(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#BenchmarkMatch_onepass_regex",
              "documentation": {
                "identifier": "BenchmarkMatch_onepass_regex",
                "newPage": false,
                "searchKey": "regexp.BenchmarkMatch_onepass_regex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkMatch_onepass_regex(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkMatch_onepass_regex(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestLongest",
              "documentation": {
                "identifier": "TestLongest",
                "newPage": false,
                "searchKey": "regexp.TestLongest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLongest(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLongest(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestProgramTooLongForBacktrack",
              "documentation": {
                "identifier": "TestProgramTooLongForBacktrack",
                "newPage": false,
                "searchKey": "regexp.TestProgramTooLongForBacktrack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestProgramTooLongForBacktrack(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestProgramTooLongForBacktrack(t *testing.T)\n```\n\nTestProgramTooLongForBacktrack tests that a regex which is too long for the backtracker still executes properly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#build",
              "documentation": {
                "identifier": "build",
                "newPage": false,
                "searchKey": "regexp.build",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func build(n int, x ...int) [][]int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc build(n int, x ...int) [][]int\n```\n\nbuild is a helper to construct a [][]int by extracting n sequences from x. This represents n matches with len(x)/n submatches each. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFind",
              "documentation": {
                "identifier": "TestFind",
                "newPage": false,
                "searchKey": "regexp.TestFind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFind(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFind(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindString",
              "documentation": {
                "identifier": "TestFindString",
                "newPage": false,
                "searchKey": "regexp.TestFindString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#testFindIndex",
              "documentation": {
                "identifier": "testFindIndex",
                "newPage": false,
                "searchKey": "regexp.testFindIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFindIndex(test *FindTest, result []int, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFindIndex(test *FindTest, result []int, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindIndex",
              "documentation": {
                "identifier": "TestFindIndex",
                "newPage": false,
                "searchKey": "regexp.TestFindIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindStringIndex",
              "documentation": {
                "identifier": "TestFindStringIndex",
                "newPage": false,
                "searchKey": "regexp.TestFindStringIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindStringIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindStringIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindReaderIndex",
              "documentation": {
                "identifier": "TestFindReaderIndex",
                "newPage": false,
                "searchKey": "regexp.TestFindReaderIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindReaderIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindReaderIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindAll",
              "documentation": {
                "identifier": "TestFindAll",
                "newPage": false,
                "searchKey": "regexp.TestFindAll",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindAll(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindAll(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindAllString",
              "documentation": {
                "identifier": "TestFindAllString",
                "newPage": false,
                "searchKey": "regexp.TestFindAllString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindAllString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindAllString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#testFindAllIndex",
              "documentation": {
                "identifier": "testFindAllIndex",
                "newPage": false,
                "searchKey": "regexp.testFindAllIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFindAllIndex(test *FindTest, result [][]int, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFindAllIndex(test *FindTest, result [][]int, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindAllIndex",
              "documentation": {
                "identifier": "TestFindAllIndex",
                "newPage": false,
                "searchKey": "regexp.TestFindAllIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindAllIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindAllIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindAllStringIndex",
              "documentation": {
                "identifier": "TestFindAllStringIndex",
                "newPage": false,
                "searchKey": "regexp.TestFindAllStringIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindAllStringIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindAllStringIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#testSubmatchBytes",
              "documentation": {
                "identifier": "testSubmatchBytes",
                "newPage": false,
                "searchKey": "regexp.testSubmatchBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testSubmatchBytes(test *FindTest, n int, submatches []int, result [][]byte, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testSubmatchBytes(test *FindTest, n int, submatches []int, result [][]byte, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindSubmatch",
              "documentation": {
                "identifier": "TestFindSubmatch",
                "newPage": false,
                "searchKey": "regexp.TestFindSubmatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindSubmatch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindSubmatch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#testSubmatchString",
              "documentation": {
                "identifier": "testSubmatchString",
                "newPage": false,
                "searchKey": "regexp.testSubmatchString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testSubmatchString(test *FindTest, n int, submatches []int, result []string, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testSubmatchString(test *FindTest, n int, submatches []int, result []string, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindStringSubmatch",
              "documentation": {
                "identifier": "TestFindStringSubmatch",
                "newPage": false,
                "searchKey": "regexp.TestFindStringSubmatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindStringSubmatch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindStringSubmatch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#testSubmatchIndices",
              "documentation": {
                "identifier": "testSubmatchIndices",
                "newPage": false,
                "searchKey": "regexp.testSubmatchIndices",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testSubmatchIndices(test *FindTest, n int, expect, result []int, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testSubmatchIndices(test *FindTest, n int, expect, result []int, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#testFindSubmatchIndex",
              "documentation": {
                "identifier": "testFindSubmatchIndex",
                "newPage": false,
                "searchKey": "regexp.testFindSubmatchIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFindSubmatchIndex(test *FindTest, result []int, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFindSubmatchIndex(test *FindTest, result []int, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindSubmatchIndex",
              "documentation": {
                "identifier": "TestFindSubmatchIndex",
                "newPage": false,
                "searchKey": "regexp.TestFindSubmatchIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindSubmatchIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindSubmatchIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindStringSubmatchIndex",
              "documentation": {
                "identifier": "TestFindStringSubmatchIndex",
                "newPage": false,
                "searchKey": "regexp.TestFindStringSubmatchIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindStringSubmatchIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindStringSubmatchIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindReaderSubmatchIndex",
              "documentation": {
                "identifier": "TestFindReaderSubmatchIndex",
                "newPage": false,
                "searchKey": "regexp.TestFindReaderSubmatchIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindReaderSubmatchIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindReaderSubmatchIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindAllSubmatch",
              "documentation": {
                "identifier": "TestFindAllSubmatch",
                "newPage": false,
                "searchKey": "regexp.TestFindAllSubmatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindAllSubmatch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindAllSubmatch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindAllStringSubmatch",
              "documentation": {
                "identifier": "TestFindAllStringSubmatch",
                "newPage": false,
                "searchKey": "regexp.TestFindAllStringSubmatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindAllStringSubmatch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindAllStringSubmatch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#testFindAllSubmatchIndex",
              "documentation": {
                "identifier": "testFindAllSubmatchIndex",
                "newPage": false,
                "searchKey": "regexp.testFindAllSubmatchIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFindAllSubmatchIndex(test *FindTest, result [][]int, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFindAllSubmatchIndex(test *FindTest, result [][]int, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindAllSubmatchIndex",
              "documentation": {
                "identifier": "TestFindAllSubmatchIndex",
                "newPage": false,
                "searchKey": "regexp.TestFindAllSubmatchIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindAllSubmatchIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindAllSubmatchIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestFindAllStringSubmatchIndex",
              "documentation": {
                "identifier": "TestFindAllStringSubmatchIndex",
                "newPage": false,
                "searchKey": "regexp.TestFindAllStringSubmatchIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindAllStringSubmatchIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindAllStringSubmatchIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestMergeRuneSet",
              "documentation": {
                "identifier": "TestMergeRuneSet",
                "newPage": false,
                "searchKey": "regexp.TestMergeRuneSet",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMergeRuneSet(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMergeRuneSet(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestCompileOnePass",
              "documentation": {
                "identifier": "TestCompileOnePass",
                "newPage": false,
                "searchKey": "regexp.TestCompileOnePass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCompileOnePass(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCompileOnePass(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/regexp#TestRunOnePass",
              "documentation": {
                "identifier": "TestRunOnePass",
                "newPage": false,
                "searchKey": "regexp.TestRunOnePass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRunOnePass(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRunOnePass(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "pathID": "/regexp/syntax"
    }
  ]
}
