{
  "pathID": "/encoding/csv",
  "documentation": {
    "identifier": "csv",
    "newPage": true,
    "searchKey": "encoding/csv",
    "tags": [
      "package"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package csv"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package csv reads and writes comma-separated values (CSV) files. There are many kinds of CSV files; this package supports the format described in RFC 4180. \n\nA csv file contains zero or more records of one or more fields per record. Each record is separated by the newline character. The final record may optionally be followed by a newline character. \n\n```\nfield1,field2,field3\n\n```\nWhite space is considered part of a field. \n\nCarriage returns before newline characters are silently removed. \n\nBlank lines are ignored. A line with only whitespace characters (excluding the ending newline character) is not considered a blank line. \n\nFields which start and stop with the quote character \" are called quoted-fields. The beginning and ending quote are not part of the field. \n\nThe source: \n\n```\nnormal string,\"quoted-field\"\n\n```\nresults in the fields \n\n```\n{`normal string`, `quoted-field`}\n\n```\nWithin a quoted-field a quote character followed by a second quote character is considered a single quote. \n\n```\n\"the \"\"word\"\" is true\",\"a \"\"quoted-field\"\"\"\n\n```\nresults in \n\n```\n{`the \"word\" is true`, `a \"quoted-field\"`}\n\n```\nNewlines and commas may be included in a quoted-field \n\n```\n\"Multi-line\nfield\",\"comma is ,\"\n\n```\nresults in \n\n```\n{`Multi-line\nfield`, `comma is ,`}\n\n```\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/encoding/csv#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/encoding/csv#benchmarkCSVData",
              "documentation": {
                "identifier": "benchmarkCSVData",
                "newPage": false,
                "searchKey": "csv.benchmarkCSVData",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const benchmarkCSVData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst benchmarkCSVData = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/encoding/csv#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/encoding/csv#ErrBareQuote",
              "documentation": {
                "identifier": "ErrBareQuote",
                "newPage": false,
                "searchKey": "csv.ErrBareQuote",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrBareQuote"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrBareQuote = errors.New(\"bare \\\" in non-quoted-field\")\n```\n\nThese are the errors that can be returned in ParseError.Err. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#ErrFieldCount",
              "documentation": {
                "identifier": "ErrFieldCount",
                "newPage": false,
                "searchKey": "csv.ErrFieldCount",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrFieldCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrFieldCount = errors.New(\"wrong number of fields\")\n```\n\nThese are the errors that can be returned in ParseError.Err. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#ErrQuote",
              "documentation": {
                "identifier": "ErrQuote",
                "newPage": false,
                "searchKey": "csv.ErrQuote",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrQuote"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrQuote = errors.New(\"extraneous or missing \\\" in quoted-field\")\n```\n\nThese are the errors that can be returned in ParseError.Err. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#ErrTrailingComma",
              "documentation": {
                "identifier": "ErrTrailingComma",
                "newPage": false,
                "searchKey": "csv.ErrTrailingComma",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrTrailingComma"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrTrailingComma = errors.New(\"extra delimiter at end of line\") // Deprecated: No longer used.\n\n```\n\nThese are the errors that can be returned in ParseError.Err. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#benchmarkWriteData",
              "documentation": {
                "identifier": "benchmarkWriteData",
                "newPage": false,
                "searchKey": "csv.benchmarkWriteData",
                "tags": [
                  "variable",
                  "array",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var benchmarkWriteData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar benchmarkWriteData = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#errInvalidDelim",
              "documentation": {
                "identifier": "errInvalidDelim",
                "newPage": false,
                "searchKey": "csv.errInvalidDelim",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errInvalidDelim"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errInvalidDelim = errors.New(\"csv: invalid field or comment delimiter\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#readTests",
              "documentation": {
                "identifier": "readTests",
                "newPage": false,
                "searchKey": "csv.readTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var readTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar readTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#writeTests",
              "documentation": {
                "identifier": "writeTests",
                "newPage": false,
                "searchKey": "csv.writeTests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var writeTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar writeTests = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/encoding/csv#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/encoding/csv#ParseError",
              "documentation": {
                "identifier": "ParseError",
                "newPage": false,
                "searchKey": "csv.ParseError",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ParseError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ParseError struct {\n\tStartLine int   // Line where the record starts\n\tLine      int   // Line where the error occurred\n\tColumn    int   // Column (1-based byte index) where the error occurred\n\tErr       error // The actual error\n}\n```\n\nA ParseError is returned for parsing errors. Line numbers are 1-indexed and columns are 0-indexed. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/encoding/csv#ParseError.Error",
                    "documentation": {
                      "identifier": "ParseError.Error",
                      "newPage": false,
                      "searchKey": "csv.ParseError.Error",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *ParseError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *ParseError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/encoding/csv#ParseError.Unwrap",
                    "documentation": {
                      "identifier": "ParseError.Unwrap",
                      "newPage": false,
                      "searchKey": "csv.ParseError.Unwrap",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *ParseError) Unwrap() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *ParseError) Unwrap() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#Reader",
              "documentation": {
                "identifier": "Reader",
                "newPage": false,
                "searchKey": "csv.Reader",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Reader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Reader struct {\n\t// Comma is the field delimiter.\n\t// It is set to comma (',') by NewReader.\n\t// Comma must be a valid rune and must not be \\r, \\n,\n\t// or the Unicode replacement character (0xFFFD).\n\tComma rune\n\n\t// Comment, if not 0, is the comment character. Lines beginning with the\n\t// Comment character without preceding whitespace are ignored.\n\t// With leading whitespace the Comment character becomes part of the\n\t// field, even if TrimLeadingSpace is true.\n\t// Comment must be a valid rune and must not be \\r, \\n,\n\t// or the Unicode replacement character (0xFFFD).\n\t// It must also not be equal to Comma.\n\tComment rune\n\n\t// FieldsPerRecord is the number of expected fields per record.\n\t// If FieldsPerRecord is positive, Read requires each record to\n\t// have the given number of fields. If FieldsPerRecord is 0, Read sets it to\n\t// the number of fields in the first record, so that future records must\n\t// have the same field count. If FieldsPerRecord is negative, no check is\n\t// made and records may have a variable number of fields.\n\tFieldsPerRecord int\n\n\t// If LazyQuotes is true, a quote may appear in an unquoted field and a\n\t// non-doubled quote may appear in a quoted field.\n\tLazyQuotes bool\n\n\t// If TrimLeadingSpace is true, leading white space in a field is ignored.\n\t// This is done even if the field delimiter, Comma, is white space.\n\tTrimLeadingSpace bool\n\n\t// ReuseRecord controls whether calls to Read may return a slice sharing\n\t// the backing array of the previous call's returned slice for performance.\n\t// By default, each call to Read returns newly allocated memory owned by the caller.\n\tReuseRecord bool\n\n\tTrailingComma bool // Deprecated: No longer used.\n\n\tr *bufio.Reader\n\n\t// numLine is the current line being read in the CSV file.\n\tnumLine int\n\n\t// rawBuffer is a line buffer only used by the readLine method.\n\trawBuffer []byte\n\n\t// recordBuffer holds the unescaped fields, one after another.\n\t// The fields can be accessed by using the indexes in fieldIndexes.\n\t// E.g., For the row `a,\"b\",\"c\"\"d\",e`, recordBuffer will contain `abc\"de`\n\t// and fieldIndexes will contain the indexes [1, 2, 5, 6].\n\trecordBuffer []byte\n\n\t// fieldIndexes is an index of fields inside recordBuffer.\n\t// The i'th field ends at offset fieldIndexes[i] in recordBuffer.\n\tfieldIndexes []int\n\n\t// fieldPositions is an index of field positions for the\n\t// last record returned by Read.\n\tfieldPositions []position\n\n\t// lastRecord is a record cache and only used when ReuseRecord == true.\n\tlastRecord []string\n}\n```\n\nA Reader reads records from a CSV-encoded file. \n\nAs returned by NewReader, a Reader expects input conforming to RFC 4180. The exported fields can be changed to customize the details before the first call to Read or ReadAll. \n\nThe Reader converts all \\r\\n sequences in its input to plain \\n, including in multiline field values, so that the returned data does not depend on which line-ending convention an input file uses. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/encoding/csv#NewReader",
                    "documentation": {
                      "identifier": "NewReader",
                      "newPage": false,
                      "searchKey": "csv.NewReader",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewReader(r io.Reader) *Reader"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewReader(r io.Reader) *Reader\n```\n\nNewReader returns a new Reader that reads from r. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/encoding/csv#Reader.FieldPos",
                    "documentation": {
                      "identifier": "Reader.FieldPos",
                      "newPage": false,
                      "searchKey": "csv.Reader.FieldPos",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) FieldPos(field int) (line, column int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) FieldPos(field int) (line, column int)\n```\n\nFieldPos returns the line and column corresponding to the start of the field with the given index in the slice most recently returned by Read. Numbering of lines and columns starts at 1; columns are counted in bytes, not runes. \n\nIf this is called with an out-of-bounds index, it panics. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/encoding/csv#Reader.Read",
                    "documentation": {
                      "identifier": "Reader.Read",
                      "newPage": false,
                      "searchKey": "csv.Reader.Read",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) Read() (record []string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) Read() (record []string, err error)\n```\n\nRead reads one record (a slice of fields) from r. If the record has an unexpected number of fields, Read returns the record along with the error ErrFieldCount. Except for that case, Read always returns either a non-nil record or a non-nil error, but not both. If there is no data left to be read, Read returns nil, io.EOF. If ReuseRecord is true, the returned slice may be shared between multiple calls to Read. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/encoding/csv#Reader.ReadAll",
                    "documentation": {
                      "identifier": "Reader.ReadAll",
                      "newPage": false,
                      "searchKey": "csv.Reader.ReadAll",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) ReadAll() (records [][]string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) ReadAll() (records [][]string, err error)\n```\n\nReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == io.EOF. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/encoding/csv#Reader.readLine",
                    "documentation": {
                      "identifier": "Reader.readLine",
                      "newPage": false,
                      "searchKey": "csv.Reader.readLine",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) readLine() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) readLine() ([]byte, error)\n```\n\nreadLine reads the next line (with the trailing endline). If EOF is hit without a trailing endline, it will be omitted. If some bytes were read, then the error is never io.EOF. The result is only valid until the next call to readLine. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/encoding/csv#Reader.readRecord",
                    "documentation": {
                      "identifier": "Reader.readRecord",
                      "newPage": false,
                      "searchKey": "csv.Reader.readRecord",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *Reader) readRecord(dst []string) ([]string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *Reader) readRecord(dst []string) ([]string, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#Writer",
              "documentation": {
                "identifier": "Writer",
                "newPage": false,
                "searchKey": "csv.Writer",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Writer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Writer struct {\n\tComma   rune // Field delimiter (set to ',' by NewWriter)\n\tUseCRLF bool // True to use \\r\\n as the line terminator\n\tw       *bufio.Writer\n}\n```\n\nA Writer writes records using CSV encoding. \n\nAs returned by NewWriter, a Writer writes records terminated by a newline and uses ',' as the field delimiter. The exported fields can be changed to customize the details before the first call to Write or WriteAll. \n\nComma is the field delimiter. \n\nIf UseCRLF is true, the Writer ends each output line with \\r\\n instead of \\n. \n\nThe writes of individual records are buffered. After all data has been written, the client should call the Flush method to guarantee all data has been forwarded to the underlying io.Writer.  Any errors that occurred should be checked by calling the Error method. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/encoding/csv#NewWriter",
                    "documentation": {
                      "identifier": "NewWriter",
                      "newPage": false,
                      "searchKey": "csv.NewWriter",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewWriter(w io.Writer) *Writer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewWriter(w io.Writer) *Writer\n```\n\nNewWriter returns a new Writer that writes to w. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/encoding/csv#Writer.Error",
                    "documentation": {
                      "identifier": "Writer.Error",
                      "newPage": false,
                      "searchKey": "csv.Writer.Error",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *Writer) Error() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *Writer) Error() error\n```\n\nError reports any error that has occurred during a previous Write or Flush. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/encoding/csv#Writer.Flush",
                    "documentation": {
                      "identifier": "Writer.Flush",
                      "newPage": false,
                      "searchKey": "csv.Writer.Flush",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *Writer) Flush()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *Writer) Flush()\n```\n\nFlush writes any buffered data to the underlying io.Writer. To check if an error occurred during the Flush, call Error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/encoding/csv#Writer.Write",
                    "documentation": {
                      "identifier": "Writer.Write",
                      "newPage": false,
                      "searchKey": "csv.Writer.Write",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *Writer) Write(record []string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *Writer) Write(record []string) error\n```\n\nWrite writes a single CSV record to w along with any necessary quoting. A record is a slice of strings with each string being one field. Writes are buffered, so Flush must eventually be called to ensure that the record is written to the underlying io.Writer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/encoding/csv#Writer.WriteAll",
                    "documentation": {
                      "identifier": "Writer.WriteAll",
                      "newPage": false,
                      "searchKey": "csv.Writer.WriteAll",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *Writer) WriteAll(records [][]string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *Writer) WriteAll(records [][]string) error\n```\n\nWriteAll writes multiple CSV records to w using Write and then calls Flush, returning any error from the Flush. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/encoding/csv#Writer.fieldNeedsQuotes",
                    "documentation": {
                      "identifier": "Writer.fieldNeedsQuotes",
                      "newPage": false,
                      "searchKey": "csv.Writer.fieldNeedsQuotes",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *Writer) fieldNeedsQuotes(field string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *Writer) fieldNeedsQuotes(field string) bool\n```\n\nfieldNeedsQuotes reports whether our field must be enclosed in quotes. Fields with a Comma, fields with a quote or newline, and fields which start with a space must be enclosed in quotes. We used to quote empty strings, but we do not anymore (as of Go 1.4). The two representations should be equivalent, but Postgres distinguishes quoted vs non-quoted empty string during database imports, and it has an option to force the quoted behavior for non-quoted CSV but it has no option to force the non-quoted behavior for quoted CSV, making CSV with quoted empty strings strictly less useful. Not quoting the empty string also makes this package match the behavior of Microsoft Excel and Google Drive. For Postgres, quote the data terminating string `\\.`. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#errorWriter",
              "documentation": {
                "identifier": "errorWriter",
                "newPage": false,
                "searchKey": "csv.errorWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type errorWriter struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype errorWriter struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/encoding/csv#errorWriter.Write",
                    "documentation": {
                      "identifier": "errorWriter.Write",
                      "newPage": false,
                      "searchKey": "csv.errorWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e errorWriter) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e errorWriter) Write(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#nTimes",
              "documentation": {
                "identifier": "nTimes",
                "newPage": false,
                "searchKey": "csv.nTimes",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type nTimes struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nTimes struct {\n\ts   string\n\tn   int\n\toff int\n}\n```\n\nnTimes is an io.Reader which yields the string s n times. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/encoding/csv#nTimes.Read",
                    "documentation": {
                      "identifier": "nTimes.Read",
                      "newPage": false,
                      "searchKey": "csv.nTimes.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *nTimes) Read(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *nTimes) Read(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#position",
              "documentation": {
                "identifier": "position",
                "newPage": false,
                "searchKey": "csv.position",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type position struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype position struct {\n\tline, col int\n}\n```\n\npos holds the position of a field in the current line. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#readTest",
              "documentation": {
                "identifier": "readTest",
                "newPage": false,
                "searchKey": "csv.readTest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type readTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype readTest struct {\n\tName      string\n\tInput     string\n\tOutput    [][]string\n\tPositions [][][2]int\n\tErrors    []error\n\n\t// These fields are copied into the Reader\n\tComma              rune\n\tComment            rune\n\tUseFieldsPerRecord bool // false (default) means FieldsPerRecord is -1\n\tFieldsPerRecord    int\n\tLazyQuotes         bool\n\tTrimLeadingSpace   bool\n\tReuseRecord        bool\n}\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/encoding/csv#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/encoding/csv#BenchmarkRead",
              "documentation": {
                "identifier": "BenchmarkRead",
                "newPage": false,
                "searchKey": "csv.BenchmarkRead",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkRead(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkRead(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#BenchmarkReadLargeFields",
              "documentation": {
                "identifier": "BenchmarkReadLargeFields",
                "newPage": false,
                "searchKey": "csv.BenchmarkReadLargeFields",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkReadLargeFields(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkReadLargeFields(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#BenchmarkReadReuseRecord",
              "documentation": {
                "identifier": "BenchmarkReadReuseRecord",
                "newPage": false,
                "searchKey": "csv.BenchmarkReadReuseRecord",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkReadReuseRecord(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkReadReuseRecord(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#BenchmarkReadReuseRecordLargeFields",
              "documentation": {
                "identifier": "BenchmarkReadReuseRecordLargeFields",
                "newPage": false,
                "searchKey": "csv.BenchmarkReadReuseRecordLargeFields",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkReadReuseRecordLargeFields(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkReadReuseRecordLargeFields(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#BenchmarkReadReuseRecordWithFieldsPerRecord",
              "documentation": {
                "identifier": "BenchmarkReadReuseRecordWithFieldsPerRecord",
                "newPage": false,
                "searchKey": "csv.BenchmarkReadReuseRecordWithFieldsPerRecord",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkReadReuseRecordWithFieldsPerRecord(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkReadReuseRecordWithFieldsPerRecord(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#BenchmarkReadReuseRecordWithoutFieldsPerRecord",
              "documentation": {
                "identifier": "BenchmarkReadReuseRecordWithoutFieldsPerRecord",
                "newPage": false,
                "searchKey": "csv.BenchmarkReadReuseRecordWithoutFieldsPerRecord",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkReadReuseRecordWithoutFieldsPerRecord(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkReadReuseRecordWithoutFieldsPerRecord(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#BenchmarkReadWithFieldsPerRecord",
              "documentation": {
                "identifier": "BenchmarkReadWithFieldsPerRecord",
                "newPage": false,
                "searchKey": "csv.BenchmarkReadWithFieldsPerRecord",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkReadWithFieldsPerRecord(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkReadWithFieldsPerRecord(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#BenchmarkReadWithoutFieldsPerRecord",
              "documentation": {
                "identifier": "BenchmarkReadWithoutFieldsPerRecord",
                "newPage": false,
                "searchKey": "csv.BenchmarkReadWithoutFieldsPerRecord",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkReadWithoutFieldsPerRecord(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkReadWithoutFieldsPerRecord(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#BenchmarkWrite",
              "documentation": {
                "identifier": "BenchmarkWrite",
                "newPage": false,
                "searchKey": "csv.BenchmarkWrite",
                "tags": [
                  "method",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkWrite(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkWrite(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#TestError",
              "documentation": {
                "identifier": "TestError",
                "newPage": false,
                "searchKey": "csv.TestError",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#TestRead",
              "documentation": {
                "identifier": "TestRead",
                "newPage": false,
                "searchKey": "csv.TestRead",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRead(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRead(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#TestWrite",
              "documentation": {
                "identifier": "TestWrite",
                "newPage": false,
                "searchKey": "csv.TestWrite",
                "tags": [
                  "method",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWrite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#benchmarkRead",
              "documentation": {
                "identifier": "benchmarkRead",
                "newPage": false,
                "searchKey": "csv.benchmarkRead",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func benchmarkRead(b *testing.B, initReader func(*Reader), rows string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc benchmarkRead(b *testing.B, initReader func(*Reader), rows string)\n```\n\nbenchmarkRead measures reading the provided CSV rows data. initReader, if non-nil, modifies the Reader before it's used. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#errorWithPosition",
              "documentation": {
                "identifier": "errorWithPosition",
                "newPage": false,
                "searchKey": "csv.errorWithPosition",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func errorWithPosition(err error, recNum int, positions [][][2]int, errPositions map[int][2]int) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc errorWithPosition(err error, recNum int, positions [][][2]int, errPositions map[int][2]int) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#firstError",
              "documentation": {
                "identifier": "firstError",
                "newPage": false,
                "searchKey": "csv.firstError",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func firstError(errs []error, positions [][][2]int, errPositions map[int][2]int) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc firstError(errs []error, positions [][][2]int, errPositions map[int][2]int) error\n```\n\nfirstError returns the first non-nil error in errs, with the position adjusted according to the error's index inside positions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#lengthNL",
              "documentation": {
                "identifier": "lengthNL",
                "newPage": false,
                "searchKey": "csv.lengthNL",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func lengthNL(b []byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lengthNL(b []byte) int\n```\n\nlengthNL reports the number of bytes for the trailing \\n. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#makePositions",
              "documentation": {
                "identifier": "makePositions",
                "newPage": false,
                "searchKey": "csv.makePositions",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func makePositions(text string) ([][][2]int, map[int][2]int, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makePositions(text string) ([][][2]int, map[int][2]int, string)\n```\n\nmakePositions returns the expected field positions of all the fields in text, the positions of any errors, and the text with the position markers removed. \n\nThe start of each field is marked with a  symbol; CSV lines are separated by  symbols; Error positions are marked with  symbols. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#nextRune",
              "documentation": {
                "identifier": "nextRune",
                "newPage": false,
                "searchKey": "csv.nextRune",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func nextRune(b []byte) rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nextRune(b []byte) rune\n```\n\nnextRune returns the next rune in b or utf8.RuneError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/encoding/csv#validDelim",
              "documentation": {
                "identifier": "validDelim",
                "newPage": false,
                "searchKey": "csv.validDelim",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validDelim(r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validDelim(r rune) bool\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
