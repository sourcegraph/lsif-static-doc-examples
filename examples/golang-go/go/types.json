{
  "pathID": "/go/types",
  "documentation": {
    "identifier": "types",
    "newPage": true,
    "searchKey": "go/types",
    "tags": []
  },
  "label": {
    "kind": "plaintext",
    "value": "Package types"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package types declares the data types and implements the algorithms for type-checking of Go packages. Use Config.Check to invoke the type checker for a package. Alternatively, create a new type checker with NewChecker and invoke it incrementally by calling Checker.Files. \n\nType-checking consists of several interdependent phases: \n\nName resolution maps each identifier (ast.Ident) in the program to the language object (Object) it denotes. Use Info.{Defs,Uses,Implicits} for the results of name resolution. \n\nConstant folding computes the exact constant value (constant.Value) for every expression (ast.Expr) that is a compile-time constant. Use Info.Types[expr].Value for the results of constant folding. \n\nType inference computes the type (Type) of every expression (ast.Expr) and checks for compliance with the language specification. Use Info.Types[expr].Type for the results of type inference. \n\nFor a tutorial, see [https://golang.org/s/types-tutorial](https://golang.org/s/types-tutorial). \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/go/types#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/go/types#debug",
              "documentation": {
                "identifier": "debug",
                "newPage": false,
                "searchKey": "types.debug",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const debug"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debug = false // leave on during development\n\n```\n\ndebugging/development support \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#trace",
              "documentation": {
                "identifier": "trace",
                "newPage": false,
                "searchKey": "types.trace",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const trace"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst trace = false // turn on for detailed type resolution traces\n\n```\n\ndebugging/development support \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#forceStrict",
              "documentation": {
                "identifier": "forceStrict",
                "newPage": false,
                "searchKey": "types.forceStrict",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const forceStrict"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst forceStrict = false\n```\n\nIf forceStrict is set, the type-checker enforces additional rules not specified by the Go 1 spec, but which will catch guaranteed run-time errors if the respective code is executed. In other words, programs passing in strict mode are Go 1 compliant, but not all Go 1 programs will pass in strict mode. The additional rules are: \n\n- A type assertion x.(T) where T is an interface type \n\n```\nis invalid if any (statically known) method that exists\nfor both x and T have different signatures.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Test",
              "documentation": {
                "identifier": "_Test",
                "newPage": false,
                "searchKey": "types._Test",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Test"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Test\n```\n\n_Test is reserved for errors that only apply while in self-test mode. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_BlankPkgName",
              "documentation": {
                "identifier": "_BlankPkgName",
                "newPage": false,
                "searchKey": "types._BlankPkgName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BlankPkgName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BlankPkgName\n```\n\n_BlankPkgName occurs when a package name is the blank identifier \"_\". \n\nPer the spec: \n\n```\n\"The PackageName must not be the blank identifier.\"\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MismatchedPkgName",
              "documentation": {
                "identifier": "_MismatchedPkgName",
                "newPage": false,
                "searchKey": "types._MismatchedPkgName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MismatchedPkgName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MismatchedPkgName\n```\n\n_MismatchedPkgName occurs when a file's package name doesn't match the package name already established by other files. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidPkgUse",
              "documentation": {
                "identifier": "_InvalidPkgUse",
                "newPage": false,
                "searchKey": "types._InvalidPkgUse",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidPkgUse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidPkgUse\n```\n\n_InvalidPkgUse occurs when a package identifier is used outside of a selector expression. \n\nExample: \n\n```\nimport \"fmt\"\n\nvar _ = fmt\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_BadImportPath",
              "documentation": {
                "identifier": "_BadImportPath",
                "newPage": false,
                "searchKey": "types._BadImportPath",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BadImportPath"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BadImportPath\n```\n\n_BadImportPath occurs when an import path is not valid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_BrokenImport",
              "documentation": {
                "identifier": "_BrokenImport",
                "newPage": false,
                "searchKey": "types._BrokenImport",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BrokenImport"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BrokenImport\n```\n\n_BrokenImport occurs when importing a package fails. \n\nExample: \n\n```\nimport \"amissingpackage\"\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_ImportCRenamed",
              "documentation": {
                "identifier": "_ImportCRenamed",
                "newPage": false,
                "searchKey": "types._ImportCRenamed",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _ImportCRenamed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _ImportCRenamed\n```\n\n_ImportCRenamed occurs when the special import \"C\" is renamed. \"C\" is a pseudo-package, and must not be renamed. \n\nExample: \n\n```\nimport _ \"C\"\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UnusedImport",
              "documentation": {
                "identifier": "_UnusedImport",
                "newPage": false,
                "searchKey": "types._UnusedImport",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UnusedImport"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UnusedImport\n```\n\n_UnusedImport occurs when an import is unused. \n\nExample: \n\n```\nimport \"fmt\"\n\nfunc main() {}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidInitCycle",
              "documentation": {
                "identifier": "_InvalidInitCycle",
                "newPage": false,
                "searchKey": "types._InvalidInitCycle",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidInitCycle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidInitCycle\n```\n\n_InvalidInitCycle occurs when an invalid cycle is detected within the initialization graph. \n\nExample: \n\n```\nvar x int = f()\n\nfunc f() int { return x }\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_DuplicateDecl",
              "documentation": {
                "identifier": "_DuplicateDecl",
                "newPage": false,
                "searchKey": "types._DuplicateDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _DuplicateDecl"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _DuplicateDecl\n```\n\n_DuplicateDecl occurs when an identifier is declared multiple times. \n\nExample: \n\n```\nvar x = 1\nvar x = 2\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidDeclCycle",
              "documentation": {
                "identifier": "_InvalidDeclCycle",
                "newPage": false,
                "searchKey": "types._InvalidDeclCycle",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidDeclCycle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidDeclCycle\n```\n\n_InvalidDeclCycle occurs when a declaration cycle is not valid. \n\nExample: \n\n```\nimport \"unsafe\"\n\ntype T struct {\n\ta [n]int\n}\n\nvar n = unsafe.Sizeof(T{})\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidTypeCycle",
              "documentation": {
                "identifier": "_InvalidTypeCycle",
                "newPage": false,
                "searchKey": "types._InvalidTypeCycle",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidTypeCycle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidTypeCycle\n```\n\n_InvalidTypeCycle occurs when a cycle in type definitions results in a type that is not well-defined. \n\nExample: \n\n```\nimport \"unsafe\"\n\ntype T [unsafe.Sizeof(T{})]int\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidConstInit",
              "documentation": {
                "identifier": "_InvalidConstInit",
                "newPage": false,
                "searchKey": "types._InvalidConstInit",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidConstInit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidConstInit\n```\n\n_InvalidConstInit occurs when a const declaration has a non-constant initializer. \n\nExample: \n\n```\nvar x int\nconst _ = x\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidConstVal",
              "documentation": {
                "identifier": "_InvalidConstVal",
                "newPage": false,
                "searchKey": "types._InvalidConstVal",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidConstVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidConstVal\n```\n\n_InvalidConstVal occurs when a const value cannot be converted to its target type. \n\nTODO(findleyr): this error code and example are not very clear. Consider removing it. \n\nExample: \n\n```\nconst _ = 1 << \"hello\"\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidConstType",
              "documentation": {
                "identifier": "_InvalidConstType",
                "newPage": false,
                "searchKey": "types._InvalidConstType",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidConstType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidConstType\n```\n\n_InvalidConstType occurs when the underlying type in a const declaration is not a valid constant type. \n\nExample: \n\n```\nconst c *int = 4\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UntypedNil",
              "documentation": {
                "identifier": "_UntypedNil",
                "newPage": false,
                "searchKey": "types._UntypedNil",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UntypedNil"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UntypedNil\n```\n\n_UntypedNil occurs when the predeclared (untyped) value nil is used to initialize a variable declared without an explicit type. \n\nExample: \n\n```\nvar x = nil\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_WrongAssignCount",
              "documentation": {
                "identifier": "_WrongAssignCount",
                "newPage": false,
                "searchKey": "types._WrongAssignCount",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _WrongAssignCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _WrongAssignCount\n```\n\n_WrongAssignCount occurs when the number of values on the right-hand side of an assignment or initialization expression does not match the number of variables on the left-hand side. \n\nExample: \n\n```\nvar x = 1, 2\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UnassignableOperand",
              "documentation": {
                "identifier": "_UnassignableOperand",
                "newPage": false,
                "searchKey": "types._UnassignableOperand",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UnassignableOperand"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UnassignableOperand\n```\n\n_UnassignableOperand occurs when the left-hand side of an assignment is not assignable. \n\nExample: \n\n```\nfunc f() {\n\tconst c = 1\n\tc = 2\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_NoNewVar",
              "documentation": {
                "identifier": "_NoNewVar",
                "newPage": false,
                "searchKey": "types._NoNewVar",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _NoNewVar"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _NoNewVar\n```\n\n_NoNewVar occurs when a short variable declaration (':=') does not declare new variables. \n\nExample: \n\n```\nfunc f() {\n\tx := 1\n\tx := 2\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MultiValAssignOp",
              "documentation": {
                "identifier": "_MultiValAssignOp",
                "newPage": false,
                "searchKey": "types._MultiValAssignOp",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MultiValAssignOp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MultiValAssignOp\n```\n\n_MultiValAssignOp occurs when an assignment operation (+=, *=, etc) does not have single-valued left-hand or right-hand side. \n\nPer the spec: \n\n```\n\"In assignment operations, both the left- and right-hand expression lists\nmust contain exactly one single-valued expression\"\n\n```\nExample: \n\n```\nfunc f() int {\n\tx, y := 1, 2\n\tx, y += 1\n\treturn x + y\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidIfaceAssign",
              "documentation": {
                "identifier": "_InvalidIfaceAssign",
                "newPage": false,
                "searchKey": "types._InvalidIfaceAssign",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidIfaceAssign"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidIfaceAssign\n```\n\n_InvalidIfaceAssign occurs when a value of type T is used as an interface, but T does not implement a method of the expected interface. \n\nExample: \n\n```\ntype I interface {\n\tf()\n}\n\ntype T int\n\nvar x I = T(1)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidChanAssign",
              "documentation": {
                "identifier": "_InvalidChanAssign",
                "newPage": false,
                "searchKey": "types._InvalidChanAssign",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidChanAssign"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidChanAssign\n```\n\n_InvalidChanAssign occurs when a chan assignment is invalid. \n\nPer the spec, a value x is assignable to a channel type T if: \n\n```\n\"x is a bidirectional channel value, T is a channel type, x's type V and\nT have identical element types, and at least one of V or T is not a\ndefined type.\"\n\n```\nExample: \n\n```\ntype T1 chan int\ntype T2 chan int\n\nvar x T1\n// Invalid assignment because both types are named\nvar _ T2 = x\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_IncompatibleAssign",
              "documentation": {
                "identifier": "_IncompatibleAssign",
                "newPage": false,
                "searchKey": "types._IncompatibleAssign",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _IncompatibleAssign"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _IncompatibleAssign\n```\n\n_IncompatibleAssign occurs when the type of the right-hand side expression in an assignment cannot be assigned to the type of the variable being assigned. \n\nExample: \n\n```\nvar x []int\nvar _ int = x\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UnaddressableFieldAssign",
              "documentation": {
                "identifier": "_UnaddressableFieldAssign",
                "newPage": false,
                "searchKey": "types._UnaddressableFieldAssign",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UnaddressableFieldAssign"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UnaddressableFieldAssign\n```\n\n_UnaddressableFieldAssign occurs when trying to assign to a struct field in a map value. \n\nExample: \n\n```\nfunc f() {\n\tm := make(map[string]struct{i int})\n\tm[\"foo\"].i = 42\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_NotAType",
              "documentation": {
                "identifier": "_NotAType",
                "newPage": false,
                "searchKey": "types._NotAType",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _NotAType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _NotAType\n```\n\n_NotAType occurs when the identifier used as the underlying type in a type declaration or the right-hand side of a type alias does not denote a type. \n\nExample: \n\n```\nvar S = 2\n\ntype T S\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidArrayLen",
              "documentation": {
                "identifier": "_InvalidArrayLen",
                "newPage": false,
                "searchKey": "types._InvalidArrayLen",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidArrayLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidArrayLen\n```\n\n_InvalidArrayLen occurs when an array length is not a constant value. \n\nExample: \n\n```\nvar n = 3\nvar _ = [n]int{}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_BlankIfaceMethod",
              "documentation": {
                "identifier": "_BlankIfaceMethod",
                "newPage": false,
                "searchKey": "types._BlankIfaceMethod",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BlankIfaceMethod"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BlankIfaceMethod\n```\n\n_BlankIfaceMethod occurs when a method name is '_'. \n\nPer the spec: \n\n```\n\"The name of each explicitly specified method must be unique and not\nblank.\"\n\n```\nExample: \n\n```\ntype T interface {\n\t_(int)\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_IncomparableMapKey",
              "documentation": {
                "identifier": "_IncomparableMapKey",
                "newPage": false,
                "searchKey": "types._IncomparableMapKey",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _IncomparableMapKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _IncomparableMapKey\n```\n\n_IncomparableMapKey occurs when a map key type does not support the == and != operators. \n\nPer the spec: \n\n```\n\"The comparison operators == and != must be fully defined for operands of\nthe key type; thus the key type must not be a function, map, or slice.\"\n\n```\nExample: \n\n```\nvar x map[T]int\n\ntype T []int\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidIfaceEmbed",
              "documentation": {
                "identifier": "_InvalidIfaceEmbed",
                "newPage": false,
                "searchKey": "types._InvalidIfaceEmbed",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidIfaceEmbed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidIfaceEmbed\n```\n\n_InvalidIfaceEmbed occurs when a non-interface type is embedded in an interface. \n\nExample: \n\n```\ntype T struct {}\n\nfunc (T) m()\n\ntype I interface {\n\tT\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidPtrEmbed",
              "documentation": {
                "identifier": "_InvalidPtrEmbed",
                "newPage": false,
                "searchKey": "types._InvalidPtrEmbed",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidPtrEmbed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidPtrEmbed\n```\n\n_InvalidPtrEmbed occurs when an embedded field is of the pointer form *T, and T itself is itself a pointer, an unsafe.Pointer, or an interface. \n\nPer the spec: \n\n```\n\"An embedded field must be specified as a type name T or as a pointer to\na non-interface type name *T, and T itself may not be a pointer type.\"\n\n```\nExample: \n\n```\ntype T *int\n\ntype S struct {\n\t*T\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_BadRecv",
              "documentation": {
                "identifier": "_BadRecv",
                "newPage": false,
                "searchKey": "types._BadRecv",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BadRecv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BadRecv\n```\n\n_BadRecv occurs when a method declaration does not have exactly one receiver parameter. \n\nExample: \n\n```\nfunc () _() {}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidRecv",
              "documentation": {
                "identifier": "_InvalidRecv",
                "newPage": false,
                "searchKey": "types._InvalidRecv",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidRecv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidRecv\n```\n\n_InvalidRecv occurs when a receiver type expression is not of the form T or *T, or T is a pointer type. \n\nExample: \n\n```\ntype T struct {}\n\nfunc (**T) m() {}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_DuplicateFieldAndMethod",
              "documentation": {
                "identifier": "_DuplicateFieldAndMethod",
                "newPage": false,
                "searchKey": "types._DuplicateFieldAndMethod",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _DuplicateFieldAndMethod"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _DuplicateFieldAndMethod\n```\n\n_DuplicateFieldAndMethod occurs when an identifier appears as both a field and method name. \n\nExample: \n\n```\ntype T struct {\n\tm int\n}\n\nfunc (T) m() {}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_DuplicateMethod",
              "documentation": {
                "identifier": "_DuplicateMethod",
                "newPage": false,
                "searchKey": "types._DuplicateMethod",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _DuplicateMethod"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _DuplicateMethod\n```\n\n_DuplicateMethod occurs when two methods on the same receiver type have the same name. \n\nExample: \n\n```\ntype T struct {}\nfunc (T) m() {}\nfunc (T) m(i int) int { return i }\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidBlank",
              "documentation": {
                "identifier": "_InvalidBlank",
                "newPage": false,
                "searchKey": "types._InvalidBlank",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidBlank"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidBlank\n```\n\n_InvalidBlank occurs when a blank identifier is used as a value or type. \n\nPer the spec: \n\n```\n\"The blank identifier may appear as an operand only on the left-hand side\nof an assignment.\"\n\n```\nExample: \n\n```\nvar x = _\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidIota",
              "documentation": {
                "identifier": "_InvalidIota",
                "newPage": false,
                "searchKey": "types._InvalidIota",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidIota"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidIota\n```\n\n_InvalidIota occurs when the predeclared identifier iota is used outside of a constant declaration. \n\nExample: \n\n```\nvar x = iota\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MissingInitBody",
              "documentation": {
                "identifier": "_MissingInitBody",
                "newPage": false,
                "searchKey": "types._MissingInitBody",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MissingInitBody"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MissingInitBody\n```\n\n_MissingInitBody occurs when an init function is missing its body. \n\nExample: \n\n```\nfunc init()\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidInitSig",
              "documentation": {
                "identifier": "_InvalidInitSig",
                "newPage": false,
                "searchKey": "types._InvalidInitSig",
                "tags": [
                  "private",
                  "deprecated"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidInitSig"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidInitSig\n```\n\n_InvalidInitSig occurs when an init function declares parameters or results. \n\nDeprecated: no longer emitted by the type checker. _InvalidInitDecl is used instead. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidInitDecl",
              "documentation": {
                "identifier": "_InvalidInitDecl",
                "newPage": false,
                "searchKey": "types._InvalidInitDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidInitDecl"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidInitDecl\n```\n\n_InvalidInitDecl occurs when init is declared as anything other than a function. \n\nExample: \n\n```\nvar init = 1\n\n```\nExample: \n\n```\nfunc init() int { return 1 }\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidMainDecl",
              "documentation": {
                "identifier": "_InvalidMainDecl",
                "newPage": false,
                "searchKey": "types._InvalidMainDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidMainDecl"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidMainDecl\n```\n\n_InvalidMainDecl occurs when main is declared as anything other than a function, in a main package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_TooManyValues",
              "documentation": {
                "identifier": "_TooManyValues",
                "newPage": false,
                "searchKey": "types._TooManyValues",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _TooManyValues"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _TooManyValues\n```\n\n_TooManyValues occurs when a function returns too many values for the expression context in which it is used. \n\nExample: \n\n```\nfunc ReturnTwo() (int, int) {\n\treturn 1, 2\n}\n\nvar x = ReturnTwo()\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_NotAnExpr",
              "documentation": {
                "identifier": "_NotAnExpr",
                "newPage": false,
                "searchKey": "types._NotAnExpr",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _NotAnExpr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _NotAnExpr\n```\n\n_NotAnExpr occurs when a type expression is used where a value expression is expected. \n\nExample: \n\n```\ntype T struct {}\n\nfunc f() {\n\tT\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_TruncatedFloat",
              "documentation": {
                "identifier": "_TruncatedFloat",
                "newPage": false,
                "searchKey": "types._TruncatedFloat",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _TruncatedFloat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _TruncatedFloat\n```\n\n_TruncatedFloat occurs when a float constant is truncated to an integer value. \n\nExample: \n\n```\nvar _ int = 98.6\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_NumericOverflow",
              "documentation": {
                "identifier": "_NumericOverflow",
                "newPage": false,
                "searchKey": "types._NumericOverflow",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _NumericOverflow"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _NumericOverflow\n```\n\n_NumericOverflow occurs when a numeric constant overflows its target type. \n\nExample: \n\n```\nvar x int8 = 1000\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UndefinedOp",
              "documentation": {
                "identifier": "_UndefinedOp",
                "newPage": false,
                "searchKey": "types._UndefinedOp",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UndefinedOp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UndefinedOp\n```\n\n_UndefinedOp occurs when an operator is not defined for the type(s) used in an operation. \n\nExample: \n\n```\nvar c = \"a\" - \"b\"\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MismatchedTypes",
              "documentation": {
                "identifier": "_MismatchedTypes",
                "newPage": false,
                "searchKey": "types._MismatchedTypes",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MismatchedTypes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MismatchedTypes\n```\n\n_MismatchedTypes occurs when operand types are incompatible in a binary operation. \n\nExample: \n\n```\nvar a = \"hello\"\nvar b = 1\nvar c = a - b\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_DivByZero",
              "documentation": {
                "identifier": "_DivByZero",
                "newPage": false,
                "searchKey": "types._DivByZero",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _DivByZero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _DivByZero\n```\n\n_DivByZero occurs when a division operation is provable at compile time to be a division by zero. \n\nExample: \n\n```\nconst divisor = 0\nvar x int = 1/divisor\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_NonNumericIncDec",
              "documentation": {
                "identifier": "_NonNumericIncDec",
                "newPage": false,
                "searchKey": "types._NonNumericIncDec",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _NonNumericIncDec"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _NonNumericIncDec\n```\n\n_NonNumericIncDec occurs when an increment or decrement operator is applied to a non-numeric value. \n\nExample: \n\n```\nfunc f() {\n\tvar c = \"c\"\n\tc++\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UnaddressableOperand",
              "documentation": {
                "identifier": "_UnaddressableOperand",
                "newPage": false,
                "searchKey": "types._UnaddressableOperand",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UnaddressableOperand"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UnaddressableOperand\n```\n\n_UnaddressableOperand occurs when the & operator is applied to an unaddressable expression. \n\nExample: \n\n```\nvar x = &1\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidIndirection",
              "documentation": {
                "identifier": "_InvalidIndirection",
                "newPage": false,
                "searchKey": "types._InvalidIndirection",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidIndirection"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidIndirection\n```\n\n_InvalidIndirection occurs when a non-pointer value is indirected via the '*' operator. \n\nExample: \n\n```\nvar x int\nvar y = *x\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_NonIndexableOperand",
              "documentation": {
                "identifier": "_NonIndexableOperand",
                "newPage": false,
                "searchKey": "types._NonIndexableOperand",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _NonIndexableOperand"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _NonIndexableOperand\n```\n\n_NonIndexableOperand occurs when an index operation is applied to a value that cannot be indexed. \n\nExample: \n\n```\nvar x = 1\nvar y = x[1]\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidIndex",
              "documentation": {
                "identifier": "_InvalidIndex",
                "newPage": false,
                "searchKey": "types._InvalidIndex",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidIndex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidIndex\n```\n\n_InvalidIndex occurs when an index argument is not of integer type, negative, or out-of-bounds. \n\nExample: \n\n```\nvar s = [...]int{1,2,3}\nvar x = s[5]\n\n```\nExample: \n\n```\nvar s = []int{1,2,3}\nvar _ = s[-1]\n\n```\nExample: \n\n```\nvar s = []int{1,2,3}\nvar i string\nvar _ = s[i]\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_SwappedSliceIndices",
              "documentation": {
                "identifier": "_SwappedSliceIndices",
                "newPage": false,
                "searchKey": "types._SwappedSliceIndices",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SwappedSliceIndices"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SwappedSliceIndices\n```\n\n_SwappedSliceIndices occurs when constant indices in a slice expression are decreasing in value. \n\nExample: \n\n```\nvar _ = []int{1,2,3}[2:1]\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_NonSliceableOperand",
              "documentation": {
                "identifier": "_NonSliceableOperand",
                "newPage": false,
                "searchKey": "types._NonSliceableOperand",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _NonSliceableOperand"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _NonSliceableOperand\n```\n\n_NonSliceableOperand occurs when a slice operation is applied to a value whose type is not sliceable, or is unaddressable. \n\nExample: \n\n```\nvar x = [...]int{1, 2, 3}[:1]\n\n```\nExample: \n\n```\nvar x = 1\nvar y = 1[:1]\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidSliceExpr",
              "documentation": {
                "identifier": "_InvalidSliceExpr",
                "newPage": false,
                "searchKey": "types._InvalidSliceExpr",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidSliceExpr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidSliceExpr\n```\n\n_InvalidSliceExpr occurs when a three-index slice expression (a[x:y:z]) is applied to a string. \n\nExample: \n\n```\nvar s = \"hello\"\nvar x = s[1:2:3]\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidShiftCount",
              "documentation": {
                "identifier": "_InvalidShiftCount",
                "newPage": false,
                "searchKey": "types._InvalidShiftCount",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidShiftCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidShiftCount\n```\n\n_InvalidShiftCount occurs when the right-hand side of a shift operation is either non-integer, negative, or too large. \n\nExample: \n\n```\nvar (\n\tx string\n\ty int = 1 << x\n)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidShiftOperand",
              "documentation": {
                "identifier": "_InvalidShiftOperand",
                "newPage": false,
                "searchKey": "types._InvalidShiftOperand",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidShiftOperand"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidShiftOperand\n```\n\n_InvalidShiftOperand occurs when the shifted operand is not an integer. \n\nExample: \n\n```\nvar s = \"hello\"\nvar x = s << 2\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidReceive",
              "documentation": {
                "identifier": "_InvalidReceive",
                "newPage": false,
                "searchKey": "types._InvalidReceive",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidReceive"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidReceive\n```\n\n_InvalidReceive occurs when there is a channel receive from a value that is either not a channel, or is a send-only channel. \n\nExample: \n\n```\nfunc f() {\n\tvar x = 1\n\t<-x\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidSend",
              "documentation": {
                "identifier": "_InvalidSend",
                "newPage": false,
                "searchKey": "types._InvalidSend",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidSend"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidSend\n```\n\n_InvalidSend occurs when there is a channel send to a value that is not a channel, or is a receive-only channel. \n\nExample: \n\n```\nfunc f() {\n\tvar x = 1\n\tx <- \"hello!\"\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_DuplicateLitKey",
              "documentation": {
                "identifier": "_DuplicateLitKey",
                "newPage": false,
                "searchKey": "types._DuplicateLitKey",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _DuplicateLitKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _DuplicateLitKey\n```\n\n_DuplicateLitKey occurs when an index is duplicated in a slice, array, or map literal. \n\nExample: \n\n```\nvar _ = []int{0:1, 0:2}\n\n```\nExample: \n\n```\nvar _ = map[string]int{\"a\": 1, \"a\": 2}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MissingLitKey",
              "documentation": {
                "identifier": "_MissingLitKey",
                "newPage": false,
                "searchKey": "types._MissingLitKey",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MissingLitKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MissingLitKey\n```\n\n_MissingLitKey occurs when a map literal is missing a key expression. \n\nExample: \n\n```\nvar _ = map[string]int{1}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidLitIndex",
              "documentation": {
                "identifier": "_InvalidLitIndex",
                "newPage": false,
                "searchKey": "types._InvalidLitIndex",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidLitIndex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidLitIndex\n```\n\n_InvalidLitIndex occurs when the key in a key-value element of a slice or array literal is not an integer constant. \n\nExample: \n\n```\nvar i = 0\nvar x = []string{i: \"world\"}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_OversizeArrayLit",
              "documentation": {
                "identifier": "_OversizeArrayLit",
                "newPage": false,
                "searchKey": "types._OversizeArrayLit",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _OversizeArrayLit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _OversizeArrayLit\n```\n\n_OversizeArrayLit occurs when an array literal exceeds its length. \n\nExample: \n\n```\nvar _ = [2]int{1,2,3}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MixedStructLit",
              "documentation": {
                "identifier": "_MixedStructLit",
                "newPage": false,
                "searchKey": "types._MixedStructLit",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MixedStructLit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MixedStructLit\n```\n\n_MixedStructLit occurs when a struct literal contains a mix of positional and named elements. \n\nExample: \n\n```\nvar _ = struct{i, j int}{i: 1, 2}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidStructLit",
              "documentation": {
                "identifier": "_InvalidStructLit",
                "newPage": false,
                "searchKey": "types._InvalidStructLit",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidStructLit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidStructLit\n```\n\n_InvalidStructLit occurs when a positional struct literal has an incorrect number of values. \n\nExample: \n\n```\nvar _ = struct{i, j int}{1,2,3}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MissingLitField",
              "documentation": {
                "identifier": "_MissingLitField",
                "newPage": false,
                "searchKey": "types._MissingLitField",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MissingLitField"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MissingLitField\n```\n\n_MissingLitField occurs when a struct literal refers to a field that does not exist on the struct type. \n\nExample: \n\n```\nvar _ = struct{i int}{j: 2}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_DuplicateLitField",
              "documentation": {
                "identifier": "_DuplicateLitField",
                "newPage": false,
                "searchKey": "types._DuplicateLitField",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _DuplicateLitField"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _DuplicateLitField\n```\n\n_DuplicateLitField occurs when a struct literal contains duplicated fields. \n\nExample: \n\n```\nvar _ = struct{i int}{i: 1, i: 2}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UnexportedLitField",
              "documentation": {
                "identifier": "_UnexportedLitField",
                "newPage": false,
                "searchKey": "types._UnexportedLitField",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UnexportedLitField"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UnexportedLitField\n```\n\n_UnexportedLitField occurs when a positional struct literal implicitly assigns an unexported field of an imported type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidLitField",
              "documentation": {
                "identifier": "_InvalidLitField",
                "newPage": false,
                "searchKey": "types._InvalidLitField",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidLitField"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidLitField\n```\n\n_InvalidLitField occurs when a field name is not a valid identifier. \n\nExample: \n\n```\nvar _ = struct{i int}{1: 1}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UntypedLit",
              "documentation": {
                "identifier": "_UntypedLit",
                "newPage": false,
                "searchKey": "types._UntypedLit",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UntypedLit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UntypedLit\n```\n\n_UntypedLit occurs when a composite literal omits a required type identifier. \n\nExample: \n\n```\ntype outer struct{\n\tinner struct { i int }\n}\n\nvar _ = outer{inner: {1}}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidLit",
              "documentation": {
                "identifier": "_InvalidLit",
                "newPage": false,
                "searchKey": "types._InvalidLit",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidLit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidLit\n```\n\n_InvalidLit occurs when a composite literal expression does not match its type. \n\nExample: \n\n```\ntype P *struct{\n\tx int\n}\nvar _ = P {}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_AmbiguousSelector",
              "documentation": {
                "identifier": "_AmbiguousSelector",
                "newPage": false,
                "searchKey": "types._AmbiguousSelector",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _AmbiguousSelector"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _AmbiguousSelector\n```\n\n_AmbiguousSelector occurs when a selector is ambiguous. \n\nExample: \n\n```\ntype E1 struct { i int }\ntype E2 struct { i int }\ntype T struct { E1; E2 }\n\nvar x T\nvar _ = x.i\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UndeclaredImportedName",
              "documentation": {
                "identifier": "_UndeclaredImportedName",
                "newPage": false,
                "searchKey": "types._UndeclaredImportedName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UndeclaredImportedName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UndeclaredImportedName\n```\n\n_UndeclaredImportedName occurs when a package-qualified identifier is undeclared by the imported package. \n\nExample: \n\n```\nimport \"go/types\"\n\nvar _ = types.NotAnActualIdentifier\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UnexportedName",
              "documentation": {
                "identifier": "_UnexportedName",
                "newPage": false,
                "searchKey": "types._UnexportedName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UnexportedName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UnexportedName\n```\n\n_UnexportedName occurs when a selector refers to an unexported identifier of an imported package. \n\nExample: \n\n```\nimport \"reflect\"\n\ntype _ reflect.flag\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UndeclaredName",
              "documentation": {
                "identifier": "_UndeclaredName",
                "newPage": false,
                "searchKey": "types._UndeclaredName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UndeclaredName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UndeclaredName\n```\n\n_UndeclaredName occurs when an identifier is not declared in the current scope. \n\nExample: \n\n```\nvar x T\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MissingFieldOrMethod",
              "documentation": {
                "identifier": "_MissingFieldOrMethod",
                "newPage": false,
                "searchKey": "types._MissingFieldOrMethod",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MissingFieldOrMethod"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MissingFieldOrMethod\n```\n\n_MissingFieldOrMethod occurs when a selector references a field or method that does not exist. \n\nExample: \n\n```\ntype T struct {}\n\nvar x = T{}.f\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_BadDotDotDotSyntax",
              "documentation": {
                "identifier": "_BadDotDotDotSyntax",
                "newPage": false,
                "searchKey": "types._BadDotDotDotSyntax",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BadDotDotDotSyntax"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BadDotDotDotSyntax\n```\n\n_BadDotDotDotSyntax occurs when a \"...\" occurs in a context where it is not valid. \n\nExample: \n\n```\nvar _ = map[int][...]int{0: {}}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_NonVariadicDotDotDot",
              "documentation": {
                "identifier": "_NonVariadicDotDotDot",
                "newPage": false,
                "searchKey": "types._NonVariadicDotDotDot",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _NonVariadicDotDotDot"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _NonVariadicDotDotDot\n```\n\n_NonVariadicDotDotDot occurs when a \"...\" is used on the final argument to a non-variadic function. \n\nExample: \n\n```\nfunc printArgs(s []string) {\n\tfor _, a := range s {\n\t\tprintln(a)\n\t}\n}\n\nfunc f() {\n\ts := []string{\"a\", \"b\", \"c\"}\n\tprintArgs(s...)\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MisplacedDotDotDot",
              "documentation": {
                "identifier": "_MisplacedDotDotDot",
                "newPage": false,
                "searchKey": "types._MisplacedDotDotDot",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MisplacedDotDotDot"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MisplacedDotDotDot\n```\n\n_MisplacedDotDotDot occurs when a \"...\" is used somewhere other than the final argument in a function declaration. \n\nExample: \n\n```\nfunc f(...int, int)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidDotDotDot",
              "documentation": {
                "identifier": "_InvalidDotDotDot",
                "newPage": false,
                "searchKey": "types._InvalidDotDotDot",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidDotDotDot"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidDotDotDot\n```\n\n_InvalidDotDotDot occurs when a \"...\" is used in a non-variadic built-in function. \n\nExample: \n\n```\nvar s = []int{1, 2, 3}\nvar l = len(s...)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UncalledBuiltin",
              "documentation": {
                "identifier": "_UncalledBuiltin",
                "newPage": false,
                "searchKey": "types._UncalledBuiltin",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UncalledBuiltin"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UncalledBuiltin\n```\n\n_UncalledBuiltin occurs when a built-in function is used as a function-valued expression, instead of being called. \n\nPer the spec: \n\n```\n\"The built-in functions do not have standard Go types, so they can only\nappear in call expressions; they cannot be used as function values.\"\n\n```\nExample: \n\n```\nvar _ = copy\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidAppend",
              "documentation": {
                "identifier": "_InvalidAppend",
                "newPage": false,
                "searchKey": "types._InvalidAppend",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidAppend"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidAppend\n```\n\n_InvalidAppend occurs when append is called with a first argument that is not a slice. \n\nExample: \n\n```\nvar _ = append(1, 2)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidCap",
              "documentation": {
                "identifier": "_InvalidCap",
                "newPage": false,
                "searchKey": "types._InvalidCap",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidCap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidCap\n```\n\n_InvalidCap occurs when an argument to the cap built-in function is not of supported type. \n\nSee [https://golang.org/ref/spec#Length_and_capacity](https://golang.org/ref/spec#Length_and_capacity) for information on which underlying types are supported as arguments to cap and len. \n\nExample: \n\n```\nvar s = 2\nvar x = cap(s)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidClose",
              "documentation": {
                "identifier": "_InvalidClose",
                "newPage": false,
                "searchKey": "types._InvalidClose",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidClose"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidClose\n```\n\n_InvalidClose occurs when close(...) is called with an argument that is not of channel type, or that is a receive-only channel. \n\nExample: \n\n```\nfunc f() {\n\tvar x int\n\tclose(x)\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidCopy",
              "documentation": {
                "identifier": "_InvalidCopy",
                "newPage": false,
                "searchKey": "types._InvalidCopy",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidCopy"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidCopy\n```\n\n_InvalidCopy occurs when the arguments are not of slice type or do not have compatible type. \n\nSee [https://golang.org/ref/spec#Appending_and_copying_slices](https://golang.org/ref/spec#Appending_and_copying_slices) for more information on the type requirements for the copy built-in. \n\nExample: \n\n```\nfunc f() {\n\tvar x []int\n\ty := []int64{1,2,3}\n\tcopy(x, y)\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidComplex",
              "documentation": {
                "identifier": "_InvalidComplex",
                "newPage": false,
                "searchKey": "types._InvalidComplex",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidComplex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidComplex\n```\n\n_InvalidComplex occurs when the complex built-in function is called with arguments with incompatible types. \n\nExample: \n\n```\nvar _ = complex(float32(1), float64(2))\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidDelete",
              "documentation": {
                "identifier": "_InvalidDelete",
                "newPage": false,
                "searchKey": "types._InvalidDelete",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidDelete"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidDelete\n```\n\n_InvalidDelete occurs when the delete built-in function is called with a first argument that is not a map. \n\nExample: \n\n```\nfunc f() {\n\tm := \"hello\"\n\tdelete(m, \"e\")\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidImag",
              "documentation": {
                "identifier": "_InvalidImag",
                "newPage": false,
                "searchKey": "types._InvalidImag",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidImag"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidImag\n```\n\n_InvalidImag occurs when the imag built-in function is called with an argument that does not have complex type. \n\nExample: \n\n```\nvar _ = imag(int(1))\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidLen",
              "documentation": {
                "identifier": "_InvalidLen",
                "newPage": false,
                "searchKey": "types._InvalidLen",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidLen\n```\n\n_InvalidLen occurs when an argument to the len built-in function is not of supported type. \n\nSee [https://golang.org/ref/spec#Length_and_capacity](https://golang.org/ref/spec#Length_and_capacity) for information on which underlying types are supported as arguments to cap and len. \n\nExample: \n\n```\nvar s = 2\nvar x = len(s)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_SwappedMakeArgs",
              "documentation": {
                "identifier": "_SwappedMakeArgs",
                "newPage": false,
                "searchKey": "types._SwappedMakeArgs",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SwappedMakeArgs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SwappedMakeArgs\n```\n\n_SwappedMakeArgs occurs when make is called with three arguments, and its length argument is larger than its capacity argument. \n\nExample: \n\n```\nvar x = make([]int, 3, 2)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidMake",
              "documentation": {
                "identifier": "_InvalidMake",
                "newPage": false,
                "searchKey": "types._InvalidMake",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidMake"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidMake\n```\n\n_InvalidMake occurs when make is called with an unsupported type argument. \n\nSee [https://golang.org/ref/spec#Making_slices_maps_and_channels](https://golang.org/ref/spec#Making_slices_maps_and_channels) for information on the types that may be created using make. \n\nExample: \n\n```\nvar x = make(int)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidReal",
              "documentation": {
                "identifier": "_InvalidReal",
                "newPage": false,
                "searchKey": "types._InvalidReal",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidReal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidReal\n```\n\n_InvalidReal occurs when the real built-in function is called with an argument that does not have complex type. \n\nExample: \n\n```\nvar _ = real(int(1))\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidAssert",
              "documentation": {
                "identifier": "_InvalidAssert",
                "newPage": false,
                "searchKey": "types._InvalidAssert",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidAssert"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidAssert\n```\n\n_InvalidAssert occurs when a type assertion is applied to a value that is not of interface type. \n\nExample: \n\n```\nvar x = 1\nvar _ = x.(float64)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_ImpossibleAssert",
              "documentation": {
                "identifier": "_ImpossibleAssert",
                "newPage": false,
                "searchKey": "types._ImpossibleAssert",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _ImpossibleAssert"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _ImpossibleAssert\n```\n\n_ImpossibleAssert occurs for a type assertion x.(T) when the value x of interface cannot have dynamic type T, due to a missing or mismatching method on T. \n\nExample: \n\n```\ntype T int\n\nfunc (t *T) m() int { return int(*t) }\n\ntype I interface { m() int }\n\nvar x I\nvar _ = x.(T)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidConversion",
              "documentation": {
                "identifier": "_InvalidConversion",
                "newPage": false,
                "searchKey": "types._InvalidConversion",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidConversion"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidConversion\n```\n\n_InvalidConversion occurs when the argument type cannot be converted to the target. \n\nSee [https://golang.org/ref/spec#Conversions](https://golang.org/ref/spec#Conversions) for the rules of convertibility. \n\nExample: \n\n```\nvar x float64\nvar _ = string(x)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidUntypedConversion",
              "documentation": {
                "identifier": "_InvalidUntypedConversion",
                "newPage": false,
                "searchKey": "types._InvalidUntypedConversion",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidUntypedConversion"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidUntypedConversion\n```\n\n_InvalidUntypedConversion occurs when an there is no valid implicit conversion from an untyped value satisfying the type constraints of the context in which it is used. \n\nExample: \n\n```\nvar _ = 1 + \"\"\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_BadOffsetofSyntax",
              "documentation": {
                "identifier": "_BadOffsetofSyntax",
                "newPage": false,
                "searchKey": "types._BadOffsetofSyntax",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BadOffsetofSyntax"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BadOffsetofSyntax\n```\n\n_BadOffsetofSyntax occurs when unsafe.Offsetof is called with an argument that is not a selector expression. \n\nExample: \n\n```\nimport \"unsafe\"\n\nvar x int\nvar _ = unsafe.Offsetof(x)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidOffsetof",
              "documentation": {
                "identifier": "_InvalidOffsetof",
                "newPage": false,
                "searchKey": "types._InvalidOffsetof",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidOffsetof"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidOffsetof\n```\n\n_InvalidOffsetof occurs when unsafe.Offsetof is called with a method selector, rather than a field selector, or when the field is embedded via a pointer. \n\nPer the spec: \n\n```\n\"If f is an embedded field, it must be reachable without pointer\nindirections through fields of the struct. \"\n\n```\nExample: \n\n```\nimport \"unsafe\"\n\ntype T struct { f int }\ntype S struct { *T }\nvar s S\nvar _ = unsafe.Offsetof(s.f)\n\n```\nExample: \n\n```\nimport \"unsafe\"\n\ntype S struct{}\n\nfunc (S) m() {}\n\nvar s S\nvar _ = unsafe.Offsetof(s.m)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UnusedExpr",
              "documentation": {
                "identifier": "_UnusedExpr",
                "newPage": false,
                "searchKey": "types._UnusedExpr",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UnusedExpr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UnusedExpr\n```\n\n_UnusedExpr occurs when a side-effect free expression is used as a statement. Such a statement has no effect. \n\nExample: \n\n```\nfunc f(i int) {\n\ti*i\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UnusedVar",
              "documentation": {
                "identifier": "_UnusedVar",
                "newPage": false,
                "searchKey": "types._UnusedVar",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UnusedVar"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UnusedVar\n```\n\n_UnusedVar occurs when a variable is declared but unused. \n\nExample: \n\n```\nfunc f() {\n\tx := 1\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MissingReturn",
              "documentation": {
                "identifier": "_MissingReturn",
                "newPage": false,
                "searchKey": "types._MissingReturn",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MissingReturn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MissingReturn\n```\n\n_MissingReturn occurs when a function with results is missing a return statement. \n\nExample: \n\n```\nfunc f() int {}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_WrongResultCount",
              "documentation": {
                "identifier": "_WrongResultCount",
                "newPage": false,
                "searchKey": "types._WrongResultCount",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _WrongResultCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _WrongResultCount\n```\n\n_WrongResultCount occurs when a return statement returns an incorrect number of values. \n\nExample: \n\n```\nfunc ReturnOne() int {\n\treturn 1, 2\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_OutOfScopeResult",
              "documentation": {
                "identifier": "_OutOfScopeResult",
                "newPage": false,
                "searchKey": "types._OutOfScopeResult",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _OutOfScopeResult"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _OutOfScopeResult\n```\n\n_OutOfScopeResult occurs when the name of a value implicitly returned by an empty return statement is shadowed in a nested scope. \n\nExample: \n\n```\nfunc factor(n int) (i int) {\n\tfor i := 2; i < n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn\n\t\t}\n\t}\n\treturn 0\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidCond",
              "documentation": {
                "identifier": "_InvalidCond",
                "newPage": false,
                "searchKey": "types._InvalidCond",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidCond"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidCond\n```\n\n_InvalidCond occurs when an if condition is not a boolean expression. \n\nExample: \n\n```\nfunc checkReturn(i int) {\n\tif i {\n\t\tpanic(\"non-zero return\")\n\t}\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidPostDecl",
              "documentation": {
                "identifier": "_InvalidPostDecl",
                "newPage": false,
                "searchKey": "types._InvalidPostDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidPostDecl"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidPostDecl\n```\n\n_InvalidPostDecl occurs when there is a declaration in a for-loop post statement. \n\nExample: \n\n```\nfunc f() {\n\tfor i := 0; i < 10; j := 0 {}\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidIterVar",
              "documentation": {
                "identifier": "_InvalidIterVar",
                "newPage": false,
                "searchKey": "types._InvalidIterVar",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidIterVar"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidIterVar\n```\n\n_InvalidIterVar occurs when two iteration variables are used while ranging over a channel. \n\nExample: \n\n```\nfunc f(c chan int) {\n\tfor k, v := range c {\n\t\tprintln(k, v)\n\t}\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidRangeExpr",
              "documentation": {
                "identifier": "_InvalidRangeExpr",
                "newPage": false,
                "searchKey": "types._InvalidRangeExpr",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidRangeExpr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidRangeExpr\n```\n\n_InvalidRangeExpr occurs when the type of a range expression is not array, slice, string, map, or channel. \n\nExample: \n\n```\nfunc f(i int) {\n\tfor j := range i {\n\t\tprintln(j)\n\t}\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MisplacedBreak",
              "documentation": {
                "identifier": "_MisplacedBreak",
                "newPage": false,
                "searchKey": "types._MisplacedBreak",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MisplacedBreak"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MisplacedBreak\n```\n\n_MisplacedBreak occurs when a break statement is not within a for, switch, or select statement of the innermost function definition. \n\nExample: \n\n```\nfunc f() {\n\tbreak\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MisplacedContinue",
              "documentation": {
                "identifier": "_MisplacedContinue",
                "newPage": false,
                "searchKey": "types._MisplacedContinue",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MisplacedContinue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MisplacedContinue\n```\n\n_MisplacedContinue occurs when a continue statement is not within a for loop of the innermost function definition. \n\nExample: \n\n```\nfunc sumeven(n int) int {\n\tproceed := func() {\n\t\tcontinue\n\t}\n\tsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i % 2 != 0 {\n\t\t\tproceed()\n\t\t}\n\t\tsum += i\n\t}\n\treturn sum\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MisplacedFallthrough",
              "documentation": {
                "identifier": "_MisplacedFallthrough",
                "newPage": false,
                "searchKey": "types._MisplacedFallthrough",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MisplacedFallthrough"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MisplacedFallthrough\n```\n\n_MisplacedFallthrough occurs when a fallthrough statement is not within an expression switch. \n\nExample: \n\n```\nfunc typename(i interface{}) string {\n\tswitch i.(type) {\n\tcase int64:\n\t\tfallthrough\n\tcase int:\n\t\treturn \"int\"\n\t}\n\treturn \"unsupported\"\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_DuplicateCase",
              "documentation": {
                "identifier": "_DuplicateCase",
                "newPage": false,
                "searchKey": "types._DuplicateCase",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _DuplicateCase"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _DuplicateCase\n```\n\n_DuplicateCase occurs when a type or expression switch has duplicate cases. \n\nExample: \n\n```\nfunc printInt(i int) {\n\tswitch i {\n\tcase 1:\n\t\tprintln(\"one\")\n\tcase 1:\n\t\tprintln(\"One\")\n\t}\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_DuplicateDefault",
              "documentation": {
                "identifier": "_DuplicateDefault",
                "newPage": false,
                "searchKey": "types._DuplicateDefault",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _DuplicateDefault"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _DuplicateDefault\n```\n\n_DuplicateDefault occurs when a type or expression switch has multiple default clauses. \n\nExample: \n\n```\nfunc printInt(i int) {\n\tswitch i {\n\tcase 1:\n\t\tprintln(\"one\")\n\tdefault:\n\t\tprintln(\"One\")\n\tdefault:\n\t\tprintln(\"1\")\n\t}\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_BadTypeKeyword",
              "documentation": {
                "identifier": "_BadTypeKeyword",
                "newPage": false,
                "searchKey": "types._BadTypeKeyword",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BadTypeKeyword"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BadTypeKeyword\n```\n\n_BadTypeKeyword occurs when a .(type) expression is used anywhere other than a type switch. \n\nExample: \n\n```\ntype I interface {\n\tm()\n}\nvar t I\nvar _ = t.(type)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidTypeSwitch",
              "documentation": {
                "identifier": "_InvalidTypeSwitch",
                "newPage": false,
                "searchKey": "types._InvalidTypeSwitch",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidTypeSwitch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidTypeSwitch\n```\n\n_InvalidTypeSwitch occurs when .(type) is used on an expression that is not of interface type. \n\nExample: \n\n```\nfunc f(i int) {\n\tswitch x := i.(type) {}\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidExprSwitch",
              "documentation": {
                "identifier": "_InvalidExprSwitch",
                "newPage": false,
                "searchKey": "types._InvalidExprSwitch",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidExprSwitch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidExprSwitch\n```\n\n_InvalidExprSwitch occurs when a switch expression is not comparable. \n\nExample: \n\n```\nfunc _() {\n\tvar a struct{ _ func() }\n\tswitch a /* ERROR cannot switch on a */ {\n\t}\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidSelectCase",
              "documentation": {
                "identifier": "_InvalidSelectCase",
                "newPage": false,
                "searchKey": "types._InvalidSelectCase",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidSelectCase"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidSelectCase\n```\n\n_InvalidSelectCase occurs when a select case is not a channel send or receive. \n\nExample: \n\n```\nfunc checkChan(c <-chan int) bool {\n\tselect {\n\tcase c:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UndeclaredLabel",
              "documentation": {
                "identifier": "_UndeclaredLabel",
                "newPage": false,
                "searchKey": "types._UndeclaredLabel",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UndeclaredLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UndeclaredLabel\n```\n\n_UndeclaredLabel occurs when an undeclared label is jumped to. \n\nExample: \n\n```\nfunc f() {\n\tgoto L\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_DuplicateLabel",
              "documentation": {
                "identifier": "_DuplicateLabel",
                "newPage": false,
                "searchKey": "types._DuplicateLabel",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _DuplicateLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _DuplicateLabel\n```\n\n_DuplicateLabel occurs when a label is declared more than once. \n\nExample: \n\n```\nfunc f() int {\nL:\nL:\n\treturn 1\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_MisplacedLabel",
              "documentation": {
                "identifier": "_MisplacedLabel",
                "newPage": false,
                "searchKey": "types._MisplacedLabel",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MisplacedLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MisplacedLabel\n```\n\n_MisplacedLabel occurs when a break or continue label is not on a for, switch, or select statement. \n\nExample: \n\n```\nfunc f() {\nL:\n\ta := []int{1,2,3}\n\tfor _, e := range a {\n\t\tif e > 10 {\n\t\t\tbreak L\n\t\t}\n\t\tprintln(a)\n\t}\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UnusedLabel",
              "documentation": {
                "identifier": "_UnusedLabel",
                "newPage": false,
                "searchKey": "types._UnusedLabel",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UnusedLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UnusedLabel\n```\n\n_UnusedLabel occurs when a label is declared but not used. \n\nExample: \n\n```\nfunc f() {\nL:\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_JumpOverDecl",
              "documentation": {
                "identifier": "_JumpOverDecl",
                "newPage": false,
                "searchKey": "types._JumpOverDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _JumpOverDecl"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _JumpOverDecl\n```\n\n_JumpOverDecl occurs when a label jumps over a variable declaration. \n\nExample: \n\n```\nfunc f() int {\n\tgoto L\n\tx := 2\nL:\n\tx++\n\treturn x\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_JumpIntoBlock",
              "documentation": {
                "identifier": "_JumpIntoBlock",
                "newPage": false,
                "searchKey": "types._JumpIntoBlock",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _JumpIntoBlock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _JumpIntoBlock\n```\n\n_JumpIntoBlock occurs when a forward jump goes to a label inside a nested block. \n\nExample: \n\n```\nfunc f(x int) {\n\tgoto L\n\tif x > 0 {\n\tL:\n\t\tprint(\"inside block\")\n\t}\n\n```\n} \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidMethodExpr",
              "documentation": {
                "identifier": "_InvalidMethodExpr",
                "newPage": false,
                "searchKey": "types._InvalidMethodExpr",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidMethodExpr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidMethodExpr\n```\n\n_InvalidMethodExpr occurs when a pointer method is called but the argument is not addressable. \n\nExample: \n\n```\ntype T struct {}\n\nfunc (*T) m() int { return 1 }\n\nvar _ = T.m(T{})\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_WrongArgCount",
              "documentation": {
                "identifier": "_WrongArgCount",
                "newPage": false,
                "searchKey": "types._WrongArgCount",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _WrongArgCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _WrongArgCount\n```\n\n_WrongArgCount occurs when too few or too many arguments are passed by a function call. \n\nExample: \n\n```\nfunc f(i int) {}\nvar x = f()\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidCall",
              "documentation": {
                "identifier": "_InvalidCall",
                "newPage": false,
                "searchKey": "types._InvalidCall",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidCall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidCall\n```\n\n_InvalidCall occurs when an expression is called that is not of function type. \n\nExample: \n\n```\nvar x = \"x\"\nvar y = x()\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_UnusedResults",
              "documentation": {
                "identifier": "_UnusedResults",
                "newPage": false,
                "searchKey": "types._UnusedResults",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _UnusedResults"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _UnusedResults\n```\n\n_UnusedResults occurs when a restricted expression-only built-in function is suspended via go or defer. Such a suspension discards the results of these side-effect free built-in functions, and therefore is ineffectual. \n\nExample: \n\n```\nfunc f(a []int) int {\n\tdefer len(a)\n\treturn i\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidDefer",
              "documentation": {
                "identifier": "_InvalidDefer",
                "newPage": false,
                "searchKey": "types._InvalidDefer",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidDefer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidDefer\n```\n\n_InvalidDefer occurs when a deferred expression is not a function call, for example if the expression is a type conversion. \n\nExample: \n\n```\nfunc f(i int) int {\n\tdefer int32(i)\n\treturn i\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidGo",
              "documentation": {
                "identifier": "_InvalidGo",
                "newPage": false,
                "searchKey": "types._InvalidGo",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidGo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidGo\n```\n\n_InvalidGo occurs when a go expression is not a function call, for example if the expression is a type conversion. \n\nExample: \n\n```\nfunc f(i int) int {\n\tgo int32(i)\n\treturn i\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_BadDecl",
              "documentation": {
                "identifier": "_BadDecl",
                "newPage": false,
                "searchKey": "types._BadDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BadDecl"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BadDecl\n```\n\n_BadDecl occurs when a declaration has invalid syntax. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_RepeatedDecl",
              "documentation": {
                "identifier": "_RepeatedDecl",
                "newPage": false,
                "searchKey": "types._RepeatedDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _RepeatedDecl"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _RepeatedDecl\n```\n\n_RepeatedDecl occurs when an identifier occurs more than once on the left hand side of a short variable declaration. \n\nExample: \n\n```\nfunc _() {\n\tx, y, y := 1, 2, 3\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidUnsafeAdd",
              "documentation": {
                "identifier": "_InvalidUnsafeAdd",
                "newPage": false,
                "searchKey": "types._InvalidUnsafeAdd",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidUnsafeAdd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidUnsafeAdd\n```\n\n_InvalidUnsafeAdd occurs when unsafe.Add is called with a length argument that is not of integer type. \n\nExample: \n\n```\nimport \"unsafe\"\n\nvar p unsafe.Pointer\nvar _ = unsafe.Add(p, float64(1))\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_InvalidUnsafeSlice",
              "documentation": {
                "identifier": "_InvalidUnsafeSlice",
                "newPage": false,
                "searchKey": "types._InvalidUnsafeSlice",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _InvalidUnsafeSlice"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _InvalidUnsafeSlice\n```\n\n_InvalidUnsafeSlice occurs when unsafe.Slice is called with a pointer argument that is not of pointer type or a length argument that is not of integer type, negative, or out of bounds. \n\nExample: \n\n```\nimport \"unsafe\"\n\nvar x int\nvar _ = unsafe.Slice(x, 1)\n\n```\nExample: \n\n```\nimport \"unsafe\"\n\nvar x int\nvar _ = unsafe.Slice(&x, float64(1))\n\n```\nExample: \n\n```\nimport \"unsafe\"\n\nvar x int\nvar _ = unsafe.Slice(&x, -1)\n\n```\nExample: \n\n```\nimport \"unsafe\"\n\nvar x int\nvar _ = unsafe.Slice(&x, uint64(1) << 63)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Todo",
              "documentation": {
                "identifier": "_Todo",
                "newPage": false,
                "searchKey": "types._Todo",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Todo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Todo\n```\n\n_Todo is a placeholder for error codes that have not been decided. TODO(rFindley) remove this error code after deciding on errors for generics code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#conversion",
              "documentation": {
                "identifier": "conversion",
                "newPage": false,
                "searchKey": "types.conversion",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const conversion"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst conversion exprKind = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#expression",
              "documentation": {
                "identifier": "expression",
                "newPage": false,
                "searchKey": "types.expression",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const expression"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst expression\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#statement",
              "documentation": {
                "identifier": "statement",
                "newPage": false,
                "searchKey": "types.statement",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const statement"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst statement\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#white",
              "documentation": {
                "identifier": "white",
                "newPage": false,
                "searchKey": "types.white",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const white"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst white color = iota\n```\n\nAn object may be painted in one of three colors. Color values other than white or black are considered grey. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#black",
              "documentation": {
                "identifier": "black",
                "newPage": false,
                "searchKey": "types.black",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const black"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst black\n```\n\nAn object may be painted in one of three colors. Color values other than white or black are considered grey. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#grey",
              "documentation": {
                "identifier": "grey",
                "newPage": false,
                "searchKey": "types.grey",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const grey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst grey // must be > white and black\n\n```\n\nAn object may be painted in one of three colors. Color values other than white or black are considered grey. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#invalid",
              "documentation": {
                "identifier": "invalid",
                "newPage": false,
                "searchKey": "types.invalid",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const invalid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst invalid operandMode = iota // operand is invalid\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#novalue",
              "documentation": {
                "identifier": "novalue",
                "newPage": false,
                "searchKey": "types.novalue",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const novalue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst novalue // operand represents no value (result of a function call w/o result)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#builtin",
              "documentation": {
                "identifier": "builtin",
                "newPage": false,
                "searchKey": "types.builtin",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const builtin"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst builtin // operand is a built-in function\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#typexpr",
              "documentation": {
                "identifier": "typexpr",
                "newPage": false,
                "searchKey": "types.typexpr",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const typexpr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typexpr // operand is a type\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#constant_",
              "documentation": {
                "identifier": "constant_",
                "newPage": false,
                "searchKey": "types.constant_",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const constant_"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst constant_ // operand is a constant; the operand's typ is a Basic type\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#variable",
              "documentation": {
                "identifier": "variable",
                "newPage": false,
                "searchKey": "types.variable",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const variable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst variable // operand is an addressable variable\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#mapindex",
              "documentation": {
                "identifier": "mapindex",
                "newPage": false,
                "searchKey": "types.mapindex",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const mapindex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mapindex // operand is a map index expression (acts like a variable on lhs, commaok on rhs of an assignment)\n = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#value",
              "documentation": {
                "identifier": "value",
                "newPage": false,
                "searchKey": "types.value",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const value"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst value // operand is a computed value\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#commaok",
              "documentation": {
                "identifier": "commaok",
                "newPage": false,
                "searchKey": "types.commaok",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const commaok"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst commaok // like value, but operand may be used in a comma,ok expression\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#commaerr",
              "documentation": {
                "identifier": "commaerr",
                "newPage": false,
                "searchKey": "types.commaerr",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const commaerr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst commaerr // like commaok, but second value is error, not boolean\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#cgofunc",
              "documentation": {
                "identifier": "cgofunc",
                "newPage": false,
                "searchKey": "types.cgofunc",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const cgofunc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cgofunc // operand is a cgo function\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#FieldVal",
              "documentation": {
                "identifier": "FieldVal",
                "newPage": false,
                "searchKey": "types.FieldVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const FieldVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FieldVal SelectionKind = iota // x.f is a struct field selector\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#MethodVal",
              "documentation": {
                "identifier": "MethodVal",
                "newPage": false,
                "searchKey": "types.MethodVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const MethodVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MethodVal // x.f is a method selector\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#MethodExpr",
              "documentation": {
                "identifier": "MethodExpr",
                "newPage": false,
                "searchKey": "types.MethodExpr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const MethodExpr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MethodExpr // x.f is a method expression\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#breakOk",
              "documentation": {
                "identifier": "breakOk",
                "newPage": false,
                "searchKey": "types.breakOk",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const breakOk"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst breakOk stmtContext = 1 << iota\n```\n\npermissible control-flow statements \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#continueOk",
              "documentation": {
                "identifier": "continueOk",
                "newPage": false,
                "searchKey": "types.continueOk",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const continueOk"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst continueOk\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#fallthroughOk",
              "documentation": {
                "identifier": "fallthroughOk",
                "newPage": false,
                "searchKey": "types.fallthroughOk",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const fallthroughOk"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst fallthroughOk\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#finalSwitchCase",
              "documentation": {
                "identifier": "finalSwitchCase",
                "newPage": false,
                "searchKey": "types.finalSwitchCase",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const finalSwitchCase"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst finalSwitchCase\n```\n\nadditional context information \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Invalid",
              "documentation": {
                "identifier": "Invalid",
                "newPage": false,
                "searchKey": "types.Invalid",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Invalid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Invalid BasicKind = iota // type is invalid\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Bool",
              "documentation": {
                "identifier": "Bool",
                "newPage": false,
                "searchKey": "types.Bool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Bool\n```\n\npredeclared types \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Int",
              "documentation": {
                "identifier": "Int",
                "newPage": false,
                "searchKey": "types.Int",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Int8",
              "documentation": {
                "identifier": "Int8",
                "newPage": false,
                "searchKey": "types.Int8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Int8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Int8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Int16",
              "documentation": {
                "identifier": "Int16",
                "newPage": false,
                "searchKey": "types.Int16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Int16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Int16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Int32",
              "documentation": {
                "identifier": "Int32",
                "newPage": false,
                "searchKey": "types.Int32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Int64",
              "documentation": {
                "identifier": "Int64",
                "newPage": false,
                "searchKey": "types.Int64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Uint",
              "documentation": {
                "identifier": "Uint",
                "newPage": false,
                "searchKey": "types.Uint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uint\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Uint8",
              "documentation": {
                "identifier": "Uint8",
                "newPage": false,
                "searchKey": "types.Uint8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uint8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Uint16",
              "documentation": {
                "identifier": "Uint16",
                "newPage": false,
                "searchKey": "types.Uint16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uint16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Uint32",
              "documentation": {
                "identifier": "Uint32",
                "newPage": false,
                "searchKey": "types.Uint32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Uint64",
              "documentation": {
                "identifier": "Uint64",
                "newPage": false,
                "searchKey": "types.Uint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Uintptr",
              "documentation": {
                "identifier": "Uintptr",
                "newPage": false,
                "searchKey": "types.Uintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Float32",
              "documentation": {
                "identifier": "Float32",
                "newPage": false,
                "searchKey": "types.Float32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Float32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Float32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Float64",
              "documentation": {
                "identifier": "Float64",
                "newPage": false,
                "searchKey": "types.Float64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Float64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Complex64",
              "documentation": {
                "identifier": "Complex64",
                "newPage": false,
                "searchKey": "types.Complex64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Complex64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Complex64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Complex128",
              "documentation": {
                "identifier": "Complex128",
                "newPage": false,
                "searchKey": "types.Complex128",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Complex128"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Complex128\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#String",
              "documentation": {
                "identifier": "String",
                "newPage": false,
                "searchKey": "types.String",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const String"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst String\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#UnsafePointer",
              "documentation": {
                "identifier": "UnsafePointer",
                "newPage": false,
                "searchKey": "types.UnsafePointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const UnsafePointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UnsafePointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#UntypedBool",
              "documentation": {
                "identifier": "UntypedBool",
                "newPage": false,
                "searchKey": "types.UntypedBool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const UntypedBool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UntypedBool\n```\n\ntypes for untyped values \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#UntypedInt",
              "documentation": {
                "identifier": "UntypedInt",
                "newPage": false,
                "searchKey": "types.UntypedInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const UntypedInt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UntypedInt\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#UntypedRune",
              "documentation": {
                "identifier": "UntypedRune",
                "newPage": false,
                "searchKey": "types.UntypedRune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const UntypedRune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UntypedRune\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#UntypedFloat",
              "documentation": {
                "identifier": "UntypedFloat",
                "newPage": false,
                "searchKey": "types.UntypedFloat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const UntypedFloat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UntypedFloat\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#UntypedComplex",
              "documentation": {
                "identifier": "UntypedComplex",
                "newPage": false,
                "searchKey": "types.UntypedComplex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const UntypedComplex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UntypedComplex\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#UntypedString",
              "documentation": {
                "identifier": "UntypedString",
                "newPage": false,
                "searchKey": "types.UntypedString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const UntypedString"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UntypedString\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#UntypedNil",
              "documentation": {
                "identifier": "UntypedNil",
                "newPage": false,
                "searchKey": "types.UntypedNil",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const UntypedNil"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UntypedNil\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Byte",
              "documentation": {
                "identifier": "Byte",
                "newPage": false,
                "searchKey": "types.Byte",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Byte = Uint8\n```\n\naliases \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Rune",
              "documentation": {
                "identifier": "Rune",
                "newPage": false,
                "searchKey": "types.Rune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Rune = Int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IsBoolean",
              "documentation": {
                "identifier": "IsBoolean",
                "newPage": false,
                "searchKey": "types.IsBoolean",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const IsBoolean"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IsBoolean BasicInfo = 1 << iota\n```\n\nProperties of basic types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IsInteger",
              "documentation": {
                "identifier": "IsInteger",
                "newPage": false,
                "searchKey": "types.IsInteger",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const IsInteger"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IsInteger\n```\n\nProperties of basic types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IsUnsigned",
              "documentation": {
                "identifier": "IsUnsigned",
                "newPage": false,
                "searchKey": "types.IsUnsigned",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const IsUnsigned"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IsUnsigned\n```\n\nProperties of basic types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IsFloat",
              "documentation": {
                "identifier": "IsFloat",
                "newPage": false,
                "searchKey": "types.IsFloat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const IsFloat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IsFloat\n```\n\nProperties of basic types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IsComplex",
              "documentation": {
                "identifier": "IsComplex",
                "newPage": false,
                "searchKey": "types.IsComplex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const IsComplex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IsComplex\n```\n\nProperties of basic types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IsString",
              "documentation": {
                "identifier": "IsString",
                "newPage": false,
                "searchKey": "types.IsString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const IsString"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IsString\n```\n\nProperties of basic types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IsUntyped",
              "documentation": {
                "identifier": "IsUntyped",
                "newPage": false,
                "searchKey": "types.IsUntyped",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const IsUntyped"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IsUntyped\n```\n\nProperties of basic types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IsOrdered",
              "documentation": {
                "identifier": "IsOrdered",
                "newPage": false,
                "searchKey": "types.IsOrdered",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const IsOrdered"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IsOrdered = IsInteger | IsFloat | IsString\n```\n\nProperties of basic types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IsNumeric",
              "documentation": {
                "identifier": "IsNumeric",
                "newPage": false,
                "searchKey": "types.IsNumeric",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const IsNumeric"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IsNumeric = IsInteger | IsFloat | IsComplex\n```\n\nProperties of basic types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IsConstType",
              "documentation": {
                "identifier": "IsConstType",
                "newPage": false,
                "searchKey": "types.IsConstType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const IsConstType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst IsConstType = IsBoolean | IsNumeric | IsString\n```\n\nProperties of basic types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#SendRecv",
              "documentation": {
                "identifier": "SendRecv",
                "newPage": false,
                "searchKey": "types.SendRecv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const SendRecv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SendRecv ChanDir = iota\n```\n\nThe direction of a channel is indicated by one of these constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#SendOnly",
              "documentation": {
                "identifier": "SendOnly",
                "newPage": false,
                "searchKey": "types.SendOnly",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const SendOnly"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SendOnly\n```\n\nThe direction of a channel is indicated by one of these constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#RecvOnly",
              "documentation": {
                "identifier": "RecvOnly",
                "newPage": false,
                "searchKey": "types.RecvOnly",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const RecvOnly"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RecvOnly\n```\n\nThe direction of a channel is indicated by one of these constants. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#instanceMarker",
              "documentation": {
                "identifier": "instanceMarker",
                "newPage": false,
                "searchKey": "types.instanceMarker",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const instanceMarker"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst instanceMarker = '#'\n```\n\ninstanceMarker is the prefix for an instantiated type in \"non-evaluated\" instance form. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Append",
              "documentation": {
                "identifier": "_Append",
                "newPage": false,
                "searchKey": "types._Append",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Append"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Append builtinId = iota\n```\n\nuniverse scope \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Cap",
              "documentation": {
                "identifier": "_Cap",
                "newPage": false,
                "searchKey": "types._Cap",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Cap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Cap\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Close",
              "documentation": {
                "identifier": "_Close",
                "newPage": false,
                "searchKey": "types._Close",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Close"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Close\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Complex",
              "documentation": {
                "identifier": "_Complex",
                "newPage": false,
                "searchKey": "types._Complex",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Complex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Complex\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Copy",
              "documentation": {
                "identifier": "_Copy",
                "newPage": false,
                "searchKey": "types._Copy",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Copy"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Copy\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Delete",
              "documentation": {
                "identifier": "_Delete",
                "newPage": false,
                "searchKey": "types._Delete",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Delete"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Delete\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Imag",
              "documentation": {
                "identifier": "_Imag",
                "newPage": false,
                "searchKey": "types._Imag",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Imag"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Imag\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Len",
              "documentation": {
                "identifier": "_Len",
                "newPage": false,
                "searchKey": "types._Len",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Len"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Len\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Make",
              "documentation": {
                "identifier": "_Make",
                "newPage": false,
                "searchKey": "types._Make",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Make"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Make\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_New",
              "documentation": {
                "identifier": "_New",
                "newPage": false,
                "searchKey": "types._New",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _New"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _New\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Panic",
              "documentation": {
                "identifier": "_Panic",
                "newPage": false,
                "searchKey": "types._Panic",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Panic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Panic\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Print",
              "documentation": {
                "identifier": "_Print",
                "newPage": false,
                "searchKey": "types._Print",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Print"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Print\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Println",
              "documentation": {
                "identifier": "_Println",
                "newPage": false,
                "searchKey": "types._Println",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Println"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Println\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Real",
              "documentation": {
                "identifier": "_Real",
                "newPage": false,
                "searchKey": "types._Real",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Real"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Real\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Recover",
              "documentation": {
                "identifier": "_Recover",
                "newPage": false,
                "searchKey": "types._Recover",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Recover"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Recover\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Add",
              "documentation": {
                "identifier": "_Add",
                "newPage": false,
                "searchKey": "types._Add",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Add"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Add\n```\n\npackage unsafe \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Alignof",
              "documentation": {
                "identifier": "_Alignof",
                "newPage": false,
                "searchKey": "types._Alignof",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Alignof"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Alignof\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Offsetof",
              "documentation": {
                "identifier": "_Offsetof",
                "newPage": false,
                "searchKey": "types._Offsetof",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Offsetof"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Offsetof\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Sizeof",
              "documentation": {
                "identifier": "_Sizeof",
                "newPage": false,
                "searchKey": "types._Sizeof",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Sizeof"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Sizeof\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Slice",
              "documentation": {
                "identifier": "_Slice",
                "newPage": false,
                "searchKey": "types._Slice",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Slice"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Slice\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Assert",
              "documentation": {
                "identifier": "_Assert",
                "newPage": false,
                "searchKey": "types._Assert",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Assert"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Assert\n```\n\ntesting support \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Trace",
              "documentation": {
                "identifier": "_Trace",
                "newPage": false,
                "searchKey": "types._Trace",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Trace"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Trace\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/go/types#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/go/types#cgoPrefixes",
              "documentation": {
                "identifier": "cgoPrefixes",
                "newPage": false,
                "searchKey": "types.cgoPrefixes",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var cgoPrefixes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cgoPrefixes = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#errBadCgo",
              "documentation": {
                "identifier": "errBadCgo",
                "newPage": false,
                "searchKey": "types.errBadCgo",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errBadCgo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errBadCgo = errors.New(\"cannot use FakeImportC and go115UsesCgo together\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#unaryOpPredicates",
              "documentation": {
                "identifier": "unaryOpPredicates",
                "newPage": false,
                "searchKey": "types.unaryOpPredicates",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var unaryOpPredicates"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar unaryOpPredicates opPredicates\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#op2str1",
              "documentation": {
                "identifier": "op2str1",
                "newPage": false,
                "searchKey": "types.op2str1",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var op2str1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar op2str1 = [...]string{\n\ttoken.XOR: \"bitwise complement\",\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#op2str2",
              "documentation": {
                "identifier": "op2str2",
                "newPage": false,
                "searchKey": "types.op2str2",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var op2str2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar op2str2 = ...\n```\n\nThis is only used for operations that may cause overflow. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#binaryOpPredicates",
              "documentation": {
                "identifier": "binaryOpPredicates",
                "newPage": false,
                "searchKey": "types.binaryOpPredicates",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var binaryOpPredicates"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar binaryOpPredicates opPredicates\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#gccgoArchSizes",
              "documentation": {
                "identifier": "gccgoArchSizes",
                "newPage": false,
                "searchKey": "types.gccgoArchSizes",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var gccgoArchSizes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gccgoArchSizes = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#emptyMethodSet",
              "documentation": {
                "identifier": "emptyMethodSet",
                "newPage": false,
                "searchKey": "types.emptyMethodSet",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var emptyMethodSet"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar emptyMethodSet MethodSet\n```\n\nShared empty method set. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#operandModeString",
              "documentation": {
                "identifier": "operandModeString",
                "newPage": false,
                "searchKey": "types.operandModeString",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var operandModeString"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar operandModeString = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#basicSizes",
              "documentation": {
                "identifier": "basicSizes",
                "newPage": false,
                "searchKey": "types.basicSizes",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var basicSizes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar basicSizes = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#gcArchSizes",
              "documentation": {
                "identifier": "gcArchSizes",
                "newPage": false,
                "searchKey": "types.gcArchSizes",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcArchSizes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcArchSizes = ...\n```\n\ncommon architecture word sizes and alignments \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#stdSizes",
              "documentation": {
                "identifier": "stdSizes",
                "newPage": false,
                "searchKey": "types.stdSizes",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var stdSizes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar stdSizes = SizesFor(\"gc\", \"amd64\")\n```\n\nstdSizes is used if Config.Sizes == nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#emptyInterface",
              "documentation": {
                "identifier": "emptyInterface",
                "newPage": false,
                "searchKey": "types.emptyInterface",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var emptyInterface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar emptyInterface = Interface{allMethods: markComplete}\n```\n\nemptyInterface represents the empty (completed) interface \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#markComplete",
              "documentation": {
                "identifier": "markComplete",
                "newPage": false,
                "searchKey": "types.markComplete",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var markComplete"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar markComplete = make([]*Func, 0)\n```\n\nmarkComplete is used to mark an empty interface as completely set up by setting the allMethods field to a non-nil empty slice. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#lastId",
              "documentation": {
                "identifier": "lastId",
                "newPage": false,
                "searchKey": "types.lastId",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var lastId"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lastId uint32\n```\n\nNote: This is a uint32 rather than a uint64 because the respective 64 bit atomic instructions are not available on all platforms. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#expandf",
              "documentation": {
                "identifier": "expandf",
                "newPage": false,
                "searchKey": "types.expandf",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var expandf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar expandf func(Type) Type\n```\n\nexpandf is set to expand. Call expandf when calling expand causes compile-time cycle error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#theBottom",
              "documentation": {
                "identifier": "theBottom",
                "newPage": false,
                "searchKey": "types.theBottom",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var theBottom"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar theBottom = &bottom{}\n```\n\ntheBottom is the singleton bottom type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#theTop",
              "documentation": {
                "identifier": "theTop",
                "newPage": false,
                "searchKey": "types.theTop",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var theTop"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar theTop = &top{}\n```\n\ntheTop is the singleton top type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#gcCompatibilityMode",
              "documentation": {
                "identifier": "gcCompatibilityMode",
                "newPage": false,
                "searchKey": "types.gcCompatibilityMode",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcCompatibilityMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcCompatibilityMode bool\n```\n\nIf gcCompatibilityMode is set, printing of types is modified to match the representation of some types in the gc compiler: \n\n```\n- byte and rune lose their alias name and simply stand for\n  uint8 and int32 respectively\n- embedded interfaces get flattened (the embedding info is lost,\n  and certain recursive interface types cannot be printed anymore)\n\n```\nThis makes it easier to compare packages computed with the type- checker vs packages imported from gc export data. \n\nCaution: This flag affects all uses of WriteType, globally. It is only provided for testing in conjunction with gc-generated data. \n\nThis flag is exported in the x/tools/go/types package. We don't need it at the moment in the std repo and so we don't export it anymore. We should eventually try to remove it altogether. TODO(gri) remove this \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Universe",
              "documentation": {
                "identifier": "Universe",
                "newPage": false,
                "searchKey": "types.Universe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Universe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Universe *Scope\n```\n\nThe Universe scope contains all predeclared objects of Go. It is the outermost scope of any chain of nested scopes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Unsafe",
              "documentation": {
                "identifier": "Unsafe",
                "newPage": false,
                "searchKey": "types.Unsafe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Unsafe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Unsafe *Package\n```\n\nThe Unsafe package is the package returned by an importer for the import path \"unsafe\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#universeIota",
              "documentation": {
                "identifier": "universeIota",
                "newPage": false,
                "searchKey": "types.universeIota",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var universeIota"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar universeIota *Const\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#universeByte",
              "documentation": {
                "identifier": "universeByte",
                "newPage": false,
                "searchKey": "types.universeByte",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var universeByte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar universeByte *Basic // uint8 alias, but has name \"byte\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#universeRune",
              "documentation": {
                "identifier": "universeRune",
                "newPage": false,
                "searchKey": "types.universeRune",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var universeRune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar universeRune *Basic // int32 alias, but has name \"rune\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#universeAny",
              "documentation": {
                "identifier": "universeAny",
                "newPage": false,
                "searchKey": "types.universeAny",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var universeAny"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar universeAny *Interface\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#universeError",
              "documentation": {
                "identifier": "universeError",
                "newPage": false,
                "searchKey": "types.universeError",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var universeError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar universeError *Named\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Typ",
              "documentation": {
                "identifier": "Typ",
                "newPage": false,
                "searchKey": "types.Typ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Typ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Typ = ...\n```\n\nTyp contains the predeclared *Basic types indexed by their corresponding BasicKind. \n\nThe *Basic type for Typ[Byte] will have the name \"uint8\". Use Universe.Lookup(\"byte\").Type() to obtain the specific alias basic type named \"byte\" (and analogous for \"rune\"). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#aliases",
              "documentation": {
                "identifier": "aliases",
                "newPage": false,
                "searchKey": "types.aliases",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var aliases"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar aliases = [...]*Basic{\n\t{Byte, IsInteger | IsUnsigned, \"byte\"},\n\t{Rune, IsInteger, \"rune\"},\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#predeclaredConsts",
              "documentation": {
                "identifier": "predeclaredConsts",
                "newPage": false,
                "searchKey": "types.predeclaredConsts",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var predeclaredConsts"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar predeclaredConsts = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#predeclaredFuncs",
              "documentation": {
                "identifier": "predeclaredFuncs",
                "newPage": false,
                "searchKey": "types.predeclaredFuncs",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var predeclaredFuncs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar predeclaredFuncs = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#goVersionRx",
              "documentation": {
                "identifier": "goVersionRx",
                "newPage": false,
                "searchKey": "types.goVersionRx",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var goVersionRx"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar goVersionRx = regexp.MustCompile(`^go([1-9][0-9]*)\\.(0|[1-9][0-9]*)$`)\n```\n\ngoVersionRx matches a Go version string, e.g. \"go1.12\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#assignOps",
              "documentation": {
                "identifier": "assignOps",
                "newPage": false,
                "searchKey": "types.assignOps",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var assignOps"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar assignOps = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/go/types#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/go/types#Error",
              "documentation": {
                "identifier": "Error",
                "newPage": false,
                "searchKey": "types.Error",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Error struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Error struct {\n\tFset *token.FileSet // file set for interpretation of Pos\n\tPos  token.Pos      // error position\n\tMsg  string         // error message\n\tSoft bool           // if set, error is \"soft\"\n\n\t// go116code is a future API, unexported as the set of error codes is large\n\t// and likely to change significantly during experimentation. Tools wishing\n\t// to preview this feature may read go116code using reflection (see\n\t// errorcodes_test.go), but beware that there is no guarantee of future\n\t// compatibility.\n\tgo116code  errorCode\n\tgo116start token.Pos\n\tgo116end   token.Pos\n}\n```\n\nAn Error describes a type-checking error; it implements the error interface. A \"soft\" error is an error that still permits a valid interpretation of a package (such as \"unused variable\"); \"hard\" errors may lead to unpredictable behavior if ignored. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#Error.Error",
                    "documentation": {
                      "identifier": "Error.Error",
                      "newPage": false,
                      "searchKey": "types.Error.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (err Error) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (err Error) Error() string\n```\n\nError returns an error string formatted as follows: filename:line:column: message \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Importer",
              "documentation": {
                "identifier": "Importer",
                "newPage": false,
                "searchKey": "types.Importer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Importer interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Importer interface {\n\t// Import returns the imported package for the given import path.\n\t// The semantics is like for ImporterFrom.ImportFrom except that\n\t// dir and mode are ignored (since they are not present).\n\tImport(path string) (*Package, error)\n}\n```\n\nAn Importer resolves import paths to Packages. \n\nCAUTION: This interface does not support the import of locally vendored packages. See [https://golang.org/s/go15vendor](https://golang.org/s/go15vendor). If possible, external implementations should implement ImporterFrom. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#ImportMode",
              "documentation": {
                "identifier": "ImportMode",
                "newPage": false,
                "searchKey": "types.ImportMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ImportMode int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ImportMode int\n```\n\nImportMode is reserved for future use. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#ImporterFrom",
              "documentation": {
                "identifier": "ImporterFrom",
                "newPage": false,
                "searchKey": "types.ImporterFrom",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ImporterFrom interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ImporterFrom interface {\n\t// Importer is present for backward-compatibility. Calling\n\t// Import(path) is the same as calling ImportFrom(path, \"\", 0);\n\t// i.e., locally vendored packages may not be found.\n\t// The types package does not call Import if an ImporterFrom\n\t// is present.\n\tImporter\n\n\t// ImportFrom returns the imported package for the given import\n\t// path when imported by a package file located in dir.\n\t// If the import failed, besides returning an error, ImportFrom\n\t// is encouraged to cache and return a package anyway, if one\n\t// was created. This will reduce package inconsistencies and\n\t// follow-on type checker errors due to the missing package.\n\t// The mode value must be 0; it is reserved for future use.\n\t// Two calls to ImportFrom with the same path and dir must\n\t// return the same package.\n\tImportFrom(path, dir string, mode ImportMode) (*Package, error)\n}\n```\n\nAn ImporterFrom resolves import paths to packages; it supports vendoring per [https://golang.org/s/go15vendor](https://golang.org/s/go15vendor). Use go/importer to obtain an ImporterFrom implementation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Config",
              "documentation": {
                "identifier": "Config",
                "newPage": false,
                "searchKey": "types.Config",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Config struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Config struct {\n\t// goVersion describes the accepted Go language version. The string\n\t// must follow the format \"go%d.%d\" (e.g. \"go1.12\") or it must be\n\t// empty; an empty string indicates the latest language version.\n\t// If the format is invalid, invoking the type checker will cause a\n\t// panic.\n\tgoVersion string\n\n\t// If IgnoreFuncBodies is set, function bodies are not\n\t// type-checked.\n\tIgnoreFuncBodies bool\n\n\t// If FakeImportC is set, `import \"C\"` (for packages requiring Cgo)\n\t// declares an empty \"C\" package and errors are omitted for qualified\n\t// identifiers referring to package C (which won't find an object).\n\t// This feature is intended for the standard library cmd/api tool.\n\t//\n\t// Caution: Effects may be unpredictable due to follow-on errors.\n\t//          Do not use casually!\n\tFakeImportC bool\n\n\t// If go115UsesCgo is set, the type checker expects the\n\t// _cgo_gotypes.go file generated by running cmd/cgo to be\n\t// provided as a package source file. Qualified identifiers\n\t// referring to package C will be resolved to cgo-provided\n\t// declarations within _cgo_gotypes.go.\n\t//\n\t// It is an error to set both FakeImportC and go115UsesCgo.\n\tgo115UsesCgo bool\n\n\t// If Error != nil, it is called with each error found\n\t// during type checking; err has dynamic type Error.\n\t// Secondary errors (for instance, to enumerate all types\n\t// involved in an invalid recursive type declaration) have\n\t// error strings that start with a '\\t' character.\n\t// If Error == nil, type-checking stops with the first\n\t// error found.\n\tError func(err error)\n\n\t// An importer is used to import packages referred to from\n\t// import declarations.\n\t// If the installed importer implements ImporterFrom, the type\n\t// checker calls ImportFrom instead of Import.\n\t// The type checker reports an error if an importer is needed\n\t// but none was installed.\n\tImporter Importer\n\n\t// If Sizes != nil, it provides the sizing functions for package unsafe.\n\t// Otherwise SizesFor(\"gc\", \"amd64\") is used instead.\n\tSizes Sizes\n\n\t// If DisableUnusedImportCheck is set, packages are not checked\n\t// for unused imports.\n\tDisableUnusedImportCheck bool\n}\n```\n\nA Config specifies the configuration for type checking. The zero value for Config is a ready-to-use default configuration. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#Config.Check",
                    "documentation": {
                      "identifier": "Config.Check",
                      "newPage": false,
                      "searchKey": "types.Config.Check",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)\n```\n\nCheck type-checks a package and returns the resulting package object and the first error if any. Additionally, if info != nil, Check populates each of the non-nil maps in the Info struct. \n\nThe package is marked as complete if no errors occurred, otherwise it is incomplete. See Config.Error for controlling behavior in the presence of errors. \n\nThe package is specified by a list of *ast.Files and corresponding file set, and the package path the package is identified with. The clean path must not be empty or dot (\".\"). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Config.alignof",
                    "documentation": {
                      "identifier": "Config.alignof",
                      "newPage": false,
                      "searchKey": "types.Config.alignof",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *Config) alignof(T Type) int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *Config) alignof(T Type) int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Config.offsetsof",
                    "documentation": {
                      "identifier": "Config.offsetsof",
                      "newPage": false,
                      "searchKey": "types.Config.offsetsof",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *Config) offsetsof(T *Struct) []int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *Config) offsetsof(T *Struct) []int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Config.offsetof",
                    "documentation": {
                      "identifier": "Config.offsetof",
                      "newPage": false,
                      "searchKey": "types.Config.offsetof",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *Config) offsetof(typ Type, index []int) int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *Config) offsetof(typ Type, index []int) int64\n```\n\noffsetof returns the offset of the field specified via the index sequence relative to typ. All embedded fields must be structs (rather than pointer to structs). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Config.sizeof",
                    "documentation": {
                      "identifier": "Config.sizeof",
                      "newPage": false,
                      "searchKey": "types.Config.sizeof",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conf *Config) sizeof(T Type) int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conf *Config) sizeof(T Type) int64\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#TypeAndValue",
              "documentation": {
                "identifier": "TypeAndValue",
                "newPage": false,
                "searchKey": "types.TypeAndValue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type TypeAndValue struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype TypeAndValue struct {\n\tmode  operandMode\n\tType  Type\n\tValue constant.Value\n}\n```\n\nTypeAndValue reports the type and value (for constants) of the corresponding expression. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#Eval",
                    "documentation": {
                      "identifier": "Eval",
                      "newPage": false,
                      "searchKey": "types.Eval",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (_ TypeAndValue, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (_ TypeAndValue, err error)\n```\n\nEval returns the type and, if constant, the value for the expression expr, evaluated at position pos of package pkg, which must have been derived from type-checking an AST with complete position information relative to the provided file set. \n\nThe meaning of the parameters fset, pkg, and pos is the same as in CheckExpr. An error is returned if expr cannot be parsed successfully, or the resulting expr AST cannot be type-checked. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#TypeAndValue.IsVoid",
                    "documentation": {
                      "identifier": "TypeAndValue.IsVoid",
                      "newPage": false,
                      "searchKey": "types.TypeAndValue.IsVoid",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tv TypeAndValue) IsVoid() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tv TypeAndValue) IsVoid() bool\n```\n\nIsVoid reports whether the corresponding expression is a function call without results. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#TypeAndValue.IsType",
                    "documentation": {
                      "identifier": "TypeAndValue.IsType",
                      "newPage": false,
                      "searchKey": "types.TypeAndValue.IsType",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tv TypeAndValue) IsType() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tv TypeAndValue) IsType() bool\n```\n\nIsType reports whether the corresponding expression specifies a type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#TypeAndValue.IsBuiltin",
                    "documentation": {
                      "identifier": "TypeAndValue.IsBuiltin",
                      "newPage": false,
                      "searchKey": "types.TypeAndValue.IsBuiltin",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tv TypeAndValue) IsBuiltin() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tv TypeAndValue) IsBuiltin() bool\n```\n\nIsBuiltin reports whether the corresponding expression denotes a (possibly parenthesized) built-in function. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#TypeAndValue.IsValue",
                    "documentation": {
                      "identifier": "TypeAndValue.IsValue",
                      "newPage": false,
                      "searchKey": "types.TypeAndValue.IsValue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tv TypeAndValue) IsValue() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tv TypeAndValue) IsValue() bool\n```\n\nIsValue reports whether the corresponding expression is a value. Builtins are not considered values. Constant values have a non- nil Value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#TypeAndValue.IsNil",
                    "documentation": {
                      "identifier": "TypeAndValue.IsNil",
                      "newPage": false,
                      "searchKey": "types.TypeAndValue.IsNil",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tv TypeAndValue) IsNil() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tv TypeAndValue) IsNil() bool\n```\n\nIsNil reports whether the corresponding expression denotes the predeclared value nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#TypeAndValue.Addressable",
                    "documentation": {
                      "identifier": "TypeAndValue.Addressable",
                      "newPage": false,
                      "searchKey": "types.TypeAndValue.Addressable",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tv TypeAndValue) Addressable() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tv TypeAndValue) Addressable() bool\n```\n\nAddressable reports whether the corresponding expression is addressable ([https://golang.org/ref/spec#Address_operators](https://golang.org/ref/spec#Address_operators)). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#TypeAndValue.Assignable",
                    "documentation": {
                      "identifier": "TypeAndValue.Assignable",
                      "newPage": false,
                      "searchKey": "types.TypeAndValue.Assignable",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tv TypeAndValue) Assignable() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tv TypeAndValue) Assignable() bool\n```\n\nAssignable reports whether the corresponding expression is assignable to (provided a value of the right type). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#TypeAndValue.HasOk",
                    "documentation": {
                      "identifier": "TypeAndValue.HasOk",
                      "newPage": false,
                      "searchKey": "types.TypeAndValue.HasOk",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tv TypeAndValue) HasOk() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tv TypeAndValue) HasOk() bool\n```\n\nHasOk reports whether the corresponding expression may be used on the rhs of a comma-ok assignment. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Inferred",
              "documentation": {
                "identifier": "_Inferred",
                "newPage": false,
                "searchKey": "types._Inferred",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type _Inferred struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype _Inferred struct {\n\tTargs []Type\n\tSig   *Signature\n}\n```\n\n_Inferred reports the _Inferred type arguments and signature for a parameterized function call that uses type inference. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Initializer",
              "documentation": {
                "identifier": "Initializer",
                "newPage": false,
                "searchKey": "types.Initializer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Initializer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Initializer struct {\n\tLhs []*Var // var Lhs = Rhs\n\tRhs ast.Expr\n}\n```\n\nAn Initializer describes a package-level variable, or a list of variables in case of a multi-valued initialization expression, and the corresponding initialization expression. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#Initializer.String",
                    "documentation": {
                      "identifier": "Initializer.String",
                      "newPage": false,
                      "searchKey": "types.Initializer.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (init *Initializer) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (init *Initializer) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Info",
              "documentation": {
                "identifier": "Info",
                "newPage": false,
                "searchKey": "types.Info",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Info struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Info struct {\n\t// Types maps expressions to their types, and for constant\n\t// expressions, also their values. Invalid expressions are\n\t// omitted.\n\t//\n\t// For (possibly parenthesized) identifiers denoting built-in\n\t// functions, the recorded signatures are call-site specific:\n\t// if the call result is not a constant, the recorded type is\n\t// an argument-specific signature. Otherwise, the recorded type\n\t// is invalid.\n\t//\n\t// The Types map does not record the type of every identifier,\n\t// only those that appear where an arbitrary expression is\n\t// permitted. For instance, the identifier f in a selector\n\t// expression x.f is found only in the Selections map, the\n\t// identifier z in a variable declaration 'var z int' is found\n\t// only in the Defs map, and identifiers denoting packages in\n\t// qualified identifiers are collected in the Uses map.\n\tTypes map[ast.Expr]TypeAndValue\n\n\t// Defs maps identifiers to the objects they define (including\n\t// package names, dots \".\" of dot-imports, and blank \"_\" identifiers).\n\t// For identifiers that do not denote objects (e.g., the package name\n\t// in package clauses, or symbolic variables t in t := x.(type) of\n\t// type switch headers), the corresponding objects are nil.\n\t//\n\t// For an embedded field, Defs returns the field *Var it defines.\n\t//\n\t// Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()\n\tDefs map[*ast.Ident]Object\n\n\t// Uses maps identifiers to the objects they denote.\n\t//\n\t// For an embedded field, Uses returns the *TypeName it denotes.\n\t//\n\t// Invariant: Uses[id].Pos() != id.Pos()\n\tUses map[*ast.Ident]Object\n\n\t// Implicits maps nodes to their implicitly declared objects, if any.\n\t// The following node and object types may appear:\n\t//\n\t//     node               declared object\n\t//\n\t//     *ast.ImportSpec    *PkgName for imports without renames\n\t//     *ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)\n\t//     *ast.Field         anonymous parameter *Var (incl. unnamed results)\n\t//\n\tImplicits map[ast.Node]Object\n\n\t// Selections maps selector expressions (excluding qualified identifiers)\n\t// to their corresponding selections.\n\tSelections map[*ast.SelectorExpr]*Selection\n\n\t// Scopes maps ast.Nodes to the scopes they define. Package scopes are not\n\t// associated with a specific node but with all files belonging to a package.\n\t// Thus, the package scope can be found in the type-checked Package object.\n\t// Scopes nest, with the Universe scope being the outermost scope, enclosing\n\t// the package scope, which contains (one or more) files scopes, which enclose\n\t// function scopes which in turn enclose statement and function literal scopes.\n\t// Note that even though package-level functions are declared in the package\n\t// scope, the function scopes are embedded in the file scope of the file\n\t// containing the function declaration.\n\t//\n\t// The following node types may appear in Scopes:\n\t//\n\t//     *ast.File\n\t//     *ast.FuncType\n\t//     *ast.BlockStmt\n\t//     *ast.IfStmt\n\t//     *ast.SwitchStmt\n\t//     *ast.TypeSwitchStmt\n\t//     *ast.CaseClause\n\t//     *ast.CommClause\n\t//     *ast.ForStmt\n\t//     *ast.RangeStmt\n\t//\n\tScopes map[ast.Node]*Scope\n\n\t// InitOrder is the list of package-level initializers in the order in which\n\t// they must be executed. Initializers referring to variables related by an\n\t// initialization dependency appear in topological order, the others appear\n\t// in source order. Variables without an initialization expression do not\n\t// appear in this list.\n\tInitOrder []*Initializer\n}\n```\n\nInfo holds result type information for a type-checked package. Only the information for which a map is provided is collected. If the package has type errors, the collected information may be incomplete. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#Info.TypeOf",
                    "documentation": {
                      "identifier": "Info.TypeOf",
                      "newPage": false,
                      "searchKey": "types.Info.TypeOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (info *Info) TypeOf(e ast.Expr) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (info *Info) TypeOf(e ast.Expr) Type\n```\n\nTypeOf returns the type of expression e, or nil if not found. Precondition: the Types, Uses and Defs maps are populated. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Info.ObjectOf",
                    "documentation": {
                      "identifier": "Info.ObjectOf",
                      "newPage": false,
                      "searchKey": "types.Info.ObjectOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (info *Info) ObjectOf(id *ast.Ident) Object"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (info *Info) ObjectOf(id *ast.Ident) Object\n```\n\nObjectOf returns the object denoted by the specified id, or nil if not found. \n\nIf id is an embedded struct field, ObjectOf returns the field (*Var) it defines, not the type (*TypeName) it uses. \n\nPrecondition: the Uses and Defs maps are populated. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#exprInfo",
              "documentation": {
                "identifier": "exprInfo",
                "newPage": false,
                "searchKey": "types.exprInfo",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type exprInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype exprInfo struct {\n\tisLhs bool // expression is lhs operand of a shift with delayed type-check\n\tmode  operandMode\n\ttyp   *Basic\n\tval   constant.Value // constant value; or nil (if not a constant)\n}\n```\n\nexprInfo stores information about an untyped expression. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#context",
              "documentation": {
                "identifier": "context",
                "newPage": false,
                "searchKey": "types.context",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type context struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype context struct {\n\tdecl          *declInfo              // package-level declaration whose init expression/function body is checked\n\tscope         *Scope                 // top-most scope for lookups\n\tpos           token.Pos              // if valid, identifiers are looked up as if at position pos (used by Eval)\n\tiota          constant.Value         // value of iota in a constant declaration; nil otherwise\n\terrpos        positioner             // if set, identifier position of a constant with inherited initializer\n\tsig           *Signature             // function signature if inside a function; nil otherwise\n\tisPanic       map[*ast.CallExpr]bool // set of panic call expressions (used for termination check)\n\thasLabel      bool                   // set if a function makes use of labels (only ~1% of functions); unused outside functions\n\thasCallOrRecv bool                   // set if an expression contains a function call or channel receive operation\n}\n```\n\nA context represents the context within which an object is type-checked. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#context.lookup",
                    "documentation": {
                      "identifier": "context.lookup",
                      "newPage": false,
                      "searchKey": "types.context.lookup",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ctxt *context) lookup(name string) Object"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ctxt *context) lookup(name string) Object\n```\n\nlookup looks up name in the current context and returns the matching object, or nil. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#importKey",
              "documentation": {
                "identifier": "importKey",
                "newPage": false,
                "searchKey": "types.importKey",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type importKey struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype importKey struct {\n\tpath, dir string\n}\n```\n\nAn importKey identifies an imported package by import path and source directory (directory containing the file containing the import). In practice, the directory may always be the same, or may not matter. Given an (import path, directory), an importer must always return the same package (but given two different import paths, an importer may still return the same package by mapping them to the same package paths). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#dotImportKey",
              "documentation": {
                "identifier": "dotImportKey",
                "newPage": false,
                "searchKey": "types.dotImportKey",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type dotImportKey struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dotImportKey struct {\n\tscope *Scope\n\tobj   Object\n}\n```\n\nA dotImportKey describes a dot-imported object in the given scope. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Checker",
              "documentation": {
                "identifier": "Checker",
                "newPage": false,
                "searchKey": "types.Checker",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Checker struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Checker struct {\n\t// package information\n\t// (initialized by NewChecker, valid for the life-time of checker)\n\tconf *Config\n\tfset *token.FileSet\n\tpkg  *Package\n\t*Info\n\tversion version                    // accepted language version\n\tobjMap  map[Object]*declInfo       // maps package-level objects and (non-interface) methods to declaration info\n\timpMap  map[importKey]*Package     // maps (import path, source directory) to (complete or fake) package\n\tposMap  map[*Interface][]token.Pos // maps interface types to lists of embedded interface positions\n\ttypMap  map[string]*Named          // maps an instantiated named type hash to a *Named type\n\n\t// pkgPathMap maps package names to the set of distinct import paths we've\n\t// seen for that name, anywhere in the import graph. It is used for\n\t// disambiguating package names in error messages.\n\t//\n\t// pkgPathMap is allocated lazily, so that we don't pay the price of building\n\t// it on the happy path. seenPkgMap tracks the packages that we've already\n\t// walked.\n\tpkgPathMap map[string]map[string]bool\n\tseenPkgMap map[*Package]bool\n\n\t// information collected during type-checking of a set of package files\n\t// (initialized by Files, valid only for the duration of check.Files;\n\t// maps and lists are allocated on demand)\n\tfiles        []*ast.File               // package files\n\timports      []*PkgName                // list of imported packages\n\tdotImportMap map[dotImportKey]*PkgName // maps dot-imported objects to the package they were dot-imported through\n\n\tfirstErr error                 // first error encountered\n\tmethods  map[*TypeName][]*Func // maps package scope type names to associated non-blank (non-interface) methods\n\tuntyped  map[ast.Expr]exprInfo // map of expressions without final type\n\tdelayed  []func()              // stack of delayed action segments; segments are processed in FIFO order\n\tobjPath  []Object              // path of object dependencies during type inference (for cycle reporting)\n\n\t// context within which the current object is type-checked\n\t// (valid only for the duration of type-checking a specific object)\n\tcontext\n\n\t// debugging\n\tindent int // indentation for tracing\n}\n```\n\nA Checker maintains the state of the type checker. It must be created with NewChecker. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewChecker",
                    "documentation": {
                      "identifier": "NewChecker",
                      "newPage": false,
                      "searchKey": "types.NewChecker",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker\n```\n\nNewChecker returns a new Checker instance for a given package. Package files may be added incrementally via checker.Files. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.assignment",
                    "documentation": {
                      "identifier": "Checker.assignment",
                      "newPage": false,
                      "searchKey": "types.Checker.assignment",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) assignment(x *operand, T Type, context string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) assignment(x *operand, T Type, context string)\n```\n\nassignment reports whether x can be assigned to a variable of type T, if necessary by attempting to convert untyped values to the appropriate type. context describes the context in which the assignment takes place. Use T == nil to indicate assignment to an untyped blank identifier. x.mode is set to invalid if the assignment failed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.initConst",
                    "documentation": {
                      "identifier": "Checker.initConst",
                      "newPage": false,
                      "searchKey": "types.Checker.initConst",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) initConst(lhs *Const, x *operand)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) initConst(lhs *Const, x *operand)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.initVar",
                    "documentation": {
                      "identifier": "Checker.initVar",
                      "newPage": false,
                      "searchKey": "types.Checker.initVar",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) initVar(lhs *Var, x *operand, context string) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) initVar(lhs *Var, x *operand, context string) Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.assignVar",
                    "documentation": {
                      "identifier": "Checker.assignVar",
                      "newPage": false,
                      "searchKey": "types.Checker.assignVar",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) assignVar(lhs ast.Expr, x *operand) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) assignVar(lhs ast.Expr, x *operand) Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.initVars",
                    "documentation": {
                      "identifier": "Checker.initVars",
                      "newPage": false,
                      "searchKey": "types.Checker.initVars",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) initVars(lhs []*Var, origRHS []ast.Expr, returnPos token.Pos)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) initVars(lhs []*Var, origRHS []ast.Expr, returnPos token.Pos)\n```\n\nIf returnPos is valid, initVars is called to type-check the assignment of return expressions, and returnPos is the position of the return statement. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.assignVars",
                    "documentation": {
                      "identifier": "Checker.assignVars",
                      "newPage": false,
                      "searchKey": "types.Checker.assignVars",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) assignVars(lhs, origRHS []ast.Expr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) assignVars(lhs, origRHS []ast.Expr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.shortVarDecl",
                    "documentation": {
                      "identifier": "Checker.shortVarDecl",
                      "newPage": false,
                      "searchKey": "types.Checker.shortVarDecl",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) shortVarDecl(pos positioner, lhs, rhs []ast.Expr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) shortVarDecl(pos positioner, lhs, rhs []ast.Expr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.builtin",
                    "documentation": {
                      "identifier": "Checker.builtin",
                      "newPage": false,
                      "searchKey": "types.Checker.builtin",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ bool)\n```\n\nbuiltin type-checks a call to the built-in specified by id and reports whether the call is valid, with *x holding the result; but x.expr is not set. If the call is invalid, the result is false, and *x is undefined. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.applyTypeFunc",
                    "documentation": {
                      "identifier": "Checker.applyTypeFunc",
                      "newPage": false,
                      "searchKey": "types.Checker.applyTypeFunc",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) applyTypeFunc(f func(Type) Type, x Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) applyTypeFunc(f func(Type) Type, x Type) Type\n```\n\napplyTypeFunc applies f to x. If x is a type parameter, the result is a type parameter constrained by an new interface bound. The type bounds for that interface are computed by applying f to each of the type bounds of x. If any of these applications of f return nil, applyTypeFunc returns nil. If x is not a type parameter, the result is f(x). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.funcInst",
                    "documentation": {
                      "identifier": "Checker.funcInst",
                      "newPage": false,
                      "searchKey": "types.Checker.funcInst",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) funcInst(x *operand, inst *ast.IndexExpr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) funcInst(x *operand, inst *ast.IndexExpr)\n```\n\nfuncInst type-checks a function instantiation inst and returns the result in x. The operand x must be the evaluation of inst.X and its type must be a signature. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.callExpr",
                    "documentation": {
                      "identifier": "Checker.callExpr",
                      "newPage": false,
                      "searchKey": "types.Checker.callExpr",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) callExpr(x *operand, call *ast.CallExpr) exprKind"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) callExpr(x *operand, call *ast.CallExpr) exprKind\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.exprList",
                    "documentation": {
                      "identifier": "Checker.exprList",
                      "newPage": false,
                      "searchKey": "types.Checker.exprList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) exprList(elist []ast.Expr, allowCommaOk bool) (xlist []*operand, commaOk bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) exprList(elist []ast.Expr, allowCommaOk bool) (xlist []*operand, commaOk bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.arguments",
                    "documentation": {
                      "identifier": "Checker.arguments",
                      "newPage": false,
                      "searchKey": "types.Checker.arguments",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) arguments(call *ast.CallExpr, sig *Signature, targs []Type, args []*operand) (rsig *Signature)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) arguments(call *ast.CallExpr, sig *Signature, targs []Type, args []*operand) (rsig *Signature)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.selector",
                    "documentation": {
                      "identifier": "Checker.selector",
                      "newPage": false,
                      "searchKey": "types.Checker.selector",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) selector(x *operand, e *ast.SelectorExpr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) selector(x *operand, e *ast.SelectorExpr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.use",
                    "documentation": {
                      "identifier": "Checker.use",
                      "newPage": false,
                      "searchKey": "types.Checker.use",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) use(arg ...ast.Expr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) use(arg ...ast.Expr)\n```\n\nuse type-checks each argument. Useful to make sure expressions are evaluated (and variables are \"used\") in the presence of other errors. The arguments may be nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.useLHS",
                    "documentation": {
                      "identifier": "Checker.useLHS",
                      "newPage": false,
                      "searchKey": "types.Checker.useLHS",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) useLHS(arg ...ast.Expr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) useLHS(arg ...ast.Expr)\n```\n\nuseLHS is like use, but doesn't \"use\" top-level identifiers. It should be called instead of use if the arguments are expressions on the lhs of an assignment. The arguments must not be nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.instantiatedOperand",
                    "documentation": {
                      "identifier": "Checker.instantiatedOperand",
                      "newPage": false,
                      "searchKey": "types.Checker.instantiatedOperand",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) instantiatedOperand(x *operand)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) instantiatedOperand(x *operand)\n```\n\ninstantiatedOperand reports an error of x is an uninstantiated (generic) type and sets x.typ to Typ[Invalid]. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.addDeclDep",
                    "documentation": {
                      "identifier": "Checker.addDeclDep",
                      "newPage": false,
                      "searchKey": "types.Checker.addDeclDep",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) addDeclDep(to Object)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) addDeclDep(to Object)\n```\n\naddDeclDep adds the dependency edge (check.decl -> to) if check.decl exists \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.rememberUntyped",
                    "documentation": {
                      "identifier": "Checker.rememberUntyped",
                      "newPage": false,
                      "searchKey": "types.Checker.rememberUntyped",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) rememberUntyped(e ast.Expr, lhs bool, mode operandMode, typ *Basic, val constant.Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) rememberUntyped(e ast.Expr, lhs bool, mode operandMode, typ *Basic, val constant.Value)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.later",
                    "documentation": {
                      "identifier": "Checker.later",
                      "newPage": false,
                      "searchKey": "types.Checker.later",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) later(f func())"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) later(f func())\n```\n\nlater pushes f on to the stack of actions that will be processed later; either at the end of the current statement, or in case of a local constant or variable declaration, before the constant or variable is in scope (so that f still sees the scope before any new declarations). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.push",
                    "documentation": {
                      "identifier": "Checker.push",
                      "newPage": false,
                      "searchKey": "types.Checker.push",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) push(obj Object) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) push(obj Object) int\n```\n\npush pushes obj onto the object path and returns its index in the path. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.pop",
                    "documentation": {
                      "identifier": "Checker.pop",
                      "newPage": false,
                      "searchKey": "types.Checker.pop",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) pop() Object"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) pop() Object\n```\n\npop pops and returns the topmost object from the object path. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.initFiles",
                    "documentation": {
                      "identifier": "Checker.initFiles",
                      "newPage": false,
                      "searchKey": "types.Checker.initFiles",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) initFiles(files []*ast.File)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) initFiles(files []*ast.File)\n```\n\ninitFiles initializes the files-specific portion of checker. The provided files must all belong to the same package. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.handleBailout",
                    "documentation": {
                      "identifier": "Checker.handleBailout",
                      "newPage": false,
                      "searchKey": "types.Checker.handleBailout",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) handleBailout(err *error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) handleBailout(err *error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.Files",
                    "documentation": {
                      "identifier": "Checker.Files",
                      "newPage": false,
                      "searchKey": "types.Checker.Files",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) Files(files []*ast.File) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) Files(files []*ast.File) error\n```\n\nFiles checks the provided files as part of the checker's package. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.checkFiles",
                    "documentation": {
                      "identifier": "Checker.checkFiles",
                      "newPage": false,
                      "searchKey": "types.Checker.checkFiles",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) checkFiles(files []*ast.File) (err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) checkFiles(files []*ast.File) (err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.processDelayed",
                    "documentation": {
                      "identifier": "Checker.processDelayed",
                      "newPage": false,
                      "searchKey": "types.Checker.processDelayed",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) processDelayed(top int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) processDelayed(top int)\n```\n\nprocessDelayed processes all delayed actions pushed after top. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.record",
                    "documentation": {
                      "identifier": "Checker.record",
                      "newPage": false,
                      "searchKey": "types.Checker.record",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) record(x *operand)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) record(x *operand)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.recordUntyped",
                    "documentation": {
                      "identifier": "Checker.recordUntyped",
                      "newPage": false,
                      "searchKey": "types.Checker.recordUntyped",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) recordUntyped()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) recordUntyped()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.recordTypeAndValue",
                    "documentation": {
                      "identifier": "Checker.recordTypeAndValue",
                      "newPage": false,
                      "searchKey": "types.Checker.recordTypeAndValue",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) recordTypeAndValue(x ast.Expr, mode operandMode, typ Type, val constant.Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) recordTypeAndValue(x ast.Expr, mode operandMode, typ Type, val constant.Value)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.recordBuiltinType",
                    "documentation": {
                      "identifier": "Checker.recordBuiltinType",
                      "newPage": false,
                      "searchKey": "types.Checker.recordBuiltinType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) recordBuiltinType(f ast.Expr, sig *Signature)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) recordBuiltinType(f ast.Expr, sig *Signature)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.recordCommaOkTypes",
                    "documentation": {
                      "identifier": "Checker.recordCommaOkTypes",
                      "newPage": false,
                      "searchKey": "types.Checker.recordCommaOkTypes",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) recordCommaOkTypes(x ast.Expr, a [2]Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) recordCommaOkTypes(x ast.Expr, a [2]Type)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.recordInferred",
                    "documentation": {
                      "identifier": "Checker.recordInferred",
                      "newPage": false,
                      "searchKey": "types.Checker.recordInferred",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) recordInferred(call ast.Expr, targs []Type, sig *Signature)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) recordInferred(call ast.Expr, targs []Type, sig *Signature)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.recordDef",
                    "documentation": {
                      "identifier": "Checker.recordDef",
                      "newPage": false,
                      "searchKey": "types.Checker.recordDef",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) recordDef(id *ast.Ident, obj Object)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) recordDef(id *ast.Ident, obj Object)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.recordUse",
                    "documentation": {
                      "identifier": "Checker.recordUse",
                      "newPage": false,
                      "searchKey": "types.Checker.recordUse",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) recordUse(id *ast.Ident, obj Object)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) recordUse(id *ast.Ident, obj Object)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.recordImplicit",
                    "documentation": {
                      "identifier": "Checker.recordImplicit",
                      "newPage": false,
                      "searchKey": "types.Checker.recordImplicit",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) recordImplicit(node ast.Node, obj Object)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) recordImplicit(node ast.Node, obj Object)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.recordSelection",
                    "documentation": {
                      "identifier": "Checker.recordSelection",
                      "newPage": false,
                      "searchKey": "types.Checker.recordSelection",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) recordSelection(x *ast.SelectorExpr, kind SelectionKind, recv Type, obj Object, index []int, indirect bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) recordSelection(x *ast.SelectorExpr, kind SelectionKind, recv Type, obj Object, index []int, indirect bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.recordScope",
                    "documentation": {
                      "identifier": "Checker.recordScope",
                      "newPage": false,
                      "searchKey": "types.Checker.recordScope",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) recordScope(node ast.Node, scope *Scope)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) recordScope(node ast.Node, scope *Scope)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.conversion",
                    "documentation": {
                      "identifier": "Checker.conversion",
                      "newPage": false,
                      "searchKey": "types.Checker.conversion",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) conversion(x *operand, T Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) conversion(x *operand, T Type)\n```\n\nConversion type-checks the conversion T(x). The result is in x. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.reportAltDecl",
                    "documentation": {
                      "identifier": "Checker.reportAltDecl",
                      "newPage": false,
                      "searchKey": "types.Checker.reportAltDecl",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) reportAltDecl(obj Object)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) reportAltDecl(obj Object)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.declare",
                    "documentation": {
                      "identifier": "Checker.declare",
                      "newPage": false,
                      "searchKey": "types.Checker.declare",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) declare(scope *Scope, id *ast.Ident, obj Object, pos token.Pos)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) declare(scope *Scope, id *ast.Ident, obj Object, pos token.Pos)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.objDecl",
                    "documentation": {
                      "identifier": "Checker.objDecl",
                      "newPage": false,
                      "searchKey": "types.Checker.objDecl",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) objDecl(obj Object, def *Named)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) objDecl(obj Object, def *Named)\n```\n\nobjDecl type-checks the declaration of obj in its respective (file) context. For the meaning of def, see Checker.definedType, in typexpr.go. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.cycle",
                    "documentation": {
                      "identifier": "Checker.cycle",
                      "newPage": false,
                      "searchKey": "types.Checker.cycle",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) cycle(obj Object) (isCycle bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) cycle(obj Object) (isCycle bool)\n```\n\ncycle checks if the cycle starting with obj is valid and reports an error if it is not. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.validType",
                    "documentation": {
                      "identifier": "Checker.validType",
                      "newPage": false,
                      "searchKey": "types.Checker.validType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) validType(typ Type, path []Object) typeInfo"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) validType(typ Type, path []Object) typeInfo\n```\n\nvalidType verifies that the given type does not \"expand\" infinitely producing a cycle in the type graph. Cycles are detected by marking defined types. (Cycles involving alias types, as in \"type A = [10]A\" are detected earlier, via the objDecl cycle detection mechanism.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.cycleError",
                    "documentation": {
                      "identifier": "Checker.cycleError",
                      "newPage": false,
                      "searchKey": "types.Checker.cycleError",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) cycleError(cycle []Object)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) cycleError(cycle []Object)\n```\n\ncycleError reports a declaration cycle starting with the object in cycle that is \"first\" in the source. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.walkDecls",
                    "documentation": {
                      "identifier": "Checker.walkDecls",
                      "newPage": false,
                      "searchKey": "types.Checker.walkDecls",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) walkDecls(decls []ast.Decl, f func(decl))"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) walkDecls(decls []ast.Decl, f func(decl))\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.walkDecl",
                    "documentation": {
                      "identifier": "Checker.walkDecl",
                      "newPage": false,
                      "searchKey": "types.Checker.walkDecl",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) walkDecl(d ast.Decl, f func(decl))"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) walkDecl(d ast.Decl, f func(decl))\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.constDecl",
                    "documentation": {
                      "identifier": "Checker.constDecl",
                      "newPage": false,
                      "searchKey": "types.Checker.constDecl",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) constDecl(obj *Const, typ, init ast.Expr, inherited bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) constDecl(obj *Const, typ, init ast.Expr, inherited bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.varDecl",
                    "documentation": {
                      "identifier": "Checker.varDecl",
                      "newPage": false,
                      "searchKey": "types.Checker.varDecl",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) varDecl(obj *Var, lhs []*Var, typ, init ast.Expr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) varDecl(obj *Var, lhs []*Var, typ, init ast.Expr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.typeDecl",
                    "documentation": {
                      "identifier": "Checker.typeDecl",
                      "newPage": false,
                      "searchKey": "types.Checker.typeDecl",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) typeDecl(obj *TypeName, tdecl *ast.TypeSpec, def *Named)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) typeDecl(obj *TypeName, tdecl *ast.TypeSpec, def *Named)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.collectTypeParams",
                    "documentation": {
                      "identifier": "Checker.collectTypeParams",
                      "newPage": false,
                      "searchKey": "types.Checker.collectTypeParams",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) collectTypeParams(list *ast.FieldList) (tparams []*TypeName)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) collectTypeParams(list *ast.FieldList) (tparams []*TypeName)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.declareTypeParams",
                    "documentation": {
                      "identifier": "Checker.declareTypeParams",
                      "newPage": false,
                      "searchKey": "types.Checker.declareTypeParams",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) declareTypeParams(tparams []*TypeName, names []*ast.Ident) []*TypeName"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) declareTypeParams(tparams []*TypeName, names []*ast.Ident) []*TypeName\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.collectMethods",
                    "documentation": {
                      "identifier": "Checker.collectMethods",
                      "newPage": false,
                      "searchKey": "types.Checker.collectMethods",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) collectMethods(obj *TypeName)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) collectMethods(obj *TypeName)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.funcDecl",
                    "documentation": {
                      "identifier": "Checker.funcDecl",
                      "newPage": false,
                      "searchKey": "types.Checker.funcDecl",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) funcDecl(obj *Func, decl *declInfo)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) funcDecl(obj *Func, decl *declInfo)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.declStmt",
                    "documentation": {
                      "identifier": "Checker.declStmt",
                      "newPage": false,
                      "searchKey": "types.Checker.declStmt",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) declStmt(d ast.Decl)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) declStmt(d ast.Decl)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.qualifier",
                    "documentation": {
                      "identifier": "Checker.qualifier",
                      "newPage": false,
                      "searchKey": "types.Checker.qualifier",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) qualifier(pkg *Package) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) qualifier(pkg *Package) string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.markImports",
                    "documentation": {
                      "identifier": "Checker.markImports",
                      "newPage": false,
                      "searchKey": "types.Checker.markImports",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) markImports(pkg *Package)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) markImports(pkg *Package)\n```\n\nmarkImports recursively walks pkg and its imports, to record unique import paths in pkgPathMap. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.sprintf",
                    "documentation": {
                      "identifier": "Checker.sprintf",
                      "newPage": false,
                      "searchKey": "types.Checker.sprintf",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) sprintf(format string, args ...interface{}) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) sprintf(format string, args ...interface{}) string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.trace",
                    "documentation": {
                      "identifier": "Checker.trace",
                      "newPage": false,
                      "searchKey": "types.Checker.trace",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) trace(pos token.Pos, format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) trace(pos token.Pos, format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.dump",
                    "documentation": {
                      "identifier": "Checker.dump",
                      "newPage": false,
                      "searchKey": "types.Checker.dump",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) dump(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) dump(format string, args ...interface{})\n```\n\ndump is only needed for debugging \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.err",
                    "documentation": {
                      "identifier": "Checker.err",
                      "newPage": false,
                      "searchKey": "types.Checker.err",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) err(err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) err(err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.newError",
                    "documentation": {
                      "identifier": "Checker.newError",
                      "newPage": false,
                      "searchKey": "types.Checker.newError",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) newError(at positioner, code errorCode, soft bool, msg string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) newError(at positioner, code errorCode, soft bool, msg string) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.newErrorf",
                    "documentation": {
                      "identifier": "Checker.newErrorf",
                      "newPage": false,
                      "searchKey": "types.Checker.newErrorf",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) newErrorf(at positioner, code errorCode, soft bool, format string, args ...interface{}) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) newErrorf(at positioner, code errorCode, soft bool, format string, args ...interface{}) error\n```\n\nnewErrorf creates a new Error, but does not handle it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.error",
                    "documentation": {
                      "identifier": "Checker.error",
                      "newPage": false,
                      "searchKey": "types.Checker.error",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) error(at positioner, code errorCode, msg string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) error(at positioner, code errorCode, msg string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.errorf",
                    "documentation": {
                      "identifier": "Checker.errorf",
                      "newPage": false,
                      "searchKey": "types.Checker.errorf",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) errorf(at positioner, code errorCode, format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) errorf(at positioner, code errorCode, format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.softErrorf",
                    "documentation": {
                      "identifier": "Checker.softErrorf",
                      "newPage": false,
                      "searchKey": "types.Checker.softErrorf",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) softErrorf(at positioner, code errorCode, format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) softErrorf(at positioner, code errorCode, format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.invalidAST",
                    "documentation": {
                      "identifier": "Checker.invalidAST",
                      "newPage": false,
                      "searchKey": "types.Checker.invalidAST",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) invalidAST(at positioner, format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) invalidAST(at positioner, format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.invalidArg",
                    "documentation": {
                      "identifier": "Checker.invalidArg",
                      "newPage": false,
                      "searchKey": "types.Checker.invalidArg",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) invalidArg(at positioner, code errorCode, format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) invalidArg(at positioner, code errorCode, format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.invalidOp",
                    "documentation": {
                      "identifier": "Checker.invalidOp",
                      "newPage": false,
                      "searchKey": "types.Checker.invalidOp",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) invalidOp(at positioner, code errorCode, format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) invalidOp(at positioner, code errorCode, format string, args ...interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.op",
                    "documentation": {
                      "identifier": "Checker.op",
                      "newPage": false,
                      "searchKey": "types.Checker.op",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) op(m opPredicates, x *operand, op token.Token) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) op(m opPredicates, x *operand, op token.Token) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.overflow",
                    "documentation": {
                      "identifier": "Checker.overflow",
                      "newPage": false,
                      "searchKey": "types.Checker.overflow",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) overflow(x *operand, op token.Token, opPos token.Pos)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) overflow(x *operand, op token.Token, opPos token.Pos)\n```\n\noverflow checks that the constant x is representable by its type. For untyped constants, it checks that the value doesn't become arbitrarily large. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.unary",
                    "documentation": {
                      "identifier": "Checker.unary",
                      "newPage": false,
                      "searchKey": "types.Checker.unary",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) unary(x *operand, e *ast.UnaryExpr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) unary(x *operand, e *ast.UnaryExpr)\n```\n\nThe unary expression e may be nil. It's passed in for better error messages only. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.representable",
                    "documentation": {
                      "identifier": "Checker.representable",
                      "newPage": false,
                      "searchKey": "types.Checker.representable",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) representable(x *operand, typ *Basic)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) representable(x *operand, typ *Basic)\n```\n\nrepresentable checks that a constant operand is representable in the given basic type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.representation",
                    "documentation": {
                      "identifier": "Checker.representation",
                      "newPage": false,
                      "searchKey": "types.Checker.representation",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) representation(x *operand, typ *Basic) (constant.Value, errorCode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) representation(x *operand, typ *Basic) (constant.Value, errorCode)\n```\n\nrepresentation returns the representation of the constant operand x as the basic type typ. \n\nIf no such representation is possible, it returns a non-zero error code. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.invalidConversion",
                    "documentation": {
                      "identifier": "Checker.invalidConversion",
                      "newPage": false,
                      "searchKey": "types.Checker.invalidConversion",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) invalidConversion(code errorCode, x *operand, target Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) invalidConversion(code errorCode, x *operand, target Type)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.updateExprType",
                    "documentation": {
                      "identifier": "Checker.updateExprType",
                      "newPage": false,
                      "searchKey": "types.Checker.updateExprType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) updateExprType(x ast.Expr, typ Type, final bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) updateExprType(x ast.Expr, typ Type, final bool)\n```\n\nupdateExprType updates the type of x to typ and invokes itself recursively for the operands of x, depending on expression kind. If typ is still an untyped and not the final type, updateExprType only updates the recorded untyped type for x and possibly its operands. Otherwise (i.e., typ is not an untyped type anymore, or it is the final type for x), the type and value are recorded. Also, if x is a constant, it must be representable as a value of typ, and if x is the (formerly untyped) lhs operand of a non-constant shift, it must be an integer value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.updateExprVal",
                    "documentation": {
                      "identifier": "Checker.updateExprVal",
                      "newPage": false,
                      "searchKey": "types.Checker.updateExprVal",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) updateExprVal(x ast.Expr, val constant.Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) updateExprVal(x ast.Expr, val constant.Value)\n```\n\nupdateExprVal updates the value of x to val. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.convertUntyped",
                    "documentation": {
                      "identifier": "Checker.convertUntyped",
                      "newPage": false,
                      "searchKey": "types.Checker.convertUntyped",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) convertUntyped(x *operand, target Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) convertUntyped(x *operand, target Type)\n```\n\nconvertUntyped attempts to set the type of an untyped value to the target type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.implicitTypeAndValue",
                    "documentation": {
                      "identifier": "Checker.implicitTypeAndValue",
                      "newPage": false,
                      "searchKey": "types.Checker.implicitTypeAndValue",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) implicitTypeAndValue(x *operand, target Type) (Type, constant.Value, errorCode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) implicitTypeAndValue(x *operand, target Type) (Type, constant.Value, errorCode)\n```\n\nimplicitTypeAndValue returns the implicit type of x when used in a context where the target type is expected. If no such implicit conversion is possible, it returns a nil Type and non-zero error code. \n\nIf x is a constant operand, the returned constant.Value will be the representation of x in this context. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.comparison",
                    "documentation": {
                      "identifier": "Checker.comparison",
                      "newPage": false,
                      "searchKey": "types.Checker.comparison",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) comparison(x, y *operand, op token.Token)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) comparison(x, y *operand, op token.Token)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.shift",
                    "documentation": {
                      "identifier": "Checker.shift",
                      "newPage": false,
                      "searchKey": "types.Checker.shift",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) shift(x, y *operand, e ast.Expr, op token.Token)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) shift(x, y *operand, e ast.Expr, op token.Token)\n```\n\nIf e != nil, it must be the shift expression; it may be nil for non-constant shifts. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.binary",
                    "documentation": {
                      "identifier": "Checker.binary",
                      "newPage": false,
                      "searchKey": "types.Checker.binary",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) binary(x *operand, e ast.Expr, lhs, rhs ast.Expr, op token.Token, opPos token.Pos)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) binary(x *operand, e ast.Expr, lhs, rhs ast.Expr, op token.Token, opPos token.Pos)\n```\n\nIf e != nil, it must be the binary expression; it may be nil for non-constant expressions (when invoked for an assignment operation where the binary expression is implicit). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.rawExpr",
                    "documentation": {
                      "identifier": "Checker.rawExpr",
                      "newPage": false,
                      "searchKey": "types.Checker.rawExpr",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) rawExpr(x *operand, e ast.Expr, hint Type) exprKind"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) rawExpr(x *operand, e ast.Expr, hint Type) exprKind\n```\n\nrawExpr typechecks expression e and initializes x with the expression value or type. If an error occurred, x.mode is set to invalid. If hint != nil, it is the type of a composite literal element. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.exprInternal",
                    "documentation": {
                      "identifier": "Checker.exprInternal",
                      "newPage": false,
                      "searchKey": "types.Checker.exprInternal",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) exprInternal(x *operand, e ast.Expr, hint Type) exprKind"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) exprInternal(x *operand, e ast.Expr, hint Type) exprKind\n```\n\nexprInternal contains the core of type checking of expressions. Must only be called by rawExpr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.typeAssertion",
                    "documentation": {
                      "identifier": "Checker.typeAssertion",
                      "newPage": false,
                      "searchKey": "types.Checker.typeAssertion",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) typeAssertion(at positioner, x *operand, xtyp *Interface, T Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) typeAssertion(at positioner, x *operand, xtyp *Interface, T Type)\n```\n\ntypeAssertion checks that x.(T) is legal; xtyp must be the type of x. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.expr",
                    "documentation": {
                      "identifier": "Checker.expr",
                      "newPage": false,
                      "searchKey": "types.Checker.expr",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) expr(x *operand, e ast.Expr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) expr(x *operand, e ast.Expr)\n```\n\nexpr typechecks expression e and initializes x with the expression value. The result must be a single value. If an error occurred, x.mode is set to invalid. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.multiExpr",
                    "documentation": {
                      "identifier": "Checker.multiExpr",
                      "newPage": false,
                      "searchKey": "types.Checker.multiExpr",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) multiExpr(x *operand, e ast.Expr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) multiExpr(x *operand, e ast.Expr)\n```\n\nmultiExpr is like expr but the result may also be a multi-value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.exprWithHint",
                    "documentation": {
                      "identifier": "Checker.exprWithHint",
                      "newPage": false,
                      "searchKey": "types.Checker.exprWithHint",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) exprWithHint(x *operand, e ast.Expr, hint Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) exprWithHint(x *operand, e ast.Expr, hint Type)\n```\n\nexprWithHint typechecks expression e and initializes x with the expression value; hint is the type of a composite literal element. If an error occurred, x.mode is set to invalid. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.exprOrType",
                    "documentation": {
                      "identifier": "Checker.exprOrType",
                      "newPage": false,
                      "searchKey": "types.Checker.exprOrType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) exprOrType(x *operand, e ast.Expr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) exprOrType(x *operand, e ast.Expr)\n```\n\nexprOrType typechecks expression or type e and initializes x with the expression value or type. If an error occurred, x.mode is set to invalid. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.exclude",
                    "documentation": {
                      "identifier": "Checker.exclude",
                      "newPage": false,
                      "searchKey": "types.Checker.exclude",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) exclude(x *operand, modeset uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) exclude(x *operand, modeset uint)\n```\n\nexclude reports an error if x.mode is in modeset and sets x.mode to invalid. The modeset may contain any of 1<<novalue, 1<<builtin, 1<<typexpr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.singleValue",
                    "documentation": {
                      "identifier": "Checker.singleValue",
                      "newPage": false,
                      "searchKey": "types.Checker.singleValue",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) singleValue(x *operand)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) singleValue(x *operand)\n```\n\nsingleValue reports an error if x describes a tuple and sets x.mode to invalid. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.indexExpr",
                    "documentation": {
                      "identifier": "Checker.indexExpr",
                      "newPage": false,
                      "searchKey": "types.Checker.indexExpr",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) indexExpr(x *operand, e *ast.IndexExpr) (isFuncInst bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) indexExpr(x *operand, e *ast.IndexExpr) (isFuncInst bool)\n```\n\nIf e is a valid function instantiation, indexExpr returns true. In that case x represents the uninstantiated function value and it is the caller's responsibility to instantiate the function. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.sliceExpr",
                    "documentation": {
                      "identifier": "Checker.sliceExpr",
                      "newPage": false,
                      "searchKey": "types.Checker.sliceExpr",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) sliceExpr(x *operand, e *ast.SliceExpr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) sliceExpr(x *operand, e *ast.SliceExpr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.singleIndex",
                    "documentation": {
                      "identifier": "Checker.singleIndex",
                      "newPage": false,
                      "searchKey": "types.Checker.singleIndex",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) singleIndex(e *ast.IndexExpr) ast.Expr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) singleIndex(e *ast.IndexExpr) ast.Expr\n```\n\nsingleIndex returns the (single) index from the index expression e. If the index is missing, or if there are multiple indices, an error is reported and the result is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.index",
                    "documentation": {
                      "identifier": "Checker.index",
                      "newPage": false,
                      "searchKey": "types.Checker.index",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) index(index ast.Expr, max int64) (typ Type, val int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) index(index ast.Expr, max int64) (typ Type, val int64)\n```\n\nindex checks an index expression for validity. If max >= 0, it is the upper bound for index. If the result typ is != Typ[Invalid], index is valid and typ is its (possibly named) integer type. If the result val >= 0, index is valid and val is its constant int value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.isValidIndex",
                    "documentation": {
                      "identifier": "Checker.isValidIndex",
                      "newPage": false,
                      "searchKey": "types.Checker.isValidIndex",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) isValidIndex(x *operand, code errorCode, what string, allowNegative bool) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) isValidIndex(x *operand, code errorCode, what string, allowNegative bool) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.indexedElts",
                    "documentation": {
                      "identifier": "Checker.indexedElts",
                      "newPage": false,
                      "searchKey": "types.Checker.indexedElts",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) indexedElts(elts []ast.Expr, typ Type, length int64) int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) indexedElts(elts []ast.Expr, typ Type, length int64) int64\n```\n\nindexElts checks the elements (elts) of an array or slice composite literal against the literal's element type (typ), and the element indices against the literal length if known (length >= 0). It returns the length of the literal (maximum index value + 1). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.infer",
                    "documentation": {
                      "identifier": "Checker.infer",
                      "newPage": false,
                      "searchKey": "types.Checker.infer",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) infer(posn positioner, tparams []*TypeName, targs []Type, params *Tuple, args []*operand, report bool) (result []Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) infer(posn positioner, tparams []*TypeName, targs []Type, params *Tuple, args []*operand, report bool) (result []Type)\n```\n\ninfer attempts to infer the complete set of type arguments for generic function instantiation/call based on the given type parameters tparams, type arguments targs, function parameters params, and function arguments args, if any. There must be at least one type parameter, no more type arguments than type parameters, and params and args must match in number (incl. zero). If successful, infer returns the complete list of type arguments, one for each type parameter. Otherwise the result is nil and appropriate errors will be reported unless report is set to false. \n\nInference proceeds in 3 steps: \n\n```\n1) Start with given type arguments.\n2) Infer type arguments from typed function arguments.\n3) Infer type arguments from untyped function arguments.\n\n```\nConstraint type inference is used after each step to expand the set of type arguments. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.inferB",
                    "documentation": {
                      "identifier": "Checker.inferB",
                      "newPage": false,
                      "searchKey": "types.Checker.inferB",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) inferB(tparams []*TypeName, targs []Type, report bool) (types []Type, index int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) inferB(tparams []*TypeName, targs []Type, report bool) (types []Type, index int)\n```\n\ninferB returns the list of actual type arguments inferred from the type parameters' bounds and an initial set of type arguments. If type inference is impossible because unification fails, an error is reported if report is set to true, the resulting types list is nil, and index is 0. Otherwise, types is the list of inferred type arguments, and index is the index of the first type argument in that list that couldn't be inferred (and thus is nil). If all type arguments were inferred successfully, index is < 0. The number of type arguments provided may be less than the number of type parameters, but there must be at least one. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.structuralType",
                    "documentation": {
                      "identifier": "Checker.structuralType",
                      "newPage": false,
                      "searchKey": "types.Checker.structuralType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) structuralType(constraint Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) structuralType(constraint Type) Type\n```\n\nstructuralType returns the structural type of a constraint, if any. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.initOrder",
                    "documentation": {
                      "identifier": "Checker.initOrder",
                      "newPage": false,
                      "searchKey": "types.Checker.initOrder",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) initOrder()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) initOrder()\n```\n\ninitOrder computes the Info.InitOrder for package variables. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.reportCycle",
                    "documentation": {
                      "identifier": "Checker.reportCycle",
                      "newPage": false,
                      "searchKey": "types.Checker.reportCycle",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) reportCycle(cycle []Object)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) reportCycle(cycle []Object)\n```\n\nreportCycle reports an error for the given cycle. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.labels",
                    "documentation": {
                      "identifier": "Checker.labels",
                      "newPage": false,
                      "searchKey": "types.Checker.labels",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) labels(body *ast.BlockStmt)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) labels(body *ast.BlockStmt)\n```\n\nlabels checks correct label use in body. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.blockBranches",
                    "documentation": {
                      "identifier": "Checker.blockBranches",
                      "newPage": false,
                      "searchKey": "types.Checker.blockBranches",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) blockBranches(all *Scope, parent *block, lstmt *ast.LabeledStmt, list []ast.Stmt) []*ast.BranchStmt"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) blockBranches(all *Scope, parent *block, lstmt *ast.LabeledStmt, list []ast.Stmt) []*ast.BranchStmt\n```\n\nblockBranches processes a block's statement list and returns the set of outgoing forward jumps. all is the scope of all declared labels, parent the set of labels declared in the immediately enclosing block, and lstmt is the labeled statement this block is associated with (or nil). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.lookupFieldOrMethod",
                    "documentation": {
                      "identifier": "Checker.lookupFieldOrMethod",
                      "newPage": false,
                      "searchKey": "types.Checker.lookupFieldOrMethod",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) lookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) lookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)\n```\n\nlookupFieldOrMethod is like the external version but completes interfaces as necessary. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.rawLookupFieldOrMethod",
                    "documentation": {
                      "identifier": "Checker.rawLookupFieldOrMethod",
                      "newPage": false,
                      "searchKey": "types.Checker.rawLookupFieldOrMethod",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) rawLookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) rawLookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)\n```\n\nrawLookupFieldOrMethod should only be called by lookupFieldOrMethod and missingMethod. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.consolidateMultiples",
                    "documentation": {
                      "identifier": "Checker.consolidateMultiples",
                      "newPage": false,
                      "searchKey": "types.Checker.consolidateMultiples",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) consolidateMultiples(list []embeddedType) []embeddedType"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) consolidateMultiples(list []embeddedType) []embeddedType\n```\n\nconsolidateMultiples collects multiple list entries with the same type into a single entry marked as containing multiples. The result is the consolidated list. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.lookupType",
                    "documentation": {
                      "identifier": "Checker.lookupType",
                      "newPage": false,
                      "searchKey": "types.Checker.lookupType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) lookupType(m map[Type]int, typ Type) (int, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) lookupType(m map[Type]int, typ Type) (int, bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.missingMethod",
                    "documentation": {
                      "identifier": "Checker.missingMethod",
                      "newPage": false,
                      "searchKey": "types.Checker.missingMethod",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) missingMethod(V Type, T *Interface, static bool) (method, wrongType *Func)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) missingMethod(V Type, T *Interface, static bool) (method, wrongType *Func)\n```\n\nmissingMethod is like MissingMethod but accepts a *Checker as receiver and an addressable flag. The receiver may be nil if missingMethod is invoked through an exported API call (such as MissingMethod), i.e., when all methods have been type-checked. If the type has the correctly named method, but with the wrong signature, the existing method is returned as well. To improve error messages, also report the wrong signature when the method exists on *V instead of V. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.assertableTo",
                    "documentation": {
                      "identifier": "Checker.assertableTo",
                      "newPage": false,
                      "searchKey": "types.Checker.assertableTo",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) assertableTo(V *Interface, T Type) (method, wrongType *Func)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) assertableTo(V *Interface, T Type) (method, wrongType *Func)\n```\n\nassertableTo reports whether a value of type V can be asserted to have type T. It returns (nil, false) as affirmative answer. Otherwise it returns a missing method required by V and whether it is missing or just has the wrong type. The receiver may be nil if assertableTo is invoked through an exported API call (such as AssertableTo), i.e., when all methods have been type-checked. If the global constant forceStrict is set, assertions that are known to fail are not permitted. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.identical",
                    "documentation": {
                      "identifier": "Checker.identical",
                      "newPage": false,
                      "searchKey": "types.Checker.identical",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) identical(x, y Type) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) identical(x, y Type) bool\n```\n\nidentical reports whether x and y are identical types. Receivers of Signature types are ignored. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.identicalIgnoreTags",
                    "documentation": {
                      "identifier": "Checker.identicalIgnoreTags",
                      "newPage": false,
                      "searchKey": "types.Checker.identicalIgnoreTags",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) identicalIgnoreTags(x, y Type) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) identicalIgnoreTags(x, y Type) bool\n```\n\nidenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of Signature types are ignored. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.identical0",
                    "documentation": {
                      "identifier": "Checker.identical0",
                      "newPage": false,
                      "searchKey": "types.Checker.identical0",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) identical0(x, y Type, cmpTags bool, p *ifacePair) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) identical0(x, y Type, cmpTags bool, p *ifacePair) bool\n```\n\nFor changes to this code the corresponding changes should be made to unifier.nify. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.identicalTParams",
                    "documentation": {
                      "identifier": "Checker.identicalTParams",
                      "newPage": false,
                      "searchKey": "types.Checker.identicalTParams",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) identicalTParams(x, y []*TypeName, cmpTags bool, p *ifacePair) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) identicalTParams(x, y []*TypeName, cmpTags bool, p *ifacePair) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.arityMatch",
                    "documentation": {
                      "identifier": "Checker.arityMatch",
                      "newPage": false,
                      "searchKey": "types.Checker.arityMatch",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) arityMatch(s, init *ast.ValueSpec)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) arityMatch(s, init *ast.ValueSpec)\n```\n\narityMatch checks that the lhs and rhs of a const or var decl have the appropriate number of names and init exprs. For const decls, init is the value spec providing the init exprs; for var decls, init is nil (the init exprs are in s in this case). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.declarePkgObj",
                    "documentation": {
                      "identifier": "Checker.declarePkgObj",
                      "newPage": false,
                      "searchKey": "types.Checker.declarePkgObj",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) declarePkgObj(ident *ast.Ident, obj Object, d *declInfo)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) declarePkgObj(ident *ast.Ident, obj Object, d *declInfo)\n```\n\ndeclarePkgObj declares obj in the package scope, records its ident -> obj mapping, and updates check.objMap. The object must not be a function or method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.filename",
                    "documentation": {
                      "identifier": "Checker.filename",
                      "newPage": false,
                      "searchKey": "types.Checker.filename",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) filename(fileNo int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) filename(fileNo int) string\n```\n\nfilename returns a filename suitable for debugging output. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.importPackage",
                    "documentation": {
                      "identifier": "Checker.importPackage",
                      "newPage": false,
                      "searchKey": "types.Checker.importPackage",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) importPackage(at positioner, path, dir string) *Package"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) importPackage(at positioner, path, dir string) *Package\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.collectObjects",
                    "documentation": {
                      "identifier": "Checker.collectObjects",
                      "newPage": false,
                      "searchKey": "types.Checker.collectObjects",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) collectObjects()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) collectObjects()\n```\n\ncollectObjects collects all file and package objects and inserts them into their respective scopes. It also performs imports and associates methods with receiver base type names. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.unpackRecv",
                    "documentation": {
                      "identifier": "Checker.unpackRecv",
                      "newPage": false,
                      "searchKey": "types.Checker.unpackRecv",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) unpackRecv(rtyp ast.Expr, unpackParams bool) (ptr bool, rname *ast.Ident, tparams []*ast.Ident)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) unpackRecv(rtyp ast.Expr, unpackParams bool) (ptr bool, rname *ast.Ident, tparams []*ast.Ident)\n```\n\nunpackRecv unpacks a receiver type and returns its components: ptr indicates whether rtyp is a pointer receiver, rname is the receiver type name, and tparams are its type parameters, if any. The type parameters are only unpacked if unpackParams is set. If rname is nil, the receiver is unusable (i.e., the source has a bug which we cannot easily work around). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.resolveBaseTypeName",
                    "documentation": {
                      "identifier": "Checker.resolveBaseTypeName",
                      "newPage": false,
                      "searchKey": "types.Checker.resolveBaseTypeName",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) resolveBaseTypeName(seenPtr bool, name *ast.Ident) (ptr bool, base *TypeName)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) resolveBaseTypeName(seenPtr bool, name *ast.Ident) (ptr bool, base *TypeName)\n```\n\nresolveBaseTypeName returns the non-alias base type name for typ, and whether there was a pointer indirection to get to it. The base type name must be declared in package scope, and there can be at most one pointer indirection. If no such type name exists, the returned base is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.packageObjects",
                    "documentation": {
                      "identifier": "Checker.packageObjects",
                      "newPage": false,
                      "searchKey": "types.Checker.packageObjects",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) packageObjects()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) packageObjects()\n```\n\npackageObjects typechecks all package objects, but not function bodies. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.unusedImports",
                    "documentation": {
                      "identifier": "Checker.unusedImports",
                      "newPage": false,
                      "searchKey": "types.Checker.unusedImports",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) unusedImports()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) unusedImports()\n```\n\nunusedImports checks for unused imports. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.errorUnusedPkg",
                    "documentation": {
                      "identifier": "Checker.errorUnusedPkg",
                      "newPage": false,
                      "searchKey": "types.Checker.errorUnusedPkg",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) errorUnusedPkg(obj *PkgName)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) errorUnusedPkg(obj *PkgName)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.isTerminating",
                    "documentation": {
                      "identifier": "Checker.isTerminating",
                      "newPage": false,
                      "searchKey": "types.Checker.isTerminating",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) isTerminating(s ast.Stmt, label string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) isTerminating(s ast.Stmt, label string) bool\n```\n\nisTerminating reports if s is a terminating statement. If s is labeled, label is the label name; otherwise s is \"\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.isTerminatingList",
                    "documentation": {
                      "identifier": "Checker.isTerminatingList",
                      "newPage": false,
                      "searchKey": "types.Checker.isTerminatingList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) isTerminatingList(list []ast.Stmt, label string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) isTerminatingList(list []ast.Stmt, label string) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.isTerminatingSwitch",
                    "documentation": {
                      "identifier": "Checker.isTerminatingSwitch",
                      "newPage": false,
                      "searchKey": "types.Checker.isTerminatingSwitch",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) isTerminatingSwitch(body *ast.BlockStmt, label string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) isTerminatingSwitch(body *ast.BlockStmt, label string) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.funcBody",
                    "documentation": {
                      "identifier": "Checker.funcBody",
                      "newPage": false,
                      "searchKey": "types.Checker.funcBody",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) funcBody(decl *declInfo, name string, sig *Signature, body *ast.BlockStmt, iota constant.Value)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) funcBody(decl *declInfo, name string, sig *Signature, body *ast.BlockStmt, iota constant.Value)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.usage",
                    "documentation": {
                      "identifier": "Checker.usage",
                      "newPage": false,
                      "searchKey": "types.Checker.usage",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) usage(scope *Scope)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) usage(scope *Scope)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.simpleStmt",
                    "documentation": {
                      "identifier": "Checker.simpleStmt",
                      "newPage": false,
                      "searchKey": "types.Checker.simpleStmt",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) simpleStmt(s ast.Stmt)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) simpleStmt(s ast.Stmt)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.stmtList",
                    "documentation": {
                      "identifier": "Checker.stmtList",
                      "newPage": false,
                      "searchKey": "types.Checker.stmtList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) stmtList(ctxt stmtContext, list []ast.Stmt)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) stmtList(ctxt stmtContext, list []ast.Stmt)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.multipleDefaults",
                    "documentation": {
                      "identifier": "Checker.multipleDefaults",
                      "newPage": false,
                      "searchKey": "types.Checker.multipleDefaults",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) multipleDefaults(list []ast.Stmt)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) multipleDefaults(list []ast.Stmt)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.openScope",
                    "documentation": {
                      "identifier": "Checker.openScope",
                      "newPage": false,
                      "searchKey": "types.Checker.openScope",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) openScope(node ast.Node, comment string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) openScope(node ast.Node, comment string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.closeScope",
                    "documentation": {
                      "identifier": "Checker.closeScope",
                      "newPage": false,
                      "searchKey": "types.Checker.closeScope",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) closeScope()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) closeScope()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.suspendedCall",
                    "documentation": {
                      "identifier": "Checker.suspendedCall",
                      "newPage": false,
                      "searchKey": "types.Checker.suspendedCall",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) suspendedCall(keyword string, call *ast.CallExpr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) suspendedCall(keyword string, call *ast.CallExpr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.caseValues",
                    "documentation": {
                      "identifier": "Checker.caseValues",
                      "newPage": false,
                      "searchKey": "types.Checker.caseValues",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) caseValues(x *operand, values []ast.Expr, seen valueMap)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) caseValues(x *operand, values []ast.Expr, seen valueMap)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.caseTypes",
                    "documentation": {
                      "identifier": "Checker.caseTypes",
                      "newPage": false,
                      "searchKey": "types.Checker.caseTypes",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) caseTypes(x *operand, xtyp *Interface, types []ast.Expr, seen map[Type]ast.Expr) (T Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) caseTypes(x *operand, xtyp *Interface, types []ast.Expr, seen map[Type]ast.Expr) (T Type)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.stmt",
                    "documentation": {
                      "identifier": "Checker.stmt",
                      "newPage": false,
                      "searchKey": "types.Checker.stmt",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) stmt(ctxt stmtContext, s ast.Stmt)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) stmt(ctxt stmtContext, s ast.Stmt)\n```\n\nstmt typechecks statement s. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.instantiate",
                    "documentation": {
                      "identifier": "Checker.instantiate",
                      "newPage": false,
                      "searchKey": "types.Checker.instantiate",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) instantiate(pos token.Pos, typ Type, targs []Type, poslist []token.Pos) (res Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) instantiate(pos token.Pos, typ Type, targs []Type, poslist []token.Pos) (res Type)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.subst",
                    "documentation": {
                      "identifier": "Checker.subst",
                      "newPage": false,
                      "searchKey": "types.Checker.subst",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) subst(pos token.Pos, typ Type, smap *substMap) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) subst(pos token.Pos, typ Type, smap *substMap) Type\n```\n\nsubst returns the type typ with its type parameters tpars replaced by the corresponding type arguments targs, recursively. subst is functional in the sense that it doesn't modify the incoming type. If a substitution took place, the result type is different from from the incoming type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.newNamed",
                    "documentation": {
                      "identifier": "Checker.newNamed",
                      "newPage": false,
                      "searchKey": "types.Checker.newNamed",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) newNamed(obj *TypeName, underlying Type, methods []*Func) *Named"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) newNamed(obj *TypeName, underlying Type, methods []*Func) *Named\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.newTypeParam",
                    "documentation": {
                      "identifier": "Checker.newTypeParam",
                      "newPage": false,
                      "searchKey": "types.Checker.newTypeParam",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) newTypeParam(obj *TypeName, index int, bound Type) *_TypeParam"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) newTypeParam(obj *TypeName, index int, bound Type) *_TypeParam\n```\n\nnewTypeParam returns a new TypeParam. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.ident",
                    "documentation": {
                      "identifier": "Checker.ident",
                      "newPage": false,
                      "searchKey": "types.Checker.ident",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) ident(x *operand, e *ast.Ident, def *Named, wantType bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) ident(x *operand, e *ast.Ident, def *Named, wantType bool)\n```\n\nident type-checks identifier e and initializes x with the value or type of e. If an error occurred, x.mode is set to invalid. For the meaning of def, see Checker.definedType, below. If wantType is set, the identifier e is expected to denote a type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.typ",
                    "documentation": {
                      "identifier": "Checker.typ",
                      "newPage": false,
                      "searchKey": "types.Checker.typ",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) typ(e ast.Expr) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) typ(e ast.Expr) Type\n```\n\ntyp type-checks the type expression e and returns its type, or Typ[Invalid]. The type must not be an (uninstantiated) generic type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.varType",
                    "documentation": {
                      "identifier": "Checker.varType",
                      "newPage": false,
                      "searchKey": "types.Checker.varType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) varType(e ast.Expr) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) varType(e ast.Expr) Type\n```\n\nvarType type-checks the type expression e and returns its type, or Typ[Invalid]. The type must not be an (uninstantiated) generic type and it must be ordinary (see ordinaryType). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.ordinaryType",
                    "documentation": {
                      "identifier": "Checker.ordinaryType",
                      "newPage": false,
                      "searchKey": "types.Checker.ordinaryType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) ordinaryType(pos positioner, typ Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) ordinaryType(pos positioner, typ Type)\n```\n\nordinaryType reports an error if typ is an interface type containing type lists or is (or embeds) the predeclared type comparable. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.anyType",
                    "documentation": {
                      "identifier": "Checker.anyType",
                      "newPage": false,
                      "searchKey": "types.Checker.anyType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) anyType(e ast.Expr) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) anyType(e ast.Expr) Type\n```\n\nanyType type-checks the type expression e and returns its type, or Typ[Invalid]. The type may be generic or instantiated. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.definedType",
                    "documentation": {
                      "identifier": "Checker.definedType",
                      "newPage": false,
                      "searchKey": "types.Checker.definedType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) definedType(e ast.Expr, def *Named) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) definedType(e ast.Expr, def *Named) Type\n```\n\ndefinedType is like typ but also accepts a type name def. If def != nil, e is the type specification for the defined type def, declared in a type declaration, and def.underlying will be set to the type of e before any components of e are type-checked. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.genericType",
                    "documentation": {
                      "identifier": "Checker.genericType",
                      "newPage": false,
                      "searchKey": "types.Checker.genericType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) genericType(e ast.Expr, reportErr bool) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) genericType(e ast.Expr, reportErr bool) Type\n```\n\ngenericType is like typ but the type must be an (uninstantiated) generic type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.funcType",
                    "documentation": {
                      "identifier": "Checker.funcType",
                      "newPage": false,
                      "searchKey": "types.Checker.funcType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) funcType(sig *Signature, recvPar *ast.FieldList, ftyp *ast.FuncType)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) funcType(sig *Signature, recvPar *ast.FieldList, ftyp *ast.FuncType)\n```\n\nfuncType type-checks a function or method type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.typInternal",
                    "documentation": {
                      "identifier": "Checker.typInternal",
                      "newPage": false,
                      "searchKey": "types.Checker.typInternal",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) typInternal(e0 ast.Expr, def *Named) (T Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) typInternal(e0 ast.Expr, def *Named) (T Type)\n```\n\ntypInternal drives type checking of types. Must only be called by definedType or genericType. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.typeOrNil",
                    "documentation": {
                      "identifier": "Checker.typeOrNil",
                      "newPage": false,
                      "searchKey": "types.Checker.typeOrNil",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) typeOrNil(e ast.Expr) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) typeOrNil(e ast.Expr) Type\n```\n\ntypeOrNil type-checks the type expression (or nil value) e and returns the type of e, or nil. If e is a type, it must not be an (uninstantiated) generic type. If e is neither a type nor nil, typeOrNil returns Typ[Invalid]. TODO(gri) should we also disallow non-var types? \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.instantiatedType",
                    "documentation": {
                      "identifier": "Checker.instantiatedType",
                      "newPage": false,
                      "searchKey": "types.Checker.instantiatedType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) instantiatedType(x ast.Expr, targs []ast.Expr, def *Named) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) instantiatedType(x ast.Expr, targs []ast.Expr, def *Named) Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.arrayLength",
                    "documentation": {
                      "identifier": "Checker.arrayLength",
                      "newPage": false,
                      "searchKey": "types.Checker.arrayLength",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) arrayLength(e ast.Expr) int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) arrayLength(e ast.Expr) int64\n```\n\narrayLength type-checks the array length expression e and returns the constant length >= 0, or a value < 0 to indicate an error (and thus an unknown length). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.typeList",
                    "documentation": {
                      "identifier": "Checker.typeList",
                      "newPage": false,
                      "searchKey": "types.Checker.typeList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) typeList(list []ast.Expr) []Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) typeList(list []ast.Expr) []Type\n```\n\ntypeList provides the list of types corresponding to the incoming expression list. If an error occurred, the result is nil, but all list elements were type-checked. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.collectParams",
                    "documentation": {
                      "identifier": "Checker.collectParams",
                      "newPage": false,
                      "searchKey": "types.Checker.collectParams",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) collectParams(scope *Scope, list *ast.FieldList, type0 ast.Expr, variadicOk bool) (params []*Var, variadic bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) collectParams(scope *Scope, list *ast.FieldList, type0 ast.Expr, variadicOk bool) (params []*Var, variadic bool)\n```\n\ncollectParams declares the parameters of list in scope and returns the corresponding variable list. If type0 != nil, it is used instead of the first type in list. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.declareInSet",
                    "documentation": {
                      "identifier": "Checker.declareInSet",
                      "newPage": false,
                      "searchKey": "types.Checker.declareInSet",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) declareInSet(oset *objset, pos token.Pos, obj Object) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) declareInSet(oset *objset, pos token.Pos, obj Object) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.interfaceType",
                    "documentation": {
                      "identifier": "Checker.interfaceType",
                      "newPage": false,
                      "searchKey": "types.Checker.interfaceType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) interfaceType(ityp *Interface, iface *ast.InterfaceType, def *Named)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) interfaceType(ityp *Interface, iface *ast.InterfaceType, def *Named)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.completeInterface",
                    "documentation": {
                      "identifier": "Checker.completeInterface",
                      "newPage": false,
                      "searchKey": "types.Checker.completeInterface",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) completeInterface(pos token.Pos, ityp *Interface)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) completeInterface(pos token.Pos, ityp *Interface)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.tag",
                    "documentation": {
                      "identifier": "Checker.tag",
                      "newPage": false,
                      "searchKey": "types.Checker.tag",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) tag(t *ast.BasicLit) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) tag(t *ast.BasicLit) string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.structType",
                    "documentation": {
                      "identifier": "Checker.structType",
                      "newPage": false,
                      "searchKey": "types.Checker.structType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) structType(styp *Struct, e *ast.StructType)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) structType(styp *Struct, e *ast.StructType)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.collectTypeConstraints",
                    "documentation": {
                      "identifier": "Checker.collectTypeConstraints",
                      "newPage": false,
                      "searchKey": "types.Checker.collectTypeConstraints",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) collectTypeConstraints(pos token.Pos, types []ast.Expr) []Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) collectTypeConstraints(pos token.Pos, types []ast.Expr) []Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.langCompat",
                    "documentation": {
                      "identifier": "Checker.langCompat",
                      "newPage": false,
                      "searchKey": "types.Checker.langCompat",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) langCompat(lit *ast.BasicLit)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) langCompat(lit *ast.BasicLit)\n```\n\nlangCompat reports an error if the representation of a numeric literal is not compatible with the current language version. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Checker.allowVersion",
                    "documentation": {
                      "identifier": "Checker.allowVersion",
                      "newPage": false,
                      "searchKey": "types.Checker.allowVersion",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (check *Checker) allowVersion(pkg *Package, major, minor int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (check *Checker) allowVersion(pkg *Package, major, minor int) bool\n```\n\nallowVersion reports whether the given package is allowed to use version major.minor. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#bailout",
              "documentation": {
                "identifier": "bailout",
                "newPage": false,
                "searchKey": "types.bailout",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type bailout struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bailout struct{}\n```\n\nA bailout panic is used for early termination. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#typeInfo",
              "documentation": {
                "identifier": "typeInfo",
                "newPage": false,
                "searchKey": "types.typeInfo",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type typeInfo uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype typeInfo uint\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#decl",
              "documentation": {
                "identifier": "decl",
                "newPage": false,
                "searchKey": "types.decl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type decl interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype decl interface {\n\tnode() ast.Node\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#importDecl",
              "documentation": {
                "identifier": "importDecl",
                "newPage": false,
                "searchKey": "types.importDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type importDecl struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype importDecl struct{ spec *ast.ImportSpec }\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#importDecl.node",
                    "documentation": {
                      "identifier": "importDecl.node",
                      "newPage": false,
                      "searchKey": "types.importDecl.node",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d importDecl) node() ast.Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d importDecl) node() ast.Node\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#constDecl",
              "documentation": {
                "identifier": "constDecl",
                "newPage": false,
                "searchKey": "types.constDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type constDecl struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype constDecl struct {\n\tspec      *ast.ValueSpec\n\tiota      int\n\ttyp       ast.Expr\n\tinit      []ast.Expr\n\tinherited bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#constDecl.node",
                    "documentation": {
                      "identifier": "constDecl.node",
                      "newPage": false,
                      "searchKey": "types.constDecl.node",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d constDecl) node() ast.Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d constDecl) node() ast.Node\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#varDecl",
              "documentation": {
                "identifier": "varDecl",
                "newPage": false,
                "searchKey": "types.varDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type varDecl struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype varDecl struct{ spec *ast.ValueSpec }\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#varDecl.node",
                    "documentation": {
                      "identifier": "varDecl.node",
                      "newPage": false,
                      "searchKey": "types.varDecl.node",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d varDecl) node() ast.Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d varDecl) node() ast.Node\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#typeDecl",
              "documentation": {
                "identifier": "typeDecl",
                "newPage": false,
                "searchKey": "types.typeDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type typeDecl struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype typeDecl struct{ spec *ast.TypeSpec }\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#typeDecl.node",
                    "documentation": {
                      "identifier": "typeDecl.node",
                      "newPage": false,
                      "searchKey": "types.typeDecl.node",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d typeDecl) node() ast.Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d typeDecl) node() ast.Node\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#funcDecl",
              "documentation": {
                "identifier": "funcDecl",
                "newPage": false,
                "searchKey": "types.funcDecl",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcDecl struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcDecl struct{ decl *ast.FuncDecl }\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#funcDecl.node",
                    "documentation": {
                      "identifier": "funcDecl.node",
                      "newPage": false,
                      "searchKey": "types.funcDecl.node",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d funcDecl) node() ast.Node"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d funcDecl) node() ast.Node\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#errorCode",
              "documentation": {
                "identifier": "errorCode",
                "newPage": false,
                "searchKey": "types.errorCode",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type errorCode int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype errorCode int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#positioner",
              "documentation": {
                "identifier": "positioner",
                "newPage": false,
                "searchKey": "types.positioner",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type positioner interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype positioner interface {\n\tPos() token.Pos\n}\n```\n\nThe positioner interface is used to extract the position of type-checker errors. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#posSpan",
              "documentation": {
                "identifier": "posSpan",
                "newPage": false,
                "searchKey": "types.posSpan",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type posSpan struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype posSpan struct {\n\tstart, pos, end token.Pos\n}\n```\n\nposSpan holds a position range along with a highlighted position within that range. This is used for positioning errors, with pos by convention being the first position in the source where the error is known to exist, and start and end defining the full span of syntax being considered when the error was detected. Invariant: start <= pos < end || start == pos == end. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#inNode",
                    "documentation": {
                      "identifier": "inNode",
                      "newPage": false,
                      "searchKey": "types.inNode",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func inNode(node ast.Node, pos token.Pos) posSpan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc inNode(node ast.Node, pos token.Pos) posSpan\n```\n\ninNode creates a posSpan for the given node. Invariant: node.Pos() <= pos < node.End() (node.End() is the position of the first byte after node within the source). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#spanOf",
                    "documentation": {
                      "identifier": "spanOf",
                      "newPage": false,
                      "searchKey": "types.spanOf",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func spanOf(at positioner) posSpan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc spanOf(at positioner) posSpan\n```\n\nspanOf extracts an error span from the given positioner. By default this is the trivial span starting and ending at pos, but this span is expanded when the argument naturally corresponds to a span of source code. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#posSpan.Pos",
                    "documentation": {
                      "identifier": "posSpan.Pos",
                      "newPage": false,
                      "searchKey": "types.posSpan.Pos",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e posSpan) Pos() token.Pos"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e posSpan) Pos() token.Pos\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#atPos",
              "documentation": {
                "identifier": "atPos",
                "newPage": false,
                "searchKey": "types.atPos",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type atPos token.Pos"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype atPos token.Pos\n```\n\natPos wraps a token.Pos to implement the positioner interface. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#atPos.Pos",
                    "documentation": {
                      "identifier": "atPos.Pos",
                      "newPage": false,
                      "searchKey": "types.atPos.Pos",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s atPos) Pos() token.Pos"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s atPos) Pos() token.Pos\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#opPredicates",
              "documentation": {
                "identifier": "opPredicates",
                "newPage": false,
                "searchKey": "types.opPredicates",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type opPredicates map[token.Token]func(std/go/types.Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype opPredicates map[token.Token]func(Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#exprKind",
              "documentation": {
                "identifier": "exprKind",
                "newPage": false,
                "searchKey": "types.exprKind",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type exprKind int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype exprKind int\n```\n\nexprKind describes the kind of an expression; the kind determines if an expression is valid in 'statement context'. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#tpWalker",
              "documentation": {
                "identifier": "tpWalker",
                "newPage": false,
                "searchKey": "types.tpWalker",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type tpWalker struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype tpWalker struct {\n\tseen    map[Type]bool\n\ttparams []*TypeName\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#tpWalker.isParameterized",
                    "documentation": {
                      "identifier": "tpWalker.isParameterized",
                      "newPage": false,
                      "searchKey": "types.tpWalker.isParameterized",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *tpWalker) isParameterized(typ Type) (res bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *tpWalker) isParameterized(typ Type) (res bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#tpWalker.isParameterizedList",
                    "documentation": {
                      "identifier": "tpWalker.isParameterizedList",
                      "newPage": false,
                      "searchKey": "types.tpWalker.isParameterizedList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *tpWalker) isParameterizedList(list []Type) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *tpWalker) isParameterizedList(list []Type) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#dependency",
              "documentation": {
                "identifier": "dependency",
                "newPage": false,
                "searchKey": "types.dependency",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type dependency interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dependency interface {\n\tObject\n\tisDependency()\n}\n```\n\nA dependency is an object that may be a dependency in an initialization expression. Only constants, variables, and functions can be dependencies. Constants are here because constant expression cycles are reported during initialization order computation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#graphNode",
              "documentation": {
                "identifier": "graphNode",
                "newPage": false,
                "searchKey": "types.graphNode",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type graphNode struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype graphNode struct {\n\tobj        dependency // object represented by this node\n\tpred, succ nodeSet    // consumers and dependencies of this node (lazily initialized)\n\tindex      int        // node index in graph slice/priority queue\n\tndeps      int        // number of outstanding dependencies before this object can be initialized\n}\n```\n\nA graphNode represents a node in the object dependency graph. Each node p in n.pred represents an edge p->n, and each node s in n.succ represents an edge n->s; with a->b indicating that a depends on b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#nodeSet",
              "documentation": {
                "identifier": "nodeSet",
                "newPage": false,
                "searchKey": "types.nodeSet",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type nodeSet map[*types.graphNode]bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nodeSet map[*graphNode]bool\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#nodeSet.add",
                    "documentation": {
                      "identifier": "nodeSet.add",
                      "newPage": false,
                      "searchKey": "types.nodeSet.add",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *nodeSet) add(p *graphNode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *nodeSet) add(p *graphNode)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#nodeQueue",
              "documentation": {
                "identifier": "nodeQueue",
                "newPage": false,
                "searchKey": "types.nodeQueue",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type nodeQueue []*types.graphNode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nodeQueue []*graphNode\n```\n\nnodeQueue implements the container/heap interface; a nodeQueue may be used as a priority queue. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#nodeQueue.Len",
                    "documentation": {
                      "identifier": "nodeQueue.Len",
                      "newPage": false,
                      "searchKey": "types.nodeQueue.Len",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a nodeQueue) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a nodeQueue) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#nodeQueue.Swap",
                    "documentation": {
                      "identifier": "nodeQueue.Swap",
                      "newPage": false,
                      "searchKey": "types.nodeQueue.Swap",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a nodeQueue) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a nodeQueue) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#nodeQueue.Less",
                    "documentation": {
                      "identifier": "nodeQueue.Less",
                      "newPage": false,
                      "searchKey": "types.nodeQueue.Less",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a nodeQueue) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a nodeQueue) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#nodeQueue.Push",
                    "documentation": {
                      "identifier": "nodeQueue.Push",
                      "newPage": false,
                      "searchKey": "types.nodeQueue.Push",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *nodeQueue) Push(x interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *nodeQueue) Push(x interface{})\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#nodeQueue.Pop",
                    "documentation": {
                      "identifier": "nodeQueue.Pop",
                      "newPage": false,
                      "searchKey": "types.nodeQueue.Pop",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *nodeQueue) Pop() interface{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *nodeQueue) Pop() interface{}\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#block",
              "documentation": {
                "identifier": "block",
                "newPage": false,
                "searchKey": "types.block",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type block struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype block struct {\n\tparent *block                      // enclosing block\n\tlstmt  *ast.LabeledStmt            // labeled statement to which this block belongs, or nil\n\tlabels map[string]*ast.LabeledStmt // allocated lazily\n}\n```\n\nA block tracks label declarations in a block and its enclosing blocks. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#block.insert",
                    "documentation": {
                      "identifier": "block.insert",
                      "newPage": false,
                      "searchKey": "types.block.insert",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) insert(s *ast.LabeledStmt)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) insert(s *ast.LabeledStmt)\n```\n\ninsert records a new label declaration for the current block. The label must not have been declared before in any block. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#block.gotoTarget",
                    "documentation": {
                      "identifier": "block.gotoTarget",
                      "newPage": false,
                      "searchKey": "types.block.gotoTarget",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) gotoTarget(name string) *ast.LabeledStmt"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) gotoTarget(name string) *ast.LabeledStmt\n```\n\ngotoTarget returns the labeled statement in the current or an enclosing block with the given label name, or nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#block.enclosingTarget",
                    "documentation": {
                      "identifier": "block.enclosingTarget",
                      "newPage": false,
                      "searchKey": "types.block.enclosingTarget",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) enclosingTarget(name string) *ast.LabeledStmt"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) enclosingTarget(name string) *ast.LabeledStmt\n```\n\nenclosingTarget returns the innermost enclosing labeled statement with the given label name, or nil. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#embeddedType",
              "documentation": {
                "identifier": "embeddedType",
                "newPage": false,
                "searchKey": "types.embeddedType",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type embeddedType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype embeddedType struct {\n\ttyp       Type\n\tindex     []int // embedded field indices, starting with index at depth 0\n\tindirect  bool  // if set, there was a pointer indirection on the path to this field\n\tmultiples bool  // if set, typ appears multiple times at this depth\n}\n```\n\nembeddedType represents an embedded type \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#MethodSet",
              "documentation": {
                "identifier": "MethodSet",
                "newPage": false,
                "searchKey": "types.MethodSet",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type MethodSet struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype MethodSet struct {\n\tlist []*Selection\n}\n```\n\nA MethodSet is an ordered set of concrete or abstract (interface) methods; a method is a MethodVal selection, and they are ordered by ascending m.Obj().Id(). The zero value for a MethodSet is a ready-to-use empty method set. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewMethodSet",
                    "documentation": {
                      "identifier": "NewMethodSet",
                      "newPage": false,
                      "searchKey": "types.NewMethodSet",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewMethodSet(T Type) *MethodSet"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewMethodSet(T Type) *MethodSet\n```\n\nNewMethodSet returns the method set for the given type T. It always returns a non-nil method set, even if it is empty. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#MethodSet.String",
                    "documentation": {
                      "identifier": "MethodSet.String",
                      "newPage": false,
                      "searchKey": "types.MethodSet.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *MethodSet) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *MethodSet) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#MethodSet.Len",
                    "documentation": {
                      "identifier": "MethodSet.Len",
                      "newPage": false,
                      "searchKey": "types.MethodSet.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *MethodSet) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *MethodSet) Len() int\n```\n\nLen returns the number of methods in s. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#MethodSet.At",
                    "documentation": {
                      "identifier": "MethodSet.At",
                      "newPage": false,
                      "searchKey": "types.MethodSet.At",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *MethodSet) At(i int) *Selection"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *MethodSet) At(i int) *Selection\n```\n\nAt returns the i'th method in s for 0 <= i < s.Len(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#MethodSet.Lookup",
                    "documentation": {
                      "identifier": "MethodSet.Lookup",
                      "newPage": false,
                      "searchKey": "types.MethodSet.Lookup",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *MethodSet) Lookup(pkg *Package, name string) *Selection"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *MethodSet) Lookup(pkg *Package, name string) *Selection\n```\n\nLookup returns the method with matching package and name, or nil if not found. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#methodSet",
              "documentation": {
                "identifier": "methodSet",
                "newPage": false,
                "searchKey": "types.methodSet",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type methodSet map[string]*types.Selection"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype methodSet map[string]*Selection // a nil entry indicates a name collision\n\n```\n\nA methodSet is a set of methods and name collisions. A collision indicates that multiple methods with the same unique id, or a field with that id appeared. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#methodSet.add",
                    "documentation": {
                      "identifier": "methodSet.add",
                      "newPage": false,
                      "searchKey": "types.methodSet.add",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s methodSet) add(list []*Func, index []int, indirect bool, multiples bool) methodSet"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s methodSet) add(list []*Func, index []int, indirect bool, multiples bool) methodSet\n```\n\nAdd adds all functions in list to the method set s. If multiples is set, every function in list appears multiple times and is treated as a collision. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Object",
              "documentation": {
                "identifier": "Object",
                "newPage": false,
                "searchKey": "types.Object",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Object interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Object interface {\n\tParent() *Scope // scope in which this object is declared; nil for methods and struct fields\n\tPos() token.Pos // position of object identifier in declaration\n\tPkg() *Package  // package to which this object belongs; nil for labels and objects in the Universe scope\n\tName() string   // package local object name\n\tType() Type     // object type\n\tExported() bool // reports whether the name starts with a capital letter\n\tId() string     // object name if exported, qualified name if not exported (see func Id)\n\n\t// String returns a human-readable string of the object.\n\tString() string\n\n\t// order reflects a package-level object's source order: if object\n\t// a is before object b in the source, then a.order() < b.order().\n\t// order returns a value > 0 for package-level objects; it returns\n\t// 0 for all other objects (including objects in file scopes).\n\torder() uint32\n\n\t// color returns the object's color.\n\tcolor() color\n\n\t// setType sets the type of the object.\n\tsetType(Type)\n\n\t// setOrder sets the order number of the object. It must be > 0.\n\tsetOrder(uint32)\n\n\t// setColor sets the object's color. It must not be white.\n\tsetColor(color color)\n\n\t// setParent sets the parent scope of the object.\n\tsetParent(*Scope)\n\n\t// sameId reports whether obj.Id() and Id(pkg, name) are the same.\n\tsameId(pkg *Package, name string) bool\n\n\t// scopePos returns the start position of the scope of this Object\n\tscopePos() token.Pos\n\n\t// setScopePos sets the start position of the scope for this Object.\n\tsetScopePos(pos token.Pos)\n}\n```\n\nAn Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label. All objects implement the Object interface. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#LookupFieldOrMethod",
                    "documentation": {
                      "identifier": "LookupFieldOrMethod",
                      "newPage": false,
                      "searchKey": "types.LookupFieldOrMethod",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)\n```\n\nLookupFieldOrMethod looks up a field or method with given package and name in T and returns the corresponding *Var or *Func, an index sequence, and a bool indicating if there were any pointer indirections on the path to the field or method. If addressable is set, T is the type of an addressable variable (only matters for method lookups). \n\nThe last index entry is the field or method index in the (possibly embedded) type where the entry was found, either: \n\n```\n1) the list of declared methods of a named type; or\n2) the list of all methods (method set) of an interface type; or\n3) the list of fields of a struct type.\n\n```\nThe earlier index entries are the indices of the embedded struct fields traversed to get to the found entry, starting at depth 0. \n\nIf no entry is found, a nil object is returned. In this case, the returned index and indirect values have the following meaning: \n\n```\n\t- If index != nil, the index sequence points to an ambiguous entry\n\t(the same name appeared more than once at the same embedding level).\n\n\t- If indirect is set, a method with a pointer receiver type was found\n     but there was no pointer on the path from the actual receiver type to\n\tthe method's formal receiver base type, nor was the receiver addressable.\n\n```\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#object",
              "documentation": {
                "identifier": "object",
                "newPage": false,
                "searchKey": "types.object",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type object struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype object struct {\n\tparent    *Scope\n\tpos       token.Pos\n\tpkg       *Package\n\tname      string\n\ttyp       Type\n\torder_    uint32\n\tcolor_    color\n\tscopePos_ token.Pos\n}\n```\n\nAn object implements the common parts of an Object. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#object.Parent",
                    "documentation": {
                      "identifier": "object.Parent",
                      "newPage": false,
                      "searchKey": "types.object.Parent",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) Parent() *Scope"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) Parent() *Scope\n```\n\nParent returns the scope in which the object is declared. The result is nil for methods and struct fields. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.Pos",
                    "documentation": {
                      "identifier": "object.Pos",
                      "newPage": false,
                      "searchKey": "types.object.Pos",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) Pos() token.Pos"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) Pos() token.Pos\n```\n\nPos returns the declaration position of the object's identifier. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.Pkg",
                    "documentation": {
                      "identifier": "object.Pkg",
                      "newPage": false,
                      "searchKey": "types.object.Pkg",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) Pkg() *Package"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) Pkg() *Package\n```\n\nPkg returns the package to which the object belongs. The result is nil for labels and objects in the Universe scope. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.Name",
                    "documentation": {
                      "identifier": "object.Name",
                      "newPage": false,
                      "searchKey": "types.object.Name",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) Name() string\n```\n\nName returns the object's (package-local, unqualified) name. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.Type",
                    "documentation": {
                      "identifier": "object.Type",
                      "newPage": false,
                      "searchKey": "types.object.Type",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) Type() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) Type() Type\n```\n\nType returns the object's type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.Exported",
                    "documentation": {
                      "identifier": "object.Exported",
                      "newPage": false,
                      "searchKey": "types.object.Exported",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) Exported() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) Exported() bool\n```\n\nExported reports whether the object is exported (starts with a capital letter). It doesn't take into account whether the object is in a local (function) scope or not. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.Id",
                    "documentation": {
                      "identifier": "object.Id",
                      "newPage": false,
                      "searchKey": "types.object.Id",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) Id() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) Id() string\n```\n\nId is a wrapper for Id(obj.Pkg(), obj.Name()). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.String",
                    "documentation": {
                      "identifier": "object.String",
                      "newPage": false,
                      "searchKey": "types.object.String",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.order",
                    "documentation": {
                      "identifier": "object.order",
                      "newPage": false,
                      "searchKey": "types.object.order",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) order() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) order() uint32\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.color",
                    "documentation": {
                      "identifier": "object.color",
                      "newPage": false,
                      "searchKey": "types.object.color",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) color() color"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) color() color\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.scopePos",
                    "documentation": {
                      "identifier": "object.scopePos",
                      "newPage": false,
                      "searchKey": "types.object.scopePos",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) scopePos() token.Pos"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) scopePos() token.Pos\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.setParent",
                    "documentation": {
                      "identifier": "object.setParent",
                      "newPage": false,
                      "searchKey": "types.object.setParent",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) setParent(parent *Scope)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) setParent(parent *Scope)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.setType",
                    "documentation": {
                      "identifier": "object.setType",
                      "newPage": false,
                      "searchKey": "types.object.setType",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) setType(typ Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) setType(typ Type)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.setOrder",
                    "documentation": {
                      "identifier": "object.setOrder",
                      "newPage": false,
                      "searchKey": "types.object.setOrder",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) setOrder(order uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) setOrder(order uint32)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.setColor",
                    "documentation": {
                      "identifier": "object.setColor",
                      "newPage": false,
                      "searchKey": "types.object.setColor",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) setColor(color color)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) setColor(color color)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.setScopePos",
                    "documentation": {
                      "identifier": "object.setScopePos",
                      "newPage": false,
                      "searchKey": "types.object.setScopePos",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) setScopePos(pos token.Pos)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) setScopePos(pos token.Pos)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#object.sameId",
                    "documentation": {
                      "identifier": "object.sameId",
                      "newPage": false,
                      "searchKey": "types.object.sameId",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *object) sameId(pkg *Package, name string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *object) sameId(pkg *Package, name string) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#color",
              "documentation": {
                "identifier": "color",
                "newPage": false,
                "searchKey": "types.color",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type color uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype color uint32\n```\n\ncolor encodes the color of an object (see Checker.objDecl for details). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#colorFor",
                    "documentation": {
                      "identifier": "colorFor",
                      "newPage": false,
                      "searchKey": "types.colorFor",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func colorFor(t Type) color"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc colorFor(t Type) color\n```\n\ncolorFor returns the (initial) color for an object depending on whether its type t is known or not. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#color.String",
                    "documentation": {
                      "identifier": "color.String",
                      "newPage": false,
                      "searchKey": "types.color.String",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c color) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c color) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#PkgName",
              "documentation": {
                "identifier": "PkgName",
                "newPage": false,
                "searchKey": "types.PkgName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type PkgName struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PkgName struct {\n\tobject\n\timported *Package\n\tused     bool // set if the package was used\n}\n```\n\nA PkgName represents an imported Go package. PkgNames don't have a type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewPkgName",
                    "documentation": {
                      "identifier": "NewPkgName",
                      "newPage": false,
                      "searchKey": "types.NewPkgName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName\n```\n\nNewPkgName returns a new PkgName object representing an imported package. The remaining arguments set the attributes found with all Objects. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#PkgName.Imported",
                    "documentation": {
                      "identifier": "PkgName.Imported",
                      "newPage": false,
                      "searchKey": "types.PkgName.Imported",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *PkgName) Imported() *Package"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *PkgName) Imported() *Package\n```\n\nImported returns the package that was imported. It is distinct from Pkg(), which is the package containing the import statement. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#PkgName.String",
                    "documentation": {
                      "identifier": "PkgName.String",
                      "newPage": false,
                      "searchKey": "types.PkgName.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *PkgName) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *PkgName) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Const",
              "documentation": {
                "identifier": "Const",
                "newPage": false,
                "searchKey": "types.Const",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Const struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Const struct {\n\tobject\n\tval constant.Value\n}\n```\n\nA Const represents a declared constant. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewConst",
                    "documentation": {
                      "identifier": "NewConst",
                      "newPage": false,
                      "searchKey": "types.NewConst",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const\n```\n\nNewConst returns a new constant with value val. The remaining arguments set the attributes found with all Objects. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Const.Val",
                    "documentation": {
                      "identifier": "Const.Val",
                      "newPage": false,
                      "searchKey": "types.Const.Val",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Const) Val() constant.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Const) Val() constant.Value\n```\n\nVal returns the constant's value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Const.isDependency",
                    "documentation": {
                      "identifier": "Const.isDependency",
                      "newPage": false,
                      "searchKey": "types.Const.isDependency",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*Const) isDependency()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*Const) isDependency()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Const.String",
                    "documentation": {
                      "identifier": "Const.String",
                      "newPage": false,
                      "searchKey": "types.Const.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Const) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Const) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#TypeName",
              "documentation": {
                "identifier": "TypeName",
                "newPage": false,
                "searchKey": "types.TypeName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type TypeName struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype TypeName struct {\n\tobject\n}\n```\n\nA TypeName represents a name for a (defined or alias) type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewTypeName",
                    "documentation": {
                      "identifier": "NewTypeName",
                      "newPage": false,
                      "searchKey": "types.NewTypeName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName\n```\n\nNewTypeName returns a new type name denoting the given typ. The remaining arguments set the attributes found with all Objects. \n\nThe typ argument may be a defined (Named) type or an alias type. It may also be nil such that the returned TypeName can be used as argument for NewNamed, which will set the TypeName's type as a side- effect. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#TypeName.IsAlias",
                    "documentation": {
                      "identifier": "TypeName.IsAlias",
                      "newPage": false,
                      "searchKey": "types.TypeName.IsAlias",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *TypeName) IsAlias() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *TypeName) IsAlias() bool\n```\n\nIsAlias reports whether obj is an alias name for a type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#TypeName.String",
                    "documentation": {
                      "identifier": "TypeName.String",
                      "newPage": false,
                      "searchKey": "types.TypeName.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *TypeName) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *TypeName) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Var",
              "documentation": {
                "identifier": "Var",
                "newPage": false,
                "searchKey": "types.Var",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Var struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Var struct {\n\tobject\n\tembedded bool // if set, the variable is an embedded struct field, and name is the type name\n\tisField  bool // var is struct field\n\tused     bool // set if the variable was used\n}\n```\n\nA Variable represents a declared variable (including function parameters and results, and struct fields). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewVar",
                    "documentation": {
                      "identifier": "NewVar",
                      "newPage": false,
                      "searchKey": "types.NewVar",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var\n```\n\nNewVar returns a new variable. The arguments set the attributes found with all Objects. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#NewParam",
                    "documentation": {
                      "identifier": "NewParam",
                      "newPage": false,
                      "searchKey": "types.NewParam",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var\n```\n\nNewParam returns a new variable representing a function parameter. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#NewField",
                    "documentation": {
                      "identifier": "NewField",
                      "newPage": false,
                      "searchKey": "types.NewField",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewField(pos token.Pos, pkg *Package, name string, typ Type, embedded bool) *Var"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewField(pos token.Pos, pkg *Package, name string, typ Type, embedded bool) *Var\n```\n\nNewField returns a new variable representing a struct field. For embedded fields, the name is the unqualified type name / under which the field is accessible. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Var.Anonymous",
                    "documentation": {
                      "identifier": "Var.Anonymous",
                      "newPage": false,
                      "searchKey": "types.Var.Anonymous",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Var) Anonymous() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Var) Anonymous() bool\n```\n\nAnonymous reports whether the variable is an embedded field. Same as Embedded; only present for backward-compatibility. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Var.Embedded",
                    "documentation": {
                      "identifier": "Var.Embedded",
                      "newPage": false,
                      "searchKey": "types.Var.Embedded",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Var) Embedded() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Var) Embedded() bool\n```\n\nEmbedded reports whether the variable is an embedded field. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Var.IsField",
                    "documentation": {
                      "identifier": "Var.IsField",
                      "newPage": false,
                      "searchKey": "types.Var.IsField",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Var) IsField() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Var) IsField() bool\n```\n\nIsField reports whether the variable is a struct field. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Var.isDependency",
                    "documentation": {
                      "identifier": "Var.isDependency",
                      "newPage": false,
                      "searchKey": "types.Var.isDependency",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*Var) isDependency()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*Var) isDependency()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Var.String",
                    "documentation": {
                      "identifier": "Var.String",
                      "newPage": false,
                      "searchKey": "types.Var.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Var) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Var) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Func",
              "documentation": {
                "identifier": "Func",
                "newPage": false,
                "searchKey": "types.Func",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Func struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Func struct {\n\tobject\n\thasPtrRecv bool // only valid for methods that don't have a type yet\n}\n```\n\nA Func represents a declared function, concrete method, or abstract (interface) method. Its Type() is always a *Signature. An abstract method may belong to many interfaces due to embedding. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#MissingMethod",
                    "documentation": {
                      "identifier": "MissingMethod",
                      "newPage": false,
                      "searchKey": "types.MissingMethod",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)\n```\n\nMissingMethod returns (nil, false) if V implements T, otherwise it returns a missing method required by T and whether it is missing or just has the wrong type. \n\nFor non-interface types V, or if static is set, V implements T if all methods of T are present in V. Otherwise (V is an interface and static is not set), MissingMethod only checks that methods of T which are also present in V have matching types (e.g., for a type assertion x.(T) where x is of interface type V). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#lookupMethod",
                    "documentation": {
                      "identifier": "lookupMethod",
                      "newPage": false,
                      "searchKey": "types.lookupMethod",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func lookupMethod(methods []*Func, pkg *Package, name string) (int, *Func)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc lookupMethod(methods []*Func, pkg *Package, name string) (int, *Func)\n```\n\nlookupMethod returns the index of and method with matching package and name, or (-1, nil). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#NewFunc",
                    "documentation": {
                      "identifier": "NewFunc",
                      "newPage": false,
                      "searchKey": "types.NewFunc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func\n```\n\nNewFunc returns a new function with the given signature, representing the function's type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Func.FullName",
                    "documentation": {
                      "identifier": "Func.FullName",
                      "newPage": false,
                      "searchKey": "types.Func.FullName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Func) FullName() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Func) FullName() string\n```\n\nFullName returns the package- or receiver-type-qualified name of function or method obj. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Func.Scope",
                    "documentation": {
                      "identifier": "Func.Scope",
                      "newPage": false,
                      "searchKey": "types.Func.Scope",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Func) Scope() *Scope"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Func) Scope() *Scope\n```\n\nScope returns the scope of the function's body block. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Func.isDependency",
                    "documentation": {
                      "identifier": "Func.isDependency",
                      "newPage": false,
                      "searchKey": "types.Func.isDependency",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*Func) isDependency()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*Func) isDependency()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Func.String",
                    "documentation": {
                      "identifier": "Func.String",
                      "newPage": false,
                      "searchKey": "types.Func.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Func) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Func) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Label",
              "documentation": {
                "identifier": "Label",
                "newPage": false,
                "searchKey": "types.Label",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Label struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Label struct {\n\tobject\n\tused bool // set if the label was used\n}\n```\n\nA Label represents a declared label. Labels don't have a type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewLabel",
                    "documentation": {
                      "identifier": "NewLabel",
                      "newPage": false,
                      "searchKey": "types.NewLabel",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewLabel(pos token.Pos, pkg *Package, name string) *Label"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewLabel(pos token.Pos, pkg *Package, name string) *Label\n```\n\nNewLabel returns a new label. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Label.String",
                    "documentation": {
                      "identifier": "Label.String",
                      "newPage": false,
                      "searchKey": "types.Label.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Label) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Label) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Builtin",
              "documentation": {
                "identifier": "Builtin",
                "newPage": false,
                "searchKey": "types.Builtin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Builtin struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Builtin struct {\n\tobject\n\tid builtinId\n}\n```\n\nA Builtin represents a built-in function. Builtins don't have a valid type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#newBuiltin",
                    "documentation": {
                      "identifier": "newBuiltin",
                      "newPage": false,
                      "searchKey": "types.newBuiltin",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newBuiltin(id builtinId) *Builtin"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newBuiltin(id builtinId) *Builtin\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Builtin.String",
                    "documentation": {
                      "identifier": "Builtin.String",
                      "newPage": false,
                      "searchKey": "types.Builtin.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Builtin) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Builtin) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Nil",
              "documentation": {
                "identifier": "Nil",
                "newPage": false,
                "searchKey": "types.Nil",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Nil struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Nil struct {\n\tobject\n}\n```\n\nNil represents the predeclared value nil. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#Nil.String",
                    "documentation": {
                      "identifier": "Nil.String",
                      "newPage": false,
                      "searchKey": "types.Nil.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *Nil) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *Nil) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#objset",
              "documentation": {
                "identifier": "objset",
                "newPage": false,
                "searchKey": "types.objset",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type objset map[string]types.Object"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype objset map[string]Object // initialized lazily\n\n```\n\nAn objset is a set of objects identified by their unique id. The zero value for objset is a ready-to-use empty objset. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#objset.insert",
                    "documentation": {
                      "identifier": "objset.insert",
                      "newPage": false,
                      "searchKey": "types.objset.insert",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *objset) insert(obj Object) Object"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *objset) insert(obj Object) Object\n```\n\ninsert attempts to insert an object obj into objset s. If s already contains an alternative object alt with the same name, insert leaves s unchanged and returns alt. Otherwise it inserts obj and returns nil. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#operandMode",
              "documentation": {
                "identifier": "operandMode",
                "newPage": false,
                "searchKey": "types.operandMode",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type operandMode byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype operandMode byte\n```\n\nAn operandMode specifies the (addressing) mode of an operand. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#operand",
              "documentation": {
                "identifier": "operand",
                "newPage": false,
                "searchKey": "types.operand",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type operand struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype operand struct {\n\tmode operandMode\n\texpr ast.Expr\n\ttyp  Type\n\tval  constant.Value\n\tid   builtinId\n}\n```\n\nAn operand represents an intermediate value during type checking. Operands have an (addressing) mode, the expression evaluating to the operand, the operand's type, a value for constants, and an id for built-in functions. The zero value of operand is a ready to use invalid operand. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#operand.convertibleTo",
                    "documentation": {
                      "identifier": "operand.convertibleTo",
                      "newPage": false,
                      "searchKey": "types.operand.convertibleTo",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *operand) convertibleTo(check *Checker, T Type, reason *string) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *operand) convertibleTo(check *Checker, T Type, reason *string) bool\n```\n\nconvertibleTo reports whether T(x) is valid. The check parameter may be nil if convertibleTo is invoked through an exported API call, i.e., when all methods have been type-checked. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#operand.Pos",
                    "documentation": {
                      "identifier": "operand.Pos",
                      "newPage": false,
                      "searchKey": "types.operand.Pos",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *operand) Pos() token.Pos"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *operand) Pos() token.Pos\n```\n\nPos returns the position of the expression corresponding to x. If x is invalid the position is token.NoPos. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#operand.String",
                    "documentation": {
                      "identifier": "operand.String",
                      "newPage": false,
                      "searchKey": "types.operand.String",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *operand) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *operand) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#operand.setConst",
                    "documentation": {
                      "identifier": "operand.setConst",
                      "newPage": false,
                      "searchKey": "types.operand.setConst",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *operand) setConst(tok token.Token, lit string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *operand) setConst(tok token.Token, lit string)\n```\n\nsetConst sets x to the untyped constant for literal lit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#operand.isNil",
                    "documentation": {
                      "identifier": "operand.isNil",
                      "newPage": false,
                      "searchKey": "types.operand.isNil",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *operand) isNil() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *operand) isNil() bool\n```\n\nisNil reports whether x is the nil value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#operand.assignableTo",
                    "documentation": {
                      "identifier": "operand.assignableTo",
                      "newPage": false,
                      "searchKey": "types.operand.assignableTo",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *operand) assignableTo(check *Checker, T Type, reason *string) (bool, errorCode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *operand) assignableTo(check *Checker, T Type, reason *string) (bool, errorCode)\n```\n\nassignableTo reports whether x is assignable to a variable of type T. If the result is false and a non-nil reason is provided, it may be set to a more detailed explanation of the failure (result != \"\"). The returned error code is only valid if the (first) result is false. The check parameter may be nil if assignableTo is invoked through an exported API call, i.e., when all methods have been type-checked. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Package",
              "documentation": {
                "identifier": "Package",
                "newPage": false,
                "searchKey": "types.Package",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Package struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Package struct {\n\tpath     string\n\tname     string\n\tscope    *Scope\n\tcomplete bool\n\timports  []*Package\n\tfake     bool // scope lookup errors are silently dropped if package is fake (internal use only)\n\tcgo      bool // uses of this package will be rewritten into uses of declarations from _cgo_gotypes.go\n}\n```\n\nA Package describes a Go package. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewPackage",
                    "documentation": {
                      "identifier": "NewPackage",
                      "newPage": false,
                      "searchKey": "types.NewPackage",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewPackage(path, name string) *Package"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewPackage(path, name string) *Package\n```\n\nNewPackage returns a new Package for the given package path and name. The package is not complete and contains no explicit imports. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Package.Path",
                    "documentation": {
                      "identifier": "Package.Path",
                      "newPage": false,
                      "searchKey": "types.Package.Path",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pkg *Package) Path() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pkg *Package) Path() string\n```\n\nPath returns the package path. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Package.Name",
                    "documentation": {
                      "identifier": "Package.Name",
                      "newPage": false,
                      "searchKey": "types.Package.Name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pkg *Package) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pkg *Package) Name() string\n```\n\nName returns the package name. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Package.SetName",
                    "documentation": {
                      "identifier": "Package.SetName",
                      "newPage": false,
                      "searchKey": "types.Package.SetName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pkg *Package) SetName(name string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pkg *Package) SetName(name string)\n```\n\nSetName sets the package name. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Package.Scope",
                    "documentation": {
                      "identifier": "Package.Scope",
                      "newPage": false,
                      "searchKey": "types.Package.Scope",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pkg *Package) Scope() *Scope"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pkg *Package) Scope() *Scope\n```\n\nScope returns the (complete or incomplete) package scope holding the objects declared at package level (TypeNames, Consts, Vars, and Funcs). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Package.Complete",
                    "documentation": {
                      "identifier": "Package.Complete",
                      "newPage": false,
                      "searchKey": "types.Package.Complete",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pkg *Package) Complete() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pkg *Package) Complete() bool\n```\n\nA package is complete if its scope contains (at least) all exported objects; otherwise it is incomplete. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Package.MarkComplete",
                    "documentation": {
                      "identifier": "Package.MarkComplete",
                      "newPage": false,
                      "searchKey": "types.Package.MarkComplete",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pkg *Package) MarkComplete()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pkg *Package) MarkComplete()\n```\n\nMarkComplete marks a package as complete. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Package.Imports",
                    "documentation": {
                      "identifier": "Package.Imports",
                      "newPage": false,
                      "searchKey": "types.Package.Imports",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pkg *Package) Imports() []*Package"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pkg *Package) Imports() []*Package\n```\n\nImports returns the list of packages directly imported by pkg; the list is in source order. \n\nIf pkg was loaded from export data, Imports includes packages that provide package-level objects referenced by pkg. This may be more or less than the set of packages directly imported by pkg's source code. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Package.SetImports",
                    "documentation": {
                      "identifier": "Package.SetImports",
                      "newPage": false,
                      "searchKey": "types.Package.SetImports",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pkg *Package) SetImports(list []*Package)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pkg *Package) SetImports(list []*Package)\n```\n\nSetImports sets the list of explicitly imported packages to list. It is the caller's responsibility to make sure list elements are unique. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Package.String",
                    "documentation": {
                      "identifier": "Package.String",
                      "newPage": false,
                      "searchKey": "types.Package.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pkg *Package) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pkg *Package) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#ifacePair",
              "documentation": {
                "identifier": "ifacePair",
                "newPage": false,
                "searchKey": "types.ifacePair",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ifacePair struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ifacePair struct {\n\tx, y *Interface\n\tprev *ifacePair\n}\n```\n\nAn ifacePair is a node in a stack of interface type pairs compared for identity. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#ifacePair.identical",
                    "documentation": {
                      "identifier": "ifacePair.identical",
                      "newPage": false,
                      "searchKey": "types.ifacePair.identical",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ifacePair) identical(q *ifacePair) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ifacePair) identical(q *ifacePair) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#declInfo",
              "documentation": {
                "identifier": "declInfo",
                "newPage": false,
                "searchKey": "types.declInfo",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type declInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype declInfo struct {\n\tfile      *Scope        // scope of file containing this declaration\n\tlhs       []*Var        // lhs of n:1 variable declarations, or nil\n\tvtyp      ast.Expr      // type, or nil (for const and var declarations only)\n\tinit      ast.Expr      // init/orig expression, or nil (for const and var declarations only)\n\tinherited bool          // if set, the init expression is inherited from a previous constant declaration\n\ttdecl     *ast.TypeSpec // type declaration, or nil\n\tfdecl     *ast.FuncDecl // func declaration, or nil\n\n\t// The deps field tracks initialization expression dependencies.\n\tdeps map[Object]bool // lazily initialized\n}\n```\n\nA declInfo describes a package-level const, type, var, or func declaration. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#declInfo.hasInitializer",
                    "documentation": {
                      "identifier": "declInfo.hasInitializer",
                      "newPage": false,
                      "searchKey": "types.declInfo.hasInitializer",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *declInfo) hasInitializer() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *declInfo) hasInitializer() bool\n```\n\nhasInitializer reports whether the declared object has an initialization expression or function body. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#declInfo.addDep",
                    "documentation": {
                      "identifier": "declInfo.addDep",
                      "newPage": false,
                      "searchKey": "types.declInfo.addDep",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *declInfo) addDep(obj Object)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *declInfo) addDep(obj Object)\n```\n\naddDep adds obj to the set of objects d's init expression depends on. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#inSourceOrder",
              "documentation": {
                "identifier": "inSourceOrder",
                "newPage": false,
                "searchKey": "types.inSourceOrder",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type inSourceOrder []types.Object"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype inSourceOrder []Object\n```\n\ninSourceOrder implements the sort.Sort interface. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#inSourceOrder.Len",
                    "documentation": {
                      "identifier": "inSourceOrder.Len",
                      "newPage": false,
                      "searchKey": "types.inSourceOrder.Len",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a inSourceOrder) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a inSourceOrder) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#inSourceOrder.Less",
                    "documentation": {
                      "identifier": "inSourceOrder.Less",
                      "newPage": false,
                      "searchKey": "types.inSourceOrder.Less",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a inSourceOrder) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a inSourceOrder) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#inSourceOrder.Swap",
                    "documentation": {
                      "identifier": "inSourceOrder.Swap",
                      "newPage": false,
                      "searchKey": "types.inSourceOrder.Swap",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a inSourceOrder) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a inSourceOrder) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#sanitizer",
              "documentation": {
                "identifier": "sanitizer",
                "newPage": false,
                "searchKey": "types.sanitizer",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type sanitizer map[types.Type]types.Type"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sanitizer map[Type]Type\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#sanitizer.typ",
                    "documentation": {
                      "identifier": "sanitizer.typ",
                      "newPage": false,
                      "searchKey": "types.sanitizer.typ",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sanitizer) typ(typ Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sanitizer) typ(typ Type) Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#sanitizer.var_",
                    "documentation": {
                      "identifier": "sanitizer.var_",
                      "newPage": false,
                      "searchKey": "types.sanitizer.var_",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sanitizer) var_(v *Var)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sanitizer) var_(v *Var)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#sanitizer.varList",
                    "documentation": {
                      "identifier": "sanitizer.varList",
                      "newPage": false,
                      "searchKey": "types.sanitizer.varList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sanitizer) varList(list []*Var)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sanitizer) varList(list []*Var)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#sanitizer.tuple",
                    "documentation": {
                      "identifier": "sanitizer.tuple",
                      "newPage": false,
                      "searchKey": "types.sanitizer.tuple",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sanitizer) tuple(t *Tuple)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sanitizer) tuple(t *Tuple)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#sanitizer.func_",
                    "documentation": {
                      "identifier": "sanitizer.func_",
                      "newPage": false,
                      "searchKey": "types.sanitizer.func_",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sanitizer) func_(f *Func)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sanitizer) func_(f *Func)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#sanitizer.funcList",
                    "documentation": {
                      "identifier": "sanitizer.funcList",
                      "newPage": false,
                      "searchKey": "types.sanitizer.funcList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sanitizer) funcList(list []*Func)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sanitizer) funcList(list []*Func)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#sanitizer.typeList",
                    "documentation": {
                      "identifier": "sanitizer.typeList",
                      "newPage": false,
                      "searchKey": "types.sanitizer.typeList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sanitizer) typeList(list []Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sanitizer) typeList(list []Type)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Scope",
              "documentation": {
                "identifier": "Scope",
                "newPage": false,
                "searchKey": "types.Scope",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Scope struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Scope struct {\n\tparent   *Scope\n\tchildren []*Scope\n\telems    map[string]Object // lazily allocated\n\tpos, end token.Pos         // scope extent; may be invalid\n\tcomment  string            // for debugging only\n\tisFunc   bool              // set if this is a function scope (internal use only)\n}\n```\n\nA Scope maintains a set of objects and links to its containing (parent) and contained (children) scopes. Objects may be inserted and looked up by name. The zero value for Scope is a ready-to-use empty scope. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewScope",
                    "documentation": {
                      "identifier": "NewScope",
                      "newPage": false,
                      "searchKey": "types.NewScope",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope\n```\n\nNewScope returns a new, empty scope contained in the given parent scope, if any. The comment is for debugging only. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.Parent",
                    "documentation": {
                      "identifier": "Scope.Parent",
                      "newPage": false,
                      "searchKey": "types.Scope.Parent",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) Parent() *Scope"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) Parent() *Scope\n```\n\nParent returns the scope's containing (parent) scope. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.Len",
                    "documentation": {
                      "identifier": "Scope.Len",
                      "newPage": false,
                      "searchKey": "types.Scope.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) Len() int\n```\n\nLen returns the number of scope elements. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.Names",
                    "documentation": {
                      "identifier": "Scope.Names",
                      "newPage": false,
                      "searchKey": "types.Scope.Names",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) Names() []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) Names() []string\n```\n\nNames returns the scope's element names in sorted order. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.NumChildren",
                    "documentation": {
                      "identifier": "Scope.NumChildren",
                      "newPage": false,
                      "searchKey": "types.Scope.NumChildren",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) NumChildren() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) NumChildren() int\n```\n\nNumChildren returns the number of scopes nested in s. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.Child",
                    "documentation": {
                      "identifier": "Scope.Child",
                      "newPage": false,
                      "searchKey": "types.Scope.Child",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) Child(i int) *Scope"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) Child(i int) *Scope\n```\n\nChild returns the i'th child scope for 0 <= i < NumChildren(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.Lookup",
                    "documentation": {
                      "identifier": "Scope.Lookup",
                      "newPage": false,
                      "searchKey": "types.Scope.Lookup",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) Lookup(name string) Object"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) Lookup(name string) Object\n```\n\nLookup returns the object in scope s with the given name if such an object exists; otherwise the result is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.LookupParent",
                    "documentation": {
                      "identifier": "Scope.LookupParent",
                      "newPage": false,
                      "searchKey": "types.Scope.LookupParent",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) LookupParent(name string, pos token.Pos) (*Scope, Object)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) LookupParent(name string, pos token.Pos) (*Scope, Object)\n```\n\nLookupParent follows the parent chain of scopes starting with s until it finds a scope where Lookup(name) returns a non-nil object, and then returns that scope and object. If a valid position pos is provided, only objects that were declared at or before pos are considered. If no such scope and object exists, the result is (nil, nil). \n\nNote that obj.Parent() may be different from the returned scope if the object was inserted into the scope and already had a parent at that time (see Insert). This can only happen for dot-imported objects whose scope is the scope of the package that exported them. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.Insert",
                    "documentation": {
                      "identifier": "Scope.Insert",
                      "newPage": false,
                      "searchKey": "types.Scope.Insert",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) Insert(obj Object) Object"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) Insert(obj Object) Object\n```\n\nInsert attempts to insert an object obj into scope s. If s already contains an alternative object alt with the same name, Insert leaves s unchanged and returns alt. Otherwise it inserts obj, sets the object's parent scope if not already set, and returns nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.squash",
                    "documentation": {
                      "identifier": "Scope.squash",
                      "newPage": false,
                      "searchKey": "types.Scope.squash",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) squash(err func(obj, alt Object))"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) squash(err func(obj, alt Object))\n```\n\nsquash merges s with its parent scope p by adding all objects of s to p, adding all children of s to the children of p, and removing s from p's children. The function f is called for each object obj in s which has an object alt in p. s should be discarded after having been squashed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.Pos",
                    "documentation": {
                      "identifier": "Scope.Pos",
                      "newPage": false,
                      "searchKey": "types.Scope.Pos",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) Pos() token.Pos"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) Pos() token.Pos\n```\n\nPos and End describe the scope's source code extent [pos, end). The results are guaranteed to be valid only if the type-checked AST has complete position information. The extent is undefined for Universe and package scopes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.End",
                    "documentation": {
                      "identifier": "Scope.End",
                      "newPage": false,
                      "searchKey": "types.Scope.End",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) End() token.Pos"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) End() token.Pos\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.Contains",
                    "documentation": {
                      "identifier": "Scope.Contains",
                      "newPage": false,
                      "searchKey": "types.Scope.Contains",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) Contains(pos token.Pos) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) Contains(pos token.Pos) bool\n```\n\nContains reports whether pos is within the scope's extent. The result is guaranteed to be valid only if the type-checked AST has complete position information. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.Innermost",
                    "documentation": {
                      "identifier": "Scope.Innermost",
                      "newPage": false,
                      "searchKey": "types.Scope.Innermost",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) Innermost(pos token.Pos) *Scope"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) Innermost(pos token.Pos) *Scope\n```\n\nInnermost returns the innermost (child) scope containing pos. If pos is not within any scope, the result is nil. The result is also nil for the Universe scope. The result is guaranteed to be valid only if the type-checked AST has complete position information. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.WriteTo",
                    "documentation": {
                      "identifier": "Scope.WriteTo",
                      "newPage": false,
                      "searchKey": "types.Scope.WriteTo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) WriteTo(w io.Writer, n int, recurse bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) WriteTo(w io.Writer, n int, recurse bool)\n```\n\nWriteTo writes a string representation of the scope to w, with the scope elements sorted by name. The level of indentation is controlled by n >= 0, with n == 0 for no indentation. If recurse is set, it also writes nested (children) scopes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Scope.String",
                    "documentation": {
                      "identifier": "Scope.String",
                      "newPage": false,
                      "searchKey": "types.Scope.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Scope) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Scope) String() string\n```\n\nString returns a string representation of the scope, for debugging. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#SelectionKind",
              "documentation": {
                "identifier": "SelectionKind",
                "newPage": false,
                "searchKey": "types.SelectionKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type SelectionKind int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype SelectionKind int\n```\n\nSelectionKind describes the kind of a selector expression x.f (excluding qualified identifiers). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Selection",
              "documentation": {
                "identifier": "Selection",
                "newPage": false,
                "searchKey": "types.Selection",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Selection struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Selection struct {\n\tkind     SelectionKind\n\trecv     Type   // type of x\n\tobj      Object // object denoted by x.f\n\tindex    []int  // path from x to x.f\n\tindirect bool   // set if there was any pointer indirection on the path\n}\n```\n\nA Selection describes a selector expression x.f. For the declarations: \n\n```\ntype T struct{ x int; E }\ntype E struct{}\nfunc (e E) m() {}\nvar p *T\n\n```\nthe following relations exist: \n\n```\nSelector    Kind          Recv    Obj    Type       Index     Indirect\n\np.x         FieldVal      T       x      int        {0}       true\np.m         MethodVal     *T      m      func()     {1, 0}    true\nT.m         MethodExpr    T       m      func(T)    {1, 0}    false\n\n```\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#Selection.Kind",
                    "documentation": {
                      "identifier": "Selection.Kind",
                      "newPage": false,
                      "searchKey": "types.Selection.Kind",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Selection) Kind() SelectionKind"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Selection) Kind() SelectionKind\n```\n\nKind returns the selection kind. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Selection.Recv",
                    "documentation": {
                      "identifier": "Selection.Recv",
                      "newPage": false,
                      "searchKey": "types.Selection.Recv",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Selection) Recv() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Selection) Recv() Type\n```\n\nRecv returns the type of x in x.f. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Selection.Obj",
                    "documentation": {
                      "identifier": "Selection.Obj",
                      "newPage": false,
                      "searchKey": "types.Selection.Obj",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Selection) Obj() Object"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Selection) Obj() Object\n```\n\nObj returns the object denoted by x.f; a *Var for a field selection, and a *Func in all other cases. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Selection.Type",
                    "documentation": {
                      "identifier": "Selection.Type",
                      "newPage": false,
                      "searchKey": "types.Selection.Type",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Selection) Type() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Selection) Type() Type\n```\n\nType returns the type of x.f, which may be different from the type of f. See Selection for more information. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Selection.Index",
                    "documentation": {
                      "identifier": "Selection.Index",
                      "newPage": false,
                      "searchKey": "types.Selection.Index",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Selection) Index() []int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Selection) Index() []int\n```\n\nIndex describes the path from x to f in x.f. The last index entry is the field or method index of the type declaring f; either: \n\n```\n1) the list of declared methods of a named type; or\n2) the list of methods of an interface type; or\n3) the list of fields of a struct type.\n\n```\nThe earlier index entries are the indices of the embedded fields implicitly traversed to get from (the type of) x to f, starting at embedding depth 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Selection.Indirect",
                    "documentation": {
                      "identifier": "Selection.Indirect",
                      "newPage": false,
                      "searchKey": "types.Selection.Indirect",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Selection) Indirect() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Selection) Indirect() bool\n```\n\nIndirect reports whether any pointer indirection was required to get from x to f in x.f. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Selection.String",
                    "documentation": {
                      "identifier": "Selection.String",
                      "newPage": false,
                      "searchKey": "types.Selection.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Selection) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Selection) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Sizes",
              "documentation": {
                "identifier": "Sizes",
                "newPage": false,
                "searchKey": "types.Sizes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Sizes interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Sizes interface {\n\t// Alignof returns the alignment of a variable of type T.\n\t// Alignof must implement the alignment guarantees required by the spec.\n\tAlignof(T Type) int64\n\n\t// Offsetsof returns the offsets of the given struct fields, in bytes.\n\t// Offsetsof must implement the offset guarantees required by the spec.\n\tOffsetsof(fields []*Var) []int64\n\n\t// Sizeof returns the size of a variable of type T.\n\t// Sizeof must implement the size guarantees required by the spec.\n\tSizeof(T Type) int64\n}\n```\n\nSizes defines the sizing functions for package unsafe. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#SizesFor",
                    "documentation": {
                      "identifier": "SizesFor",
                      "newPage": false,
                      "searchKey": "types.SizesFor",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func SizesFor(compiler, arch string) Sizes"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc SizesFor(compiler, arch string) Sizes\n```\n\nSizesFor returns the Sizes used by a compiler for an architecture. The result is nil if a compiler/architecture pair is not known. \n\nSupported architectures for compiler \"gc\": \"386\", \"arm\", \"arm64\", \"amd64\", \"amd64p32\", \"mips\", \"mipsle\", \"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"sparc64\", \"wasm\". \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#StdSizes",
              "documentation": {
                "identifier": "StdSizes",
                "newPage": false,
                "searchKey": "types.StdSizes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type StdSizes struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype StdSizes struct {\n\tWordSize int64 // word size in bytes - must be >= 4 (32bits)\n\tMaxAlign int64 // maximum alignment in bytes - must be >= 1\n}\n```\n\nStdSizes is a convenience type for creating commonly used Sizes. It makes the following simplifying assumptions: \n\n```\n\t- The size of explicitly sized basic types (int16, etc.) is the\n\t  specified size.\n\t- The size of strings and interfaces is 2*WordSize.\n\t- The size of slices is 3*WordSize.\n\t- The size of an array of n elements corresponds to the size of\n\t  a struct of n consecutive fields of the array's element type.\n     - The size of a struct is the offset of the last field plus that\n\t  field's size. As with all element types, if the struct is used\n\t  in an array its size must first be aligned to a multiple of the\n\t  struct's alignment.\n\t- All other types have size WordSize.\n\t- Arrays and structs are aligned per spec definition; all other\n\t  types are naturally aligned with a maximum alignment MaxAlign.\n\n```\n*StdSizes implements Sizes. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#StdSizes.Alignof",
                    "documentation": {
                      "identifier": "StdSizes.Alignof",
                      "newPage": false,
                      "searchKey": "types.StdSizes.Alignof",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *StdSizes) Alignof(T Type) int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *StdSizes) Alignof(T Type) int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#StdSizes.Offsetsof",
                    "documentation": {
                      "identifier": "StdSizes.Offsetsof",
                      "newPage": false,
                      "searchKey": "types.StdSizes.Offsetsof",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *StdSizes) Offsetsof(fields []*Var) []int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *StdSizes) Offsetsof(fields []*Var) []int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#StdSizes.Sizeof",
                    "documentation": {
                      "identifier": "StdSizes.Sizeof",
                      "newPage": false,
                      "searchKey": "types.StdSizes.Sizeof",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *StdSizes) Sizeof(T Type) int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *StdSizes) Sizeof(T Type) int64\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#stmtContext",
              "documentation": {
                "identifier": "stmtContext",
                "newPage": false,
                "searchKey": "types.stmtContext",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type stmtContext uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stmtContext uint\n```\n\nstmtContext is a bitset describing which control-flow statements are permissible, and provides additional context information for better error messages. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#valueMap",
              "documentation": {
                "identifier": "valueMap",
                "newPage": false,
                "searchKey": "types.valueMap",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type valueMap map[interface{}][]types.valueType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype valueMap map[interface{}][]valueType // underlying Go value -> valueType\n\n```\n\nA valueMap maps a case value (of a basic Go type) to a list of positions where the same case value appeared, together with the corresponding case types. Since two case values may have the same \"underlying\" value but different types we need to also check the value's types (e.g., byte(1) vs myByte(1)) when the switch expression is of interface type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#valueType",
              "documentation": {
                "identifier": "valueType",
                "newPage": false,
                "searchKey": "types.valueType",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type valueType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype valueType struct {\n\tpos token.Pos\n\ttyp Type\n}\n```\n\nA valueMap maps a case value (of a basic Go type) to a list of positions where the same case value appeared, together with the corresponding case types. Since two case values may have the same \"underlying\" value but different types we need to also check the value's types (e.g., byte(1) vs myByte(1)) when the switch expression is of interface type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#substMap",
              "documentation": {
                "identifier": "substMap",
                "newPage": false,
                "searchKey": "types.substMap",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type substMap struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype substMap struct {\n\t// The targs field is currently needed for *Named type substitution.\n\t// TODO(gri) rewrite that code, get rid of this field, and make this\n\t//           struct just the map (proj)\n\ttargs []Type\n\tproj  map[*_TypeParam]Type\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#makeSubstMap",
                    "documentation": {
                      "identifier": "makeSubstMap",
                      "newPage": false,
                      "searchKey": "types.makeSubstMap",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeSubstMap(tpars []*TypeName, targs []Type) *substMap"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeSubstMap(tpars []*TypeName, targs []Type) *substMap\n```\n\nmakeSubstMap creates a new substitution map mapping tpars[i] to targs[i]. If targs[i] is nil, tpars[i] is not substituted. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#substMap.String",
                    "documentation": {
                      "identifier": "substMap.String",
                      "newPage": false,
                      "searchKey": "types.substMap.String",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *substMap) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *substMap) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#substMap.empty",
                    "documentation": {
                      "identifier": "substMap.empty",
                      "newPage": false,
                      "searchKey": "types.substMap.empty",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *substMap) empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *substMap) empty() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#substMap.lookup",
                    "documentation": {
                      "identifier": "substMap.lookup",
                      "newPage": false,
                      "searchKey": "types.substMap.lookup",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *substMap) lookup(tpar *_TypeParam) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *substMap) lookup(tpar *_TypeParam) Type\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#subster",
              "documentation": {
                "identifier": "subster",
                "newPage": false,
                "searchKey": "types.subster",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type subster struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype subster struct {\n\tcheck *Checker\n\tpos   token.Pos\n\tcache map[Type]Type\n\tsmap  *substMap\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#subster.typ",
                    "documentation": {
                      "identifier": "subster.typ",
                      "newPage": false,
                      "searchKey": "types.subster.typ",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (subst *subster) typ(typ Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (subst *subster) typ(typ Type) Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#subster.typOrNil",
                    "documentation": {
                      "identifier": "subster.typOrNil",
                      "newPage": false,
                      "searchKey": "types.subster.typOrNil",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (subst *subster) typOrNil(typ Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (subst *subster) typOrNil(typ Type) Type\n```\n\ntypOrNil is like typ but if the argument is nil it is replaced with Typ[Invalid]. A nil type may appear in pathological cases such as type T[P any] []func(_ T([]_)) where an array/slice element is accessed before it is set up. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#subster.var_",
                    "documentation": {
                      "identifier": "subster.var_",
                      "newPage": false,
                      "searchKey": "types.subster.var_",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (subst *subster) var_(v *Var) *Var"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (subst *subster) var_(v *Var) *Var\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#subster.tuple",
                    "documentation": {
                      "identifier": "subster.tuple",
                      "newPage": false,
                      "searchKey": "types.subster.tuple",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (subst *subster) tuple(t *Tuple) *Tuple"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (subst *subster) tuple(t *Tuple) *Tuple\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#subster.varList",
                    "documentation": {
                      "identifier": "subster.varList",
                      "newPage": false,
                      "searchKey": "types.subster.varList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (subst *subster) varList(in []*Var) (out []*Var, copied bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (subst *subster) varList(in []*Var) (out []*Var, copied bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#subster.func_",
                    "documentation": {
                      "identifier": "subster.func_",
                      "newPage": false,
                      "searchKey": "types.subster.func_",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (subst *subster) func_(f *Func) *Func"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (subst *subster) func_(f *Func) *Func\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#subster.funcList",
                    "documentation": {
                      "identifier": "subster.funcList",
                      "newPage": false,
                      "searchKey": "types.subster.funcList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (subst *subster) funcList(in []*Func) (out []*Func, copied bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (subst *subster) funcList(in []*Func) (out []*Func, copied bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#subster.typeList",
                    "documentation": {
                      "identifier": "subster.typeList",
                      "newPage": false,
                      "searchKey": "types.subster.typeList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (subst *subster) typeList(in []Type) (out []Type, copied bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (subst *subster) typeList(in []Type) (out []Type, copied bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Type",
              "documentation": {
                "identifier": "Type",
                "newPage": false,
                "searchKey": "types.Type",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Type interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Type interface {\n\t// Underlying returns the underlying type of a type\n\t// w/o following forwarding chains. Only used by\n\t// client packages (here for backward-compatibility).\n\tUnderlying() Type\n\n\t// String returns a string representation of a type.\n\tString() string\n}\n```\n\nA Type represents a type of Go. All types implement the Type interface. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#implicitArrayDeref",
                    "documentation": {
                      "identifier": "implicitArrayDeref",
                      "newPage": false,
                      "searchKey": "types.implicitArrayDeref",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func implicitArrayDeref(typ Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc implicitArrayDeref(typ Type) Type\n```\n\nimplicitArrayDeref returns A if typ is of the form *A and A is an array; otherwise it returns typ. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#deref",
                    "documentation": {
                      "identifier": "deref",
                      "newPage": false,
                      "searchKey": "types.deref",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func deref(typ Type) (Type, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc deref(typ Type) (Type, bool)\n```\n\nderef dereferences typ if it is a *Pointer and returns its base and true. Otherwise it returns (typ, false). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#derefStructPtr",
                    "documentation": {
                      "identifier": "derefStructPtr",
                      "newPage": false,
                      "searchKey": "types.derefStructPtr",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func derefStructPtr(typ Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc derefStructPtr(typ Type) Type\n```\n\nderefStructPtr dereferences typ if it is a (named or unnamed) pointer to a (named or unnamed) struct and returns its base. Otherwise it returns typ. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Default",
                    "documentation": {
                      "identifier": "Default",
                      "newPage": false,
                      "searchKey": "types.Default",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Default(typ Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Default(typ Type) Type\n```\n\nDefault returns the default \"typed\" type for an \"untyped\" type; it returns the incoming type for all other types. The default type for untyped nil is untyped nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#_NewSum",
                    "documentation": {
                      "identifier": "_NewSum",
                      "newPage": false,
                      "searchKey": "types._NewSum",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func _NewSum(types []Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc _NewSum(types []Type) Type\n```\n\n_NewSum returns a new Sum type consisting of the provided types if there are more than one. If there is exactly one type, it returns that type. If the list of types is empty the result is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#optype",
                    "documentation": {
                      "identifier": "optype",
                      "newPage": false,
                      "searchKey": "types.optype",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func optype(typ Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc optype(typ Type) Type\n```\n\noptype returns a type's operational type. Except for type parameters, the operational type is the same as the underlying type (as returned by under). For Type parameters, the operational type is determined by the corresponding type bound's type list. The result may be the bottom or top type, but it is never the incoming type parameter. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#expand",
                    "documentation": {
                      "identifier": "expand",
                      "newPage": false,
                      "searchKey": "types.expand",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func expand(typ Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc expand(typ Type) Type\n```\n\nexpand expands a type instance into its instantiated type and leaves all other types alone. expand does not recurse. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#under",
                    "documentation": {
                      "identifier": "under",
                      "newPage": false,
                      "searchKey": "types.under",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func under(t Type) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc under(t Type) Type\n```\n\nunder returns the true expanded underlying type. If it doesn't exist, the result is Typ[Invalid]. under must only be called when a type is known to be fully set up. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#intersect",
                    "documentation": {
                      "identifier": "intersect",
                      "newPage": false,
                      "searchKey": "types.intersect",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func intersect(x, y Type) (r Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc intersect(x, y Type) (r Type)\n```\n\nintersect computes the intersection of the types x and y. Note: A incomming nil type stands for the top type. A top type result is returned as nil. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#BasicKind",
              "documentation": {
                "identifier": "BasicKind",
                "newPage": false,
                "searchKey": "types.BasicKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type BasicKind int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype BasicKind int\n```\n\nBasicKind describes the kind of basic type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#BasicInfo",
              "documentation": {
                "identifier": "BasicInfo",
                "newPage": false,
                "searchKey": "types.BasicInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type BasicInfo int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype BasicInfo int\n```\n\nBasicInfo is a set of flags describing properties of a basic type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Basic",
              "documentation": {
                "identifier": "Basic",
                "newPage": false,
                "searchKey": "types.Basic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Basic struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Basic struct {\n\tkind BasicKind\n\tinfo BasicInfo\n\tname string\n}\n```\n\nA Basic represents a basic type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#asBasic",
                    "documentation": {
                      "identifier": "asBasic",
                      "newPage": false,
                      "searchKey": "types.asBasic",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asBasic(t Type) *Basic"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asBasic(t Type) *Basic\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Basic.Kind",
                    "documentation": {
                      "identifier": "Basic.Kind",
                      "newPage": false,
                      "searchKey": "types.Basic.Kind",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Basic) Kind() BasicKind"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Basic) Kind() BasicKind\n```\n\nKind returns the kind of basic type b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Basic.Info",
                    "documentation": {
                      "identifier": "Basic.Info",
                      "newPage": false,
                      "searchKey": "types.Basic.Info",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Basic) Info() BasicInfo"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Basic) Info() BasicInfo\n```\n\nInfo returns information about properties of basic type b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Basic.Name",
                    "documentation": {
                      "identifier": "Basic.Name",
                      "newPage": false,
                      "searchKey": "types.Basic.Name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *Basic) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *Basic) Name() string\n```\n\nName returns the name of basic type b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Basic.Underlying",
                    "documentation": {
                      "identifier": "Basic.Underlying",
                      "newPage": false,
                      "searchKey": "types.Basic.Underlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Basic) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Basic) Underlying() Type\n```\n\nType-specific implementations of Underlying. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Basic.String",
                    "documentation": {
                      "identifier": "Basic.String",
                      "newPage": false,
                      "searchKey": "types.Basic.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Basic) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Basic) String() string\n```\n\nType-specific implementations of String. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Array",
              "documentation": {
                "identifier": "Array",
                "newPage": false,
                "searchKey": "types.Array",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Array struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Array struct {\n\tlen  int64\n\telem Type\n}\n```\n\nAn Array represents an array type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewArray",
                    "documentation": {
                      "identifier": "NewArray",
                      "newPage": false,
                      "searchKey": "types.NewArray",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewArray(elem Type, len int64) *Array"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewArray(elem Type, len int64) *Array\n```\n\nNewArray returns a new array type for the given element type and length. A negative length indicates an unknown length. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#asArray",
                    "documentation": {
                      "identifier": "asArray",
                      "newPage": false,
                      "searchKey": "types.asArray",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asArray(t Type) *Array"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asArray(t Type) *Array\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Array.Len",
                    "documentation": {
                      "identifier": "Array.Len",
                      "newPage": false,
                      "searchKey": "types.Array.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *Array) Len() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *Array) Len() int64\n```\n\nLen returns the length of array a. A negative result indicates an unknown length. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Array.Elem",
                    "documentation": {
                      "identifier": "Array.Elem",
                      "newPage": false,
                      "searchKey": "types.Array.Elem",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *Array) Elem() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *Array) Elem() Type\n```\n\nElem returns element type of array a. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Array.Underlying",
                    "documentation": {
                      "identifier": "Array.Underlying",
                      "newPage": false,
                      "searchKey": "types.Array.Underlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Array) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Array) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Array.String",
                    "documentation": {
                      "identifier": "Array.String",
                      "newPage": false,
                      "searchKey": "types.Array.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Array) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Array) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Slice",
              "documentation": {
                "identifier": "Slice",
                "newPage": false,
                "searchKey": "types.Slice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Slice struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Slice struct {\n\telem Type\n}\n```\n\nA Slice represents a slice type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewSlice",
                    "documentation": {
                      "identifier": "NewSlice",
                      "newPage": false,
                      "searchKey": "types.NewSlice",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewSlice(elem Type) *Slice"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewSlice(elem Type) *Slice\n```\n\nNewSlice returns a new slice type for the given element type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#asSlice",
                    "documentation": {
                      "identifier": "asSlice",
                      "newPage": false,
                      "searchKey": "types.asSlice",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asSlice(t Type) *Slice"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asSlice(t Type) *Slice\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Slice.Elem",
                    "documentation": {
                      "identifier": "Slice.Elem",
                      "newPage": false,
                      "searchKey": "types.Slice.Elem",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Slice) Elem() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Slice) Elem() Type\n```\n\nElem returns the element type of slice s. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Slice.Underlying",
                    "documentation": {
                      "identifier": "Slice.Underlying",
                      "newPage": false,
                      "searchKey": "types.Slice.Underlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Slice) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Slice) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Slice.String",
                    "documentation": {
                      "identifier": "Slice.String",
                      "newPage": false,
                      "searchKey": "types.Slice.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Slice) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Slice) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Struct",
              "documentation": {
                "identifier": "Struct",
                "newPage": false,
                "searchKey": "types.Struct",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Struct struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Struct struct {\n\tfields []*Var\n\ttags   []string // field tags; nil if there are no tags\n}\n```\n\nA Struct represents a struct type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewStruct",
                    "documentation": {
                      "identifier": "NewStruct",
                      "newPage": false,
                      "searchKey": "types.NewStruct",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewStruct(fields []*Var, tags []string) *Struct"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewStruct(fields []*Var, tags []string) *Struct\n```\n\nNewStruct returns a new struct with the given fields and corresponding field tags. If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be only as long as required to hold the tag with the largest index i. Consequently, if no field has a tag, tags may be nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#asStruct",
                    "documentation": {
                      "identifier": "asStruct",
                      "newPage": false,
                      "searchKey": "types.asStruct",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asStruct(t Type) *Struct"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asStruct(t Type) *Struct\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Struct.NumFields",
                    "documentation": {
                      "identifier": "Struct.NumFields",
                      "newPage": false,
                      "searchKey": "types.Struct.NumFields",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Struct) NumFields() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Struct) NumFields() int\n```\n\nNumFields returns the number of fields in the struct (including blank and embedded fields). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Struct.Field",
                    "documentation": {
                      "identifier": "Struct.Field",
                      "newPage": false,
                      "searchKey": "types.Struct.Field",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Struct) Field(i int) *Var"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Struct) Field(i int) *Var\n```\n\nField returns the i'th field for 0 <= i < NumFields(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Struct.Tag",
                    "documentation": {
                      "identifier": "Struct.Tag",
                      "newPage": false,
                      "searchKey": "types.Struct.Tag",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Struct) Tag(i int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Struct) Tag(i int) string\n```\n\nTag returns the i'th field tag for 0 <= i < NumFields(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Struct.Underlying",
                    "documentation": {
                      "identifier": "Struct.Underlying",
                      "newPage": false,
                      "searchKey": "types.Struct.Underlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Struct) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Struct) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Struct.String",
                    "documentation": {
                      "identifier": "Struct.String",
                      "newPage": false,
                      "searchKey": "types.Struct.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Struct) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Struct) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Pointer",
              "documentation": {
                "identifier": "Pointer",
                "newPage": false,
                "searchKey": "types.Pointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Pointer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Pointer struct {\n\tbase Type // element type\n}\n```\n\nA Pointer represents a pointer type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewPointer",
                    "documentation": {
                      "identifier": "NewPointer",
                      "newPage": false,
                      "searchKey": "types.NewPointer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewPointer(elem Type) *Pointer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewPointer(elem Type) *Pointer\n```\n\nNewPointer returns a new pointer type for the given element (base) type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#asPointer",
                    "documentation": {
                      "identifier": "asPointer",
                      "newPage": false,
                      "searchKey": "types.asPointer",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asPointer(t Type) *Pointer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asPointer(t Type) *Pointer\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Pointer.Elem",
                    "documentation": {
                      "identifier": "Pointer.Elem",
                      "newPage": false,
                      "searchKey": "types.Pointer.Elem",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Pointer) Elem() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Pointer) Elem() Type\n```\n\nElem returns the element type for the given pointer p. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Pointer.Underlying",
                    "documentation": {
                      "identifier": "Pointer.Underlying",
                      "newPage": false,
                      "searchKey": "types.Pointer.Underlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Pointer) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Pointer) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Pointer.String",
                    "documentation": {
                      "identifier": "Pointer.String",
                      "newPage": false,
                      "searchKey": "types.Pointer.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Pointer) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Pointer) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Tuple",
              "documentation": {
                "identifier": "Tuple",
                "newPage": false,
                "searchKey": "types.Tuple",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Tuple struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Tuple struct {\n\tvars []*Var\n}\n```\n\nA Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple. Tuples are used as components of signatures and to represent the type of multiple assignments; they are not first class types of Go. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewTuple",
                    "documentation": {
                      "identifier": "NewTuple",
                      "newPage": false,
                      "searchKey": "types.NewTuple",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewTuple(x ...*Var) *Tuple"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewTuple(x ...*Var) *Tuple\n```\n\nNewTuple returns a new tuple for the given variables. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#asTuple",
                    "documentation": {
                      "identifier": "asTuple",
                      "newPage": false,
                      "searchKey": "types.asTuple",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asTuple(t Type) *Tuple"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asTuple(t Type) *Tuple\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Tuple.Len",
                    "documentation": {
                      "identifier": "Tuple.Len",
                      "newPage": false,
                      "searchKey": "types.Tuple.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Tuple) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Tuple) Len() int\n```\n\nLen returns the number variables of tuple t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Tuple.At",
                    "documentation": {
                      "identifier": "Tuple.At",
                      "newPage": false,
                      "searchKey": "types.Tuple.At",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Tuple) At(i int) *Var"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Tuple) At(i int) *Var\n```\n\nAt returns the i'th variable of tuple t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Tuple.Underlying",
                    "documentation": {
                      "identifier": "Tuple.Underlying",
                      "newPage": false,
                      "searchKey": "types.Tuple.Underlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Tuple) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Tuple) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Tuple.String",
                    "documentation": {
                      "identifier": "Tuple.String",
                      "newPage": false,
                      "searchKey": "types.Tuple.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Tuple) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Tuple) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Signature",
              "documentation": {
                "identifier": "Signature",
                "newPage": false,
                "searchKey": "types.Signature",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Signature struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Signature struct {\n\t// We need to keep the scope in Signature (rather than passing it around\n\t// and store it in the Func Object) because when type-checking a function\n\t// literal we call the general type checker which returns a general Type.\n\t// We then unpack the *Signature and use the scope for the literal body.\n\trparams  []*TypeName // receiver type parameters from left to right, or nil\n\ttparams  []*TypeName // type parameters from left to right, or nil\n\tscope    *Scope      // function scope, present for package-local signatures\n\trecv     *Var        // nil if not a method\n\tparams   *Tuple      // (incoming) parameters from left to right; or nil\n\tresults  *Tuple      // (outgoing) results from left to right; or nil\n\tvariadic bool        // true if the last parameter's type is of the form ...T (or string, for append built-in only)\n}\n```\n\nA Signature represents a (non-builtin) function or method type. The receiver is ignored when comparing signatures for identity. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#makeSig",
                    "documentation": {
                      "identifier": "makeSig",
                      "newPage": false,
                      "searchKey": "types.makeSig",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeSig(res Type, args ...Type) *Signature"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeSig(res Type, args ...Type) *Signature\n```\n\nmakeSig makes a signature for the given argument and result types. Default types are used for untyped arguments, and res may be nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#NewSignature",
                    "documentation": {
                      "identifier": "NewSignature",
                      "newPage": false,
                      "searchKey": "types.NewSignature",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature\n```\n\nNewSignature returns a new function type for the given receiver, parameters, and results, either of which may be nil. If variadic is set, the function is variadic, it must have at least one parameter, and the last parameter must be of unnamed slice type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#asSignature",
                    "documentation": {
                      "identifier": "asSignature",
                      "newPage": false,
                      "searchKey": "types.asSignature",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asSignature(t Type) *Signature"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asSignature(t Type) *Signature\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Signature.Recv",
                    "documentation": {
                      "identifier": "Signature.Recv",
                      "newPage": false,
                      "searchKey": "types.Signature.Recv",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Signature) Recv() *Var"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Signature) Recv() *Var\n```\n\nRecv returns the receiver of signature s (if a method), or nil if a function. It is ignored when comparing signatures for identity. \n\nFor an abstract method, Recv returns the enclosing interface either as a *Named or an *Interface. Due to embedding, an interface may contain methods whose receiver type is a different interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Signature._TParams",
                    "documentation": {
                      "identifier": "Signature._TParams",
                      "newPage": false,
                      "searchKey": "types.Signature._TParams",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Signature) _TParams() []*TypeName"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Signature) _TParams() []*TypeName\n```\n\n_TParams returns the type parameters of signature s, or nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Signature._SetTParams",
                    "documentation": {
                      "identifier": "Signature._SetTParams",
                      "newPage": false,
                      "searchKey": "types.Signature._SetTParams",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Signature) _SetTParams(tparams []*TypeName)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Signature) _SetTParams(tparams []*TypeName)\n```\n\n_SetTParams sets the type parameters of signature s. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Signature.Params",
                    "documentation": {
                      "identifier": "Signature.Params",
                      "newPage": false,
                      "searchKey": "types.Signature.Params",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Signature) Params() *Tuple"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Signature) Params() *Tuple\n```\n\nParams returns the parameters of signature s, or nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Signature.Results",
                    "documentation": {
                      "identifier": "Signature.Results",
                      "newPage": false,
                      "searchKey": "types.Signature.Results",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Signature) Results() *Tuple"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Signature) Results() *Tuple\n```\n\nResults returns the results of signature s, or nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Signature.Variadic",
                    "documentation": {
                      "identifier": "Signature.Variadic",
                      "newPage": false,
                      "searchKey": "types.Signature.Variadic",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *Signature) Variadic() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *Signature) Variadic() bool\n```\n\nVariadic reports whether the signature s is variadic. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Signature.Underlying",
                    "documentation": {
                      "identifier": "Signature.Underlying",
                      "newPage": false,
                      "searchKey": "types.Signature.Underlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Signature) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Signature) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Signature.String",
                    "documentation": {
                      "identifier": "Signature.String",
                      "newPage": false,
                      "searchKey": "types.Signature.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Signature) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Signature) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#_Sum",
              "documentation": {
                "identifier": "_Sum",
                "newPage": false,
                "searchKey": "types._Sum",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type _Sum struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype _Sum struct {\n\ttypes []Type // types are unique\n}\n```\n\nA _Sum represents a set of possible types. Sums are currently used to represent type lists of interfaces and thus the underlying types of type parameters; they are not first class types of Go. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#asSum",
                    "documentation": {
                      "identifier": "asSum",
                      "newPage": false,
                      "searchKey": "types.asSum",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asSum(t Type) *_Sum"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asSum(t Type) *_Sum\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#_Sum.is",
                    "documentation": {
                      "identifier": "_Sum.is",
                      "newPage": false,
                      "searchKey": "types._Sum.is",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *_Sum) is(pred func(Type) bool) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *_Sum) is(pred func(Type) bool) bool\n```\n\nis reports whether all types in t satisfy pred. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#_Sum.Underlying",
                    "documentation": {
                      "identifier": "_Sum.Underlying",
                      "newPage": false,
                      "searchKey": "types._Sum.Underlying",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_Sum) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_Sum) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#_Sum.String",
                    "documentation": {
                      "identifier": "_Sum.String",
                      "newPage": false,
                      "searchKey": "types._Sum.String",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_Sum) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_Sum) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Interface",
              "documentation": {
                "identifier": "Interface",
                "newPage": false,
                "searchKey": "types.Interface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Interface struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Interface struct {\n\tmethods   []*Func // ordered list of explicitly declared methods\n\ttypes     Type    // (possibly a Sum) type declared with a type list (TODO(gri) need better field name)\n\tembeddeds []Type  // ordered list of explicitly embedded types\n\n\tallMethods []*Func // ordered list of methods declared with or embedded in this interface (TODO(gri): replace with mset)\n\tallTypes   Type    // intersection of all embedded and locally declared types  (TODO(gri) need better field name)\n\n\tobj Object // type declaration defining this interface; or nil (for better error messages)\n}\n```\n\nAn Interface represents an interface type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewInterface",
                    "documentation": {
                      "identifier": "NewInterface",
                      "newPage": false,
                      "searchKey": "types.NewInterface",
                      "tags": [
                        "deprecated"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewInterface(methods []*Func, embeddeds []*Named) *Interface"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewInterface(methods []*Func, embeddeds []*Named) *Interface\n```\n\nNewInterface returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type. NewInterface takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called. \n\nDeprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types to be embedded. This is necessary for interfaces that embed alias type names referring to non-defined (literal) interface types. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#NewInterfaceType",
                    "documentation": {
                      "identifier": "NewInterfaceType",
                      "newPage": false,
                      "searchKey": "types.NewInterfaceType",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewInterfaceType(methods []*Func, embeddeds []Type) *Interface"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewInterfaceType(methods []*Func, embeddeds []Type) *Interface\n```\n\nNewInterfaceType returns a new (incomplete) interface for the given methods and embedded types. Each embedded type must have an underlying type of interface type (this property is not verified for defined types, which may be in the process of being set up and which don't have a valid underlying type yet). NewInterfaceType takes ownership of the provided methods and may modify their types by setting missing receivers. To compute the method set of the interface, Complete must be called. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#asInterface",
                    "documentation": {
                      "identifier": "asInterface",
                      "newPage": false,
                      "searchKey": "types.asInterface",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asInterface(t Type) *Interface"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asInterface(t Type) *Interface\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.is",
                    "documentation": {
                      "identifier": "Interface.is",
                      "newPage": false,
                      "searchKey": "types.Interface.is",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) is(pred func(Type) bool) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) is(pred func(Type) bool) bool\n```\n\nis reports whether interface t represents types that all satisfy pred. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.NumExplicitMethods",
                    "documentation": {
                      "identifier": "Interface.NumExplicitMethods",
                      "newPage": false,
                      "searchKey": "types.Interface.NumExplicitMethods",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) NumExplicitMethods() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) NumExplicitMethods() int\n```\n\nNumExplicitMethods returns the number of explicitly declared methods of interface t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.ExplicitMethod",
                    "documentation": {
                      "identifier": "Interface.ExplicitMethod",
                      "newPage": false,
                      "searchKey": "types.Interface.ExplicitMethod",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) ExplicitMethod(i int) *Func"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) ExplicitMethod(i int) *Func\n```\n\nExplicitMethod returns the i'th explicitly declared method of interface t for 0 <= i < t.NumExplicitMethods(). The methods are ordered by their unique Id. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.NumEmbeddeds",
                    "documentation": {
                      "identifier": "Interface.NumEmbeddeds",
                      "newPage": false,
                      "searchKey": "types.Interface.NumEmbeddeds",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) NumEmbeddeds() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) NumEmbeddeds() int\n```\n\nNumEmbeddeds returns the number of embedded types in interface t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.Embedded",
                    "documentation": {
                      "identifier": "Interface.Embedded",
                      "newPage": false,
                      "searchKey": "types.Interface.Embedded",
                      "tags": [
                        "deprecated"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) Embedded(i int) *Named"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) Embedded(i int) *Named\n```\n\nEmbedded returns the i'th embedded defined (*Named) type of interface t for 0 <= i < t.NumEmbeddeds(). The result is nil if the i'th embedded type is not a defined type. \n\nDeprecated: Use EmbeddedType which is not restricted to defined (*Named) types. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.EmbeddedType",
                    "documentation": {
                      "identifier": "Interface.EmbeddedType",
                      "newPage": false,
                      "searchKey": "types.Interface.EmbeddedType",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) EmbeddedType(i int) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) EmbeddedType(i int) Type\n```\n\nEmbeddedType returns the i'th embedded type of interface t for 0 <= i < t.NumEmbeddeds(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.NumMethods",
                    "documentation": {
                      "identifier": "Interface.NumMethods",
                      "newPage": false,
                      "searchKey": "types.Interface.NumMethods",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) NumMethods() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) NumMethods() int\n```\n\nNumMethods returns the total number of methods of interface t. The interface must have been completed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.assertCompleteness",
                    "documentation": {
                      "identifier": "Interface.assertCompleteness",
                      "newPage": false,
                      "searchKey": "types.Interface.assertCompleteness",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) assertCompleteness()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) assertCompleteness()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.Method",
                    "documentation": {
                      "identifier": "Interface.Method",
                      "newPage": false,
                      "searchKey": "types.Interface.Method",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) Method(i int) *Func"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) Method(i int) *Func\n```\n\nMethod returns the i'th method of interface t for 0 <= i < t.NumMethods(). The methods are ordered by their unique Id. The interface must have been completed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.Empty",
                    "documentation": {
                      "identifier": "Interface.Empty",
                      "newPage": false,
                      "searchKey": "types.Interface.Empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) Empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) Empty() bool\n```\n\nEmpty reports whether t is the empty interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface._HasTypeList",
                    "documentation": {
                      "identifier": "Interface._HasTypeList",
                      "newPage": false,
                      "searchKey": "types.Interface._HasTypeList",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) _HasTypeList() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) _HasTypeList() bool\n```\n\n_HasTypeList reports whether interface t has a type list, possibly from an embedded type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface._IsComparable",
                    "documentation": {
                      "identifier": "Interface._IsComparable",
                      "newPage": false,
                      "searchKey": "types.Interface._IsComparable",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) _IsComparable() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) _IsComparable() bool\n```\n\n_IsComparable reports whether interface t is or embeds the predeclared interface \"comparable\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface._IsConstraint",
                    "documentation": {
                      "identifier": "Interface._IsConstraint",
                      "newPage": false,
                      "searchKey": "types.Interface._IsConstraint",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) _IsConstraint() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) _IsConstraint() bool\n```\n\n_IsConstraint reports t.HasTypeList() || t.IsComparable(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.iterate",
                    "documentation": {
                      "identifier": "Interface.iterate",
                      "newPage": false,
                      "searchKey": "types.Interface.iterate",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) iterate(f func(*Interface) bool, seen map[*Interface]bool) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) iterate(f func(*Interface) bool, seen map[*Interface]bool) bool\n```\n\niterate calls f with t and then with any embedded interface of t, recursively, until f returns true. iterate reports whether any call to f returned true. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.isSatisfiedBy",
                    "documentation": {
                      "identifier": "Interface.isSatisfiedBy",
                      "newPage": false,
                      "searchKey": "types.Interface.isSatisfiedBy",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) isSatisfiedBy(typ Type) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) isSatisfiedBy(typ Type) bool\n```\n\nisSatisfiedBy reports whether interface t's type list is satisfied by the type typ. If the type list is empty (absent), typ trivially satisfies the interface. TODO(gri) This is not a great name. Eventually, we should have a more comprehensive \n\n```\n\"implements\" predicate.\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.Complete",
                    "documentation": {
                      "identifier": "Interface.Complete",
                      "newPage": false,
                      "searchKey": "types.Interface.Complete",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) Complete() *Interface"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) Complete() *Interface\n```\n\nComplete computes the interface's method set. It must be called by users of NewInterfaceType and NewInterface after the interface's embedded types are fully defined and before using the interface type in any way other than to form other types. The interface must not contain duplicate methods or a panic occurs. Complete returns the receiver. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.Underlying",
                    "documentation": {
                      "identifier": "Interface.Underlying",
                      "newPage": false,
                      "searchKey": "types.Interface.Underlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Interface.String",
                    "documentation": {
                      "identifier": "Interface.String",
                      "newPage": false,
                      "searchKey": "types.Interface.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Interface) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Interface) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Map",
              "documentation": {
                "identifier": "Map",
                "newPage": false,
                "searchKey": "types.Map",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Map struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Map struct {\n\tkey, elem Type\n}\n```\n\nA Map represents a map type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewMap",
                    "documentation": {
                      "identifier": "NewMap",
                      "newPage": false,
                      "searchKey": "types.NewMap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewMap(key, elem Type) *Map"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewMap(key, elem Type) *Map\n```\n\nNewMap returns a new map for the given key and element types. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#asMap",
                    "documentation": {
                      "identifier": "asMap",
                      "newPage": false,
                      "searchKey": "types.asMap",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asMap(t Type) *Map"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asMap(t Type) *Map\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Map.Key",
                    "documentation": {
                      "identifier": "Map.Key",
                      "newPage": false,
                      "searchKey": "types.Map.Key",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *Map) Key() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *Map) Key() Type\n```\n\nKey returns the key type of map m. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Map.Elem",
                    "documentation": {
                      "identifier": "Map.Elem",
                      "newPage": false,
                      "searchKey": "types.Map.Elem",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *Map) Elem() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *Map) Elem() Type\n```\n\nElem returns the element type of map m. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Map.Underlying",
                    "documentation": {
                      "identifier": "Map.Underlying",
                      "newPage": false,
                      "searchKey": "types.Map.Underlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Map) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Map) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Map.String",
                    "documentation": {
                      "identifier": "Map.String",
                      "newPage": false,
                      "searchKey": "types.Map.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Map) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Map) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Chan",
              "documentation": {
                "identifier": "Chan",
                "newPage": false,
                "searchKey": "types.Chan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Chan struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Chan struct {\n\tdir  ChanDir\n\telem Type\n}\n```\n\nA Chan represents a channel type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewChan",
                    "documentation": {
                      "identifier": "NewChan",
                      "newPage": false,
                      "searchKey": "types.NewChan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewChan(dir ChanDir, elem Type) *Chan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewChan(dir ChanDir, elem Type) *Chan\n```\n\nNewChan returns a new channel type for the given direction and element type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#asChan",
                    "documentation": {
                      "identifier": "asChan",
                      "newPage": false,
                      "searchKey": "types.asChan",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asChan(t Type) *Chan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asChan(t Type) *Chan\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Chan.Dir",
                    "documentation": {
                      "identifier": "Chan.Dir",
                      "newPage": false,
                      "searchKey": "types.Chan.Dir",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Chan) Dir() ChanDir"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Chan) Dir() ChanDir\n```\n\nDir returns the direction of channel c. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Chan.Elem",
                    "documentation": {
                      "identifier": "Chan.Elem",
                      "newPage": false,
                      "searchKey": "types.Chan.Elem",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Chan) Elem() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Chan) Elem() Type\n```\n\nElem returns the element type of channel c. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Chan.Underlying",
                    "documentation": {
                      "identifier": "Chan.Underlying",
                      "newPage": false,
                      "searchKey": "types.Chan.Underlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Chan) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Chan) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Chan.String",
                    "documentation": {
                      "identifier": "Chan.String",
                      "newPage": false,
                      "searchKey": "types.Chan.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Chan) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Chan) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#ChanDir",
              "documentation": {
                "identifier": "ChanDir",
                "newPage": false,
                "searchKey": "types.ChanDir",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ChanDir int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ChanDir int\n```\n\nA ChanDir value indicates a channel direction. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Named",
              "documentation": {
                "identifier": "Named",
                "newPage": false,
                "searchKey": "types.Named",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Named struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Named struct {\n\tcheck      *Checker    // for Named.under implementation; nilled once under has been called\n\tinfo       typeInfo    // for cycle detection\n\tobj        *TypeName   // corresponding declared object\n\torig       Type        // type (on RHS of declaration) this *Named type is derived of (for cycle reporting)\n\tunderlying Type        // possibly a *Named during setup; never a *Named once set up completely\n\ttparams    []*TypeName // type parameters, or nil\n\ttargs      []Type      // type arguments (after instantiation), or nil\n\tmethods    []*Func     // methods declared for this type (not the method set of this type); signatures are type-checked lazily\n}\n```\n\nA Named represents a named (defined) type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#NewNamed",
                    "documentation": {
                      "identifier": "NewNamed",
                      "newPage": false,
                      "searchKey": "types.NewNamed",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named\n```\n\nNewNamed returns a new named type for the given type name, underlying type, and associated methods. If the given type name obj doesn't have a type yet, its type is set to the returned named type. The underlying type must not be a *Named. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#asNamed",
                    "documentation": {
                      "identifier": "asNamed",
                      "newPage": false,
                      "searchKey": "types.asNamed",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asNamed(t Type) *Named"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asNamed(t Type) *Named\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named.under",
                    "documentation": {
                      "identifier": "Named.under",
                      "newPage": false,
                      "searchKey": "types.Named.under",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n0 *Named) under() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n0 *Named) under() Type\n```\n\nunder returns the expanded underlying type of n0; possibly by following forward chains of named types. If an underlying type is found, resolve the chain by setting the underlying type for each defined type in the chain before returning it. If no underlying type is found or a cycle is detected, the result is Typ[Invalid]. If a cycle is detected and n0.check != nil, the cycle is reported. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named.setUnderlying",
                    "documentation": {
                      "identifier": "Named.setUnderlying",
                      "newPage": false,
                      "searchKey": "types.Named.setUnderlying",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n *Named) setUnderlying(typ Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n *Named) setUnderlying(typ Type)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named.Obj",
                    "documentation": {
                      "identifier": "Named.Obj",
                      "newPage": false,
                      "searchKey": "types.Named.Obj",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Named) Obj() *TypeName"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Named) Obj() *TypeName\n```\n\nObj returns the type name for the named type t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named._TParams",
                    "documentation": {
                      "identifier": "Named._TParams",
                      "newPage": false,
                      "searchKey": "types.Named._TParams",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Named) _TParams() []*TypeName"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Named) _TParams() []*TypeName\n```\n\n_TParams returns the type parameters of the named type t, or nil. The result is non-nil for an (originally) parameterized type even if it is instantiated. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named._TArgs",
                    "documentation": {
                      "identifier": "Named._TArgs",
                      "newPage": false,
                      "searchKey": "types.Named._TArgs",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Named) _TArgs() []Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Named) _TArgs() []Type\n```\n\n_TArgs returns the type arguments after instantiation of the named type t, or nil if not instantiated. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named._SetTArgs",
                    "documentation": {
                      "identifier": "Named._SetTArgs",
                      "newPage": false,
                      "searchKey": "types.Named._SetTArgs",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Named) _SetTArgs(args []Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Named) _SetTArgs(args []Type)\n```\n\n_SetTArgs sets the type arguments of Named. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named.NumMethods",
                    "documentation": {
                      "identifier": "Named.NumMethods",
                      "newPage": false,
                      "searchKey": "types.Named.NumMethods",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Named) NumMethods() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Named) NumMethods() int\n```\n\nNumMethods returns the number of explicit methods whose receiver is named type t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named.Method",
                    "documentation": {
                      "identifier": "Named.Method",
                      "newPage": false,
                      "searchKey": "types.Named.Method",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Named) Method(i int) *Func"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Named) Method(i int) *Func\n```\n\nMethod returns the i'th method of named type t for 0 <= i < t.NumMethods(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named.SetUnderlying",
                    "documentation": {
                      "identifier": "Named.SetUnderlying",
                      "newPage": false,
                      "searchKey": "types.Named.SetUnderlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Named) SetUnderlying(underlying Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Named) SetUnderlying(underlying Type)\n```\n\nSetUnderlying sets the underlying type and marks t as complete. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named.AddMethod",
                    "documentation": {
                      "identifier": "Named.AddMethod",
                      "newPage": false,
                      "searchKey": "types.Named.AddMethod",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Named) AddMethod(m *Func)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Named) AddMethod(m *Func)\n```\n\nAddMethod adds method m unless it is already in the method list. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named.Underlying",
                    "documentation": {
                      "identifier": "Named.Underlying",
                      "newPage": false,
                      "searchKey": "types.Named.Underlying",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Named) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Named) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#Named.String",
                    "documentation": {
                      "identifier": "Named.String",
                      "newPage": false,
                      "searchKey": "types.Named.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Named) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Named) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#_TypeParam",
              "documentation": {
                "identifier": "_TypeParam",
                "newPage": false,
                "searchKey": "types._TypeParam",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type _TypeParam struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype _TypeParam struct {\n\tcheck *Checker  // for lazy type bound completion\n\tid    uint64    // unique id\n\tobj   *TypeName // corresponding type name\n\tindex int       // parameter index\n\tbound Type      // *Named or *Interface; underlying type is always *Interface\n}\n```\n\nA _TypeParam represents a type parameter type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#asTypeParam",
                    "documentation": {
                      "identifier": "asTypeParam",
                      "newPage": false,
                      "searchKey": "types.asTypeParam",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func asTypeParam(t Type) *_TypeParam"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc asTypeParam(t Type) *_TypeParam\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#_TypeParam.Bound",
                    "documentation": {
                      "identifier": "_TypeParam.Bound",
                      "newPage": false,
                      "searchKey": "types._TypeParam.Bound",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_TypeParam) Bound() *Interface"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_TypeParam) Bound() *Interface\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#_TypeParam.Underlying",
                    "documentation": {
                      "identifier": "_TypeParam.Underlying",
                      "newPage": false,
                      "searchKey": "types._TypeParam.Underlying",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_TypeParam) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_TypeParam) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#_TypeParam.String",
                    "documentation": {
                      "identifier": "_TypeParam.String",
                      "newPage": false,
                      "searchKey": "types._TypeParam.String",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_TypeParam) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_TypeParam) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#instance",
              "documentation": {
                "identifier": "instance",
                "newPage": false,
                "searchKey": "types.instance",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type instance struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype instance struct {\n\tcheck   *Checker    // for lazy instantiation\n\tpos     token.Pos   // position of type instantiation; for error reporting only\n\tbase    *Named      // parameterized type to be instantiated\n\ttargs   []Type      // type arguments\n\tposlist []token.Pos // position of each targ; for error reporting only\n\tvalue   Type        // base(targs...) after instantiation or Typ[Invalid]; nil if not yet set\n}\n```\n\nAn instance represents an instantiated generic type syntactically (without expanding the instantiation). Type instances appear only during type-checking and are replaced by their fully instantiated (expanded) types before the end of type-checking. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#instance.expand",
                    "documentation": {
                      "identifier": "instance.expand",
                      "newPage": false,
                      "searchKey": "types.instance.expand",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *instance) expand() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *instance) expand() Type\n```\n\nexpand returns the instantiated (= expanded) type of t. The result is either an instantiated *Named type, or Typ[Invalid] if there was an error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#instance.Underlying",
                    "documentation": {
                      "identifier": "instance.Underlying",
                      "newPage": false,
                      "searchKey": "types.instance.Underlying",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *instance) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *instance) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#instance.String",
                    "documentation": {
                      "identifier": "instance.String",
                      "newPage": false,
                      "searchKey": "types.instance.String",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *instance) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *instance) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#bottom",
              "documentation": {
                "identifier": "bottom",
                "newPage": false,
                "searchKey": "types.bottom",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type bottom struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bottom struct{}\n```\n\nbottom represents the bottom of the type lattice. It is the underlying type of a type parameter that cannot be satisfied by any type, usually because the intersection of type constraints left nothing). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#bottom.Underlying",
                    "documentation": {
                      "identifier": "bottom.Underlying",
                      "newPage": false,
                      "searchKey": "types.bottom.Underlying",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *bottom) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *bottom) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#bottom.String",
                    "documentation": {
                      "identifier": "bottom.String",
                      "newPage": false,
                      "searchKey": "types.bottom.String",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *bottom) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *bottom) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#top",
              "documentation": {
                "identifier": "top",
                "newPage": false,
                "searchKey": "types.top",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type top struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype top struct{}\n```\n\ntop represents the top of the type lattice. It is the underlying type of a type parameter that can be satisfied by any type (ignoring methods), usually because the type constraint has no type list. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#top.Underlying",
                    "documentation": {
                      "identifier": "top.Underlying",
                      "newPage": false,
                      "searchKey": "types.top.Underlying",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *top) Underlying() Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *top) Underlying() Type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#top.String",
                    "documentation": {
                      "identifier": "top.String",
                      "newPage": false,
                      "searchKey": "types.top.String",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *top) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *top) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#Qualifier",
              "documentation": {
                "identifier": "Qualifier",
                "newPage": false,
                "searchKey": "types.Qualifier",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Qualifier func(*std/go/types.Package) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Qualifier func(*Package) string\n```\n\nA Qualifier controls how named package-level objects are printed in calls to TypeString, ObjectString, and SelectionString. \n\nThese three formatting routines call the Qualifier for each package-level object O, and if the Qualifier returns a non-empty string p, the object is printed in the form p.O. If it returns an empty string, only the object name O is printed. \n\nUsing a nil Qualifier is equivalent to using (*Package).Path: the object is qualified by the import path, e.g., \"encoding/json.Marshal\". \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#RelativeTo",
                    "documentation": {
                      "identifier": "RelativeTo",
                      "newPage": false,
                      "searchKey": "types.RelativeTo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func RelativeTo(pkg *Package) Qualifier"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc RelativeTo(pkg *Package) Qualifier\n```\n\nRelativeTo returns a Qualifier that fully qualifies members of all packages other than pkg. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#byUniqueTypeName",
              "documentation": {
                "identifier": "byUniqueTypeName",
                "newPage": false,
                "searchKey": "types.byUniqueTypeName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type byUniqueTypeName []types.Type"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype byUniqueTypeName []Type\n```\n\nbyUniqueTypeName named type lists can be sorted by their unique type names. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#byUniqueTypeName.Len",
                    "documentation": {
                      "identifier": "byUniqueTypeName.Len",
                      "newPage": false,
                      "searchKey": "types.byUniqueTypeName.Len",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a byUniqueTypeName) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a byUniqueTypeName) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#byUniqueTypeName.Less",
                    "documentation": {
                      "identifier": "byUniqueTypeName.Less",
                      "newPage": false,
                      "searchKey": "types.byUniqueTypeName.Less",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a byUniqueTypeName) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a byUniqueTypeName) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#byUniqueTypeName.Swap",
                    "documentation": {
                      "identifier": "byUniqueTypeName.Swap",
                      "newPage": false,
                      "searchKey": "types.byUniqueTypeName.Swap",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a byUniqueTypeName) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a byUniqueTypeName) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#byUniqueMethodName",
              "documentation": {
                "identifier": "byUniqueMethodName",
                "newPage": false,
                "searchKey": "types.byUniqueMethodName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type byUniqueMethodName []*types.Func"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype byUniqueMethodName []*Func\n```\n\nbyUniqueMethodName method lists can be sorted by their unique method names. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#byUniqueMethodName.Len",
                    "documentation": {
                      "identifier": "byUniqueMethodName.Len",
                      "newPage": false,
                      "searchKey": "types.byUniqueMethodName.Len",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a byUniqueMethodName) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a byUniqueMethodName) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#byUniqueMethodName.Less",
                    "documentation": {
                      "identifier": "byUniqueMethodName.Less",
                      "newPage": false,
                      "searchKey": "types.byUniqueMethodName.Less",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a byUniqueMethodName) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a byUniqueMethodName) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#byUniqueMethodName.Swap",
                    "documentation": {
                      "identifier": "byUniqueMethodName.Swap",
                      "newPage": false,
                      "searchKey": "types.byUniqueMethodName.Swap",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a byUniqueMethodName) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a byUniqueMethodName) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#unifier",
              "documentation": {
                "identifier": "unifier",
                "newPage": false,
                "searchKey": "types.unifier",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type unifier struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype unifier struct {\n\tcheck *Checker\n\texact bool\n\tx, y  tparamsList // x and y must initialized via tparamsList.init\n\ttypes []Type      // inferred types, shared by x and y\n}\n```\n\nA unifier maintains the current type parameters for x and y and the respective types inferred for each type parameter. A unifier is created by calling newUnifier. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#newUnifier",
                    "documentation": {
                      "identifier": "newUnifier",
                      "newPage": false,
                      "searchKey": "types.newUnifier",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newUnifier(check *Checker, exact bool) *unifier"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newUnifier(check *Checker, exact bool) *unifier\n```\n\nnewUnifier returns a new unifier. If exact is set, unification requires unified types to match exactly. If exact is not set, a named type's underlying type is considered if unification would fail otherwise, and the direction of channels is ignored. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#unifier.unify",
                    "documentation": {
                      "identifier": "unifier.unify",
                      "newPage": false,
                      "searchKey": "types.unifier.unify",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (u *unifier) unify(x, y Type) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (u *unifier) unify(x, y Type) bool\n```\n\nunify attempts to unify x and y and reports whether it succeeded. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#unifier.join",
                    "documentation": {
                      "identifier": "unifier.join",
                      "newPage": false,
                      "searchKey": "types.unifier.join",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (u *unifier) join(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (u *unifier) join(i, j int) bool\n```\n\njoin unifies the i'th type parameter of x with the j'th type parameter of y. If both type parameters already have a type associated with them and they are not joined, join fails and return false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#unifier.nifyEq",
                    "documentation": {
                      "identifier": "unifier.nifyEq",
                      "newPage": false,
                      "searchKey": "types.unifier.nifyEq",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (u *unifier) nifyEq(x, y Type, p *ifacePair) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (u *unifier) nifyEq(x, y Type, p *ifacePair) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#unifier.nify",
                    "documentation": {
                      "identifier": "unifier.nify",
                      "newPage": false,
                      "searchKey": "types.unifier.nify",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (u *unifier) nify(x, y Type, p *ifacePair) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (u *unifier) nify(x, y Type, p *ifacePair) bool\n```\n\nnify implements the core unification algorithm which is an adapted version of Checker.identical0. For changes to that code the corresponding changes should be made here. Must not be called directly from outside the unifier. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#tparamsList",
              "documentation": {
                "identifier": "tparamsList",
                "newPage": false,
                "searchKey": "types.tparamsList",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type tparamsList struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype tparamsList struct {\n\tunifier *unifier\n\ttparams []*TypeName\n\t// For each tparams element, there is a corresponding type slot index in indices.\n\t// index  < 0: unifier.types[-index-1] == nil\n\t// index == 0: no type slot allocated yet\n\t// index  > 0: unifier.types[index-1] == typ\n\t// Joined tparams elements share the same type slot and thus have the same index.\n\t// By using a negative index for nil types we don't need to check unifier.types\n\t// to see if we have a type or not.\n\tindices []int // len(d.indices) == len(d.tparams)\n}\n```\n\nA tparamsList describes a list of type parameters and the types inferred for them. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#tparamsList.String",
                    "documentation": {
                      "identifier": "tparamsList.String",
                      "newPage": false,
                      "searchKey": "types.tparamsList.String",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *tparamsList) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *tparamsList) String() string\n```\n\nString returns a string representation for a tparamsList. For debugging. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#tparamsList.init.unify.go",
                    "documentation": {
                      "identifier": "tparamsList.init.unify.go",
                      "newPage": false,
                      "searchKey": "types.tparamsList.init",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *tparamsList) init(tparams []*TypeName)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *tparamsList) init(tparams []*TypeName)\n```\n\ninit initializes d with the given type parameters. The type parameters must be in the order in which they appear in their declaration (this ensures that the tparams indices match the respective type parameter index). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#tparamsList.index",
                    "documentation": {
                      "identifier": "tparamsList.index",
                      "newPage": false,
                      "searchKey": "types.tparamsList.index",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *tparamsList) index(typ Type) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *tparamsList) index(typ Type) int\n```\n\nIf typ is a type parameter of d, index returns the type parameter index. Otherwise, the result is < 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#tparamsList.setIndex",
                    "documentation": {
                      "identifier": "tparamsList.setIndex",
                      "newPage": false,
                      "searchKey": "types.tparamsList.setIndex",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *tparamsList) setIndex(i, tj int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *tparamsList) setIndex(i, tj int)\n```\n\nsetIndex sets the type slot index for the i'th type parameter (and all its joined parameters) to tj. The type parameter must have a (possibly nil) type slot associated with it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#tparamsList.at",
                    "documentation": {
                      "identifier": "tparamsList.at",
                      "newPage": false,
                      "searchKey": "types.tparamsList.at",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *tparamsList) at(i int) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *tparamsList) at(i int) Type\n```\n\nat returns the type set for the i'th type parameter; or nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#tparamsList.set",
                    "documentation": {
                      "identifier": "tparamsList.set",
                      "newPage": false,
                      "searchKey": "types.tparamsList.set",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *tparamsList) set(i int, typ Type)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *tparamsList) set(i int, typ Type)\n```\n\nset sets the type typ for the i'th type parameter; typ must not be nil and it must not have been set before. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/go/types#tparamsList.types",
                    "documentation": {
                      "identifier": "tparamsList.types",
                      "newPage": false,
                      "searchKey": "types.tparamsList.types",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *tparamsList) types() (list []Type, index int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *tparamsList) types() (list []Type, index int)\n```\n\ntypes returns the list of inferred types (via unification) for the type parameters described by d, and an index. If all types were inferred, the returned index is < 0. Otherwise, it is the index of the first type parameter which couldn't be inferred; i.e., for which list[index] is nil. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/go/types#builtinId",
              "documentation": {
                "identifier": "builtinId",
                "newPage": false,
                "searchKey": "types.builtinId",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type builtinId int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype builtinId int\n```\n\nA builtinId is the id of a builtin function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#version",
              "documentation": {
                "identifier": "version",
                "newPage": false,
                "searchKey": "types.version",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type version struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype version struct {\n\tmajor, minor int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/go/types#parseGoVersion",
                    "documentation": {
                      "identifier": "parseGoVersion",
                      "newPage": false,
                      "searchKey": "types.parseGoVersion",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseGoVersion(s string) (v version, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseGoVersion(s string) (v version, err error)\n```\n\nparseGoVersion parses a Go version string (such as \"go1.12\") and returns the version, or an error. If s is the empty string, the version is 0.0. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/go/types#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/go/types#srcimporter_setUsesCgo",
              "documentation": {
                "identifier": "srcimporter_setUsesCgo",
                "newPage": false,
                "searchKey": "types.srcimporter_setUsesCgo",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func srcimporter_setUsesCgo(conf *Config)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc srcimporter_setUsesCgo(conf *Config)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#AssertableTo",
              "documentation": {
                "identifier": "AssertableTo",
                "newPage": false,
                "searchKey": "types.AssertableTo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func AssertableTo(V *Interface, T Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc AssertableTo(V *Interface, T Type) bool\n```\n\nAssertableTo reports whether a value of type V can be asserted to have type T. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#AssignableTo",
              "documentation": {
                "identifier": "AssignableTo",
                "newPage": false,
                "searchKey": "types.AssignableTo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func AssignableTo(V, T Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc AssignableTo(V, T Type) bool\n```\n\nAssignableTo reports whether a value of type V is assignable to a variable of type T. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#ConvertibleTo",
              "documentation": {
                "identifier": "ConvertibleTo",
                "newPage": false,
                "searchKey": "types.ConvertibleTo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ConvertibleTo(V, T Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ConvertibleTo(V, T Type) bool\n```\n\nConvertibleTo reports whether a value of type V is convertible to a value of type T. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Implements",
              "documentation": {
                "identifier": "Implements",
                "newPage": false,
                "searchKey": "types.Implements",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Implements(V Type, T *Interface) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Implements(V Type, T *Interface) bool\n```\n\nImplements reports whether type V implements interface T. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Identical",
              "documentation": {
                "identifier": "Identical",
                "newPage": false,
                "searchKey": "types.Identical",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Identical(x, y Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Identical(x, y Type) bool\n```\n\nIdentical reports whether x and y are identical types. Receivers of Signature types are ignored. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IdenticalIgnoreTags",
              "documentation": {
                "identifier": "IdenticalIgnoreTags",
                "newPage": false,
                "searchKey": "types.IdenticalIgnoreTags",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func IdenticalIgnoreTags(x, y Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IdenticalIgnoreTags(x, y Type) bool\n```\n\nIdenticalIgnoreTags reports whether x and y are identical types if tags are ignored. Receivers of Signature types are ignored. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#getInferred",
              "documentation": {
                "identifier": "getInferred",
                "newPage": false,
                "searchKey": "types.getInferred",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func getInferred(info *Info) map[ast.Expr]_Inferred"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getInferred(info *Info) map[ast.Expr]_Inferred\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#unparen",
              "documentation": {
                "identifier": "unparen",
                "newPage": false,
                "searchKey": "types.unparen",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func unparen(e ast.Expr) ast.Expr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unparen(e ast.Expr) ast.Expr\n```\n\nunparen returns e with any enclosing parentheses stripped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isUintptr",
              "documentation": {
                "identifier": "isUintptr",
                "newPage": false,
                "searchKey": "types.isUintptr",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isUintptr(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isUintptr(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isUnsafePointer",
              "documentation": {
                "identifier": "isUnsafePointer",
                "newPage": false,
                "searchKey": "types.isUnsafePointer",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isUnsafePointer(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isUnsafePointer(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isPointer",
              "documentation": {
                "identifier": "isPointer",
                "newPage": false,
                "searchKey": "types.isPointer",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isPointer(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isPointer(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isBytesOrRunes",
              "documentation": {
                "identifier": "isBytesOrRunes",
                "newPage": false,
                "searchKey": "types.isBytesOrRunes",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isBytesOrRunes(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isBytesOrRunes(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#pathString",
              "documentation": {
                "identifier": "pathString",
                "newPage": false,
                "searchKey": "types.pathString",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func pathString(path []Object) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pathString(path []Object) string\n```\n\npathString returns a string of the form a->b-> ... ->g for a path [a, b, ... g]. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#firstInSrc",
              "documentation": {
                "identifier": "firstInSrc",
                "newPage": false,
                "searchKey": "types.firstInSrc",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func firstInSrc(path []Object) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc firstInSrc(path []Object) int\n```\n\nfirstInSrc reports the index of the object with the \"smallest\" source position in path. path must not be empty. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#assert",
              "documentation": {
                "identifier": "assert",
                "newPage": false,
                "searchKey": "types.assert",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func assert(p bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc assert(p bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#unreachable",
              "documentation": {
                "identifier": "unreachable",
                "newPage": false,
                "searchKey": "types.unreachable",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func unreachable()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unreachable()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#stripAnnotations",
              "documentation": {
                "identifier": "stripAnnotations",
                "newPage": false,
                "searchKey": "types.stripAnnotations",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func stripAnnotations(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stripAnnotations(s string) string\n```\n\nstripAnnotations removes internal (type) annotations from s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#CheckExpr",
              "documentation": {
                "identifier": "CheckExpr",
                "newPage": false,
                "searchKey": "types.CheckExpr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func CheckExpr(fset *token.FileSet, pkg *Package, pos token.Pos, expr ast.Expr, info *Info) (err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc CheckExpr(fset *token.FileSet, pkg *Package, pos token.Pos, expr ast.Expr, info *Info) (err error)\n```\n\nCheckExpr type checks the expression expr as if it had appeared at position pos of package pkg. Type information about the expression is recorded in info. \n\nIf pkg == nil, the Universe scope is used and the provided position pos is ignored. If pkg != nil, and pos is invalid, the package scope is used. Otherwise, pos must belong to the package. \n\nAn error is returned if pos is not within the package or if the node cannot be type-checked. \n\nNote: Eval and CheckExpr should not be used instead of running Check to compute types and values, but in addition to Check, as these functions ignore the context in which an expression is used (e.g., an assignment). Thus, top-level untyped constants will return an untyped type rather then the respective context-specific type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#init.expr.go",
              "documentation": {
                "identifier": "init.expr.go",
                "newPage": false,
                "searchKey": "types.init",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#opName",
              "documentation": {
                "identifier": "opName",
                "newPage": false,
                "searchKey": "types.opName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func opName(e ast.Expr) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc opName(e ast.Expr) string\n```\n\nopName returns the name of an operation, or the empty string. For now, only operations that might overflow are handled. TODO(gri) Expand this to a general mechanism giving names to \n\n```\nnodes?\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isShift",
              "documentation": {
                "identifier": "isShift",
                "newPage": false,
                "searchKey": "types.isShift",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isShift(op token.Token) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isShift(op token.Token) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isComparison",
              "documentation": {
                "identifier": "isComparison",
                "newPage": false,
                "searchKey": "types.isComparison",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isComparison(op token.Token) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isComparison(op token.Token) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#fitsFloat32",
              "documentation": {
                "identifier": "fitsFloat32",
                "newPage": false,
                "searchKey": "types.fitsFloat32",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fitsFloat32(x constant.Value) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fitsFloat32(x constant.Value) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#roundFloat32",
              "documentation": {
                "identifier": "roundFloat32",
                "newPage": false,
                "searchKey": "types.roundFloat32",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func roundFloat32(x constant.Value) constant.Value"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc roundFloat32(x constant.Value) constant.Value\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#fitsFloat64",
              "documentation": {
                "identifier": "fitsFloat64",
                "newPage": false,
                "searchKey": "types.fitsFloat64",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fitsFloat64(x constant.Value) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fitsFloat64(x constant.Value) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#roundFloat64",
              "documentation": {
                "identifier": "roundFloat64",
                "newPage": false,
                "searchKey": "types.roundFloat64",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func roundFloat64(x constant.Value) constant.Value"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc roundFloat64(x constant.Value) constant.Value\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#representableConst",
              "documentation": {
                "identifier": "representableConst",
                "newPage": false,
                "searchKey": "types.representableConst",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func representableConst(x constant.Value, check *Checker, typ *Basic, rounded *constant.Value) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc representableConst(x constant.Value, check *Checker, typ *Basic, rounded *constant.Value) bool\n```\n\nrepresentableConst reports whether x can be represented as value of the given basic type and for the configuration provided (only needed for int/uint sizes). \n\nIf rounded != nil, *rounded is set to the rounded value of x for representable floating-point and complex values, and to an Int value for integer values; it is left alone otherwise. It is ok to provide the addressof the first argument for rounded. \n\nThe check parameter may be nil if representableConst is invoked (indirectly) through an exported API call (AssignableTo, ConvertibleTo) because we don't need the Checker's config for those calls. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#init.expr.go.0xc05a5bcd60",
              "documentation": {
                "identifier": "init.expr.go.0xc05a5bcd60",
                "newPage": false,
                "searchKey": "types.init",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#keyVal",
              "documentation": {
                "identifier": "keyVal",
                "newPage": false,
                "searchKey": "types.keyVal",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func keyVal(x constant.Value) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc keyVal(x constant.Value) interface{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#ExprString",
              "documentation": {
                "identifier": "ExprString",
                "newPage": false,
                "searchKey": "types.ExprString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ExprString(x ast.Expr) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ExprString(x ast.Expr) string\n```\n\nExprString returns the (possibly shortened) string representation for x. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#WriteExpr",
              "documentation": {
                "identifier": "WriteExpr",
                "newPage": false,
                "searchKey": "types.WriteExpr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func WriteExpr(buf *bytes.Buffer, x ast.Expr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc WriteExpr(buf *bytes.Buffer, x ast.Expr)\n```\n\nWriteExpr writes the (possibly shortened) string representation for x to buf. Shortened representations are suitable for user interfaces but may not necessarily follow Go syntax. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeSigExpr",
              "documentation": {
                "identifier": "writeSigExpr",
                "newPage": false,
                "searchKey": "types.writeSigExpr",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeSigExpr(buf *bytes.Buffer, sig *ast.FuncType)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeSigExpr(buf *bytes.Buffer, sig *ast.FuncType)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeFieldList",
              "documentation": {
                "identifier": "writeFieldList",
                "newPage": false,
                "searchKey": "types.writeFieldList",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeFieldList(buf *bytes.Buffer, list []*ast.Field, sep string, iface bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeFieldList(buf *bytes.Buffer, list []*ast.Field, sep string, iface bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeIdentList",
              "documentation": {
                "identifier": "writeIdentList",
                "newPage": false,
                "searchKey": "types.writeIdentList",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeIdentList(buf *bytes.Buffer, list []*ast.Ident)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeIdentList(buf *bytes.Buffer, list []*ast.Ident)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeExprList",
              "documentation": {
                "identifier": "writeExprList",
                "newPage": false,
                "searchKey": "types.writeExprList",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeExprList(buf *bytes.Buffer, list []ast.Expr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeExprList(buf *bytes.Buffer, list []ast.Expr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#typeNamesString",
              "documentation": {
                "identifier": "typeNamesString",
                "newPage": false,
                "searchKey": "types.typeNamesString",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func typeNamesString(list []*TypeName) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typeNamesString(list []*TypeName) string\n```\n\ntypeNamesString produces a string containing all the type names in list suitable for human consumption. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isParameterized",
              "documentation": {
                "identifier": "isParameterized",
                "newPage": false,
                "searchKey": "types.isParameterized",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isParameterized(tparams []*TypeName, typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isParameterized(tparams []*TypeName, typ Type) bool\n```\n\nIsParameterized reports whether typ contains any of the type parameters of tparams. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#findPath",
              "documentation": {
                "identifier": "findPath",
                "newPage": false,
                "searchKey": "types.findPath",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func findPath(objMap map[Object]*declInfo, from, to Object, seen map[Object]bool) []Object"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc findPath(objMap map[Object]*declInfo, from, to Object, seen map[Object]bool) []Object\n```\n\nfindPath returns the (reversed) list of objects []Object{to, ... from} such that there is a path of object dependencies from 'from' to 'to'. If there is no such path, the result is nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#dependencyGraph",
              "documentation": {
                "identifier": "dependencyGraph",
                "newPage": false,
                "searchKey": "types.dependencyGraph",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func dependencyGraph(objMap map[Object]*declInfo) []*graphNode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dependencyGraph(objMap map[Object]*declInfo) []*graphNode\n```\n\ndependencyGraph computes the object dependency graph from the given objMap, with any function nodes removed. The resulting graph contains only constants and variables. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#concat",
              "documentation": {
                "identifier": "concat",
                "newPage": false,
                "searchKey": "types.concat",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func concat(list []int, i int) []int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc concat(list []int, i int) []int\n```\n\nconcat returns the result of concatenating list and i. The result does not share its underlying array with list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#fieldIndex",
              "documentation": {
                "identifier": "fieldIndex",
                "newPage": false,
                "searchKey": "types.fieldIndex",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fieldIndex(fields []*Var, pkg *Package, name string) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fieldIndex(fields []*Var, pkg *Package, name string) int\n```\n\nfieldIndex returns the index for the field with matching package and name, or a value < 0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#ptrRecv",
              "documentation": {
                "identifier": "ptrRecv",
                "newPage": false,
                "searchKey": "types.ptrRecv",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ptrRecv(f *Func) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ptrRecv(f *Func) bool\n```\n\nptrRecv reports whether the receiver is of the form *T. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Id",
              "documentation": {
                "identifier": "Id",
                "newPage": false,
                "searchKey": "types.Id",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Id(pkg *Package, name string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Id(pkg *Package, name string) string\n```\n\nId returns name if it is exported, otherwise it returns the name qualified with the package path. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeObject",
              "documentation": {
                "identifier": "writeObject",
                "newPage": false,
                "searchKey": "types.writeObject",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeObject(buf *bytes.Buffer, obj Object, qf Qualifier)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeObject(buf *bytes.Buffer, obj Object, qf Qualifier)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writePackage",
              "documentation": {
                "identifier": "writePackage",
                "newPage": false,
                "searchKey": "types.writePackage",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writePackage(buf *bytes.Buffer, pkg *Package, qf Qualifier)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writePackage(buf *bytes.Buffer, pkg *Package, qf Qualifier)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#ObjectString",
              "documentation": {
                "identifier": "ObjectString",
                "newPage": false,
                "searchKey": "types.ObjectString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ObjectString(obj Object, qf Qualifier) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ObjectString(obj Object, qf Qualifier) string\n```\n\nObjectString returns the string form of obj. The Qualifier controls the printing of package-level objects, and may be nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeFuncName",
              "documentation": {
                "identifier": "writeFuncName",
                "newPage": false,
                "searchKey": "types.writeFuncName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeFuncName(buf *bytes.Buffer, f *Func, qf Qualifier)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeFuncName(buf *bytes.Buffer, f *Func, qf Qualifier)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#operandString",
              "documentation": {
                "identifier": "operandString",
                "newPage": false,
                "searchKey": "types.operandString",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func operandString(x *operand, qf Qualifier) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc operandString(x *operand, qf Qualifier) string\n```\n\nOperand string formats (not all \"untyped\" cases can appear due to the type system, but they fall out naturally here) \n\nmode       format \n\ninvalid    <expr> (               <mode>                    ) novalue    <expr> (               <mode>                    ) builtin    <expr> (               <mode>                    ) typexpr    <expr> (               <mode>                    ) \n\nconstant   <expr> (<untyped kind> <mode>                    ) constant   <expr> (               <mode>       of type <typ>) constant   <expr> (<untyped kind> <mode> <val>              ) constant   <expr> (               <mode> <val> of type <typ>) \n\nvariable   <expr> (<untyped kind> <mode>                    ) variable   <expr> (               <mode>       of type <typ>) \n\nmapindex   <expr> (<untyped kind> <mode>                    ) mapindex   <expr> (               <mode>       of type <typ>) \n\nvalue      <expr> (<untyped kind> <mode>                    ) value      <expr> (               <mode>       of type <typ>) \n\ncommaok    <expr> (<untyped kind> <mode>                    ) commaok    <expr> (               <mode>       of type <typ>) \n\ncommaerr   <expr> (<untyped kind> <mode>                    ) commaerr   <expr> (               <mode>       of type <typ>) \n\ncgofunc    <expr> (<untyped kind> <mode>                    ) cgofunc    <expr> (               <mode>       of type <typ>) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isNamed",
              "documentation": {
                "identifier": "isNamed",
                "newPage": false,
                "searchKey": "types.isNamed",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isNamed(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isNamed(typ Type) bool\n```\n\nisNamed reports whether typ has a name. isNamed may be called with types that are not fully set up. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isGeneric",
              "documentation": {
                "identifier": "isGeneric",
                "newPage": false,
                "searchKey": "types.isGeneric",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isGeneric(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isGeneric(typ Type) bool\n```\n\nisGeneric reports whether a type is a generic, uninstantiated type (generic signatures are not included). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#is",
              "documentation": {
                "identifier": "is",
                "newPage": false,
                "searchKey": "types.is",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func is(typ Type, what BasicInfo) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc is(typ Type, what BasicInfo) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isBoolean",
              "documentation": {
                "identifier": "isBoolean",
                "newPage": false,
                "searchKey": "types.isBoolean",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isBoolean(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isBoolean(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isInteger",
              "documentation": {
                "identifier": "isInteger",
                "newPage": false,
                "searchKey": "types.isInteger",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isInteger(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isInteger(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isUnsigned",
              "documentation": {
                "identifier": "isUnsigned",
                "newPage": false,
                "searchKey": "types.isUnsigned",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isUnsigned(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isUnsigned(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isFloat",
              "documentation": {
                "identifier": "isFloat",
                "newPage": false,
                "searchKey": "types.isFloat",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isFloat(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isFloat(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isComplex",
              "documentation": {
                "identifier": "isComplex",
                "newPage": false,
                "searchKey": "types.isComplex",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isComplex(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isComplex(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isNumeric",
              "documentation": {
                "identifier": "isNumeric",
                "newPage": false,
                "searchKey": "types.isNumeric",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isNumeric(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isNumeric(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isString",
              "documentation": {
                "identifier": "isString",
                "newPage": false,
                "searchKey": "types.isString",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isString(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isString(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isIntegerOrFloat",
              "documentation": {
                "identifier": "isIntegerOrFloat",
                "newPage": false,
                "searchKey": "types.isIntegerOrFloat",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isIntegerOrFloat(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isIntegerOrFloat(typ Type) bool\n```\n\nNote that if typ is a type parameter, isInteger(typ) || isFloat(typ) does not produce the expected result because a type list that contains both an integer and a floating-point type is neither (all) integers, nor (all) floats. Use isIntegerOrFloat instead. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isNumericOrString",
              "documentation": {
                "identifier": "isNumericOrString",
                "newPage": false,
                "searchKey": "types.isNumericOrString",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isNumericOrString(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isNumericOrString(typ Type) bool\n```\n\nisNumericOrString is the equivalent of isIntegerOrFloat for isNumeric(typ) || isString(typ). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isTyped",
              "documentation": {
                "identifier": "isTyped",
                "newPage": false,
                "searchKey": "types.isTyped",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isTyped(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isTyped(typ Type) bool\n```\n\nisTyped reports whether typ is typed; i.e., not an untyped constant or boolean. isTyped may be called with types that are not fully set up. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isUntyped",
              "documentation": {
                "identifier": "isUntyped",
                "newPage": false,
                "searchKey": "types.isUntyped",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isUntyped(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isUntyped(typ Type) bool\n```\n\nisUntyped(typ) is the same as !isTyped(typ). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isOrdered",
              "documentation": {
                "identifier": "isOrdered",
                "newPage": false,
                "searchKey": "types.isOrdered",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isOrdered(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isOrdered(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isConstType",
              "documentation": {
                "identifier": "isConstType",
                "newPage": false,
                "searchKey": "types.isConstType",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isConstType(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isConstType(typ Type) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#IsInterface",
              "documentation": {
                "identifier": "IsInterface",
                "newPage": false,
                "searchKey": "types.IsInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsInterface(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsInterface(typ Type) bool\n```\n\nIsInterface reports whether typ is an interface type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#Comparable",
              "documentation": {
                "identifier": "Comparable",
                "newPage": false,
                "searchKey": "types.Comparable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Comparable(T Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Comparable(T Type) bool\n```\n\nComparable reports whether values of type T are comparable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#comparable",
              "documentation": {
                "identifier": "comparable",
                "newPage": false,
                "searchKey": "types.comparable",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func comparable(T Type, seen map[Type]bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc comparable(T Type, seen map[Type]bool) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#hasNil",
              "documentation": {
                "identifier": "hasNil",
                "newPage": false,
                "searchKey": "types.hasNil",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func hasNil(typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hasNil(typ Type) bool\n```\n\nhasNil reports whether a type includes the nil value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#validatedImportPath",
              "documentation": {
                "identifier": "validatedImportPath",
                "newPage": false,
                "searchKey": "types.validatedImportPath",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validatedImportPath(path string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validatedImportPath(path string) (string, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#dir",
              "documentation": {
                "identifier": "dir",
                "newPage": false,
                "searchKey": "types.dir",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func dir(path string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dir(path string) string\n```\n\ndir makes a good-faith attempt to return the directory portion of path. If path is empty, the result is \".\". (Per the go/build package dependency tests, we cannot import path/filepath and simply use filepath.Dir.) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#hasBreak",
              "documentation": {
                "identifier": "hasBreak",
                "newPage": false,
                "searchKey": "types.hasBreak",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func hasBreak(s ast.Stmt, label string, implicit bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hasBreak(s ast.Stmt, label string, implicit bool) bool\n```\n\nhasBreak reports if s is or contains a break statement referring to the label-ed statement or implicit-ly the closest outer breakable statement. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#hasBreakList",
              "documentation": {
                "identifier": "hasBreakList",
                "newPage": false,
                "searchKey": "types.hasBreakList",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func hasBreakList(list []ast.Stmt, label string, implicit bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hasBreakList(list []ast.Stmt, label string, implicit bool) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#sanitizeInfo",
              "documentation": {
                "identifier": "sanitizeInfo",
                "newPage": false,
                "searchKey": "types.sanitizeInfo",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sanitizeInfo(info *Info)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sanitizeInfo(info *Info)\n```\n\nsanitizeInfo walks the types contained in info to ensure that all instances are expanded. \n\nThis includes some objects that may be shared across concurrent type-checking passes (such as those in the universe scope), so we are careful here not to write types that are already sanitized. This avoids a data race as any shared types should already be sanitized. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#SelectionString",
              "documentation": {
                "identifier": "SelectionString",
                "newPage": false,
                "searchKey": "types.SelectionString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func SelectionString(s *Selection, qf Qualifier) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SelectionString(s *Selection, qf Qualifier) string\n```\n\nSelectionString returns the string form of s. The Qualifier controls the printing of package-level objects, and may be nil. \n\nExamples: \n\n```\n\"field (T) f int\"\n\"method (T) f(X) Y\"\n\"method expr (T) f(X) Y\"\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#align",
              "documentation": {
                "identifier": "align",
                "newPage": false,
                "searchKey": "types.align",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func align(x, a int64) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc align(x, a int64) int64\n```\n\nalign returns the smallest y >= x such that y % a == 0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#trimTrailingEmptyStmts",
              "documentation": {
                "identifier": "trimTrailingEmptyStmts",
                "newPage": false,
                "searchKey": "types.trimTrailingEmptyStmts",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func trimTrailingEmptyStmts(list []ast.Stmt) []ast.Stmt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc trimTrailingEmptyStmts(list []ast.Stmt) []ast.Stmt\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#assignOp",
              "documentation": {
                "identifier": "assignOp",
                "newPage": false,
                "searchKey": "types.assignOp",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func assignOp(op token.Token) token.Token"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc assignOp(op token.Token) token.Token\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#goVal",
              "documentation": {
                "identifier": "goVal",
                "newPage": false,
                "searchKey": "types.goVal",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func goVal(val constant.Value) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goVal(val constant.Value) interface{}\n```\n\ngoVal returns the Go value for val, or nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isVarName",
              "documentation": {
                "identifier": "isVarName",
                "newPage": false,
                "searchKey": "types.isVarName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isVarName(x ast.Expr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isVarName(x ast.Expr) bool\n```\n\nisVarName reports whether x is a non-nil, non-blank (_) expression. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#rangeKeyVal",
              "documentation": {
                "identifier": "rangeKeyVal",
                "newPage": false,
                "searchKey": "types.rangeKeyVal",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func rangeKeyVal(typ Type, wantKey, wantVal bool) (Type, Type, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rangeKeyVal(typ Type, wantKey, wantVal bool) (Type, Type, string)\n```\n\nrangeKeyVal returns the key and value type produced by a range clause over an expression of type typ, and possibly an error message. If the range clause is not permitted the returned key is nil or msg is not empty (in that case we still may have a non-nil key type which can be used to reduce the chance for follow-on errors). The wantKey, wantVal, and hasVal flags indicate which of the iteration variables are used or present; this matters if we range over a generic type where not all keys or values are of the same type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#instantiatedHash",
              "documentation": {
                "identifier": "instantiatedHash",
                "newPage": false,
                "searchKey": "types.instantiatedHash",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func instantiatedHash(typ *Named, targs []Type) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc instantiatedHash(typ *Named, targs []Type) string\n```\n\nTODO(gri) Eventually, this should be more sophisticated. \n\n```\nIt won't work correctly for locally declared types.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#typeListString",
              "documentation": {
                "identifier": "typeListString",
                "newPage": false,
                "searchKey": "types.typeListString",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func typeListString(list []Type) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typeListString(list []Type) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#unpackType",
              "documentation": {
                "identifier": "unpackType",
                "newPage": false,
                "searchKey": "types.unpackType",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func unpackType(typ Type) []Type"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unpackType(typ Type) []Type\n```\n\nunpack unpacks a type into a list of types. TODO(gri) Try to eliminate the need for this function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#nextId",
              "documentation": {
                "identifier": "nextId",
                "newPage": false,
                "searchKey": "types.nextId",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func nextId() uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nextId() uint64\n```\n\nnextId returns a value increasing monotonically by 1 with each call, starting with 1. It may be called concurrently. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#init.type.go",
              "documentation": {
                "identifier": "init.type.go",
                "newPage": false,
                "searchKey": "types.init",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#TypeString",
              "documentation": {
                "identifier": "TypeString",
                "newPage": false,
                "searchKey": "types.TypeString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TypeString(typ Type, qf Qualifier) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TypeString(typ Type, qf Qualifier) string\n```\n\nTypeString returns the string representation of typ. The Qualifier controls the printing of package-level objects, and may be nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#WriteType",
              "documentation": {
                "identifier": "WriteType",
                "newPage": false,
                "searchKey": "types.WriteType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)\n```\n\nWriteType writes the string representation of typ to buf. The Qualifier controls the printing of package-level objects, and may be nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeType",
              "documentation": {
                "identifier": "writeType",
                "newPage": false,
                "searchKey": "types.writeType",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeType(buf *bytes.Buffer, typ Type, qf Qualifier, visited []Type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeType(buf *bytes.Buffer, typ Type, qf Qualifier, visited []Type)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeTypeList",
              "documentation": {
                "identifier": "writeTypeList",
                "newPage": false,
                "searchKey": "types.writeTypeList",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeTypeList(buf *bytes.Buffer, list []Type, qf Qualifier, visited []Type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeTypeList(buf *bytes.Buffer, list []Type, qf Qualifier, visited []Type)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeTParamList",
              "documentation": {
                "identifier": "writeTParamList",
                "newPage": false,
                "searchKey": "types.writeTParamList",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeTParamList(buf *bytes.Buffer, list []*TypeName, qf Qualifier, visited []Type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeTParamList(buf *bytes.Buffer, list []*TypeName, qf Qualifier, visited []Type)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeTypeName",
              "documentation": {
                "identifier": "writeTypeName",
                "newPage": false,
                "searchKey": "types.writeTypeName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeTypeName(buf *bytes.Buffer, obj *TypeName, qf Qualifier)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeTypeName(buf *bytes.Buffer, obj *TypeName, qf Qualifier)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeTuple",
              "documentation": {
                "identifier": "writeTuple",
                "newPage": false,
                "searchKey": "types.writeTuple",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeTuple(buf *bytes.Buffer, tup *Tuple, variadic bool, qf Qualifier, visited []Type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeTuple(buf *bytes.Buffer, tup *Tuple, variadic bool, qf Qualifier, visited []Type)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#WriteSignature",
              "documentation": {
                "identifier": "WriteSignature",
                "newPage": false,
                "searchKey": "types.WriteSignature",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)\n```\n\nWriteSignature writes the representation of the signature sig to buf, without a leading \"func\" keyword. The Qualifier controls the printing of package-level objects, and may be nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#writeSignature",
              "documentation": {
                "identifier": "writeSignature",
                "newPage": false,
                "searchKey": "types.writeSignature",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier, visited []Type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier, visited []Type)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#subscript",
              "documentation": {
                "identifier": "subscript",
                "newPage": false,
                "searchKey": "types.subscript",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func subscript(x uint64) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc subscript(x uint64) string\n```\n\nsubscript returns the decimal (utf8) representation of x using subscript digits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#isubst",
              "documentation": {
                "identifier": "isubst",
                "newPage": false,
                "searchKey": "types.isubst",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isubst(x ast.Expr, smap map[*ast.Ident]*ast.Ident) ast.Expr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isubst(x ast.Expr, smap map[*ast.Ident]*ast.Ident) ast.Expr\n```\n\nisubst returns an x with identifiers substituted per the substitution map smap. isubst only handles the case of (valid) method receiver type expressions correctly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#goTypeName",
              "documentation": {
                "identifier": "goTypeName",
                "newPage": false,
                "searchKey": "types.goTypeName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func goTypeName(typ Type) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goTypeName(typ Type) string\n```\n\ngoTypeName returns the Go type name for typ and removes any occurrences of \"types.\" from that name. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#sortTypes",
              "documentation": {
                "identifier": "sortTypes",
                "newPage": false,
                "searchKey": "types.sortTypes",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sortTypes(list []Type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sortTypes(list []Type)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#sortName",
              "documentation": {
                "identifier": "sortName",
                "newPage": false,
                "searchKey": "types.sortName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sortName(t Type) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sortName(t Type) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#sortMethods",
              "documentation": {
                "identifier": "sortMethods",
                "newPage": false,
                "searchKey": "types.sortMethods",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sortMethods(list []*Func)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sortMethods(list []*Func)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#assertSortedMethods",
              "documentation": {
                "identifier": "assertSortedMethods",
                "newPage": false,
                "searchKey": "types.assertSortedMethods",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func assertSortedMethods(list []*Func)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc assertSortedMethods(list []*Func)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#embeddedFieldIdent",
              "documentation": {
                "identifier": "embeddedFieldIdent",
                "newPage": false,
                "searchKey": "types.embeddedFieldIdent",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func embeddedFieldIdent(e ast.Expr) *ast.Ident"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc embeddedFieldIdent(e ast.Expr) *ast.Ident\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#includes",
              "documentation": {
                "identifier": "includes",
                "newPage": false,
                "searchKey": "types.includes",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func includes(list []Type, typ Type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc includes(list []Type, typ Type) bool\n```\n\nincludes reports whether typ is in list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#defPredeclaredTypes",
              "documentation": {
                "identifier": "defPredeclaredTypes",
                "newPage": false,
                "searchKey": "types.defPredeclaredTypes",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func defPredeclaredTypes()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc defPredeclaredTypes()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#defPredeclaredConsts",
              "documentation": {
                "identifier": "defPredeclaredConsts",
                "newPage": false,
                "searchKey": "types.defPredeclaredConsts",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func defPredeclaredConsts()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc defPredeclaredConsts()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#defPredeclaredNil",
              "documentation": {
                "identifier": "defPredeclaredNil",
                "newPage": false,
                "searchKey": "types.defPredeclaredNil",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func defPredeclaredNil()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc defPredeclaredNil()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#defPredeclaredFuncs",
              "documentation": {
                "identifier": "defPredeclaredFuncs",
                "newPage": false,
                "searchKey": "types.defPredeclaredFuncs",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func defPredeclaredFuncs()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc defPredeclaredFuncs()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#DefPredeclaredTestFuncs",
              "documentation": {
                "identifier": "DefPredeclaredTestFuncs",
                "newPage": false,
                "searchKey": "types.DefPredeclaredTestFuncs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func DefPredeclaredTestFuncs()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc DefPredeclaredTestFuncs()\n```\n\nDefPredeclaredTestFuncs defines the assert and trace built-ins. These built-ins are intended for debugging and testing of this package only. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#defPredeclaredComparable",
              "documentation": {
                "identifier": "defPredeclaredComparable",
                "newPage": false,
                "searchKey": "types.defPredeclaredComparable",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func defPredeclaredComparable()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc defPredeclaredComparable()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#init.universe.go",
              "documentation": {
                "identifier": "init.universe.go",
                "newPage": false,
                "searchKey": "types.init",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#def",
              "documentation": {
                "identifier": "def",
                "newPage": false,
                "searchKey": "types.def",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func def(obj Object)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc def(obj Object)\n```\n\nObjects with names containing blanks are internal and not entered into a scope. Objects with exported names are inserted in the unsafe package scope; other objects are inserted in the universe scope. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#TestStripAnnotations",
              "documentation": {
                "identifier": "TestStripAnnotations",
                "newPage": false,
                "searchKey": "types.TestStripAnnotations",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestStripAnnotations(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestStripAnnotations(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#TestIsAlias",
              "documentation": {
                "identifier": "TestIsAlias",
                "newPage": false,
                "searchKey": "types.TestIsAlias",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIsAlias(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIsAlias(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#TestEmbeddedMethod",
              "documentation": {
                "identifier": "TestEmbeddedMethod",
                "newPage": false,
                "searchKey": "types.TestEmbeddedMethod",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEmbeddedMethod(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEmbeddedMethod(t *testing.T)\n```\n\nTestEmbeddedMethod checks that an embedded method is represented by the same Func Object as the original method. See also issue #34421. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#TestSizeof",
              "documentation": {
                "identifier": "TestSizeof",
                "newPage": false,
                "searchKey": "types.TestSizeof",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSizeof(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSizeof(t *testing.T)\n```\n\nSignal size changes of important structures. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#TestZeroTok",
              "documentation": {
                "identifier": "TestZeroTok",
                "newPage": false,
                "searchKey": "types.TestZeroTok",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestZeroTok(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestZeroTok(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#TestAssignOp",
              "documentation": {
                "identifier": "TestAssignOp",
                "newPage": false,
                "searchKey": "types.TestAssignOp",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAssignOp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAssignOp(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#ResetId",
              "documentation": {
                "identifier": "ResetId",
                "newPage": false,
                "searchKey": "types.ResetId",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ResetId()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ResetId()\n```\n\nUpon calling ResetId, nextId starts with 1 again. It may be called concurrently. This is only needed for tests where we may want to have a consistent numbering for each individual test case. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/go/types#SetGoVersion",
              "documentation": {
                "identifier": "SetGoVersion",
                "newPage": false,
                "searchKey": "types.SetGoVersion",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetGoVersion(config *Config, goVersion string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetGoVersion(config *Config, goVersion string)\n```\n\nSetGoVersion sets the unexported goVersion field on config, so that tests which assert on behavior for older Go versions can set it. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
