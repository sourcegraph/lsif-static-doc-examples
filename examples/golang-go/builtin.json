{
  "pathID": "/builtin",
  "documentation": {
    "identifier": "builtin",
    "newPage": true,
    "searchKey": "builtin",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package builtin"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package builtin provides documentation for Go's predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/builtin#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/builtin#true",
              "documentation": {
                "identifier": "true",
                "newPage": false,
                "searchKey": "builtin.true",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const true"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst true = 0 == 0 // Untyped bool.\n\n```\n\ntrue and false are the two untyped boolean values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#false",
              "documentation": {
                "identifier": "false",
                "newPage": false,
                "searchKey": "builtin.false",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const false"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst false = 0 != 0 // Untyped bool.\n\n```\n\ntrue and false are the two untyped boolean values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#iota",
              "documentation": {
                "identifier": "iota",
                "newPage": false,
                "searchKey": "builtin.iota",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const iota"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst iota = 0 // Untyped int.\n\n```\n\niota is a predeclared identifier representing the untyped integer ordinal number of the current const specification in a (usually parenthesized) const declaration. It is zero-indexed. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/builtin#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/builtin#nil",
              "documentation": {
                "identifier": "nil",
                "newPage": false,
                "searchKey": "builtin.nil",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var nil"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar nil Type // Type must be a pointer, channel, func, interface, map, or slice type\n\n```\n\nnil is a predeclared identifier representing the zero value for a pointer, channel, func, interface, map, or slice type. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/builtin#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/builtin#bool",
              "documentation": {
                "identifier": "bool",
                "newPage": false,
                "searchKey": "builtin.bool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type bool builtin.bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bool bool\n```\n\nbool is the set of boolean values, true and false. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#uint8",
              "documentation": {
                "identifier": "uint8",
                "newPage": false,
                "searchKey": "builtin.uint8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type uint8 builtin.uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype uint8 uint8\n```\n\nuint8 is the set of all unsigned 8-bit integers. Range: 0 through 255. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#uint16",
              "documentation": {
                "identifier": "uint16",
                "newPage": false,
                "searchKey": "builtin.uint16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type uint16 builtin.uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype uint16 uint16\n```\n\nuint16 is the set of all unsigned 16-bit integers. Range: 0 through 65535. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#uint32",
              "documentation": {
                "identifier": "uint32",
                "newPage": false,
                "searchKey": "builtin.uint32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type uint32 builtin.uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype uint32 uint32\n```\n\nuint32 is the set of all unsigned 32-bit integers. Range: 0 through 4294967295. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#uint64",
              "documentation": {
                "identifier": "uint64",
                "newPage": false,
                "searchKey": "builtin.uint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type uint64 builtin.uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype uint64 uint64\n```\n\nuint64 is the set of all unsigned 64-bit integers. Range: 0 through 18446744073709551615. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#int8",
              "documentation": {
                "identifier": "int8",
                "newPage": false,
                "searchKey": "builtin.int8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type int8 builtin.int8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype int8 int8\n```\n\nint8 is the set of all signed 8-bit integers. Range: -128 through 127. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#int16",
              "documentation": {
                "identifier": "int16",
                "newPage": false,
                "searchKey": "builtin.int16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type int16 builtin.int16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype int16 int16\n```\n\nint16 is the set of all signed 16-bit integers. Range: -32768 through 32767. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#int32",
              "documentation": {
                "identifier": "int32",
                "newPage": false,
                "searchKey": "builtin.int32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type int32 builtin.int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype int32 int32\n```\n\nint32 is the set of all signed 32-bit integers. Range: -2147483648 through 2147483647. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#int64",
              "documentation": {
                "identifier": "int64",
                "newPage": false,
                "searchKey": "builtin.int64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type int64 builtin.int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype int64 int64\n```\n\nint64 is the set of all signed 64-bit integers. Range: -9223372036854775808 through 9223372036854775807. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#float32",
              "documentation": {
                "identifier": "float32",
                "newPage": false,
                "searchKey": "builtin.float32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type float32 builtin.float32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype float32 float32\n```\n\nfloat32 is the set of all IEEE-754 32-bit floating-point numbers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#float64",
              "documentation": {
                "identifier": "float64",
                "newPage": false,
                "searchKey": "builtin.float64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type float64 builtin.float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype float64 float64\n```\n\nfloat64 is the set of all IEEE-754 64-bit floating-point numbers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#complex64",
              "documentation": {
                "identifier": "complex64",
                "newPage": false,
                "searchKey": "builtin.complex64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type complex64 builtin.complex64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype complex64 complex64\n```\n\ncomplex64 is the set of all complex numbers with float32 real and imaginary parts. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#complex128",
              "documentation": {
                "identifier": "complex128",
                "newPage": false,
                "searchKey": "builtin.complex128",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type complex128 builtin.complex128"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype complex128 complex128\n```\n\ncomplex128 is the set of all complex numbers with float64 real and imaginary parts. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#string",
              "documentation": {
                "identifier": "string",
                "newPage": false,
                "searchKey": "builtin.string",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type string builtin.string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype string string\n```\n\nstring is the set of all strings of 8-bit bytes, conventionally but not necessarily representing UTF-8-encoded text. A string may be empty, but not nil. Values of string type are immutable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#int",
              "documentation": {
                "identifier": "int",
                "newPage": false,
                "searchKey": "builtin.int",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type int builtin.int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype int int\n```\n\nint is a signed integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, int32. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/builtin#copy",
                    "documentation": {
                      "identifier": "copy",
                      "newPage": false,
                      "searchKey": "builtin.copy",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func copy(dst, src []Type) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc copy(dst, src []Type) int\n```\n\nThe copy built-in function copies elements from a source slice into a destination slice. (As a special case, it also will copy bytes from a string to a slice of bytes.) The source and destination may overlap. Copy returns the number of elements copied, which will be the minimum of len(src) and len(dst). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/builtin#len",
                    "documentation": {
                      "identifier": "len",
                      "newPage": false,
                      "searchKey": "builtin.len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func len(v Type) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc len(v Type) int\n```\n\nThe len built-in function returns the length of v, according to its type: \n\n```\nArray: the number of elements in v.\nPointer to array: the number of elements in *v (even if v is nil).\nSlice, or map: the number of elements in v; if v is nil, len(v) is zero.\nString: the number of bytes in v.\nChannel: the number of elements queued (unread) in the channel buffer;\n         if v is nil, len(v) is zero.\n\n```\nFor some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification's \"Length and capacity\" section for details. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/builtin#cap",
                    "documentation": {
                      "identifier": "cap",
                      "newPage": false,
                      "searchKey": "builtin.cap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cap(v Type) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cap(v Type) int\n```\n\nThe cap built-in function returns the capacity of v, according to its type: \n\n```\nArray: the number of elements in v (same as len(v)).\nPointer to array: the number of elements in *v (same as len(v)).\nSlice: the maximum length the slice can reach when resliced;\nif v is nil, cap(v) is zero.\nChannel: the channel buffer capacity, in units of elements;\nif v is nil, cap(v) is zero.\n\n```\nFor some arguments, such as a simple array expression, the result can be a constant. See the Go language specification's \"Length and capacity\" section for details. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/builtin#uint",
              "documentation": {
                "identifier": "uint",
                "newPage": false,
                "searchKey": "builtin.uint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type uint builtin.uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype uint uint\n```\n\nuint is an unsigned integer type that is at least 32 bits in size. It is a distinct type, however, and not an alias for, say, uint32. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#uintptr",
              "documentation": {
                "identifier": "uintptr",
                "newPage": false,
                "searchKey": "builtin.uintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type uintptr builtin.uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype uintptr uintptr\n```\n\nuintptr is an integer type that is large enough to hold the bit pattern of any pointer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#byte",
              "documentation": {
                "identifier": "byte",
                "newPage": false,
                "searchKey": "builtin.byte",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type byte builtin.uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype byte = uint8\n```\n\nbyte is an alias for uint8 and is equivalent to uint8 in all ways. It is used, by convention, to distinguish byte values from 8-bit unsigned integer values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#rune",
              "documentation": {
                "identifier": "rune",
                "newPage": false,
                "searchKey": "builtin.rune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type rune builtin.int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype rune = int32\n```\n\nrune is an alias for int32 and is equivalent to int32 in all ways. It is used, by convention, to distinguish character values from integer values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#Type",
              "documentation": {
                "identifier": "Type",
                "newPage": false,
                "searchKey": "builtin.Type",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Type builtin.int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Type int\n```\n\nType is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/builtin#make",
                    "documentation": {
                      "identifier": "make",
                      "newPage": false,
                      "searchKey": "builtin.make",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func make(t Type, size ...IntegerType) Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc make(t Type, size ...IntegerType) Type\n```\n\nThe make built-in function allocates and initializes an object of type slice, map, or chan (only). Like new, the first argument is a type, not a value. Unlike new, make's return type is the same as the type of its argument, not a pointer to it. The specification of the result depends on the type: \n\n```\nSlice: The size specifies the length. The capacity of the slice is\nequal to its length. A second integer argument may be provided to\nspecify a different capacity; it must be no smaller than the\nlength. For example, make([]int, 0, 10) allocates an underlying array\nof size 10 and returns a slice of length 0 and capacity 10 that is\nbacked by this underlying array.\nMap: An empty map is allocated with enough space to hold the\nspecified number of elements. The size may be omitted, in which case\na small starting size is allocated.\nChannel: The channel's buffer is initialized with the specified\nbuffer capacity. If zero, or the size is omitted, the channel is\nunbuffered.\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/builtin#new",
                    "documentation": {
                      "identifier": "new",
                      "newPage": false,
                      "searchKey": "builtin.new",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func new(Type) *Type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc new(Type) *Type\n```\n\nThe new built-in function allocates memory. The first argument is a type, not a value, and the value returned is a pointer to a newly allocated zero value of that type. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/builtin#Type1",
              "documentation": {
                "identifier": "Type1",
                "newPage": false,
                "searchKey": "builtin.Type1",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Type1 builtin.int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Type1 int\n```\n\nType1 is here for the purposes of documentation only. It is a stand-in for any Go type, but represents the same type for any given function invocation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#IntegerType",
              "documentation": {
                "identifier": "IntegerType",
                "newPage": false,
                "searchKey": "builtin.IntegerType",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type IntegerType builtin.int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype IntegerType int\n```\n\nIntegerType is here for the purposes of documentation only. It is a stand-in for any integer type: int, uint, int8 etc. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#FloatType",
              "documentation": {
                "identifier": "FloatType",
                "newPage": false,
                "searchKey": "builtin.FloatType",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type FloatType builtin.float32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FloatType float32\n```\n\nFloatType is here for the purposes of documentation only. It is a stand-in for either float type: float32 or float64. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/builtin#real",
                    "documentation": {
                      "identifier": "real",
                      "newPage": false,
                      "searchKey": "builtin.real",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func real(c ComplexType) FloatType"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc real(c ComplexType) FloatType\n```\n\nThe real built-in function returns the real part of the complex number c. The return value will be floating point type corresponding to the type of c. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/builtin#imag",
                    "documentation": {
                      "identifier": "imag",
                      "newPage": false,
                      "searchKey": "builtin.imag",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func imag(c ComplexType) FloatType"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc imag(c ComplexType) FloatType\n```\n\nThe imag built-in function returns the imaginary part of the complex number c. The return value will be floating point type corresponding to the type of c. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/builtin#ComplexType",
              "documentation": {
                "identifier": "ComplexType",
                "newPage": false,
                "searchKey": "builtin.ComplexType",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ComplexType builtin.complex64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ComplexType complex64\n```\n\nComplexType is here for the purposes of documentation only. It is a stand-in for either complex type: complex64 or complex128. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/builtin#complex",
                    "documentation": {
                      "identifier": "complex",
                      "newPage": false,
                      "searchKey": "builtin.complex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func complex(r, i FloatType) ComplexType"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc complex(r, i FloatType) ComplexType\n```\n\nThe complex built-in function constructs a complex value from two floating-point values. The real and imaginary parts must be of the same size, either float32 or float64 (or assignable to them), and the return value will be the corresponding complex type (complex64 for float32, complex128 for float64). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/builtin#error",
              "documentation": {
                "identifier": "error",
                "newPage": false,
                "searchKey": "builtin.error",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type error interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype error interface {\n\tError() string\n}\n```\n\nThe error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/builtin#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/builtin#append",
              "documentation": {
                "identifier": "append",
                "newPage": false,
                "searchKey": "builtin.append",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func append(slice []Type, elems ...Type) []Type"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc append(slice []Type, elems ...Type) []Type\n```\n\nThe append built-in function appends elements to the end of a slice. If it has sufficient capacity, the destination is resliced to accommodate the new elements. If it does not, a new underlying array will be allocated. Append returns the updated slice. It is therefore necessary to store the result of append, often in the variable holding the slice itself: \n\n```\nslice = append(slice, elem1, elem2)\nslice = append(slice, anotherSlice...)\n\n```\nAs a special case, it is legal to append a string to a byte slice, like this: \n\n```\nslice = append([]byte(\"hello \"), \"world\"...)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#delete",
              "documentation": {
                "identifier": "delete",
                "newPage": false,
                "searchKey": "builtin.delete",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func delete(m map[Type]Type1, key Type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc delete(m map[Type]Type1, key Type)\n```\n\nThe delete built-in function deletes the element with the specified key (m[key]) from the map. If m is nil or there is no such element, delete is a no-op. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#close",
              "documentation": {
                "identifier": "close",
                "newPage": false,
                "searchKey": "builtin.close",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func close(c chan<- Type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc close(c chan<- Type)\n```\n\nThe close built-in function closes a channel, which must be either bidirectional or send-only. It should be executed only by the sender, never the receiver, and has the effect of shutting down the channel after the last sent value is received. After the last value has been received from a closed channel c, any receive from c will succeed without blocking, returning the zero value for the channel element. The form \n\n```\nx, ok := <-c\n\n```\nwill also set ok to false for a closed channel. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#panic",
              "documentation": {
                "identifier": "panic",
                "newPage": false,
                "searchKey": "builtin.panic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panic(v interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panic(v interface{})\n```\n\nThe panic built-in function stops normal execution of the current goroutine. When a function F calls panic, normal execution of F stops immediately. Any functions whose execution was deferred by F are run in the usual way, and then F returns to its caller. To the caller G, the invocation of F then behaves like a call to panic, terminating G's execution and running any deferred functions. This continues until all functions in the executing goroutine have stopped, in reverse order. At that point, the program is terminated with a non-zero exit code. This termination sequence is called panicking and can be controlled by the built-in function recover. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#recover",
              "documentation": {
                "identifier": "recover",
                "newPage": false,
                "searchKey": "builtin.recover",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func recover() interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc recover() interface{}\n```\n\nThe recover built-in function allows a program to manage behavior of a panicking goroutine. Executing a call to recover inside a deferred function (but not any function called by it) stops the panicking sequence by restoring normal execution and retrieves the error value passed to the call of panic. If recover is called outside the deferred function it will not stop a panicking sequence. In this case, or when the goroutine is not panicking, or if the argument supplied to panic was nil, recover returns nil. Thus the return value from recover reports whether the goroutine is panicking. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#print",
              "documentation": {
                "identifier": "print",
                "newPage": false,
                "searchKey": "builtin.print",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func print(args ...Type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc print(args ...Type)\n```\n\nThe print built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Print is useful for bootstrapping and debugging; it is not guaranteed to stay in the language. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/builtin#println",
              "documentation": {
                "identifier": "println",
                "newPage": false,
                "searchKey": "builtin.println",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func println(args ...Type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc println(args ...Type)\n```\n\nThe println built-in function formats its arguments in an implementation-specific way and writes the result to standard error. Spaces are always added between arguments and a newline is appended. Println is useful for bootstrapping and debugging; it is not guaranteed to stay in the language. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
