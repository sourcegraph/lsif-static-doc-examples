{
  "pathID": "/archive/tar",
  "documentation": {
    "identifier": "tar",
    "newPage": true,
    "searchKey": "archive/tar",
    "tags": [
      "package"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package tar"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package tar implements access to tar archives. \n\nTape archives (tar) are a file format for storing a sequence of files that can be read and written in a streaming manner. This package aims to cover most variations of the format, including those produced by GNU and BSD tar tools. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/archive/tar#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/archive/tar#FormatGNU",
              "documentation": {
                "identifier": "FormatGNU",
                "newPage": false,
                "searchKey": "tar.FormatGNU",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FormatGNU"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FormatGNU\n```\n\nConstants to identify various tar formats. \n\nFormatGNU represents the GNU header format. \n\nThe GNU header format is older than the USTAR and PAX standards and is not compatible with them. The GNU format supports arbitrary file sizes, filenames of arbitrary encoding and length, sparse files, and other features. \n\nIt is recommended that PAX be chosen over GNU unless the target application can only parse GNU formatted archives. \n\nReference: \n\n```\n[https://www.gnu.org/software/tar/manual/html_node/Standard.html](https://www.gnu.org/software/tar/manual/html_node/Standard.html)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#FormatPAX",
              "documentation": {
                "identifier": "FormatPAX",
                "newPage": false,
                "searchKey": "tar.FormatPAX",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FormatPAX"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FormatPAX\n```\n\nConstants to identify various tar formats. \n\nFormatPAX represents the PAX header format defined in POSIX.1-2001. \n\nPAX extends USTAR by writing a special file with Typeflag TypeXHeader preceding the original header. This file contains a set of key-value records, which are used to overcome USTAR's shortcomings, in addition to providing the ability to have sub-second resolution for timestamps. \n\nSome newer formats add their own extensions to PAX by defining their own keys and assigning certain semantic meaning to the associated values. For example, sparse file support in PAX is implemented using keys defined by the GNU manual (e.g., \"GNU.sparse.map\"). \n\nReference: \n\n```\n[http://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html](http://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#FormatUSTAR",
              "documentation": {
                "identifier": "FormatUSTAR",
                "newPage": false,
                "searchKey": "tar.FormatUSTAR",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FormatUSTAR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FormatUSTAR\n```\n\nConstants to identify various tar formats. \n\nFormatUSTAR represents the USTAR header format defined in POSIX.1-1988. \n\nWhile this format is compatible with most tar readers, the format has several limitations making it unsuitable for some usages. Most notably, it cannot support sparse files, files larger than 8GiB, filenames larger than 256 characters, and non-ASCII filenames. \n\nReference: \n\n```\n[http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#FormatUnknown",
              "documentation": {
                "identifier": "FormatUnknown",
                "newPage": false,
                "searchKey": "tar.FormatUnknown",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FormatUnknown"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FormatUnknown\n```\n\nConstants to identify various tar formats. \n\nFormatUnknown indicates that the format is unknown. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeBlock",
              "documentation": {
                "identifier": "TypeBlock",
                "newPage": false,
                "searchKey": "tar.TypeBlock",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeBlock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeBlock = '4' // Block device node\n\n```\n\nType flags for Header.Typeflag. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeChar",
              "documentation": {
                "identifier": "TypeChar",
                "newPage": false,
                "searchKey": "tar.TypeChar",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeChar"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeChar = '3' // Character device node\n\n```\n\nType flags for Header.Typeflag. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeCont",
              "documentation": {
                "identifier": "TypeCont",
                "newPage": false,
                "searchKey": "tar.TypeCont",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeCont"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeCont = '7'\n```\n\nType flags for Header.Typeflag. \n\nType '7' is reserved. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeDir",
              "documentation": {
                "identifier": "TypeDir",
                "newPage": false,
                "searchKey": "tar.TypeDir",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeDir"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeDir = '5' // Directory\n\n```\n\nType flags for Header.Typeflag. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeFifo",
              "documentation": {
                "identifier": "TypeFifo",
                "newPage": false,
                "searchKey": "tar.TypeFifo",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeFifo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeFifo = '6' // FIFO node\n\n```\n\nType flags for Header.Typeflag. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeGNULongLink",
              "documentation": {
                "identifier": "TypeGNULongLink",
                "newPage": false,
                "searchKey": "tar.TypeGNULongLink",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeGNULongLink"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeGNULongLink = 'K'\n```\n\nType flags for Header.Typeflag. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeGNULongName",
              "documentation": {
                "identifier": "TypeGNULongName",
                "newPage": false,
                "searchKey": "tar.TypeGNULongName",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeGNULongName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeGNULongName = 'L'\n```\n\nType flags for Header.Typeflag. \n\nTypes 'L' and 'K' are used by the GNU format for a meta file used to store the path or link name for the next file. This package transparently handles these types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeGNUSparse",
              "documentation": {
                "identifier": "TypeGNUSparse",
                "newPage": false,
                "searchKey": "tar.TypeGNUSparse",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeGNUSparse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeGNUSparse = 'S'\n```\n\nType flags for Header.Typeflag. \n\nType 'S' indicates a sparse file in the GNU format. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeLink",
              "documentation": {
                "identifier": "TypeLink",
                "newPage": false,
                "searchKey": "tar.TypeLink",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeLink"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeLink = '1' // Hard link\n\n```\n\nType flags for Header.Typeflag. \n\nType '1' to '6' are header-only flags and may not have a data body. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeReg",
              "documentation": {
                "identifier": "TypeReg",
                "newPage": false,
                "searchKey": "tar.TypeReg",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeReg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeReg = '0'\n```\n\nType flags for Header.Typeflag. \n\nType '0' indicates a regular file. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeRegA",
              "documentation": {
                "identifier": "TypeRegA",
                "newPage": false,
                "searchKey": "tar.TypeRegA",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeRegA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeRegA = '\\x00' // Deprecated: Use TypeReg instead.\n\n```\n\nType flags for Header.Typeflag. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeSymlink",
              "documentation": {
                "identifier": "TypeSymlink",
                "newPage": false,
                "searchKey": "tar.TypeSymlink",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeSymlink"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeSymlink = '2' // Symbolic link\n\n```\n\nType flags for Header.Typeflag. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeXGlobalHeader",
              "documentation": {
                "identifier": "TypeXGlobalHeader",
                "newPage": false,
                "searchKey": "tar.TypeXGlobalHeader",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeXGlobalHeader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeXGlobalHeader = 'g'\n```\n\nType flags for Header.Typeflag. \n\nType 'g' is used by the PAX format to store key-value records that are relevant to all subsequent files. This package only supports parsing and composing such headers, but does not currently support persisting the global state across files. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TypeXHeader",
              "documentation": {
                "identifier": "TypeXHeader",
                "newPage": false,
                "searchKey": "tar.TypeXHeader",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TypeXHeader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TypeXHeader = 'x'\n```\n\nType flags for Header.Typeflag. \n\nType 'x' is used by the PAX format to store key-value records that are only relevant to the next file. This package transparently handles these types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#blockSize",
              "documentation": {
                "identifier": "blockSize",
                "newPage": false,
                "searchKey": "tar.blockSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const blockSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst blockSize = 512 // Size of each block in a tar stream\n\n```\n\nSize constants from various tar specifications. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#c_ISBLK",
              "documentation": {
                "identifier": "c_ISBLK",
                "newPage": false,
                "searchKey": "tar.c_ISBLK",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const c_ISBLK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c_ISBLK = 060000 // Block special file\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#c_ISCHR",
              "documentation": {
                "identifier": "c_ISCHR",
                "newPage": false,
                "searchKey": "tar.c_ISCHR",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const c_ISCHR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c_ISCHR = 020000 // Character special file\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#c_ISDIR",
              "documentation": {
                "identifier": "c_ISDIR",
                "newPage": false,
                "searchKey": "tar.c_ISDIR",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const c_ISDIR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c_ISDIR = 040000 // Directory\n\n```\n\nCommon Unix mode constants; these are not defined in any common tar standard. Header.FileInfo understands these, but FileInfoHeader will never produce these. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#c_ISFIFO",
              "documentation": {
                "identifier": "c_ISFIFO",
                "newPage": false,
                "searchKey": "tar.c_ISFIFO",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const c_ISFIFO"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c_ISFIFO = 010000 // FIFO\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#c_ISGID",
              "documentation": {
                "identifier": "c_ISGID",
                "newPage": false,
                "searchKey": "tar.c_ISGID",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const c_ISGID"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c_ISGID = 02000 // Set gid\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#c_ISLNK",
              "documentation": {
                "identifier": "c_ISLNK",
                "newPage": false,
                "searchKey": "tar.c_ISLNK",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const c_ISLNK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c_ISLNK = 0120000 // Symbolic link\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#c_ISREG",
              "documentation": {
                "identifier": "c_ISREG",
                "newPage": false,
                "searchKey": "tar.c_ISREG",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const c_ISREG"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c_ISREG = 0100000 // Regular file\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#c_ISSOCK",
              "documentation": {
                "identifier": "c_ISSOCK",
                "newPage": false,
                "searchKey": "tar.c_ISSOCK",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const c_ISSOCK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c_ISSOCK = 0140000 // Socket\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#c_ISUID",
              "documentation": {
                "identifier": "c_ISUID",
                "newPage": false,
                "searchKey": "tar.c_ISUID",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const c_ISUID"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c_ISUID = 04000 // Set uid\n\n```\n\nMode constants from the USTAR spec: See [http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06](http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#c_ISVTX",
              "documentation": {
                "identifier": "c_ISVTX",
                "newPage": false,
                "searchKey": "tar.c_ISVTX",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const c_ISVTX"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c_ISVTX = 01000 // Save text (sticky bit)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#formatMax",
              "documentation": {
                "identifier": "formatMax",
                "newPage": false,
                "searchKey": "tar.formatMax",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const formatMax"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst formatMax\n```\n\nConstants to identify various tar formats. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#formatSTAR",
              "documentation": {
                "identifier": "formatSTAR",
                "newPage": false,
                "searchKey": "tar.formatSTAR",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const formatSTAR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst formatSTAR\n```\n\nConstants to identify various tar formats. \n\nSchily's tar format, which is incompatible with USTAR. This does not cover STAR extensions to the PAX format; these fall under the PAX format. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#formatV7",
              "documentation": {
                "identifier": "formatV7",
                "newPage": false,
                "searchKey": "tar.formatV7",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const formatV7"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst formatV7\n```\n\nConstants to identify various tar formats. \n\nThe format of the original Unix V7 tar tool prior to standardization. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#magicGNU",
              "documentation": {
                "identifier": "magicGNU",
                "newPage": false,
                "searchKey": "tar.magicGNU",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const magicGNU"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst magicGNU, versionGNU = \"ustar \", \" \\x00\"\n```\n\nMagics used to identify various formats. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#magicUSTAR",
              "documentation": {
                "identifier": "magicUSTAR",
                "newPage": false,
                "searchKey": "tar.magicUSTAR",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const magicUSTAR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst magicUSTAR, versionUSTAR = \"ustar\\x00\", \"00\"\n```\n\nMagics used to identify various formats. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#nameSize",
              "documentation": {
                "identifier": "nameSize",
                "newPage": false,
                "searchKey": "tar.nameSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const nameSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst nameSize = 100 // Max length of the name field in USTAR format\n\n```\n\nSize constants from various tar specifications. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxAtime",
              "documentation": {
                "identifier": "paxAtime",
                "newPage": false,
                "searchKey": "tar.paxAtime",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxAtime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxAtime = \"atime\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxCharset",
              "documentation": {
                "identifier": "paxCharset",
                "newPage": false,
                "searchKey": "tar.paxCharset",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxCharset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxCharset = \"charset\" // Currently unused\n\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxComment",
              "documentation": {
                "identifier": "paxComment",
                "newPage": false,
                "searchKey": "tar.paxComment",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxComment"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxComment = \"comment\" // Currently unused\n\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxCtime",
              "documentation": {
                "identifier": "paxCtime",
                "newPage": false,
                "searchKey": "tar.paxCtime",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxCtime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxCtime = \"ctime\" // Removed from later revision of PAX spec, but was valid\n\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGNUSparse",
              "documentation": {
                "identifier": "paxGNUSparse",
                "newPage": false,
                "searchKey": "tar.paxGNUSparse",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGNUSparse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGNUSparse = \"GNU.sparse.\"\n```\n\nKeywords for PAX extended header records. \n\nKeywords for GNU sparse files in a PAX extended header. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGNUSparseMajor",
              "documentation": {
                "identifier": "paxGNUSparseMajor",
                "newPage": false,
                "searchKey": "tar.paxGNUSparseMajor",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGNUSparseMajor"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGNUSparseMajor = \"GNU.sparse.major\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGNUSparseMap",
              "documentation": {
                "identifier": "paxGNUSparseMap",
                "newPage": false,
                "searchKey": "tar.paxGNUSparseMap",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGNUSparseMap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGNUSparseMap = \"GNU.sparse.map\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGNUSparseMinor",
              "documentation": {
                "identifier": "paxGNUSparseMinor",
                "newPage": false,
                "searchKey": "tar.paxGNUSparseMinor",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGNUSparseMinor"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGNUSparseMinor = \"GNU.sparse.minor\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGNUSparseName",
              "documentation": {
                "identifier": "paxGNUSparseName",
                "newPage": false,
                "searchKey": "tar.paxGNUSparseName",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGNUSparseName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGNUSparseName = \"GNU.sparse.name\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGNUSparseNumBlocks",
              "documentation": {
                "identifier": "paxGNUSparseNumBlocks",
                "newPage": false,
                "searchKey": "tar.paxGNUSparseNumBlocks",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGNUSparseNumBlocks"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGNUSparseNumBlocks = \"GNU.sparse.numblocks\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGNUSparseNumBytes",
              "documentation": {
                "identifier": "paxGNUSparseNumBytes",
                "newPage": false,
                "searchKey": "tar.paxGNUSparseNumBytes",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGNUSparseNumBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGNUSparseNumBytes = \"GNU.sparse.numbytes\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGNUSparseOffset",
              "documentation": {
                "identifier": "paxGNUSparseOffset",
                "newPage": false,
                "searchKey": "tar.paxGNUSparseOffset",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGNUSparseOffset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGNUSparseOffset = \"GNU.sparse.offset\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGNUSparseRealSize",
              "documentation": {
                "identifier": "paxGNUSparseRealSize",
                "newPage": false,
                "searchKey": "tar.paxGNUSparseRealSize",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGNUSparseRealSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGNUSparseRealSize = \"GNU.sparse.realsize\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGNUSparseSize",
              "documentation": {
                "identifier": "paxGNUSparseSize",
                "newPage": false,
                "searchKey": "tar.paxGNUSparseSize",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGNUSparseSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGNUSparseSize = \"GNU.sparse.size\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGid",
              "documentation": {
                "identifier": "paxGid",
                "newPage": false,
                "searchKey": "tar.paxGid",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGid = \"gid\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxGname",
              "documentation": {
                "identifier": "paxGname",
                "newPage": false,
                "searchKey": "tar.paxGname",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxGname"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxGname = \"gname\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxLinkpath",
              "documentation": {
                "identifier": "paxLinkpath",
                "newPage": false,
                "searchKey": "tar.paxLinkpath",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxLinkpath"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxLinkpath = \"linkpath\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxMtime",
              "documentation": {
                "identifier": "paxMtime",
                "newPage": false,
                "searchKey": "tar.paxMtime",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxMtime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxMtime = \"mtime\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxNone",
              "documentation": {
                "identifier": "paxNone",
                "newPage": false,
                "searchKey": "tar.paxNone",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxNone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxNone = \"\" // Indicates that no PAX key is suitable\n\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxPath",
              "documentation": {
                "identifier": "paxPath",
                "newPage": false,
                "searchKey": "tar.paxPath",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxPath"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxPath = \"path\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxSchilyXattr",
              "documentation": {
                "identifier": "paxSchilyXattr",
                "newPage": false,
                "searchKey": "tar.paxSchilyXattr",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxSchilyXattr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxSchilyXattr = \"SCHILY.xattr.\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxSize",
              "documentation": {
                "identifier": "paxSize",
                "newPage": false,
                "searchKey": "tar.paxSize",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxSize = \"size\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxUid",
              "documentation": {
                "identifier": "paxUid",
                "newPage": false,
                "searchKey": "tar.paxUid",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxUid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxUid = \"uid\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#paxUname",
              "documentation": {
                "identifier": "paxUname",
                "newPage": false,
                "searchKey": "tar.paxUname",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const paxUname"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst paxUname = \"uname\"\n```\n\nKeywords for PAX extended header records. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#prefixSize",
              "documentation": {
                "identifier": "prefixSize",
                "newPage": false,
                "searchKey": "tar.prefixSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const prefixSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst prefixSize = 155 // Max length of the prefix field in USTAR format\n\n```\n\nSize constants from various tar specifications. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#trailerSTAR",
              "documentation": {
                "identifier": "trailerSTAR",
                "newPage": false,
                "searchKey": "tar.trailerSTAR",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const trailerSTAR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst trailerSTAR = \"tar\\x00\"\n```\n\nMagics used to identify various formats. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#versionGNU",
              "documentation": {
                "identifier": "versionGNU",
                "newPage": false,
                "searchKey": "tar.versionGNU",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const versionGNU"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst magicGNU, versionGNU = \"ustar \", \" \\x00\"\n```\n\nMagics used to identify various formats. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#versionUSTAR",
              "documentation": {
                "identifier": "versionUSTAR",
                "newPage": false,
                "searchKey": "tar.versionUSTAR",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const versionUSTAR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst magicUSTAR, versionUSTAR = \"ustar\\x00\", \"00\"\n```\n\nMagics used to identify various formats. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/archive/tar#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/archive/tar#ErrFieldTooLong",
              "documentation": {
                "identifier": "ErrFieldTooLong",
                "newPage": false,
                "searchKey": "tar.ErrFieldTooLong",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrFieldTooLong"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrFieldTooLong = errors.New(\"archive/tar: header field too long\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#ErrHeader",
              "documentation": {
                "identifier": "ErrHeader",
                "newPage": false,
                "searchKey": "tar.ErrHeader",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrHeader"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrHeader = errors.New(\"archive/tar: invalid tar header\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#ErrWriteAfterClose",
              "documentation": {
                "identifier": "ErrWriteAfterClose",
                "newPage": false,
                "searchKey": "tar.ErrWriteAfterClose",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrWriteAfterClose"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrWriteAfterClose = errors.New(\"archive/tar: write after close\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#ErrWriteTooLong",
              "documentation": {
                "identifier": "ErrWriteTooLong",
                "newPage": false,
                "searchKey": "tar.ErrWriteTooLong",
                "tags": [
                  "variable",
                  "interface"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrWriteTooLong"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrWriteTooLong = errors.New(\"archive/tar: write too long\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#basicKeys",
              "documentation": {
                "identifier": "basicKeys",
                "newPage": false,
                "searchKey": "tar.basicKeys",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var basicKeys"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar basicKeys = ...\n```\n\nbasicKeys is a set of the PAX keys for which we have built-in support. This does not contain \"charset\" or \"comment\", which are both PAX-specific, so adding them as first-class features of Header is unlikely. Users can use the PAXRecords field to set it themselves. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#errMissData",
              "documentation": {
                "identifier": "errMissData",
                "newPage": false,
                "searchKey": "tar.errMissData",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errMissData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errMissData = errors.New(\"archive/tar: sparse file references non-existent data\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#errUnrefData",
              "documentation": {
                "identifier": "errUnrefData",
                "newPage": false,
                "searchKey": "tar.errUnrefData",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errUnrefData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errUnrefData = errors.New(\"archive/tar: sparse file contains unreferenced data\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#errWriteHole",
              "documentation": {
                "identifier": "errWriteHole",
                "newPage": false,
                "searchKey": "tar.errWriteHole",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errWriteHole"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errWriteHole = errors.New(\"archive/tar: write non-NUL byte in sparse hole\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#formatNames",
              "documentation": {
                "identifier": "formatNames",
                "newPage": false,
                "searchKey": "tar.formatNames",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var formatNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar formatNames = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#groupMap",
              "documentation": {
                "identifier": "groupMap",
                "newPage": false,
                "searchKey": "tar.groupMap",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var groupMap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar userMap, groupMap sync.Map // map[int]string\n\n```\n\nuserMap and groupMap caches UID and GID lookups for performance reasons. The downside is that renaming uname or gname by the OS never takes effect. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#sysStat",
              "documentation": {
                "identifier": "sysStat",
                "newPage": false,
                "searchKey": "tar.sysStat",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var sysStat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sysStat func(fi fs.FileInfo, h *Header) error\n```\n\nsysStat, if non-nil, populates h from system-dependent fields of fi. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#userMap",
              "documentation": {
                "identifier": "userMap",
                "newPage": false,
                "searchKey": "tar.userMap",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var userMap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar userMap, groupMap sync.Map // map[int]string\n\n```\n\nuserMap and groupMap caches UID and GID lookups for performance reasons. The downside is that renaming uname or gname by the OS never takes effect. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#zeroBlock",
              "documentation": {
                "identifier": "zeroBlock",
                "newPage": false,
                "searchKey": "tar.zeroBlock",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var zeroBlock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar zeroBlock block\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/archive/tar#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/archive/tar#Format",
              "documentation": {
                "identifier": "Format",
                "newPage": false,
                "searchKey": "tar.Format",
                "tags": [
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Format int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Format int\n```\n\nFormat represents the tar archive format. \n\nThe original tar format was introduced in Unix V7. Since then, there have been multiple competing formats attempting to standardize or extend the V7 format to overcome its limitations. The most common formats are the USTAR, PAX, and GNU formats, each with their own advantages and limitations. \n\nThe following table captures the capabilities of each format: \n\n```\n                  |  USTAR |       PAX |       GNU\n------------------+--------+-----------+----------\nName              |   256B | unlimited | unlimited\nLinkname          |   100B | unlimited | unlimited\nSize              | uint33 | unlimited |    uint89\nMode              | uint21 |    uint21 |    uint57\nUid/Gid           | uint21 | unlimited |    uint57\nUname/Gname       |    32B | unlimited |       32B\nModTime           | uint33 | unlimited |     int89\nAccessTime        |    n/a | unlimited |     int89\nChangeTime        |    n/a | unlimited |     int89\nDevmajor/Devminor | uint21 |    uint21 |    uint57\n------------------+--------+-----------+----------\nstring encoding   |  ASCII |     UTF-8 |    binary\nsub-second times  |     no |       yes |        no\nsparse files      |     no |       yes |       yes\n\n```\nThe table's upper portion shows the Header fields, where each format reports the maximum number of bytes allowed for each string field and the integer type used to store each numeric field (where timestamps are stored as the number of seconds since the Unix epoch). \n\nThe table's lower portion shows specialized features of each format, such as supported string encodings, support for sub-second timestamps, or support for sparse files. \n\nThe Writer currently provides no support for sparse files. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#Format.String",
                    "documentation": {
                      "identifier": "Format.String",
                      "newPage": false,
                      "searchKey": "tar.Format.String",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f Format) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f Format) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Format.has",
                    "documentation": {
                      "identifier": "Format.has",
                      "newPage": false,
                      "searchKey": "tar.Format.has",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f Format) has(f2 Format) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f Format) has(f2 Format) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Format.mayBe",
                    "documentation": {
                      "identifier": "Format.mayBe",
                      "newPage": false,
                      "searchKey": "tar.Format.mayBe",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *Format) mayBe(f2 Format)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *Format) mayBe(f2 Format)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Format.mayOnlyBe",
                    "documentation": {
                      "identifier": "Format.mayOnlyBe",
                      "newPage": false,
                      "searchKey": "tar.Format.mayOnlyBe",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *Format) mayOnlyBe(f2 Format)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *Format) mayOnlyBe(f2 Format)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Format.mustNotBe",
                    "documentation": {
                      "identifier": "Format.mustNotBe",
                      "newPage": false,
                      "searchKey": "tar.Format.mustNotBe",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *Format) mustNotBe(f2 Format)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *Format) mustNotBe(f2 Format)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#Header",
              "documentation": {
                "identifier": "Header",
                "newPage": false,
                "searchKey": "tar.Header",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Header struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Header struct {\n\t// Typeflag is the type of header entry.\n\t// The zero value is automatically promoted to either TypeReg or TypeDir\n\t// depending on the presence of a trailing slash in Name.\n\tTypeflag byte\n\n\tName     string // Name of file entry\n\tLinkname string // Target name of link (valid for TypeLink or TypeSymlink)\n\n\tSize  int64  // Logical file size in bytes\n\tMode  int64  // Permission and mode bits\n\tUid   int    // User ID of owner\n\tGid   int    // Group ID of owner\n\tUname string // User name of owner\n\tGname string // Group name of owner\n\n\t// If the Format is unspecified, then Writer.WriteHeader rounds ModTime\n\t// to the nearest second and ignores the AccessTime and ChangeTime fields.\n\t//\n\t// To use AccessTime or ChangeTime, specify the Format as PAX or GNU.\n\t// To use sub-second resolution, specify the Format as PAX.\n\tModTime    time.Time // Modification time\n\tAccessTime time.Time // Access time (requires either PAX or GNU support)\n\tChangeTime time.Time // Change time (requires either PAX or GNU support)\n\n\tDevmajor int64 // Major device number (valid for TypeChar or TypeBlock)\n\tDevminor int64 // Minor device number (valid for TypeChar or TypeBlock)\n\n\t// Xattrs stores extended attributes as PAX records under the\n\t// \"SCHILY.xattr.\" namespace.\n\t//\n\t// The following are semantically equivalent:\n\t//  h.Xattrs[key] = value\n\t//  h.PAXRecords[\"SCHILY.xattr.\"+key] = value\n\t//\n\t// When Writer.WriteHeader is called, the contents of Xattrs will take\n\t// precedence over those in PAXRecords.\n\t//\n\t// Deprecated: Use PAXRecords instead.\n\tXattrs map[string]string\n\n\t// PAXRecords is a map of PAX extended header records.\n\t//\n\t// User-defined records should have keys of the following form:\n\t//\tVENDOR.keyword\n\t// Where VENDOR is some namespace in all uppercase, and keyword may\n\t// not contain the '=' character (e.g., \"GOLANG.pkg.version\").\n\t// The key and value should be non-empty UTF-8 strings.\n\t//\n\t// When Writer.WriteHeader is called, PAX records derived from the\n\t// other fields in Header take precedence over PAXRecords.\n\tPAXRecords map[string]string\n\n\t// Format specifies the format of the tar header.\n\t//\n\t// This is set by Reader.Next as a best-effort guess at the format.\n\t// Since the Reader liberally reads some non-compliant files,\n\t// it is possible for this to be FormatUnknown.\n\t//\n\t// If the format is unspecified when Writer.WriteHeader is called,\n\t// then it uses the first format (in the order of USTAR, PAX, GNU)\n\t// capable of encoding this Header (see Format).\n\tFormat Format\n}\n```\n\nA Header represents a single header in a tar archive. Some fields may not be populated. \n\nFor forward compatibility, users that retrieve a Header from Reader.Next, mutate it in some ways, and then pass it back to Writer.WriteHeader should do so by creating a new Header and copying the fields that they are interested in preserving. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#FileInfoHeader",
                    "documentation": {
                      "identifier": "FileInfoHeader",
                      "newPage": false,
                      "searchKey": "tar.FileInfoHeader",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FileInfoHeader(fi fs.FileInfo, link string) (*Header, error)\n```\n\nFileInfoHeader creates a partially-populated Header from fi. If fi describes a symlink, FileInfoHeader records link as the link target. If fi describes a directory, a slash is appended to the name. \n\nSince fs.FileInfo's Name method only returns the base name of the file it describes, it may be necessary to modify Header.Name to provide the full path name of the file. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Header.FileInfo",
                    "documentation": {
                      "identifier": "Header.FileInfo",
                      "newPage": false,
                      "searchKey": "tar.Header.FileInfo",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *Header) FileInfo() fs.FileInfo"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *Header) FileInfo() fs.FileInfo\n```\n\nFileInfo returns an fs.FileInfo for the Header. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Header.allowedFormats",
                    "documentation": {
                      "identifier": "Header.allowedFormats",
                      "newPage": false,
                      "searchKey": "tar.Header.allowedFormats",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h Header) allowedFormats() (format Format, paxHdrs map[string]string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h Header) allowedFormats() (format Format, paxHdrs map[string]string, err error)\n```\n\nallowedFormats determines which formats can be used. The value returned is the logical OR of multiple possible formats. If the value is FormatUnknown, then the input Header cannot be encoded and an error is returned explaining why. \n\nAs a by-product of checking the fields, this function returns paxHdrs, which contain all fields that could not be directly encoded. A value receiver ensures that this method does not mutate the source Header. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#Reader",
              "documentation": {
                "identifier": "Reader",
                "newPage": false,
                "searchKey": "tar.Reader",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Reader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Reader struct {\n\tr    io.Reader\n\tpad  int64      // Amount of padding (ignored) after current file entry\n\tcurr fileReader // Reader for current file entry\n\tblk  block      // Buffer to use as temporary local storage\n\n\t// err is a persistent error.\n\t// It is only the responsibility of every exported method of Reader to\n\t// ensure that this error is sticky.\n\terr error\n}\n```\n\nReader provides sequential access to the contents of a tar archive. Reader.Next advances to the next file in the archive (including the first), and then Reader can be treated as an io.Reader to access the file's data. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#NewReader",
                    "documentation": {
                      "identifier": "NewReader",
                      "newPage": false,
                      "searchKey": "tar.NewReader",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewReader(r io.Reader) *Reader"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewReader(r io.Reader) *Reader\n```\n\nNewReader creates a new Reader reading from r. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Reader.Next",
                    "documentation": {
                      "identifier": "Reader.Next",
                      "newPage": false,
                      "searchKey": "tar.Reader.Next",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *Reader) Next() (*Header, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *Reader) Next() (*Header, error)\n```\n\nNext advances to the next entry in the tar archive. The Header.Size determines how many bytes can be read for the next file. Any remaining data in the current file is automatically discarded. \n\nio.EOF is returned at the end of the input. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Reader.Read",
                    "documentation": {
                      "identifier": "Reader.Read",
                      "newPage": false,
                      "searchKey": "tar.Reader.Read",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *Reader) Read(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *Reader) Read(b []byte) (int, error)\n```\n\nRead reads from the current file in the tar archive. It returns (0, io.EOF) when it reaches the end of that file, until Next is called to advance to the next file. \n\nIf the current file is sparse, then the regions marked as a hole are read back as NUL-bytes. \n\nCalling Read on special types like TypeLink, TypeSymlink, TypeChar, TypeBlock, TypeDir, and TypeFifo returns (0, io.EOF) regardless of what the Header.Size claims. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Reader.handleRegularFile",
                    "documentation": {
                      "identifier": "Reader.handleRegularFile",
                      "newPage": false,
                      "searchKey": "tar.Reader.handleRegularFile",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *Reader) handleRegularFile(hdr *Header) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *Reader) handleRegularFile(hdr *Header) error\n```\n\nhandleRegularFile sets up the current file reader and padding such that it can only read the following logical data section. It will properly handle special headers that contain no data section. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Reader.handleSparseFile",
                    "documentation": {
                      "identifier": "Reader.handleSparseFile",
                      "newPage": false,
                      "searchKey": "tar.Reader.handleSparseFile",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *Reader) handleSparseFile(hdr *Header, rawHdr *block) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *Reader) handleSparseFile(hdr *Header, rawHdr *block) error\n```\n\nhandleSparseFile checks if the current file is a sparse format of any type and sets the curr reader appropriately. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Reader.next",
                    "documentation": {
                      "identifier": "Reader.next",
                      "newPage": false,
                      "searchKey": "tar.Reader.next",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *Reader) next() (*Header, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *Reader) next() (*Header, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Reader.readGNUSparsePAXHeaders",
                    "documentation": {
                      "identifier": "Reader.readGNUSparsePAXHeaders",
                      "newPage": false,
                      "searchKey": "tar.Reader.readGNUSparsePAXHeaders",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *Reader) readGNUSparsePAXHeaders(hdr *Header) (sparseDatas, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *Reader) readGNUSparsePAXHeaders(hdr *Header) (sparseDatas, error)\n```\n\nreadGNUSparsePAXHeaders checks the PAX headers for GNU sparse headers. If they are found, then this function reads the sparse map and returns it. This assumes that 0.0 headers have already been converted to 0.1 headers by the PAX header parsing logic. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Reader.readHeader",
                    "documentation": {
                      "identifier": "Reader.readHeader",
                      "newPage": false,
                      "searchKey": "tar.Reader.readHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *Reader) readHeader() (*Header, *block, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *Reader) readHeader() (*Header, *block, error)\n```\n\nreadHeader reads the next block header and assumes that the underlying reader is already aligned to a block boundary. It returns the raw block of the header in case further processing is required. \n\nThe err will be set to io.EOF only when one of the following occurs: \n\n```\n* Exactly 0 bytes are read and EOF is hit.\n* Exactly 1 block of zeros is read and EOF is hit.\n* At least 2 blocks of zeros are read.\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Reader.readOldGNUSparseMap",
                    "documentation": {
                      "identifier": "Reader.readOldGNUSparseMap",
                      "newPage": false,
                      "searchKey": "tar.Reader.readOldGNUSparseMap",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *Reader) readOldGNUSparseMap(hdr *Header, blk *block) (sparseDatas, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *Reader) readOldGNUSparseMap(hdr *Header, blk *block) (sparseDatas, error)\n```\n\nreadOldGNUSparseMap reads the sparse map from the old GNU sparse format. The sparse map is stored in the tar header if it's small enough. If it's larger than four entries, then one or more extension headers are used to store the rest of the sparse map. \n\nThe Header.Size does not reflect the size of any extended headers used. Thus, this function will read from the raw io.Reader to fetch extra headers. This method mutates blk in the process. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Reader.writeTo",
                    "documentation": {
                      "identifier": "Reader.writeTo",
                      "newPage": false,
                      "searchKey": "tar.Reader.writeTo",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tr *Reader) writeTo(w io.Writer) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tr *Reader) writeTo(w io.Writer) (int64, error)\n```\n\nwriteTo writes the content of the current file to w. The bytes written matches the number of remaining bytes in the current file. \n\nIf the current file is sparse and w is an io.WriteSeeker, then writeTo uses Seek to skip past holes defined in Header.SparseHoles, assuming that skipped regions are filled with NULs. This always writes the last byte to ensure w is the right size. \n\nTODO(dsnet): Re-export this when adding sparse file support. See [https://golang.org/issue/22735](https://golang.org/issue/22735) \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#Writer",
              "documentation": {
                "identifier": "Writer",
                "newPage": false,
                "searchKey": "tar.Writer",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Writer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Writer struct {\n\tw    io.Writer\n\tpad  int64      // Amount of padding to write after current file entry\n\tcurr fileWriter // Writer for current file entry\n\thdr  Header     // Shallow copy of Header that is safe for mutations\n\tblk  block      // Buffer to use as temporary local storage\n\n\t// err is a persistent error.\n\t// It is only the responsibility of every exported method of Writer to\n\t// ensure that this error is sticky.\n\terr error\n}\n```\n\nWriter provides sequential writing of a tar archive. Write.WriteHeader begins a new file with the provided Header, and then Writer can be treated as an io.Writer to supply that file's data. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#NewWriter",
                    "documentation": {
                      "identifier": "NewWriter",
                      "newPage": false,
                      "searchKey": "tar.NewWriter",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewWriter(w io.Writer) *Writer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewWriter(w io.Writer) *Writer\n```\n\nNewWriter creates a new Writer writing to w. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Writer.Close",
                    "documentation": {
                      "identifier": "Writer.Close",
                      "newPage": false,
                      "searchKey": "tar.Writer.Close",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *Writer) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *Writer) Close() error\n```\n\nClose closes the tar archive by flushing the padding, and writing the footer. If the current file (from a prior call to WriteHeader) is not fully written, then this returns an error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Writer.Flush",
                    "documentation": {
                      "identifier": "Writer.Flush",
                      "newPage": false,
                      "searchKey": "tar.Writer.Flush",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *Writer) Flush() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *Writer) Flush() error\n```\n\nFlush finishes writing the current file's block padding. The current file must be fully written before Flush can be called. \n\nThis is unnecessary as the next call to WriteHeader or Close will implicitly flush out the file's padding. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Writer.Write",
                    "documentation": {
                      "identifier": "Writer.Write",
                      "newPage": false,
                      "searchKey": "tar.Writer.Write",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *Writer) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *Writer) Write(b []byte) (int, error)\n```\n\nWrite writes to the current file in the tar archive. Write returns the error ErrWriteTooLong if more than Header.Size bytes are written after WriteHeader. \n\nCalling Write on special types like TypeLink, TypeSymlink, TypeChar, TypeBlock, TypeDir, and TypeFifo returns (0, ErrWriteTooLong) regardless of what the Header.Size claims. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Writer.WriteHeader",
                    "documentation": {
                      "identifier": "Writer.WriteHeader",
                      "newPage": false,
                      "searchKey": "tar.Writer.WriteHeader",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *Writer) WriteHeader(hdr *Header) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *Writer) WriteHeader(hdr *Header) error\n```\n\nWriteHeader writes hdr and prepares to accept the file's contents. The Header.Size determines how many bytes can be written for the next file. If the current file is not fully written, then this returns an error. This implicitly flushes any padding necessary before writing the header. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Writer.readFrom",
                    "documentation": {
                      "identifier": "Writer.readFrom",
                      "newPage": false,
                      "searchKey": "tar.Writer.readFrom",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *Writer) readFrom(r io.Reader) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *Writer) readFrom(r io.Reader) (int64, error)\n```\n\nreadFrom populates the content of the current file by reading from r. The bytes read must match the number of remaining bytes in the current file. \n\nIf the current file is sparse and r is an io.ReadSeeker, then readFrom uses Seek to skip past holes defined in Header.SparseHoles, assuming that skipped regions are all NULs. This always reads the last byte to ensure r is the right size. \n\nTODO(dsnet): Re-export this when adding sparse file support. See [https://golang.org/issue/22735](https://golang.org/issue/22735) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Writer.templateV7Plus",
                    "documentation": {
                      "identifier": "Writer.templateV7Plus",
                      "newPage": false,
                      "searchKey": "tar.Writer.templateV7Plus",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *Writer) templateV7Plus(hdr *Header, fmtStr stringFormatter, fmtNum numberFormatter) *block"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *Writer) templateV7Plus(hdr *Header, fmtStr stringFormatter, fmtNum numberFormatter) *block\n```\n\ntemplateV7Plus fills out the V7 fields of a block using values from hdr. It also fills out fields (uname, gname, devmajor, devminor) that are shared in the USTAR, PAX, and GNU formats using the provided formatters. \n\nThe block returned is only valid until the next call to templateV7Plus or writeRawFile. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Writer.writeGNUHeader",
                    "documentation": {
                      "identifier": "Writer.writeGNUHeader",
                      "newPage": false,
                      "searchKey": "tar.Writer.writeGNUHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *Writer) writeGNUHeader(hdr *Header) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *Writer) writeGNUHeader(hdr *Header) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Writer.writePAXHeader",
                    "documentation": {
                      "identifier": "Writer.writePAXHeader",
                      "newPage": false,
                      "searchKey": "tar.Writer.writePAXHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *Writer) writePAXHeader(hdr *Header, paxHdrs map[string]string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *Writer) writePAXHeader(hdr *Header, paxHdrs map[string]string) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Writer.writeRawFile",
                    "documentation": {
                      "identifier": "Writer.writeRawFile",
                      "newPage": false,
                      "searchKey": "tar.Writer.writeRawFile",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *Writer) writeRawFile(name, data string, flag byte, format Format) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *Writer) writeRawFile(name, data string, flag byte, format Format) error\n```\n\nwriteRawFile writes a minimal file with the given name and flag type. It uses format to encode the header format and will write data as the body. It uses default values for all of the other fields (as BSD and GNU tar does). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Writer.writeRawHeader",
                    "documentation": {
                      "identifier": "Writer.writeRawHeader",
                      "newPage": false,
                      "searchKey": "tar.Writer.writeRawHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *Writer) writeRawHeader(blk *block, size int64, flag byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *Writer) writeRawHeader(blk *block, size int64, flag byte) error\n```\n\nwriteRawHeader writes the value of blk, regardless of its value. It sets up the Writer such that it can accept a file of the given size. If the flag is a special header-only flag, then the size is treated as zero. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#Writer.writeUSTARHeader",
                    "documentation": {
                      "identifier": "Writer.writeUSTARHeader",
                      "newPage": false,
                      "searchKey": "tar.Writer.writeUSTARHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tw *Writer) writeUSTARHeader(hdr *Header) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tw *Writer) writeUSTARHeader(hdr *Header) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#block",
              "documentation": {
                "identifier": "block",
                "newPage": false,
                "searchKey": "tar.block",
                "tags": [
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type block [512]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype block [blockSize]byte\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#block.ComputeChecksum",
                    "documentation": {
                      "identifier": "block.ComputeChecksum",
                      "newPage": false,
                      "searchKey": "tar.block.ComputeChecksum",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) ComputeChecksum() (unsigned, signed int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) ComputeChecksum() (unsigned, signed int64)\n```\n\nComputeChecksum computes the checksum for the header block. POSIX specifies a sum of the unsigned byte values, but the Sun tar used signed byte values. We compute and return both. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#block.GNU",
                    "documentation": {
                      "identifier": "block.GNU",
                      "newPage": false,
                      "searchKey": "tar.block.GNU",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) GNU() *headerGNU"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) GNU() *headerGNU\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#block.GetFormat",
                    "documentation": {
                      "identifier": "block.GetFormat",
                      "newPage": false,
                      "searchKey": "tar.block.GetFormat",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) GetFormat() Format"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) GetFormat() Format\n```\n\nGetFormat checks that the block is a valid tar header based on the checksum. It then attempts to guess the specific format based on magic values. If the checksum fails, then FormatUnknown is returned. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#block.Reset",
                    "documentation": {
                      "identifier": "block.Reset",
                      "newPage": false,
                      "searchKey": "tar.block.Reset",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) Reset()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) Reset()\n```\n\nReset clears the block with all zeros. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#block.STAR",
                    "documentation": {
                      "identifier": "block.STAR",
                      "newPage": false,
                      "searchKey": "tar.block.STAR",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) STAR() *headerSTAR"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) STAR() *headerSTAR\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#block.SetFormat",
                    "documentation": {
                      "identifier": "block.SetFormat",
                      "newPage": false,
                      "searchKey": "tar.block.SetFormat",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) SetFormat(format Format)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) SetFormat(format Format)\n```\n\nSetFormat writes the magic values necessary for specified format and then updates the checksum accordingly. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#block.Sparse",
                    "documentation": {
                      "identifier": "block.Sparse",
                      "newPage": false,
                      "searchKey": "tar.block.Sparse",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) Sparse() sparseArray"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) Sparse() sparseArray\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#block.USTAR",
                    "documentation": {
                      "identifier": "block.USTAR",
                      "newPage": false,
                      "searchKey": "tar.block.USTAR",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) USTAR() *headerUSTAR"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) USTAR() *headerUSTAR\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#block.V7",
                    "documentation": {
                      "identifier": "block.V7",
                      "newPage": false,
                      "searchKey": "tar.block.V7",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *block) V7() *headerV7"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *block) V7() *headerV7\n```\n\nConvert block to any number of formats. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#failOnceWriter",
              "documentation": {
                "identifier": "failOnceWriter",
                "newPage": false,
                "searchKey": "tar.failOnceWriter",
                "tags": [
                  "boolean",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type failOnceWriter bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype failOnceWriter bool\n```\n\nfailOnceWriter fails exactly once and then always reports success. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#failOnceWriter.Write",
                    "documentation": {
                      "identifier": "failOnceWriter.Write",
                      "newPage": false,
                      "searchKey": "tar.failOnceWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *failOnceWriter) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *failOnceWriter) Write(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#fileOps",
              "documentation": {
                "identifier": "fileOps",
                "newPage": false,
                "searchKey": "tar.fileOps",
                "tags": [
                  "array",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type fileOps []interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fileOps []interface{} // []T where T is (string | int64)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#fileReader",
              "documentation": {
                "identifier": "fileReader",
                "newPage": false,
                "searchKey": "tar.fileReader",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type fileReader interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fileReader interface {\n\tio.Reader\n\tfileState\n\n\tWriteTo(io.Writer) (int64, error)\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#fileState",
              "documentation": {
                "identifier": "fileState",
                "newPage": false,
                "searchKey": "tar.fileState",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type fileState interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fileState interface {\n\tLogicalRemaining() int64\n\tPhysicalRemaining() int64\n}\n```\n\nfileState tracks the number of logical (includes sparse holes) and physical (actual in tar archive) bytes remaining for the current file. \n\nInvariant: LogicalRemaining >= PhysicalRemaining \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#fileWriter",
              "documentation": {
                "identifier": "fileWriter",
                "newPage": false,
                "searchKey": "tar.fileWriter",
                "tags": [
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type fileWriter interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fileWriter interface {\n\tio.Writer\n\tfileState\n\n\tReadFrom(io.Reader) (int64, error)\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#formatter",
              "documentation": {
                "identifier": "formatter",
                "newPage": false,
                "searchKey": "tar.formatter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type formatter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype formatter struct {\n\terr error // Last error seen\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#formatter.formatNumeric",
                    "documentation": {
                      "identifier": "formatter.formatNumeric",
                      "newPage": false,
                      "searchKey": "tar.formatter.formatNumeric",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *formatter) formatNumeric(b []byte, x int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *formatter) formatNumeric(b []byte, x int64)\n```\n\nformatNumeric encodes x into b using base-8 (octal) encoding if possible. Otherwise it will attempt to use base-256 (binary) encoding. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#formatter.formatOctal",
                    "documentation": {
                      "identifier": "formatter.formatOctal",
                      "newPage": false,
                      "searchKey": "tar.formatter.formatOctal",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *formatter) formatOctal(b []byte, x int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *formatter) formatOctal(b []byte, x int64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#formatter.formatString",
                    "documentation": {
                      "identifier": "formatter.formatString",
                      "newPage": false,
                      "searchKey": "tar.formatter.formatString",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *formatter) formatString(b []byte, s string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *formatter) formatString(b []byte, s string)\n```\n\nformatString copies s into b, NUL-terminating if possible. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#headerError",
              "documentation": {
                "identifier": "headerError",
                "newPage": false,
                "searchKey": "tar.headerError",
                "tags": [
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type headerError []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype headerError []string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#headerError.Error",
                    "documentation": {
                      "identifier": "headerError.Error",
                      "newPage": false,
                      "searchKey": "tar.headerError.Error",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (he headerError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (he headerError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#headerFileInfo",
              "documentation": {
                "identifier": "headerFileInfo",
                "newPage": false,
                "searchKey": "tar.headerFileInfo",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type headerFileInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype headerFileInfo struct {\n\th *Header\n}\n```\n\nheaderFileInfo implements fs.FileInfo. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#headerFileInfo.IsDir",
                    "documentation": {
                      "identifier": "headerFileInfo.IsDir",
                      "newPage": false,
                      "searchKey": "tar.headerFileInfo.IsDir",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fi headerFileInfo) IsDir() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fi headerFileInfo) IsDir() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerFileInfo.ModTime",
                    "documentation": {
                      "identifier": "headerFileInfo.ModTime",
                      "newPage": false,
                      "searchKey": "tar.headerFileInfo.ModTime",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fi headerFileInfo) ModTime() time.Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fi headerFileInfo) ModTime() time.Time\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerFileInfo.Mode",
                    "documentation": {
                      "identifier": "headerFileInfo.Mode",
                      "newPage": false,
                      "searchKey": "tar.headerFileInfo.Mode",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fi headerFileInfo) Mode() (mode fs.FileMode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fi headerFileInfo) Mode() (mode fs.FileMode)\n```\n\nMode returns the permission and mode bits for the headerFileInfo. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerFileInfo.Name",
                    "documentation": {
                      "identifier": "headerFileInfo.Name",
                      "newPage": false,
                      "searchKey": "tar.headerFileInfo.Name",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fi headerFileInfo) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fi headerFileInfo) Name() string\n```\n\nName returns the base name of the file. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerFileInfo.Size",
                    "documentation": {
                      "identifier": "headerFileInfo.Size",
                      "newPage": false,
                      "searchKey": "tar.headerFileInfo.Size",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fi headerFileInfo) Size() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fi headerFileInfo) Size() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerFileInfo.Sys",
                    "documentation": {
                      "identifier": "headerFileInfo.Sys",
                      "newPage": false,
                      "searchKey": "tar.headerFileInfo.Sys",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fi headerFileInfo) Sys() interface{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fi headerFileInfo) Sys() interface{}\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#headerGNU",
              "documentation": {
                "identifier": "headerGNU",
                "newPage": false,
                "searchKey": "tar.headerGNU",
                "tags": [
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type headerGNU [512]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype headerGNU [blockSize]byte\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#headerGNU.AccessTime",
                    "documentation": {
                      "identifier": "headerGNU.AccessTime",
                      "newPage": false,
                      "searchKey": "tar.headerGNU.AccessTime",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerGNU) AccessTime() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerGNU) AccessTime() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerGNU.ChangeTime",
                    "documentation": {
                      "identifier": "headerGNU.ChangeTime",
                      "newPage": false,
                      "searchKey": "tar.headerGNU.ChangeTime",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerGNU) ChangeTime() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerGNU) ChangeTime() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerGNU.DevMajor",
                    "documentation": {
                      "identifier": "headerGNU.DevMajor",
                      "newPage": false,
                      "searchKey": "tar.headerGNU.DevMajor",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerGNU) DevMajor() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerGNU) DevMajor() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerGNU.DevMinor",
                    "documentation": {
                      "identifier": "headerGNU.DevMinor",
                      "newPage": false,
                      "searchKey": "tar.headerGNU.DevMinor",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerGNU) DevMinor() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerGNU) DevMinor() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerGNU.GroupName",
                    "documentation": {
                      "identifier": "headerGNU.GroupName",
                      "newPage": false,
                      "searchKey": "tar.headerGNU.GroupName",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerGNU) GroupName() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerGNU) GroupName() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerGNU.Magic",
                    "documentation": {
                      "identifier": "headerGNU.Magic",
                      "newPage": false,
                      "searchKey": "tar.headerGNU.Magic",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerGNU) Magic() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerGNU) Magic() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerGNU.RealSize",
                    "documentation": {
                      "identifier": "headerGNU.RealSize",
                      "newPage": false,
                      "searchKey": "tar.headerGNU.RealSize",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerGNU) RealSize() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerGNU) RealSize() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerGNU.Sparse",
                    "documentation": {
                      "identifier": "headerGNU.Sparse",
                      "newPage": false,
                      "searchKey": "tar.headerGNU.Sparse",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerGNU) Sparse() sparseArray"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerGNU) Sparse() sparseArray\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerGNU.UserName",
                    "documentation": {
                      "identifier": "headerGNU.UserName",
                      "newPage": false,
                      "searchKey": "tar.headerGNU.UserName",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerGNU) UserName() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerGNU) UserName() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerGNU.V7",
                    "documentation": {
                      "identifier": "headerGNU.V7",
                      "newPage": false,
                      "searchKey": "tar.headerGNU.V7",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerGNU) V7() *headerV7"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerGNU) V7() *headerV7\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerGNU.Version",
                    "documentation": {
                      "identifier": "headerGNU.Version",
                      "newPage": false,
                      "searchKey": "tar.headerGNU.Version",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerGNU) Version() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerGNU) Version() []byte\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#headerRoundTripTest",
              "documentation": {
                "identifier": "headerRoundTripTest",
                "newPage": false,
                "searchKey": "tar.headerRoundTripTest",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type headerRoundTripTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype headerRoundTripTest struct {\n\th  *Header\n\tfm fs.FileMode\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#headerSTAR",
              "documentation": {
                "identifier": "headerSTAR",
                "newPage": false,
                "searchKey": "tar.headerSTAR",
                "tags": [
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type headerSTAR [512]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype headerSTAR [blockSize]byte\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#headerSTAR.AccessTime",
                    "documentation": {
                      "identifier": "headerSTAR.AccessTime",
                      "newPage": false,
                      "searchKey": "tar.headerSTAR.AccessTime",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerSTAR) AccessTime() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerSTAR) AccessTime() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerSTAR.ChangeTime",
                    "documentation": {
                      "identifier": "headerSTAR.ChangeTime",
                      "newPage": false,
                      "searchKey": "tar.headerSTAR.ChangeTime",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerSTAR) ChangeTime() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerSTAR) ChangeTime() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerSTAR.DevMajor",
                    "documentation": {
                      "identifier": "headerSTAR.DevMajor",
                      "newPage": false,
                      "searchKey": "tar.headerSTAR.DevMajor",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerSTAR) DevMajor() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerSTAR) DevMajor() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerSTAR.DevMinor",
                    "documentation": {
                      "identifier": "headerSTAR.DevMinor",
                      "newPage": false,
                      "searchKey": "tar.headerSTAR.DevMinor",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerSTAR) DevMinor() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerSTAR) DevMinor() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerSTAR.GroupName",
                    "documentation": {
                      "identifier": "headerSTAR.GroupName",
                      "newPage": false,
                      "searchKey": "tar.headerSTAR.GroupName",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerSTAR) GroupName() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerSTAR) GroupName() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerSTAR.Magic",
                    "documentation": {
                      "identifier": "headerSTAR.Magic",
                      "newPage": false,
                      "searchKey": "tar.headerSTAR.Magic",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerSTAR) Magic() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerSTAR) Magic() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerSTAR.Prefix",
                    "documentation": {
                      "identifier": "headerSTAR.Prefix",
                      "newPage": false,
                      "searchKey": "tar.headerSTAR.Prefix",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerSTAR) Prefix() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerSTAR) Prefix() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerSTAR.Trailer",
                    "documentation": {
                      "identifier": "headerSTAR.Trailer",
                      "newPage": false,
                      "searchKey": "tar.headerSTAR.Trailer",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerSTAR) Trailer() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerSTAR) Trailer() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerSTAR.UserName",
                    "documentation": {
                      "identifier": "headerSTAR.UserName",
                      "newPage": false,
                      "searchKey": "tar.headerSTAR.UserName",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerSTAR) UserName() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerSTAR) UserName() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerSTAR.V7",
                    "documentation": {
                      "identifier": "headerSTAR.V7",
                      "newPage": false,
                      "searchKey": "tar.headerSTAR.V7",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerSTAR) V7() *headerV7"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerSTAR) V7() *headerV7\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerSTAR.Version",
                    "documentation": {
                      "identifier": "headerSTAR.Version",
                      "newPage": false,
                      "searchKey": "tar.headerSTAR.Version",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerSTAR) Version() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerSTAR) Version() []byte\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#headerUSTAR",
              "documentation": {
                "identifier": "headerUSTAR",
                "newPage": false,
                "searchKey": "tar.headerUSTAR",
                "tags": [
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type headerUSTAR [512]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype headerUSTAR [blockSize]byte\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#headerUSTAR.DevMajor",
                    "documentation": {
                      "identifier": "headerUSTAR.DevMajor",
                      "newPage": false,
                      "searchKey": "tar.headerUSTAR.DevMajor",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerUSTAR) DevMajor() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerUSTAR) DevMajor() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerUSTAR.DevMinor",
                    "documentation": {
                      "identifier": "headerUSTAR.DevMinor",
                      "newPage": false,
                      "searchKey": "tar.headerUSTAR.DevMinor",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerUSTAR) DevMinor() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerUSTAR) DevMinor() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerUSTAR.GroupName",
                    "documentation": {
                      "identifier": "headerUSTAR.GroupName",
                      "newPage": false,
                      "searchKey": "tar.headerUSTAR.GroupName",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerUSTAR) GroupName() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerUSTAR) GroupName() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerUSTAR.Magic",
                    "documentation": {
                      "identifier": "headerUSTAR.Magic",
                      "newPage": false,
                      "searchKey": "tar.headerUSTAR.Magic",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerUSTAR) Magic() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerUSTAR) Magic() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerUSTAR.Prefix",
                    "documentation": {
                      "identifier": "headerUSTAR.Prefix",
                      "newPage": false,
                      "searchKey": "tar.headerUSTAR.Prefix",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerUSTAR) Prefix() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerUSTAR) Prefix() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerUSTAR.UserName",
                    "documentation": {
                      "identifier": "headerUSTAR.UserName",
                      "newPage": false,
                      "searchKey": "tar.headerUSTAR.UserName",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerUSTAR) UserName() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerUSTAR) UserName() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerUSTAR.V7",
                    "documentation": {
                      "identifier": "headerUSTAR.V7",
                      "newPage": false,
                      "searchKey": "tar.headerUSTAR.V7",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerUSTAR) V7() *headerV7"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerUSTAR) V7() *headerV7\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerUSTAR.Version",
                    "documentation": {
                      "identifier": "headerUSTAR.Version",
                      "newPage": false,
                      "searchKey": "tar.headerUSTAR.Version",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerUSTAR) Version() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerUSTAR) Version() []byte\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#headerV7",
              "documentation": {
                "identifier": "headerV7",
                "newPage": false,
                "searchKey": "tar.headerV7",
                "tags": [
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type headerV7 [512]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype headerV7 [blockSize]byte\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#headerV7.Chksum",
                    "documentation": {
                      "identifier": "headerV7.Chksum",
                      "newPage": false,
                      "searchKey": "tar.headerV7.Chksum",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerV7) Chksum() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerV7) Chksum() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerV7.GID",
                    "documentation": {
                      "identifier": "headerV7.GID",
                      "newPage": false,
                      "searchKey": "tar.headerV7.GID",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerV7) GID() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerV7) GID() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerV7.LinkName",
                    "documentation": {
                      "identifier": "headerV7.LinkName",
                      "newPage": false,
                      "searchKey": "tar.headerV7.LinkName",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerV7) LinkName() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerV7) LinkName() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerV7.ModTime",
                    "documentation": {
                      "identifier": "headerV7.ModTime",
                      "newPage": false,
                      "searchKey": "tar.headerV7.ModTime",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerV7) ModTime() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerV7) ModTime() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerV7.Mode",
                    "documentation": {
                      "identifier": "headerV7.Mode",
                      "newPage": false,
                      "searchKey": "tar.headerV7.Mode",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerV7) Mode() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerV7) Mode() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerV7.Name",
                    "documentation": {
                      "identifier": "headerV7.Name",
                      "newPage": false,
                      "searchKey": "tar.headerV7.Name",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerV7) Name() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerV7) Name() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerV7.Size",
                    "documentation": {
                      "identifier": "headerV7.Size",
                      "newPage": false,
                      "searchKey": "tar.headerV7.Size",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerV7) Size() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerV7) Size() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerV7.TypeFlag",
                    "documentation": {
                      "identifier": "headerV7.TypeFlag",
                      "newPage": false,
                      "searchKey": "tar.headerV7.TypeFlag",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerV7) TypeFlag() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerV7) TypeFlag() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#headerV7.UID",
                    "documentation": {
                      "identifier": "headerV7.UID",
                      "newPage": false,
                      "searchKey": "tar.headerV7.UID",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headerV7) UID() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headerV7) UID() []byte\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#numberFormatter",
              "documentation": {
                "identifier": "numberFormatter",
                "newPage": false,
                "searchKey": "tar.numberFormatter",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type numberFormatter func([]byte, int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype numberFormatter func([]byte, int64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#parser",
              "documentation": {
                "identifier": "parser",
                "newPage": false,
                "searchKey": "tar.parser",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type parser struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype parser struct {\n\terr error // Last error seen\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#parser.parseNumeric",
                    "documentation": {
                      "identifier": "parser.parseNumeric",
                      "newPage": false,
                      "searchKey": "tar.parser.parseNumeric",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseNumeric(b []byte) int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseNumeric(b []byte) int64\n```\n\nparseNumeric parses the input as being encoded in either base-256 or octal. This function may return negative numbers. If parsing fails or an integer overflow occurs, err will be set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#parser.parseOctal",
                    "documentation": {
                      "identifier": "parser.parseOctal",
                      "newPage": false,
                      "searchKey": "tar.parser.parseOctal",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseOctal(b []byte) int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseOctal(b []byte) int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#parser.parseString",
                    "documentation": {
                      "identifier": "parser.parseString",
                      "newPage": false,
                      "searchKey": "tar.parser.parseString",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*parser) parseString(b []byte) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*parser) parseString(b []byte) string\n```\n\nparseString parses bytes as a NUL-terminated C-style string. If a NUL byte is not found then the whole slice is returned as a string. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#readBadSeeker",
              "documentation": {
                "identifier": "readBadSeeker",
                "newPage": false,
                "searchKey": "tar.readBadSeeker",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type readBadSeeker struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype readBadSeeker struct{ io.ReadSeeker }\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#readBadSeeker.Seek",
                    "documentation": {
                      "identifier": "readBadSeeker.Seek",
                      "newPage": false,
                      "searchKey": "tar.readBadSeeker.Seek",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rbs *readBadSeeker) Seek(int64, int) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rbs *readBadSeeker) Seek(int64, int) (int64, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#readSeeker",
              "documentation": {
                "identifier": "readSeeker",
                "newPage": false,
                "searchKey": "tar.readSeeker",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type readSeeker struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype readSeeker struct{ io.ReadSeeker }\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#reader",
              "documentation": {
                "identifier": "reader",
                "newPage": false,
                "searchKey": "tar.reader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type reader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype reader struct{ io.Reader }\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#regFileReader",
              "documentation": {
                "identifier": "regFileReader",
                "newPage": false,
                "searchKey": "tar.regFileReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type regFileReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype regFileReader struct {\n\tr  io.Reader // Underlying Reader\n\tnb int64     // Number of remaining bytes to read\n}\n```\n\nregFileReader is a fileReader for reading data from a regular file entry. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#regFileReader.LogicalRemaining",
                    "documentation": {
                      "identifier": "regFileReader.LogicalRemaining",
                      "newPage": false,
                      "searchKey": "tar.regFileReader.LogicalRemaining",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr regFileReader) LogicalRemaining() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr regFileReader) LogicalRemaining() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#regFileReader.PhysicalRemaining",
                    "documentation": {
                      "identifier": "regFileReader.PhysicalRemaining",
                      "newPage": false,
                      "searchKey": "tar.regFileReader.PhysicalRemaining",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr regFileReader) PhysicalRemaining() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr regFileReader) PhysicalRemaining() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#regFileReader.Read",
                    "documentation": {
                      "identifier": "regFileReader.Read",
                      "newPage": false,
                      "searchKey": "tar.regFileReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr *regFileReader) Read(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr *regFileReader) Read(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#regFileReader.WriteTo",
                    "documentation": {
                      "identifier": "regFileReader.WriteTo",
                      "newPage": false,
                      "searchKey": "tar.regFileReader.WriteTo",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fr *regFileReader) WriteTo(w io.Writer) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fr *regFileReader) WriteTo(w io.Writer) (int64, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#regFileWriter",
              "documentation": {
                "identifier": "regFileWriter",
                "newPage": false,
                "searchKey": "tar.regFileWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type regFileWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype regFileWriter struct {\n\tw  io.Writer // Underlying Writer\n\tnb int64     // Number of remaining bytes to write\n}\n```\n\nregFileWriter is a fileWriter for writing data to a regular file entry. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#regFileWriter.LogicalRemaining",
                    "documentation": {
                      "identifier": "regFileWriter.LogicalRemaining",
                      "newPage": false,
                      "searchKey": "tar.regFileWriter.LogicalRemaining",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fw regFileWriter) LogicalRemaining() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fw regFileWriter) LogicalRemaining() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#regFileWriter.PhysicalRemaining",
                    "documentation": {
                      "identifier": "regFileWriter.PhysicalRemaining",
                      "newPage": false,
                      "searchKey": "tar.regFileWriter.PhysicalRemaining",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fw regFileWriter) PhysicalRemaining() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fw regFileWriter) PhysicalRemaining() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#regFileWriter.ReadFrom",
                    "documentation": {
                      "identifier": "regFileWriter.ReadFrom",
                      "newPage": false,
                      "searchKey": "tar.regFileWriter.ReadFrom",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fw *regFileWriter) ReadFrom(r io.Reader) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fw *regFileWriter) ReadFrom(r io.Reader) (int64, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#regFileWriter.Write",
                    "documentation": {
                      "identifier": "regFileWriter.Write",
                      "newPage": false,
                      "searchKey": "tar.regFileWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fw *regFileWriter) Write(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fw *regFileWriter) Write(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#sparseArray",
              "documentation": {
                "identifier": "sparseArray",
                "newPage": false,
                "searchKey": "tar.sparseArray",
                "tags": [
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type sparseArray []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sparseArray []byte\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#sparseArray.Entry",
                    "documentation": {
                      "identifier": "sparseArray.Entry",
                      "newPage": false,
                      "searchKey": "tar.sparseArray.Entry",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sparseArray) Entry(i int) sparseElem"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sparseArray) Entry(i int) sparseElem\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#sparseArray.IsExtended",
                    "documentation": {
                      "identifier": "sparseArray.IsExtended",
                      "newPage": false,
                      "searchKey": "tar.sparseArray.IsExtended",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sparseArray) IsExtended() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sparseArray) IsExtended() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#sparseArray.MaxEntries",
                    "documentation": {
                      "identifier": "sparseArray.MaxEntries",
                      "newPage": false,
                      "searchKey": "tar.sparseArray.MaxEntries",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sparseArray) MaxEntries() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sparseArray) MaxEntries() int\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#sparseDatas",
              "documentation": {
                "identifier": "sparseDatas",
                "newPage": false,
                "searchKey": "tar.sparseDatas",
                "tags": [
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type sparseDatas []tar.sparseEntry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sparseDatas []sparseEntry\n```\n\nA sparse file can be represented as either a sparseDatas or a sparseHoles. As long as the total size is known, they are equivalent and one can be converted to the other form and back. The various tar formats with sparse file support represent sparse files in the sparseDatas form. That is, they specify the fragments in the file that has data, and treat everything else as having zero bytes. As such, the encoding and decoding logic in this package deals with sparseDatas. \n\nHowever, the external API uses sparseHoles instead of sparseDatas because the zero value of sparseHoles logically represents a normal file (i.e., there are no holes in it). On the other hand, the zero value of sparseDatas implies that the file has no data in it, which is rather odd. \n\nAs an example, if the underlying raw file contains the 10-byte data: \n\n```\nvar compactFile = \"abcdefgh\"\n\n```\nAnd the sparse map has the following entries: \n\n```\nvar spd sparseDatas = []sparseEntry{\n\t{Offset: 2,  Length: 5},  // Data fragment for 2..6\n\t{Offset: 18, Length: 3},  // Data fragment for 18..20\n}\nvar sph sparseHoles = []sparseEntry{\n\t{Offset: 0,  Length: 2},  // Hole fragment for 0..1\n\t{Offset: 7,  Length: 11}, // Hole fragment for 7..17\n\t{Offset: 21, Length: 4},  // Hole fragment for 21..24\n}\n\n```\nThen the content of the resulting sparse file with a Header.Size of 25 is: \n\n```\nvar sparseFile = \"\\x00\"*2 + \"abcde\" + \"\\x00\"*11 + \"fgh\" + \"\\x00\"*4\n\n```\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#readGNUSparseMap0x1",
                    "documentation": {
                      "identifier": "readGNUSparseMap0x1",
                      "newPage": false,
                      "searchKey": "tar.readGNUSparseMap0x1",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func readGNUSparseMap0x1(paxHdrs map[string]string) (sparseDatas, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc readGNUSparseMap0x1(paxHdrs map[string]string) (sparseDatas, error)\n```\n\nreadGNUSparseMap0x1 reads the sparse map as stored in GNU's PAX sparse format version 0.1. The sparse map is stored in the PAX headers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#readGNUSparseMap1x0",
                    "documentation": {
                      "identifier": "readGNUSparseMap1x0",
                      "newPage": false,
                      "searchKey": "tar.readGNUSparseMap1x0",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func readGNUSparseMap1x0(r io.Reader) (sparseDatas, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc readGNUSparseMap1x0(r io.Reader) (sparseDatas, error)\n```\n\nreadGNUSparseMap1x0 reads the sparse map as stored in GNU's PAX sparse format version 1.0. The format of the sparse map consists of a series of newline-terminated numeric fields. The first field is the number of entries and is always present. Following this are the entries, consisting of two fields (offset, length). This function must stop reading at the end boundary of the block containing the last newline. \n\nNote that the GNU manual says that numeric values should be encoded in octal format. However, the GNU tar utility itself outputs these values in decimal. As such, this library treats values as being encoded in decimal. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#sparseElem",
              "documentation": {
                "identifier": "sparseElem",
                "newPage": false,
                "searchKey": "tar.sparseElem",
                "tags": [
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type sparseElem []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sparseElem []byte\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#sparseElem.Length",
                    "documentation": {
                      "identifier": "sparseElem.Length",
                      "newPage": false,
                      "searchKey": "tar.sparseElem.Length",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sparseElem) Length() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sparseElem) Length() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#sparseElem.Offset",
                    "documentation": {
                      "identifier": "sparseElem.Offset",
                      "newPage": false,
                      "searchKey": "tar.sparseElem.Offset",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sparseElem) Offset() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sparseElem) Offset() []byte\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#sparseEntry",
              "documentation": {
                "identifier": "sparseEntry",
                "newPage": false,
                "searchKey": "tar.sparseEntry",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type sparseEntry struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sparseEntry struct{ Offset, Length int64 }\n```\n\nsparseEntry represents a Length-sized fragment at Offset in the file. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#sparseEntry.endOffset",
                    "documentation": {
                      "identifier": "sparseEntry.endOffset",
                      "newPage": false,
                      "searchKey": "tar.sparseEntry.endOffset",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sparseEntry) endOffset() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sparseEntry) endOffset() int64\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#sparseFileReader",
              "documentation": {
                "identifier": "sparseFileReader",
                "newPage": false,
                "searchKey": "tar.sparseFileReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type sparseFileReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sparseFileReader struct {\n\tfr  fileReader  // Underlying fileReader\n\tsp  sparseHoles // Normalized list of sparse holes\n\tpos int64       // Current position in sparse file\n}\n```\n\nsparseFileReader is a fileReader for reading data from a sparse file entry. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#sparseFileReader.LogicalRemaining",
                    "documentation": {
                      "identifier": "sparseFileReader.LogicalRemaining",
                      "newPage": false,
                      "searchKey": "tar.sparseFileReader.LogicalRemaining",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sr sparseFileReader) LogicalRemaining() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sr sparseFileReader) LogicalRemaining() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#sparseFileReader.PhysicalRemaining",
                    "documentation": {
                      "identifier": "sparseFileReader.PhysicalRemaining",
                      "newPage": false,
                      "searchKey": "tar.sparseFileReader.PhysicalRemaining",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sr sparseFileReader) PhysicalRemaining() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sr sparseFileReader) PhysicalRemaining() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#sparseFileReader.Read",
                    "documentation": {
                      "identifier": "sparseFileReader.Read",
                      "newPage": false,
                      "searchKey": "tar.sparseFileReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sr *sparseFileReader) Read(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sr *sparseFileReader) Read(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#sparseFileReader.WriteTo",
                    "documentation": {
                      "identifier": "sparseFileReader.WriteTo",
                      "newPage": false,
                      "searchKey": "tar.sparseFileReader.WriteTo",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sr *sparseFileReader) WriteTo(w io.Writer) (n int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sr *sparseFileReader) WriteTo(w io.Writer) (n int64, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#sparseFileWriter",
              "documentation": {
                "identifier": "sparseFileWriter",
                "newPage": false,
                "searchKey": "tar.sparseFileWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type sparseFileWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sparseFileWriter struct {\n\tfw  fileWriter  // Underlying fileWriter\n\tsp  sparseDatas // Normalized list of data fragments\n\tpos int64       // Current position in sparse file\n}\n```\n\nsparseFileWriter is a fileWriter for writing data to a sparse file entry. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#sparseFileWriter.LogicalRemaining",
                    "documentation": {
                      "identifier": "sparseFileWriter.LogicalRemaining",
                      "newPage": false,
                      "searchKey": "tar.sparseFileWriter.LogicalRemaining",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sw sparseFileWriter) LogicalRemaining() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sw sparseFileWriter) LogicalRemaining() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#sparseFileWriter.PhysicalRemaining",
                    "documentation": {
                      "identifier": "sparseFileWriter.PhysicalRemaining",
                      "newPage": false,
                      "searchKey": "tar.sparseFileWriter.PhysicalRemaining",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sw sparseFileWriter) PhysicalRemaining() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sw sparseFileWriter) PhysicalRemaining() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#sparseFileWriter.ReadFrom",
                    "documentation": {
                      "identifier": "sparseFileWriter.ReadFrom",
                      "newPage": false,
                      "searchKey": "tar.sparseFileWriter.ReadFrom",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sw *sparseFileWriter) ReadFrom(r io.Reader) (n int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sw *sparseFileWriter) ReadFrom(r io.Reader) (n int64, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#sparseFileWriter.Write",
                    "documentation": {
                      "identifier": "sparseFileWriter.Write",
                      "newPage": false,
                      "searchKey": "tar.sparseFileWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sw *sparseFileWriter) Write(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sw *sparseFileWriter) Write(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#sparseHoles",
              "documentation": {
                "identifier": "sparseHoles",
                "newPage": false,
                "searchKey": "tar.sparseHoles",
                "tags": [
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type sparseHoles []tar.sparseEntry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sparseHoles []sparseEntry\n```\n\nA sparse file can be represented as either a sparseDatas or a sparseHoles. As long as the total size is known, they are equivalent and one can be converted to the other form and back. The various tar formats with sparse file support represent sparse files in the sparseDatas form. That is, they specify the fragments in the file that has data, and treat everything else as having zero bytes. As such, the encoding and decoding logic in this package deals with sparseDatas. \n\nHowever, the external API uses sparseHoles instead of sparseDatas because the zero value of sparseHoles logically represents a normal file (i.e., there are no holes in it). On the other hand, the zero value of sparseDatas implies that the file has no data in it, which is rather odd. \n\nAs an example, if the underlying raw file contains the 10-byte data: \n\n```\nvar compactFile = \"abcdefgh\"\n\n```\nAnd the sparse map has the following entries: \n\n```\nvar spd sparseDatas = []sparseEntry{\n\t{Offset: 2,  Length: 5},  // Data fragment for 2..6\n\t{Offset: 18, Length: 3},  // Data fragment for 18..20\n}\nvar sph sparseHoles = []sparseEntry{\n\t{Offset: 0,  Length: 2},  // Hole fragment for 0..1\n\t{Offset: 7,  Length: 11}, // Hole fragment for 7..17\n\t{Offset: 21, Length: 4},  // Hole fragment for 21..24\n}\n\n```\nThen the content of the resulting sparse file with a Header.Size of 25 is: \n\n```\nvar sparseFile = \"\\x00\"*2 + \"abcde\" + \"\\x00\"*11 + \"fgh\" + \"\\x00\"*4\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#stringFormatter",
              "documentation": {
                "identifier": "stringFormatter",
                "newPage": false,
                "searchKey": "tar.stringFormatter",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type stringFormatter func([]byte, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stringFormatter func([]byte, string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#testError",
              "documentation": {
                "identifier": "testError",
                "newPage": false,
                "searchKey": "tar.testError",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type testError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype testError struct{ error }\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#testFile",
              "documentation": {
                "identifier": "testFile",
                "newPage": false,
                "searchKey": "tar.testFile",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type testFile struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype testFile struct {\n\tops fileOps\n\tpos int64\n}\n```\n\ntestFile is an io.ReadWriteSeeker where the IO operations performed on it must match the list of operations in ops. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#testFile.Read",
                    "documentation": {
                      "identifier": "testFile.Read",
                      "newPage": false,
                      "searchKey": "tar.testFile.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *testFile) Read(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *testFile) Read(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#testFile.Seek",
                    "documentation": {
                      "identifier": "testFile.Seek",
                      "newPage": false,
                      "searchKey": "tar.testFile.Seek",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *testFile) Seek(pos int64, whence int) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *testFile) Seek(pos int64, whence int) (int64, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/archive/tar#testFile.Write",
                    "documentation": {
                      "identifier": "testFile.Write",
                      "newPage": false,
                      "searchKey": "tar.testFile.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *testFile) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *testFile) Write(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#testNonEmptyReader",
              "documentation": {
                "identifier": "testNonEmptyReader",
                "newPage": false,
                "searchKey": "tar.testNonEmptyReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type testNonEmptyReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype testNonEmptyReader struct{ io.Reader }\n```\n\ntestNonEmptyReader wraps an io.Reader and ensures that Read is never called with an empty buffer. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#testNonEmptyReader.Read",
                    "documentation": {
                      "identifier": "testNonEmptyReader.Read",
                      "newPage": false,
                      "searchKey": "tar.testNonEmptyReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r testNonEmptyReader) Read(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r testNonEmptyReader) Read(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#testNonEmptyWriter",
              "documentation": {
                "identifier": "testNonEmptyWriter",
                "newPage": false,
                "searchKey": "tar.testNonEmptyWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type testNonEmptyWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype testNonEmptyWriter struct{ io.Writer }\n```\n\ntestNonEmptyWriter wraps an io.Writer and ensures that Write is never called with an empty buffer. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#testNonEmptyWriter.Write",
                    "documentation": {
                      "identifier": "testNonEmptyWriter.Write",
                      "newPage": false,
                      "searchKey": "tar.testNonEmptyWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w testNonEmptyWriter) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w testNonEmptyWriter) Write(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#zeroReader",
              "documentation": {
                "identifier": "zeroReader",
                "newPage": false,
                "searchKey": "tar.zeroReader",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type zeroReader struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype zeroReader struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#zeroReader.Read",
                    "documentation": {
                      "identifier": "zeroReader.Read",
                      "newPage": false,
                      "searchKey": "tar.zeroReader.Read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (zeroReader) Read(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (zeroReader) Read(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#zeroWriter",
              "documentation": {
                "identifier": "zeroWriter",
                "newPage": false,
                "searchKey": "tar.zeroWriter",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type zeroWriter struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype zeroWriter struct{}\n```\n\nzeroWriter may only be written with NULs, otherwise it returns errWriteHole. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/archive/tar#zeroWriter.Write",
                    "documentation": {
                      "identifier": "zeroWriter.Write",
                      "newPage": false,
                      "searchKey": "tar.zeroWriter.Write",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (zeroWriter) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (zeroWriter) Write(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/archive/tar#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/archive/tar#Benchmark",
              "documentation": {
                "identifier": "Benchmark",
                "newPage": false,
                "searchKey": "tar.Benchmark",
                "tags": [
                  "function",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Benchmark(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Benchmark(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestFileInfoHeader",
              "documentation": {
                "identifier": "TestFileInfoHeader",
                "newPage": false,
                "searchKey": "tar.TestFileInfoHeader",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFileInfoHeader(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFileInfoHeader(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestFileInfoHeaderDir",
              "documentation": {
                "identifier": "TestFileInfoHeaderDir",
                "newPage": false,
                "searchKey": "tar.TestFileInfoHeaderDir",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFileInfoHeaderDir(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFileInfoHeaderDir(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestFileInfoHeaderSymlink",
              "documentation": {
                "identifier": "TestFileInfoHeaderSymlink",
                "newPage": false,
                "searchKey": "tar.TestFileInfoHeaderSymlink",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFileInfoHeaderSymlink(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFileInfoHeaderSymlink(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestFileReader",
              "documentation": {
                "identifier": "TestFileReader",
                "newPage": false,
                "searchKey": "tar.TestFileReader",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFileReader(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFileReader(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestFileWriter",
              "documentation": {
                "identifier": "TestFileWriter",
                "newPage": false,
                "searchKey": "tar.TestFileWriter",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFileWriter(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFileWriter(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestFitsInBase256",
              "documentation": {
                "identifier": "TestFitsInBase256",
                "newPage": false,
                "searchKey": "tar.TestFitsInBase256",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFitsInBase256(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFitsInBase256(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestFitsInOctal",
              "documentation": {
                "identifier": "TestFitsInOctal",
                "newPage": false,
                "searchKey": "tar.TestFitsInOctal",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFitsInOctal(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFitsInOctal(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestFormatNumeric",
              "documentation": {
                "identifier": "TestFormatNumeric",
                "newPage": false,
                "searchKey": "tar.TestFormatNumeric",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFormatNumeric(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFormatNumeric(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestFormatPAXRecord",
              "documentation": {
                "identifier": "TestFormatPAXRecord",
                "newPage": false,
                "searchKey": "tar.TestFormatPAXRecord",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFormatPAXRecord(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFormatPAXRecord(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestFormatPAXTime",
              "documentation": {
                "identifier": "TestFormatPAXTime",
                "newPage": false,
                "searchKey": "tar.TestFormatPAXTime",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFormatPAXTime(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFormatPAXTime(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestHeaderAllowedFormats",
              "documentation": {
                "identifier": "TestHeaderAllowedFormats",
                "newPage": false,
                "searchKey": "tar.TestHeaderAllowedFormats",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHeaderAllowedFormats(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHeaderAllowedFormats(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestHeaderRoundTrip",
              "documentation": {
                "identifier": "TestHeaderRoundTrip",
                "newPage": false,
                "searchKey": "tar.TestHeaderRoundTrip",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHeaderRoundTrip(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHeaderRoundTrip(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestIssue12594",
              "documentation": {
                "identifier": "TestIssue12594",
                "newPage": false,
                "searchKey": "tar.TestIssue12594",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue12594(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue12594(t *testing.T)\n```\n\nTestIssue12594 tests that the Writer does not attempt to populate the prefix field when encoding a header in the GNU format. The prefix field is valid in USTAR and PAX, but not GNU. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestMergePAX",
              "documentation": {
                "identifier": "TestMergePAX",
                "newPage": false,
                "searchKey": "tar.TestMergePAX",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMergePAX(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMergePAX(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestParseNumeric",
              "documentation": {
                "identifier": "TestParseNumeric",
                "newPage": false,
                "searchKey": "tar.TestParseNumeric",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseNumeric(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseNumeric(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestParsePAX",
              "documentation": {
                "identifier": "TestParsePAX",
                "newPage": false,
                "searchKey": "tar.TestParsePAX",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParsePAX(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParsePAX(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestParsePAXRecord",
              "documentation": {
                "identifier": "TestParsePAXRecord",
                "newPage": false,
                "searchKey": "tar.TestParsePAXRecord",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParsePAXRecord(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParsePAXRecord(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestParsePAXTime",
              "documentation": {
                "identifier": "TestParsePAXTime",
                "newPage": false,
                "searchKey": "tar.TestParsePAXTime",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParsePAXTime(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParsePAXTime(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestPartialRead",
              "documentation": {
                "identifier": "TestPartialRead",
                "newPage": false,
                "searchKey": "tar.TestPartialRead",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPartialRead(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPartialRead(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestPax",
              "documentation": {
                "identifier": "TestPax",
                "newPage": false,
                "searchKey": "tar.TestPax",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPax(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPax(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestPaxHeadersSorted",
              "documentation": {
                "identifier": "TestPaxHeadersSorted",
                "newPage": false,
                "searchKey": "tar.TestPaxHeadersSorted",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPaxHeadersSorted(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPaxHeadersSorted(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestPaxNonAscii",
              "documentation": {
                "identifier": "TestPaxNonAscii",
                "newPage": false,
                "searchKey": "tar.TestPaxNonAscii",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPaxNonAscii(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPaxNonAscii(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestPaxSymlink",
              "documentation": {
                "identifier": "TestPaxSymlink",
                "newPage": false,
                "searchKey": "tar.TestPaxSymlink",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPaxSymlink(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPaxSymlink(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestPaxXattrs",
              "documentation": {
                "identifier": "TestPaxXattrs",
                "newPage": false,
                "searchKey": "tar.TestPaxXattrs",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPaxXattrs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPaxXattrs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestReadGNUSparsePAXHeaders",
              "documentation": {
                "identifier": "TestReadGNUSparsePAXHeaders",
                "newPage": false,
                "searchKey": "tar.TestReadGNUSparsePAXHeaders",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadGNUSparsePAXHeaders(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadGNUSparsePAXHeaders(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestReadHeaderOnly",
              "documentation": {
                "identifier": "TestReadHeaderOnly",
                "newPage": false,
                "searchKey": "tar.TestReadHeaderOnly",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadHeaderOnly(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadHeaderOnly(t *testing.T)\n```\n\nTestReadHeaderOnly tests that Reader does not attempt to read special header-only files. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestReadOldGNUSparseMap",
              "documentation": {
                "identifier": "TestReadOldGNUSparseMap",
                "newPage": false,
                "searchKey": "tar.TestReadOldGNUSparseMap",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadOldGNUSparseMap(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadOldGNUSparseMap(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestReadTruncation",
              "documentation": {
                "identifier": "TestReadTruncation",
                "newPage": false,
                "searchKey": "tar.TestReadTruncation",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReadTruncation(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReadTruncation(t *testing.T)\n```\n\nTestReadTruncation test the ending condition on various truncated files and that truncated files are still detected even if the underlying io.Reader satisfies io.Seeker. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestReader",
              "documentation": {
                "identifier": "TestReader",
                "newPage": false,
                "searchKey": "tar.TestReader",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestReader(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestReader(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestRoundTrip",
              "documentation": {
                "identifier": "TestRoundTrip",
                "newPage": false,
                "searchKey": "tar.TestRoundTrip",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRoundTrip(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRoundTrip(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestSparseEntries",
              "documentation": {
                "identifier": "TestSparseEntries",
                "newPage": false,
                "searchKey": "tar.TestSparseEntries",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSparseEntries(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSparseEntries(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestSplitUSTARPath",
              "documentation": {
                "identifier": "TestSplitUSTARPath",
                "newPage": false,
                "searchKey": "tar.TestSplitUSTARPath",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSplitUSTARPath(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSplitUSTARPath(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestUSTARLongName",
              "documentation": {
                "identifier": "TestUSTARLongName",
                "newPage": false,
                "searchKey": "tar.TestUSTARLongName",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUSTARLongName(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUSTARLongName(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestUninitializedRead",
              "documentation": {
                "identifier": "TestUninitializedRead",
                "newPage": false,
                "searchKey": "tar.TestUninitializedRead",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUninitializedRead(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUninitializedRead(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestValidTypeflagWithPAXHeader",
              "documentation": {
                "identifier": "TestValidTypeflagWithPAXHeader",
                "newPage": false,
                "searchKey": "tar.TestValidTypeflagWithPAXHeader",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestValidTypeflagWithPAXHeader(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestValidTypeflagWithPAXHeader(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestWriter",
              "documentation": {
                "identifier": "TestWriter",
                "newPage": false,
                "searchKey": "tar.TestWriter",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriter(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriter(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#TestWriterErrors",
              "documentation": {
                "identifier": "TestWriterErrors",
                "newPage": false,
                "searchKey": "tar.TestWriterErrors",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWriterErrors(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWriterErrors(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#alignSparseEntries",
              "documentation": {
                "identifier": "alignSparseEntries",
                "newPage": false,
                "searchKey": "tar.alignSparseEntries",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func alignSparseEntries(src []sparseEntry, size int64) []sparseEntry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc alignSparseEntries(src []sparseEntry, size int64) []sparseEntry\n```\n\nalignSparseEntries mutates src and returns dst where each fragment's starting offset is aligned up to the nearest block edge, and each ending offset is aligned down to the nearest block edge. \n\nEven though the Go tar Reader and the BSD tar utility can handle entries with arbitrary offsets and lengths, the GNU tar utility can only handle offsets and lengths that are multiples of blockSize. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#blockPadding",
              "documentation": {
                "identifier": "blockPadding",
                "newPage": false,
                "searchKey": "tar.blockPadding",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func blockPadding(offset int64) (n int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc blockPadding(offset int64) (n int64)\n```\n\nblockPadding computes the number of bytes needed to pad offset up to the nearest block edge where 0 <= n < blockSize. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#bytediff",
              "documentation": {
                "identifier": "bytediff",
                "newPage": false,
                "searchKey": "tar.bytediff",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func bytediff(a, b []byte) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bytediff(a, b []byte) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#discard",
              "documentation": {
                "identifier": "discard",
                "newPage": false,
                "searchKey": "tar.discard",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func discard(r io.Reader, n int64) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc discard(r io.Reader, n int64) error\n```\n\ndiscard skips n bytes in r, reporting an error if unable to do so. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#ensureEOF",
              "documentation": {
                "identifier": "ensureEOF",
                "newPage": false,
                "searchKey": "tar.ensureEOF",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ensureEOF(r io.Reader) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ensureEOF(r io.Reader) error\n```\n\nensureEOF checks whether r is at EOF, reporting ErrWriteTooLong if not so. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#equalSparseEntries",
              "documentation": {
                "identifier": "equalSparseEntries",
                "newPage": false,
                "searchKey": "tar.equalSparseEntries",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func equalSparseEntries(x, y []sparseEntry) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc equalSparseEntries(x, y []sparseEntry) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#fitsInBase256",
              "documentation": {
                "identifier": "fitsInBase256",
                "newPage": false,
                "searchKey": "tar.fitsInBase256",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fitsInBase256(n int, x int64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fitsInBase256(n int, x int64) bool\n```\n\nfitsInBase256 reports whether x can be encoded into n bytes using base-256 encoding. Unlike octal encoding, base-256 encoding does not require that the string ends with a NUL character. Thus, all n bytes are available for output. \n\nIf operating in binary mode, this assumes strict GNU binary mode; which means that the first byte can only be either 0x80 or 0xff. Thus, the first byte is equivalent to the sign bit in two's complement form. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#fitsInOctal",
              "documentation": {
                "identifier": "fitsInOctal",
                "newPage": false,
                "searchKey": "tar.fitsInOctal",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fitsInOctal(n int, x int64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fitsInOctal(n int, x int64) bool\n```\n\nfitsInOctal reports whether the integer x fits in a field n-bytes long using octal encoding with the appropriate NUL terminator. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#formatPAXRecord",
              "documentation": {
                "identifier": "formatPAXRecord",
                "newPage": false,
                "searchKey": "tar.formatPAXRecord",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func formatPAXRecord(k, v string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc formatPAXRecord(k, v string) (string, error)\n```\n\nformatPAXRecord formats a single PAX record, prefixing it with the appropriate length. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#formatPAXTime",
              "documentation": {
                "identifier": "formatPAXTime",
                "newPage": false,
                "searchKey": "tar.formatPAXTime",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func formatPAXTime(ts time.Time) (s string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc formatPAXTime(ts time.Time) (s string)\n```\n\nformatPAXTime converts ts into a time of the form %d.%d as described in the PAX specification. This function is capable of negative timestamps. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#hasNUL",
              "documentation": {
                "identifier": "hasNUL",
                "newPage": false,
                "searchKey": "tar.hasNUL",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func hasNUL(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hasNUL(s string) bool\n```\n\nhasNUL reports whether the NUL character exists within s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#init.stat_unix.go",
              "documentation": {
                "identifier": "init.stat_unix.go",
                "newPage": false,
                "searchKey": "tar.init",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#invertSparseEntries",
              "documentation": {
                "identifier": "invertSparseEntries",
                "newPage": false,
                "searchKey": "tar.invertSparseEntries",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func invertSparseEntries(src []sparseEntry, size int64) []sparseEntry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc invertSparseEntries(src []sparseEntry, size int64) []sparseEntry\n```\n\ninvertSparseEntries converts a sparse map from one form to the other. If the input is sparseHoles, then it will output sparseDatas and vice-versa. The input must have been already validated. \n\nThis function mutates src and returns a normalized map where: \n\n```\n* adjacent fragments are coalesced together\n* only the last fragment may be empty\n* the endOffset of the last fragment is the total size\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#isASCII",
              "documentation": {
                "identifier": "isASCII",
                "newPage": false,
                "searchKey": "tar.isASCII",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isASCII(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isASCII(s string) bool\n```\n\nisASCII reports whether the input is an ASCII C-style string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#isHeaderOnlyType",
              "documentation": {
                "identifier": "isHeaderOnlyType",
                "newPage": false,
                "searchKey": "tar.isHeaderOnlyType",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isHeaderOnlyType(flag byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isHeaderOnlyType(flag byte) bool\n```\n\nisHeaderOnlyType checks if the given type flag is of the type that has no data section even if a size is specified. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#mergePAX",
              "documentation": {
                "identifier": "mergePAX",
                "newPage": false,
                "searchKey": "tar.mergePAX",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func mergePAX(hdr *Header, paxHdrs map[string]string) (err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mergePAX(hdr *Header, paxHdrs map[string]string) (err error)\n```\n\nmergePAX merges paxHdrs into hdr for all relevant fields of Header. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#min",
              "documentation": {
                "identifier": "min",
                "newPage": false,
                "searchKey": "tar.min",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func min(a, b int64) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc min(a, b int64) int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#mustReadFull",
              "documentation": {
                "identifier": "mustReadFull",
                "newPage": false,
                "searchKey": "tar.mustReadFull",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func mustReadFull(r io.Reader, b []byte) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mustReadFull(r io.Reader, b []byte) (int, error)\n```\n\nmustReadFull is like io.ReadFull except it returns io.ErrUnexpectedEOF when io.EOF is hit before len(b) bytes are read. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#parsePAX",
              "documentation": {
                "identifier": "parsePAX",
                "newPage": false,
                "searchKey": "tar.parsePAX",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parsePAX(r io.Reader) (map[string]string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parsePAX(r io.Reader) (map[string]string, error)\n```\n\nparsePAX parses PAX headers. If an extended header (type 'x') is invalid, ErrHeader is returned \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#parsePAXRecord",
              "documentation": {
                "identifier": "parsePAXRecord",
                "newPage": false,
                "searchKey": "tar.parsePAXRecord",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parsePAXRecord(s string) (k, v, r string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parsePAXRecord(s string) (k, v, r string, err error)\n```\n\nparsePAXRecord parses the input PAX record string into a key-value pair. If parsing is successful, it will slice off the currently read record and return the remainder as r. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#parsePAXTime",
              "documentation": {
                "identifier": "parsePAXTime",
                "newPage": false,
                "searchKey": "tar.parsePAXTime",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parsePAXTime(s string) (time.Time, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parsePAXTime(s string) (time.Time, error)\n```\n\nparsePAXTime takes a string of the form %d.%d as described in the PAX specification. Note that this implementation allows for negative timestamps, which is allowed for by the PAX specification, but not always portable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#splitUSTARPath",
              "documentation": {
                "identifier": "splitUSTARPath",
                "newPage": false,
                "searchKey": "tar.splitUSTARPath",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func splitUSTARPath(name string) (prefix, suffix string, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc splitUSTARPath(name string) (prefix, suffix string, ok bool)\n```\n\nsplitUSTARPath splits a path according to USTAR prefix and suffix rules. If the path is not splittable, then it will return (\"\", \"\", false). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#statAtime",
              "documentation": {
                "identifier": "statAtime",
                "newPage": false,
                "searchKey": "tar.statAtime",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func statAtime(st *syscall.Stat_t) time.Time"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc statAtime(st *syscall.Stat_t) time.Time\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#statCtime",
              "documentation": {
                "identifier": "statCtime",
                "newPage": false,
                "searchKey": "tar.statCtime",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func statCtime(st *syscall.Stat_t) time.Time"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc statCtime(st *syscall.Stat_t) time.Time\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#statUnix",
              "documentation": {
                "identifier": "statUnix",
                "newPage": false,
                "searchKey": "tar.statUnix",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func statUnix(fi fs.FileInfo, h *Header) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc statUnix(fi fs.FileInfo, h *Header) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#toASCII",
              "documentation": {
                "identifier": "toASCII",
                "newPage": false,
                "searchKey": "tar.toASCII",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func toASCII(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc toASCII(s string) string\n```\n\ntoASCII converts the input to an ASCII C-style string. This is a best effort conversion, so invalid characters are dropped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#tryReadFull",
              "documentation": {
                "identifier": "tryReadFull",
                "newPage": false,
                "searchKey": "tar.tryReadFull",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func tryReadFull(r io.Reader, b []byte) (n int, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tryReadFull(r io.Reader, b []byte) (n int, err error)\n```\n\ntryReadFull is like io.ReadFull except it returns io.EOF when it is hit before len(b) bytes are read. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#validPAXRecord",
              "documentation": {
                "identifier": "validPAXRecord",
                "newPage": false,
                "searchKey": "tar.validPAXRecord",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validPAXRecord(k, v string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validPAXRecord(k, v string) bool\n```\n\nvalidPAXRecord reports whether the key-value pair is valid where each record is formatted as: \n\n```\n\"%d %s=%s\\n\" % (size, key, value)\n\n```\nKeys and values should be UTF-8, but the number of bad writers out there forces us to be a more liberal. Thus, we only reject all keys with NUL, and only reject NULs in values for the PAX version of the USTAR string fields. The key must not contain an '=' character. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/archive/tar#validateSparseEntries",
              "documentation": {
                "identifier": "validateSparseEntries",
                "newPage": false,
                "searchKey": "tar.validateSparseEntries",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func validateSparseEntries(sp []sparseEntry, size int64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validateSparseEntries(sp []sparseEntry, size int64) bool\n```\n\nvalidateSparseEntries reports whether sp is a valid sparse map. It does not matter whether sp represents data fragments or hole fragments. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
