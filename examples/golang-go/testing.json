{
  "pathID": "/testing",
  "documentation": {
    "identifier": "testing",
    "newPage": true,
    "searchKey": "testing",
    "tags": []
  },
  "label": {
    "kind": "plaintext",
    "value": "Package testing"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package testing provides support for automated testing of Go packages. It is intended to be used in concert with the \"go test\" command, which automates execution of any function of the form \n\n```\nfunc TestXxx(*testing.T)\n\n```\nwhere Xxx does not start with a lowercase letter. The function name serves to identify the test routine. \n\nWithin these functions, use the Error, Fail or related methods to signal failure. \n\nTo write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the \"go test\" command is run. For more detail, run \"go help test\" and \"go help testflag\". \n\nA simple test function looks like this: \n\n```\nfunc TestAbs(t *testing.T) {\n    got := Abs(-1)\n    if got != 1 {\n        t.Errorf(\"Abs(-1) = %d; want 1\", got)\n    }\n}\n\n```\n### hdr-BenchmarksBenchmarks\nFunctions of the form \n\n```\nfunc BenchmarkXxx(*testing.B)\n\n```\nare considered benchmarks, and are executed by the \"go test\" command when its -bench flag is provided. Benchmarks are run sequentially. \n\nFor a description of the testing flags, see [https://golang.org/cmd/go/#hdr-Testing_flags](https://golang.org/cmd/go/#hdr-Testing_flags) \n\nA sample benchmark function looks like this: \n\n```\nfunc BenchmarkRandInt(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        rand.Int()\n    }\n}\n\n```\nThe benchmark function must run the target code b.N times. During benchmark execution, b.N is adjusted until the benchmark function lasts long enough to be timed reliably. The output \n\n```\nBenchmarkRandInt-8   \t68453040\t        17.8 ns/op\n\n```\nmeans that the loop ran 68453040 times at a speed of 17.8 ns per loop. \n\nIf a benchmark needs some expensive setup before running, the timer may be reset: \n\n```\nfunc BenchmarkBigLen(b *testing.B) {\n    big := NewBig()\n    b.ResetTimer()\n    for i := 0; i < b.N; i++ {\n        big.Len()\n    }\n}\n\n```\nIf a benchmark needs to test performance in a parallel setting, it may use the RunParallel helper function; such benchmarks are intended to be used with the go test -cpu flag: \n\n```\nfunc BenchmarkTemplateParallel(b *testing.B) {\n    templ := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\"))\n    b.RunParallel(func(pb *testing.PB) {\n        var buf bytes.Buffer\n        for pb.Next() {\n            buf.Reset()\n            templ.Execute(&buf, \"World\")\n        }\n    })\n}\n\n```\n### hdr-ExamplesExamples\nThe package also runs and verifies example code. Example functions may include a concluding line comment that begins with \"Output:\" and is compared with the standard output of the function when the tests are run. (The comparison ignores leading and trailing space.) These are examples of an example: \n\n```\nfunc ExampleHello() {\n    fmt.Println(\"hello\")\n    // Output: hello\n}\n\nfunc ExampleSalutations() {\n    fmt.Println(\"hello, and\")\n    fmt.Println(\"goodbye\")\n    // Output:\n    // hello, and\n    // goodbye\n}\n\n```\nThe comment prefix \"Unordered output:\" is like \"Output:\", but matches any line order: \n\n```\nfunc ExamplePerm() {\n    for _, value := range Perm(5) {\n        fmt.Println(value)\n    }\n    // Unordered output: 4\n    // 2\n    // 1\n    // 3\n    // 0\n}\n\n```\nExample functions without output comments are compiled but not executed. \n\nThe naming convention to declare examples for the package, a function F, a type T and method M on type T are: \n\n```\nfunc Example() { ... }\nfunc ExampleF() { ... }\nfunc ExampleT() { ... }\nfunc ExampleT_M() { ... }\n\n```\nMultiple example functions for a package/type/function/method may be provided by appending a distinct suffix to the name. The suffix must start with a lower-case letter. \n\n```\nfunc Example_suffix() { ... }\nfunc ExampleF_suffix() { ... }\nfunc ExampleT_suffix() { ... }\nfunc ExampleT_M_suffix() { ... }\n\n```\nThe entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions. \n\n### hdr-SkippingSkipping\nTests or benchmarks may be skipped at run time with a call to the Skip method of *T or *B: \n\n```\nfunc TestTimeConsuming(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"skipping test in short mode.\")\n    }\n    ...\n}\n\n```\n### hdr-Subtests_and_Sub_benchmarksSubtests and Sub-benchmarks\nThe Run methods of T and B allow defining subtests and sub-benchmarks, without having to define separate functions for each. This enables uses like table-driven benchmarks and creating hierarchical tests. It also provides a way to share common setup and tear-down code: \n\n```\nfunc TestFoo(t *testing.T) {\n    // <setup code>\n    t.Run(\"A=1\", func(t *testing.T) { ... })\n    t.Run(\"A=2\", func(t *testing.T) { ... })\n    t.Run(\"B=1\", func(t *testing.T) { ... })\n    // <tear-down code>\n}\n\n```\nEach subtest and sub-benchmark has a unique name: the combination of the name of the top-level test and the sequence of names passed to Run, separated by slashes, with an optional trailing sequence number for disambiguation. \n\nThe argument to the -run and -bench command-line flags is an unanchored regular expression that matches the test's name. For tests with multiple slash-separated elements, such as subtests, the argument is itself slash-separated, with expressions matching each name element in turn. Because it is unanchored, an empty expression matches any string. For example, using \"matching\" to mean \"whose name contains\": \n\n```\ngo test -run ''      # Run all tests.\ngo test -run Foo     # Run top-level tests matching \"Foo\", such as \"TestFooBar\".\ngo test -run Foo/A=  # For top-level tests matching \"Foo\", run subtests matching \"A=\".\ngo test -run /A=1    # For all top-level tests, run subtests matching \"A=1\".\n\n```\nSubtests can also be used to control parallelism. A parent test will only complete once all of its subtests complete. In this example, all tests are run in parallel with each other, and only with each other, regardless of other top-level tests that may be defined: \n\n```\nfunc TestGroupedParallel(t *testing.T) {\n    for _, tc := range tests {\n        tc := tc // capture range variable\n        t.Run(tc.Name, func(t *testing.T) {\n            t.Parallel()\n            ...\n        })\n    }\n}\n\n```\nThe race detector kills the program if it exceeds 8128 concurrent goroutines, so use care when running parallel tests with the -race flag set. \n\nRun does not return until parallel subtests have completed, providing a way to clean up after a group of parallel tests: \n\n```\nfunc TestTeardownParallel(t *testing.T) {\n    // This Run will not return until the parallel tests finish.\n    t.Run(\"group\", func(t *testing.T) {\n        t.Run(\"Test1\", parallelTest1)\n        t.Run(\"Test2\", parallelTest2)\n        t.Run(\"Test3\", parallelTest3)\n    })\n    // <tear-down code>\n}\n\n```\n### hdr-MainMain\nIt is sometimes necessary for a test or benchmark program to do extra setup or teardown before or after it executes. It is also sometimes necessary to control which code runs on the main thread. To support these and other cases, if a test file contains a function: \n\n```\nfunc TestMain(m *testing.M)\n\n```\nthen the generated test will call TestMain(m) instead of running the tests or benchmarks directly. TestMain runs in the main goroutine and can do whatever setup and teardown is necessary around a call to m.Run. m.Run will return an exit code that may be passed to os.Exit. If TestMain returns, the test wrapper will pass the result of m.Run to os.Exit itself. \n\nWhen TestMain is called, flag.Parse has not been run. If TestMain depends on command-line flags, including those of the testing package, it should call flag.Parse explicitly. Command line flags are always parsed by the time test or benchmark functions run. \n\nA simple implementation of TestMain is: \n\n```\nfunc TestMain(m *testing.M) {\n\t// call flag.Parse() here if TestMain uses flags\n\tos.Exit(m.Run())\n}\n\n```\n"
  },
  "children": [
    {
      "pathID": "/testing/internal"
    },
    {
      "node": {
        "pathID": "/testing#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/testing#maxStackLen",
              "documentation": {
                "identifier": "maxStackLen",
                "newPage": false,
                "searchKey": "testing.maxStackLen",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxStackLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxStackLen = 50\n```\n\nThe maximum number of stack frames to go through when skipping helper functions for the purpose of decorating log messages. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#normalPanic",
              "documentation": {
                "identifier": "normalPanic",
                "newPage": false,
                "searchKey": "testing.normalPanic",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const normalPanic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst normalPanic panicHandling = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#recoverAndReturnPanic",
              "documentation": {
                "identifier": "recoverAndReturnPanic",
                "newPage": false,
                "searchKey": "testing.recoverAndReturnPanic",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const recoverAndReturnPanic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst recoverAndReturnPanic\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/testing#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/testing#matchBenchmarks",
              "documentation": {
                "identifier": "matchBenchmarks",
                "newPage": false,
                "searchKey": "testing.matchBenchmarks",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var matchBenchmarks"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar matchBenchmarks *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#benchmarkMemory",
              "documentation": {
                "identifier": "benchmarkMemory",
                "newPage": false,
                "searchKey": "testing.benchmarkMemory",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var benchmarkMemory"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar benchmarkMemory *bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#benchTime",
              "documentation": {
                "identifier": "benchTime",
                "newPage": false,
                "searchKey": "testing.benchTime",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var benchTime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar benchTime = benchTimeFlag{d: 1 * time.Second} // changed during test of testing package\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#benchmarkLock",
              "documentation": {
                "identifier": "benchmarkLock",
                "newPage": false,
                "searchKey": "testing.benchmarkLock",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var benchmarkLock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar benchmarkLock sync.Mutex\n```\n\nGlobal lock to ensure only one benchmark runs at a time. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#memStats",
              "documentation": {
                "identifier": "memStats",
                "newPage": false,
                "searchKey": "testing.memStats",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var memStats"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar memStats runtime.MemStats\n```\n\nUsed for every benchmark for measuring memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#labelsOnce",
              "documentation": {
                "identifier": "labelsOnce",
                "newPage": false,
                "searchKey": "testing.labelsOnce",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var labelsOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar labelsOnce sync.Once\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#cover",
              "documentation": {
                "identifier": "cover",
                "newPage": false,
                "searchKey": "testing.cover",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var cover"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cover Cover\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#matchMutex",
              "documentation": {
                "identifier": "matchMutex",
                "newPage": false,
                "searchKey": "testing.matchMutex",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var matchMutex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar matchMutex sync.Mutex\n```\n\nTODO: fix test_main to avoid race and improve caching, also allowing to eliminate this Mutex. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#initRan",
              "documentation": {
                "identifier": "initRan",
                "newPage": false,
                "searchKey": "testing.initRan",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var initRan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar initRan bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#short",
              "documentation": {
                "identifier": "short",
                "newPage": false,
                "searchKey": "testing.short",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var short"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar short *bool\n```\n\nFlags, registered during Init. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#failFast",
              "documentation": {
                "identifier": "failFast",
                "newPage": false,
                "searchKey": "testing.failFast",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var failFast"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar failFast *bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#outputDir",
              "documentation": {
                "identifier": "outputDir",
                "newPage": false,
                "searchKey": "testing.outputDir",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var outputDir"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar outputDir *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#chatty",
              "documentation": {
                "identifier": "chatty",
                "newPage": false,
                "searchKey": "testing.chatty",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var chatty"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar chatty *bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#count",
              "documentation": {
                "identifier": "count",
                "newPage": false,
                "searchKey": "testing.count",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var count"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar count *uint\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#coverProfile",
              "documentation": {
                "identifier": "coverProfile",
                "newPage": false,
                "searchKey": "testing.coverProfile",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var coverProfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar coverProfile *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#matchList",
              "documentation": {
                "identifier": "matchList",
                "newPage": false,
                "searchKey": "testing.matchList",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var matchList"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar matchList *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#match",
              "documentation": {
                "identifier": "match",
                "newPage": false,
                "searchKey": "testing.match",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var match"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar match *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#memProfile",
              "documentation": {
                "identifier": "memProfile",
                "newPage": false,
                "searchKey": "testing.memProfile",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var memProfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar memProfile *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#memProfileRate",
              "documentation": {
                "identifier": "memProfileRate",
                "newPage": false,
                "searchKey": "testing.memProfileRate",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var memProfileRate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar memProfileRate *int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#cpuProfile",
              "documentation": {
                "identifier": "cpuProfile",
                "newPage": false,
                "searchKey": "testing.cpuProfile",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var cpuProfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cpuProfile *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#blockProfile",
              "documentation": {
                "identifier": "blockProfile",
                "newPage": false,
                "searchKey": "testing.blockProfile",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var blockProfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar blockProfile *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#blockProfileRate",
              "documentation": {
                "identifier": "blockProfileRate",
                "newPage": false,
                "searchKey": "testing.blockProfileRate",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var blockProfileRate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar blockProfileRate *int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#mutexProfile",
              "documentation": {
                "identifier": "mutexProfile",
                "newPage": false,
                "searchKey": "testing.mutexProfile",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var mutexProfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mutexProfile *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#mutexProfileFraction",
              "documentation": {
                "identifier": "mutexProfileFraction",
                "newPage": false,
                "searchKey": "testing.mutexProfileFraction",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var mutexProfileFraction"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mutexProfileFraction *int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#panicOnExit0",
              "documentation": {
                "identifier": "panicOnExit0",
                "newPage": false,
                "searchKey": "testing.panicOnExit0",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var panicOnExit0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar panicOnExit0 *bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#traceFile",
              "documentation": {
                "identifier": "traceFile",
                "newPage": false,
                "searchKey": "testing.traceFile",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var traceFile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar traceFile *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#timeout",
              "documentation": {
                "identifier": "timeout",
                "newPage": false,
                "searchKey": "testing.timeout",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var timeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar timeout *time.Duration\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#cpuListStr",
              "documentation": {
                "identifier": "cpuListStr",
                "newPage": false,
                "searchKey": "testing.cpuListStr",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var cpuListStr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cpuListStr *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#parallel",
              "documentation": {
                "identifier": "parallel",
                "newPage": false,
                "searchKey": "testing.parallel",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var parallel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar parallel *int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#shuffle",
              "documentation": {
                "identifier": "shuffle",
                "newPage": false,
                "searchKey": "testing.shuffle",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var shuffle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar shuffle *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#testlog",
              "documentation": {
                "identifier": "testlog",
                "newPage": false,
                "searchKey": "testing.testlog",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testlog"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testlog *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#haveExamples",
              "documentation": {
                "identifier": "haveExamples",
                "newPage": false,
                "searchKey": "testing.haveExamples",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var haveExamples"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar haveExamples bool // are there examples?\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#cpuList",
              "documentation": {
                "identifier": "cpuList",
                "newPage": false,
                "searchKey": "testing.cpuList",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var cpuList"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cpuList []int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#testlogFile",
              "documentation": {
                "identifier": "testlogFile",
                "newPage": false,
                "searchKey": "testing.testlogFile",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var testlogFile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testlogFile *os.File\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#numFailed",
              "documentation": {
                "identifier": "numFailed",
                "newPage": false,
                "searchKey": "testing.numFailed",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var numFailed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar numFailed uint32 // number of test failures\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#errNilPanicOrGoexit",
              "documentation": {
                "identifier": "errNilPanicOrGoexit",
                "newPage": false,
                "searchKey": "testing.errNilPanicOrGoexit",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errNilPanicOrGoexit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errNilPanicOrGoexit = errors.New(\"test executed panic(nil) or runtime.Goexit\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#errMain",
              "documentation": {
                "identifier": "errMain",
                "newPage": false,
                "searchKey": "testing.errMain",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errMain"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errMain = errors.New(\"testing: unexpected use of func Main\")\n```\n\nNo one should be using func Main anymore. See the doc comment on func Main and use MainStart instead. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#PrettyPrint",
              "documentation": {
                "identifier": "PrettyPrint",
                "newPage": false,
                "searchKey": "testing.PrettyPrint",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var PrettyPrint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar PrettyPrint = prettyPrint\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/testing#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/testing#benchTimeFlag",
              "documentation": {
                "identifier": "benchTimeFlag",
                "newPage": false,
                "searchKey": "testing.benchTimeFlag",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type benchTimeFlag struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype benchTimeFlag struct {\n\td time.Duration\n\tn int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#benchTimeFlag.String",
                    "documentation": {
                      "identifier": "benchTimeFlag.String",
                      "newPage": false,
                      "searchKey": "testing.benchTimeFlag.String",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *benchTimeFlag) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *benchTimeFlag) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#benchTimeFlag.Set",
                    "documentation": {
                      "identifier": "benchTimeFlag.Set",
                      "newPage": false,
                      "searchKey": "testing.benchTimeFlag.Set",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *benchTimeFlag) Set(s string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *benchTimeFlag) Set(s string) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#InternalBenchmark",
              "documentation": {
                "identifier": "InternalBenchmark",
                "newPage": false,
                "searchKey": "testing.InternalBenchmark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type InternalBenchmark struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype InternalBenchmark struct {\n\tName string\n\tF    func(b *B)\n}\n```\n\nInternalBenchmark is an internal type but exported because it is cross-package; it is part of the implementation of the \"go test\" command. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#B",
              "documentation": {
                "identifier": "B",
                "newPage": false,
                "searchKey": "testing.B",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type B struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype B struct {\n\tcommon\n\timportPath       string // import path of the package containing the benchmark\n\tcontext          *benchContext\n\tN                int\n\tpreviousN        int           // number of iterations in the previous run\n\tpreviousDuration time.Duration // total duration of the previous run\n\tbenchFunc        func(b *B)\n\tbenchTime        benchTimeFlag\n\tbytes            int64\n\tmissingBytes     bool // one of the subbenchmarks does not have bytes set.\n\ttimerOn          bool\n\tshowAllocResult  bool\n\tresult           BenchmarkResult\n\tparallelism      int // RunParallel creates parallelism*GOMAXPROCS goroutines\n\t// The initial states of memStats.Mallocs and memStats.TotalAlloc.\n\tstartAllocs uint64\n\tstartBytes  uint64\n\t// The net total of this test after being run.\n\tnetAllocs uint64\n\tnetBytes  uint64\n\t// Extra metrics collected by ReportMetric.\n\textra map[string]float64\n}\n```\n\nB is a type passed to Benchmark functions to manage benchmark timing and to specify the number of iterations to run. \n\nA benchmark ends when its Benchmark function returns or calls any of the methods FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods must be called only from the goroutine running the Benchmark function. The other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines. \n\nLike in tests, benchmark logs are accumulated during execution and dumped to standard output when done. Unlike in tests, benchmark logs are always printed, so as not to hide output whose existence may be affecting benchmark results. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#B.StartTimer",
                    "documentation": {
                      "identifier": "B.StartTimer",
                      "newPage": false,
                      "searchKey": "testing.B.StartTimer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) StartTimer()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) StartTimer()\n```\n\nStartTimer starts timing a test. This function is called automatically before a benchmark starts, but it can also be used to resume timing after a call to StopTimer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.StopTimer",
                    "documentation": {
                      "identifier": "B.StopTimer",
                      "newPage": false,
                      "searchKey": "testing.B.StopTimer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) StopTimer()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) StopTimer()\n```\n\nStopTimer stops timing a test. This can be used to pause the timer while performing complex initialization that you don't want to measure. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.ResetTimer",
                    "documentation": {
                      "identifier": "B.ResetTimer",
                      "newPage": false,
                      "searchKey": "testing.B.ResetTimer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) ResetTimer()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) ResetTimer()\n```\n\nResetTimer zeroes the elapsed benchmark time and memory allocation counters and deletes user-reported metrics. It does not affect whether the timer is running. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.SetBytes",
                    "documentation": {
                      "identifier": "B.SetBytes",
                      "newPage": false,
                      "searchKey": "testing.B.SetBytes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) SetBytes(n int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) SetBytes(n int64)\n```\n\nSetBytes records the number of bytes processed in a single operation. If this is called, the benchmark will report ns/op and MB/s. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.ReportAllocs",
                    "documentation": {
                      "identifier": "B.ReportAllocs",
                      "newPage": false,
                      "searchKey": "testing.B.ReportAllocs",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) ReportAllocs()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) ReportAllocs()\n```\n\nReportAllocs enables malloc statistics for this benchmark. It is equivalent to setting -test.benchmem, but it only affects the benchmark function that calls ReportAllocs. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.runN",
                    "documentation": {
                      "identifier": "B.runN",
                      "newPage": false,
                      "searchKey": "testing.B.runN",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) runN(n int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) runN(n int)\n```\n\nrunN runs a single benchmark for the specified number of iterations. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.run1",
                    "documentation": {
                      "identifier": "B.run1",
                      "newPage": false,
                      "searchKey": "testing.B.run1",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) run1() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) run1() bool\n```\n\nrun1 runs the first iteration of benchFunc. It reports whether more iterations of this benchmarks should be run. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.run",
                    "documentation": {
                      "identifier": "B.run",
                      "newPage": false,
                      "searchKey": "testing.B.run",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) run()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) run()\n```\n\nrun executes the benchmark in a separate goroutine, including all of its subbenchmarks. b must not have subbenchmarks. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.doBench",
                    "documentation": {
                      "identifier": "B.doBench",
                      "newPage": false,
                      "searchKey": "testing.B.doBench",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) doBench() BenchmarkResult"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) doBench() BenchmarkResult\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.launch",
                    "documentation": {
                      "identifier": "B.launch",
                      "newPage": false,
                      "searchKey": "testing.B.launch",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) launch()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) launch()\n```\n\nlaunch launches the benchmark function. It gradually increases the number of benchmark iterations until the benchmark runs for the requested benchtime. launch is run by the doBench function as a separate goroutine. run1 must have been called on b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.ReportMetric",
                    "documentation": {
                      "identifier": "B.ReportMetric",
                      "newPage": false,
                      "searchKey": "testing.B.ReportMetric",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) ReportMetric(n float64, unit string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) ReportMetric(n float64, unit string)\n```\n\nReportMetric adds \"n unit\" to the reported benchmark results. If the metric is per-iteration, the caller should divide by b.N, and by convention units should end in \"/op\". ReportMetric overrides any previously reported value for the same unit. ReportMetric panics if unit is the empty string or if unit contains any whitespace. If unit is a unit normally reported by the benchmark framework itself (such as \"allocs/op\"), ReportMetric will override that metric. Setting \"ns/op\" to 0 will suppress that built-in metric. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.Run",
                    "documentation": {
                      "identifier": "B.Run",
                      "newPage": false,
                      "searchKey": "testing.B.Run",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) Run(name string, f func(b *B)) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) Run(name string, f func(b *B)) bool\n```\n\nRun benchmarks f as a subbenchmark with the given name. It reports whether there were any failures. \n\nA subbenchmark is like any other benchmark. A benchmark that calls Run at least once will not be measured itself and will be called once with N=1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.add",
                    "documentation": {
                      "identifier": "B.add",
                      "newPage": false,
                      "searchKey": "testing.B.add",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) add(other BenchmarkResult)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) add(other BenchmarkResult)\n```\n\nadd simulates running benchmarks in sequence in a single iteration. It is used to give some meaningful results in case func Benchmark is used in combination with Run. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.trimOutput",
                    "documentation": {
                      "identifier": "B.trimOutput",
                      "newPage": false,
                      "searchKey": "testing.B.trimOutput",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) trimOutput()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) trimOutput()\n```\n\ntrimOutput shortens the output from a benchmark, which can be very long. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.RunParallel",
                    "documentation": {
                      "identifier": "B.RunParallel",
                      "newPage": false,
                      "searchKey": "testing.B.RunParallel",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) RunParallel(body func(*PB))"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) RunParallel(body func(*PB))\n```\n\nRunParallel runs a benchmark in parallel. It creates multiple goroutines and distributes b.N iterations among them. The number of goroutines defaults to GOMAXPROCS. To increase parallelism for non-CPU-bound benchmarks, call SetParallelism before RunParallel. RunParallel is usually used with the go test -cpu flag. \n\nThe body function will be run in each goroutine. It should set up any goroutine-local state and then iterate until pb.Next returns false. It should not use the StartTimer, StopTimer, or ResetTimer functions, because they have global effect. It should also not call Run. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#B.SetParallelism",
                    "documentation": {
                      "identifier": "B.SetParallelism",
                      "newPage": false,
                      "searchKey": "testing.B.SetParallelism",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *B) SetParallelism(p int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *B) SetParallelism(p int)\n```\n\nSetParallelism sets the number of goroutines used by RunParallel to p*GOMAXPROCS. There is usually no need to call SetParallelism for CPU-bound benchmarks. If p is less than 1, this call will have no effect. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#BenchmarkResult",
              "documentation": {
                "identifier": "BenchmarkResult",
                "newPage": false,
                "searchKey": "testing.BenchmarkResult",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type BenchmarkResult struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype BenchmarkResult struct {\n\tN         int           // The number of iterations.\n\tT         time.Duration // The total time taken.\n\tBytes     int64         // Bytes processed in one iteration.\n\tMemAllocs uint64        // The total number of memory allocations.\n\tMemBytes  uint64        // The total number of bytes allocated.\n\n\t// Extra records additional metrics reported by ReportMetric.\n\tExtra map[string]float64\n}\n```\n\nBenchmarkResult contains the results of a benchmark run. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#Benchmark",
                    "documentation": {
                      "identifier": "Benchmark",
                      "newPage": false,
                      "searchKey": "testing.Benchmark",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Benchmark(f func(b *B)) BenchmarkResult"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Benchmark(f func(b *B)) BenchmarkResult\n```\n\nBenchmark benchmarks a single function. It is useful for creating custom benchmarks that do not use the \"go test\" command. \n\nIf f depends on testing flags, then Init must be used to register those flags before calling Benchmark and before calling flag.Parse. \n\nIf f calls Run, the result will be an estimate of running all its subbenchmarks that don't call Run in sequence in a single benchmark. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#BenchmarkResult.NsPerOp",
                    "documentation": {
                      "identifier": "BenchmarkResult.NsPerOp",
                      "newPage": false,
                      "searchKey": "testing.BenchmarkResult.NsPerOp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r BenchmarkResult) NsPerOp() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r BenchmarkResult) NsPerOp() int64\n```\n\nNsPerOp returns the \"ns/op\" metric. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#BenchmarkResult.mbPerSec",
                    "documentation": {
                      "identifier": "BenchmarkResult.mbPerSec",
                      "newPage": false,
                      "searchKey": "testing.BenchmarkResult.mbPerSec",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r BenchmarkResult) mbPerSec() float64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r BenchmarkResult) mbPerSec() float64\n```\n\nmbPerSec returns the \"MB/s\" metric. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#BenchmarkResult.AllocsPerOp",
                    "documentation": {
                      "identifier": "BenchmarkResult.AllocsPerOp",
                      "newPage": false,
                      "searchKey": "testing.BenchmarkResult.AllocsPerOp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r BenchmarkResult) AllocsPerOp() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r BenchmarkResult) AllocsPerOp() int64\n```\n\nAllocsPerOp returns the \"allocs/op\" metric, which is calculated as r.MemAllocs / r.N. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#BenchmarkResult.AllocedBytesPerOp",
                    "documentation": {
                      "identifier": "BenchmarkResult.AllocedBytesPerOp",
                      "newPage": false,
                      "searchKey": "testing.BenchmarkResult.AllocedBytesPerOp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r BenchmarkResult) AllocedBytesPerOp() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r BenchmarkResult) AllocedBytesPerOp() int64\n```\n\nAllocedBytesPerOp returns the \"B/op\" metric, which is calculated as r.MemBytes / r.N. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#BenchmarkResult.String",
                    "documentation": {
                      "identifier": "BenchmarkResult.String",
                      "newPage": false,
                      "searchKey": "testing.BenchmarkResult.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r BenchmarkResult) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r BenchmarkResult) String() string\n```\n\nString returns a summary of the benchmark results. It follows the benchmark result line format from [https://golang.org/design/14313-benchmark-format](https://golang.org/design/14313-benchmark-format), not including the benchmark name. Extra metrics override built-in metrics of the same name. String does not include allocs/op or B/op, since those are reported by MemString. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#BenchmarkResult.MemString",
                    "documentation": {
                      "identifier": "BenchmarkResult.MemString",
                      "newPage": false,
                      "searchKey": "testing.BenchmarkResult.MemString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r BenchmarkResult) MemString() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r BenchmarkResult) MemString() string\n```\n\nMemString returns r.AllocedBytesPerOp and r.AllocsPerOp in the same format as 'go test'. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#benchContext",
              "documentation": {
                "identifier": "benchContext",
                "newPage": false,
                "searchKey": "testing.benchContext",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type benchContext struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype benchContext struct {\n\tmatch *matcher\n\n\tmaxLen int // The largest recorded benchmark name.\n\textLen int // Maximum extension length.\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#benchContext.processBench",
                    "documentation": {
                      "identifier": "benchContext.processBench",
                      "newPage": false,
                      "searchKey": "testing.benchContext.processBench",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ctx *benchContext) processBench(b *B)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ctx *benchContext) processBench(b *B)\n```\n\nprocessBench runs bench b for the configured CPU counts and prints the results. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#PB",
              "documentation": {
                "identifier": "PB",
                "newPage": false,
                "searchKey": "testing.PB",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type PB struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PB struct {\n\tglobalN *uint64 // shared between all worker goroutines iteration counter\n\tgrain   uint64  // acquire that many iterations from globalN at once\n\tcache   uint64  // local cache of acquired iterations\n\tbN      uint64  // total number of iterations to execute (b.N)\n}\n```\n\nA PB is used by RunParallel for running parallel benchmarks. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#PB.Next",
                    "documentation": {
                      "identifier": "PB.Next",
                      "newPage": false,
                      "searchKey": "testing.PB.Next",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pb *PB) Next() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pb *PB) Next() bool\n```\n\nNext reports whether there are more iterations to execute. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#discard",
              "documentation": {
                "identifier": "discard",
                "newPage": false,
                "searchKey": "testing.discard",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type discard struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype discard struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#discard.Write",
                    "documentation": {
                      "identifier": "discard.Write",
                      "newPage": false,
                      "searchKey": "testing.discard.Write",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (discard) Write(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (discard) Write(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#CoverBlock",
              "documentation": {
                "identifier": "CoverBlock",
                "newPage": false,
                "searchKey": "testing.CoverBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type CoverBlock struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype CoverBlock struct {\n\tLine0 uint32 // Line number for block start.\n\tCol0  uint16 // Column number for block start.\n\tLine1 uint32 // Line number for block end.\n\tCol1  uint16 // Column number for block end.\n\tStmts uint16 // Number of statements included in this block.\n}\n```\n\nCoverBlock records the coverage data for a single basic block. The fields are 1-indexed, as in an editor: The opening line of the file is number 1, for example. Columns are measured in bytes. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#Cover",
              "documentation": {
                "identifier": "Cover",
                "newPage": false,
                "searchKey": "testing.Cover",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Cover struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Cover struct {\n\tMode            string\n\tCounters        map[string][]uint32\n\tBlocks          map[string][]CoverBlock\n\tCoveredPackages string\n}\n```\n\nCover records information about test coverage checking. NOTE: This struct is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#InternalExample",
              "documentation": {
                "identifier": "InternalExample",
                "newPage": false,
                "searchKey": "testing.InternalExample",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type InternalExample struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype InternalExample struct {\n\tName      string\n\tF         func()\n\tOutput    string\n\tUnordered bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#InternalExample.processRunResult",
                    "documentation": {
                      "identifier": "InternalExample.processRunResult",
                      "newPage": false,
                      "searchKey": "testing.InternalExample.processRunResult",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (eg *InternalExample) processRunResult(stdout string, timeSpent time.Duration, finished bool, recovered interface{}) (passed bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (eg *InternalExample) processRunResult(stdout string, timeSpent time.Duration, finished bool, recovered interface{}) (passed bool)\n```\n\nprocessRunResult computes a summary and status of the result of running an example test. stdout is the captured output from stdout of the test. recovered is the result of invoking recover after running the test, in case it panicked. \n\nIf stdout doesn't match the expected output or if recovered is non-nil, it'll print the cause of failure to stdout. If the test is chatty/verbose, it'll print a success message to stdout. If recovered is non-nil, it'll panic with that value. If the test panicked with nil, or invoked runtime.Goexit, it'll be made to fail and panic with errNilPanicOrGoexit \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#matcher",
              "documentation": {
                "identifier": "matcher",
                "newPage": false,
                "searchKey": "testing.matcher",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type matcher struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype matcher struct {\n\tfilter    []string\n\tmatchFunc func(pat, str string) (bool, error)\n\n\tmu       sync.Mutex\n\tsubNames map[string]int64\n}\n```\n\nmatcher sanitizes, uniques, and filters names of subtests and subbenchmarks. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#newMatcher",
                    "documentation": {
                      "identifier": "newMatcher",
                      "newPage": false,
                      "searchKey": "testing.newMatcher",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newMatcher(matchString func(pat, str string) (bool, error), patterns, name string) *matcher"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newMatcher(matchString func(pat, str string) (bool, error), patterns, name string) *matcher\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#matcher.fullName",
                    "documentation": {
                      "identifier": "matcher.fullName",
                      "newPage": false,
                      "searchKey": "testing.matcher.fullName",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *matcher) fullName(c *common, subname string) (name string, ok, partial bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *matcher) fullName(c *common, subname string) (name string, ok, partial bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#matcher.unique",
                    "documentation": {
                      "identifier": "matcher.unique",
                      "newPage": false,
                      "searchKey": "testing.matcher.unique",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *matcher) unique(parent, subname string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *matcher) unique(parent, subname string) string\n```\n\nunique creates a unique name for the given parent and subname by affixing it with one or more counts, if necessary. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#chattyPrinter",
              "documentation": {
                "identifier": "chattyPrinter",
                "newPage": false,
                "searchKey": "testing.chattyPrinter",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type chattyPrinter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype chattyPrinter struct {\n\tw          io.Writer\n\tlastNameMu sync.Mutex // guards lastName\n\tlastName   string     // last printed test name in chatty mode\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#newChattyPrinter",
                    "documentation": {
                      "identifier": "newChattyPrinter",
                      "newPage": false,
                      "searchKey": "testing.newChattyPrinter",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newChattyPrinter(w io.Writer) *chattyPrinter"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newChattyPrinter(w io.Writer) *chattyPrinter\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#chattyPrinter.Updatef",
                    "documentation": {
                      "identifier": "chattyPrinter.Updatef",
                      "newPage": false,
                      "searchKey": "testing.chattyPrinter.Updatef",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *chattyPrinter) Updatef(testName, format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *chattyPrinter) Updatef(testName, format string, args ...interface{})\n```\n\nUpdatef prints a message about the status of the named test to w. \n\nThe formatted message must include the test name itself. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#chattyPrinter.Printf",
                    "documentation": {
                      "identifier": "chattyPrinter.Printf",
                      "newPage": false,
                      "searchKey": "testing.chattyPrinter.Printf",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *chattyPrinter) Printf(testName, format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *chattyPrinter) Printf(testName, format string, args ...interface{})\n```\n\nPrintf prints a message, generated by the named test, that does not necessarily mention that tests's name itself. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#common",
              "documentation": {
                "identifier": "common",
                "newPage": false,
                "searchKey": "testing.common",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type common struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype common struct {\n\tmu          sync.RWMutex         // guards this group of fields\n\toutput      []byte               // Output generated by test or benchmark.\n\tw           io.Writer            // For flushToParent.\n\tran         bool                 // Test or benchmark (or one of its subtests) was executed.\n\tfailed      bool                 // Test or benchmark has failed.\n\tskipped     bool                 // Test or benchmark has been skipped.\n\tdone        bool                 // Test is finished and all subtests have completed.\n\thelperPCs   map[uintptr]struct{} // functions to be skipped when writing file/line info\n\thelperNames map[string]struct{}  // helperPCs converted to function names\n\tcleanups    []func()             // optional functions to be called at the end of the test\n\tcleanupName string               // Name of the cleanup function.\n\tcleanupPc   []uintptr            // The stack trace at the point where Cleanup was called.\n\tfinished    bool                 // Test function has completed.\n\n\tchatty     *chattyPrinter // A copy of chattyPrinter, if the chatty flag is set.\n\tbench      bool           // Whether the current test is a benchmark.\n\thasSub     int32          // Written atomically.\n\traceErrors int            // Number of races detected during test.\n\trunner     string         // Function name of tRunner running the test.\n\n\tparent   *common\n\tlevel    int       // Nesting depth of test or benchmark.\n\tcreator  []uintptr // If level > 0, the stack trace at the point where the parent called t.Run.\n\tname     string    // Name of test or benchmark.\n\tstart    time.Time // Time test or benchmark started\n\tduration time.Duration\n\tbarrier  chan bool // To signal parallel subtests they may start.\n\tsignal   chan bool // To signal a test is done.\n\tsub      []*T      // Queue of subtests to be run in parallel.\n\n\ttempDirMu  sync.Mutex\n\ttempDir    string\n\ttempDirErr error\n\ttempDirSeq int32\n}\n```\n\ncommon holds the elements common between T and B and captures common methods such as Errorf. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#common.frameSkip",
                    "documentation": {
                      "identifier": "common.frameSkip",
                      "newPage": false,
                      "searchKey": "testing.common.frameSkip",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) frameSkip(skip int) runtime.Frame"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) frameSkip(skip int) runtime.Frame\n```\n\nframeSkip searches, starting after skip frames, for the first caller frame in a function not marked as a helper and returns that frame. The search stops if it finds a tRunner function that was the entry point into the test and the test is not a subtest. This function must be called with c.mu held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.decorate",
                    "documentation": {
                      "identifier": "common.decorate",
                      "newPage": false,
                      "searchKey": "testing.common.decorate",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) decorate(s string, skip int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) decorate(s string, skip int) string\n```\n\ndecorate prefixes the string with the file and line of the call site and inserts the final newline if needed and indentation spaces for formatting. This function must be called with c.mu held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.flushToParent",
                    "documentation": {
                      "identifier": "common.flushToParent",
                      "newPage": false,
                      "searchKey": "testing.common.flushToParent",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) flushToParent(testName, format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) flushToParent(testName, format string, args ...interface{})\n```\n\nflushToParent writes c.output to the parent after first writing the header with the given format and arguments. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.private",
                    "documentation": {
                      "identifier": "common.private",
                      "newPage": false,
                      "searchKey": "testing.common.private",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) private()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) private()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Name",
                    "documentation": {
                      "identifier": "common.Name",
                      "newPage": false,
                      "searchKey": "testing.common.Name",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Name() string\n```\n\nName returns the name of the running test or benchmark. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.setRan",
                    "documentation": {
                      "identifier": "common.setRan",
                      "newPage": false,
                      "searchKey": "testing.common.setRan",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) setRan()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) setRan()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Fail",
                    "documentation": {
                      "identifier": "common.Fail",
                      "newPage": false,
                      "searchKey": "testing.common.Fail",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Fail()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Fail()\n```\n\nFail marks the function as having failed but continues execution. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Failed",
                    "documentation": {
                      "identifier": "common.Failed",
                      "newPage": false,
                      "searchKey": "testing.common.Failed",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Failed() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Failed() bool\n```\n\nFailed reports whether the function has failed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.FailNow",
                    "documentation": {
                      "identifier": "common.FailNow",
                      "newPage": false,
                      "searchKey": "testing.common.FailNow",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) FailNow()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) FailNow()\n```\n\nFailNow marks the function as having failed and stops its execution by calling runtime.Goexit (which then runs all deferred calls in the current goroutine). Execution will continue at the next test or benchmark. FailNow must be called from the goroutine running the test or benchmark function, not from other goroutines created during the test. Calling FailNow does not stop those other goroutines. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.log",
                    "documentation": {
                      "identifier": "common.log",
                      "newPage": false,
                      "searchKey": "testing.common.log",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) log(s string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) log(s string)\n```\n\nlog generates the output. It's always at the same stack depth. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.logDepth",
                    "documentation": {
                      "identifier": "common.logDepth",
                      "newPage": false,
                      "searchKey": "testing.common.logDepth",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) logDepth(s string, depth int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) logDepth(s string, depth int)\n```\n\nlogDepth generates the output at an arbitrary stack depth. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Log",
                    "documentation": {
                      "identifier": "common.Log",
                      "newPage": false,
                      "searchKey": "testing.common.Log",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Log(args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Log(args ...interface{})\n```\n\nLog formats its arguments using default formatting, analogous to Println, and records the text in the error log. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Logf",
                    "documentation": {
                      "identifier": "common.Logf",
                      "newPage": false,
                      "searchKey": "testing.common.Logf",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Logf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Logf(format string, args ...interface{})\n```\n\nLogf formats its arguments according to the format, analogous to Printf, and records the text in the error log. A final newline is added if not provided. For tests, the text will be printed only if the test fails or the -test.v flag is set. For benchmarks, the text is always printed to avoid having performance depend on the value of the -test.v flag. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Error",
                    "documentation": {
                      "identifier": "common.Error",
                      "newPage": false,
                      "searchKey": "testing.common.Error",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Error(args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Error(args ...interface{})\n```\n\nError is equivalent to Log followed by Fail. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Errorf",
                    "documentation": {
                      "identifier": "common.Errorf",
                      "newPage": false,
                      "searchKey": "testing.common.Errorf",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Errorf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Errorf(format string, args ...interface{})\n```\n\nErrorf is equivalent to Logf followed by Fail. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Fatal",
                    "documentation": {
                      "identifier": "common.Fatal",
                      "newPage": false,
                      "searchKey": "testing.common.Fatal",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Fatal(args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Fatal(args ...interface{})\n```\n\nFatal is equivalent to Log followed by FailNow. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Fatalf",
                    "documentation": {
                      "identifier": "common.Fatalf",
                      "newPage": false,
                      "searchKey": "testing.common.Fatalf",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Fatalf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Fatalf(format string, args ...interface{})\n```\n\nFatalf is equivalent to Logf followed by FailNow. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Skip",
                    "documentation": {
                      "identifier": "common.Skip",
                      "newPage": false,
                      "searchKey": "testing.common.Skip",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Skip(args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Skip(args ...interface{})\n```\n\nSkip is equivalent to Log followed by SkipNow. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Skipf",
                    "documentation": {
                      "identifier": "common.Skipf",
                      "newPage": false,
                      "searchKey": "testing.common.Skipf",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Skipf(format string, args ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Skipf(format string, args ...interface{})\n```\n\nSkipf is equivalent to Logf followed by SkipNow. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.SkipNow",
                    "documentation": {
                      "identifier": "common.SkipNow",
                      "newPage": false,
                      "searchKey": "testing.common.SkipNow",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) SkipNow()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) SkipNow()\n```\n\nSkipNow marks the test as having been skipped and stops its execution by calling runtime.Goexit. If a test fails (see Error, Errorf, Fail) and is then skipped, it is still considered to have failed. Execution will continue at the next test or benchmark. See also FailNow. SkipNow must be called from the goroutine running the test, not from other goroutines created during the test. Calling SkipNow does not stop those other goroutines. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Skipped",
                    "documentation": {
                      "identifier": "common.Skipped",
                      "newPage": false,
                      "searchKey": "testing.common.Skipped",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Skipped() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Skipped() bool\n```\n\nSkipped reports whether the test was skipped. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Helper",
                    "documentation": {
                      "identifier": "common.Helper",
                      "newPage": false,
                      "searchKey": "testing.common.Helper",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Helper()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Helper()\n```\n\nHelper marks the calling function as a test helper function. When printing file and line information, that function will be skipped. Helper may be called simultaneously from multiple goroutines. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Cleanup",
                    "documentation": {
                      "identifier": "common.Cleanup",
                      "newPage": false,
                      "searchKey": "testing.common.Cleanup",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Cleanup(f func())"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Cleanup(f func())\n```\n\nCleanup registers a function to be called when the test (or subtest) and all its subtests complete. Cleanup functions will be called in last added, first called order. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.TempDir",
                    "documentation": {
                      "identifier": "common.TempDir",
                      "newPage": false,
                      "searchKey": "testing.common.TempDir",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) TempDir() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) TempDir() string\n```\n\nTempDir returns a temporary directory for the test to use. The directory is automatically removed by Cleanup when the test and all its subtests complete. Each subsequent call to t.TempDir returns a unique directory; if the directory creation fails, TempDir terminates the test by calling Fatal. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.Setenv",
                    "documentation": {
                      "identifier": "common.Setenv",
                      "newPage": false,
                      "searchKey": "testing.common.Setenv",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) Setenv(key, value string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) Setenv(key, value string)\n```\n\nSetenv calls os.Setenv(key, value) and uses Cleanup to restore the environment variable to its original value after the test. \n\nThis cannot be used in parallel tests. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#common.runCleanup",
                    "documentation": {
                      "identifier": "common.runCleanup",
                      "newPage": false,
                      "searchKey": "testing.common.runCleanup",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *common) runCleanup(ph panicHandling) (panicVal interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *common) runCleanup(ph panicHandling) (panicVal interface{})\n```\n\nrunCleanup is called at the end of the test. If catchPanic is true, this will catch panics, and return the recovered value if any. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#indenter",
              "documentation": {
                "identifier": "indenter",
                "newPage": false,
                "searchKey": "testing.indenter",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type indenter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype indenter struct {\n\tc *common\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#indenter.Write",
                    "documentation": {
                      "identifier": "indenter.Write",
                      "newPage": false,
                      "searchKey": "testing.indenter.Write",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w indenter) Write(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w indenter) Write(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#TB",
              "documentation": {
                "identifier": "TB",
                "newPage": false,
                "searchKey": "testing.TB",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type TB interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype TB interface {\n\tCleanup(func())\n\tError(args ...interface{})\n\tErrorf(format string, args ...interface{})\n\tFail()\n\tFailNow()\n\tFailed() bool\n\tFatal(args ...interface{})\n\tFatalf(format string, args ...interface{})\n\tHelper()\n\tLog(args ...interface{})\n\tLogf(format string, args ...interface{})\n\tName() string\n\tSkip(args ...interface{})\n\tSkipNow()\n\tSkipf(format string, args ...interface{})\n\tSkipped() bool\n\tTempDir() string\n\n\t// A private method to prevent users implementing the\n\t// interface and so future additions to it will not\n\t// violate Go 1 compatibility.\n\tprivate()\n}\n```\n\nTB is the interface common to T and B. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#T",
              "documentation": {
                "identifier": "T",
                "newPage": false,
                "searchKey": "testing.T",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type T struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype T struct {\n\tcommon\n\tisParallel bool\n\tisEnvSet   bool\n\tcontext    *testContext // For running tests and subtests.\n}\n```\n\nT is a type passed to Test functions to manage test state and support formatted test logs. \n\nA test ends when its Test function returns or calls any of the methods FailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as the Parallel method, must be called only from the goroutine running the Test function. \n\nThe other reporting methods, such as the variations of Log and Error, may be called simultaneously from multiple goroutines. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#T.Parallel",
                    "documentation": {
                      "identifier": "T.Parallel",
                      "newPage": false,
                      "searchKey": "testing.T.Parallel",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Parallel()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Parallel()\n```\n\nParallel signals that this test is to be run in parallel with (and only with) other parallel tests. When a test is run multiple times due to use of -test.count or -test.cpu, multiple instances of a single test never run in parallel with each other. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#T.Setenv",
                    "documentation": {
                      "identifier": "T.Setenv",
                      "newPage": false,
                      "searchKey": "testing.T.Setenv",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Setenv(key, value string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Setenv(key, value string)\n```\n\nSetenv calls os.Setenv(key, value) and uses Cleanup to restore the environment variable to its original value after the test. \n\nThis cannot be used in parallel tests. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#T.Run",
                    "documentation": {
                      "identifier": "T.Run",
                      "newPage": false,
                      "searchKey": "testing.T.Run",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Run(name string, f func(t *T)) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Run(name string, f func(t *T)) bool\n```\n\nRun runs f as a subtest of t called name. It runs f in a separate goroutine and blocks until f returns or calls t.Parallel to become a parallel test. Run reports whether f succeeded (or at least did not fail before calling t.Parallel). \n\nRun may be called simultaneously from multiple goroutines, but all such calls must return before the outer test function for t returns. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#T.Deadline",
                    "documentation": {
                      "identifier": "T.Deadline",
                      "newPage": false,
                      "searchKey": "testing.T.Deadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Deadline() (deadline time.Time, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Deadline() (deadline time.Time, ok bool)\n```\n\nDeadline reports the time at which the test binary will have exceeded the timeout specified by the -timeout flag. \n\nThe ok result is false if the -timeout flag indicates no timeout (0). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#T.report",
                    "documentation": {
                      "identifier": "T.report",
                      "newPage": false,
                      "searchKey": "testing.T.report",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) report()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) report()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#panicHandling",
              "documentation": {
                "identifier": "panicHandling",
                "newPage": false,
                "searchKey": "testing.panicHandling",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type panicHandling int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype panicHandling int\n```\n\npanicHanding is an argument to runCleanup. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#InternalTest",
              "documentation": {
                "identifier": "InternalTest",
                "newPage": false,
                "searchKey": "testing.InternalTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type InternalTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype InternalTest struct {\n\tName string\n\tF    func(*T)\n}\n```\n\nInternalTest is an internal type but exported because it is cross-package; it is part of the implementation of the \"go test\" command. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#testContext",
              "documentation": {
                "identifier": "testContext",
                "newPage": false,
                "searchKey": "testing.testContext",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type testContext struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype testContext struct {\n\tmatch    *matcher\n\tdeadline time.Time\n\n\tmu sync.Mutex\n\n\t// Channel used to signal tests that are ready to be run in parallel.\n\tstartParallel chan bool\n\n\t// running is the number of tests currently running in parallel.\n\t// This does not include tests that are waiting for subtests to complete.\n\trunning int\n\n\t// numWaiting is the number tests waiting to be run in parallel.\n\tnumWaiting int\n\n\t// maxParallel is a copy of the parallel flag.\n\tmaxParallel int\n}\n```\n\ntestContext holds all fields that are common to all tests. This includes synchronization primitives to run at most *parallel tests. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#newTestContext",
                    "documentation": {
                      "identifier": "newTestContext",
                      "newPage": false,
                      "searchKey": "testing.newTestContext",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newTestContext(maxParallel int, m *matcher) *testContext"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newTestContext(maxParallel int, m *matcher) *testContext\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#testContext.waitParallel",
                    "documentation": {
                      "identifier": "testContext.waitParallel",
                      "newPage": false,
                      "searchKey": "testing.testContext.waitParallel",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *testContext) waitParallel()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *testContext) waitParallel()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#testContext.release",
                    "documentation": {
                      "identifier": "testContext.release",
                      "newPage": false,
                      "searchKey": "testing.testContext.release",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *testContext) release()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *testContext) release()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#matchStringOnly",
              "documentation": {
                "identifier": "matchStringOnly",
                "newPage": false,
                "searchKey": "testing.matchStringOnly",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type matchStringOnly func(pat string, str string) (bool, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype matchStringOnly func(pat, str string) (bool, error)\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#matchStringOnly.MatchString",
                    "documentation": {
                      "identifier": "matchStringOnly.MatchString",
                      "newPage": false,
                      "searchKey": "testing.matchStringOnly.MatchString",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f matchStringOnly) MatchString(pat, str string) (bool, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f matchStringOnly) MatchString(pat, str string) (bool, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#matchStringOnly.StartCPUProfile",
                    "documentation": {
                      "identifier": "matchStringOnly.StartCPUProfile",
                      "newPage": false,
                      "searchKey": "testing.matchStringOnly.StartCPUProfile",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f matchStringOnly) StartCPUProfile(w io.Writer) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f matchStringOnly) StartCPUProfile(w io.Writer) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#matchStringOnly.StopCPUProfile",
                    "documentation": {
                      "identifier": "matchStringOnly.StopCPUProfile",
                      "newPage": false,
                      "searchKey": "testing.matchStringOnly.StopCPUProfile",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f matchStringOnly) StopCPUProfile()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f matchStringOnly) StopCPUProfile()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#matchStringOnly.WriteProfileTo",
                    "documentation": {
                      "identifier": "matchStringOnly.WriteProfileTo",
                      "newPage": false,
                      "searchKey": "testing.matchStringOnly.WriteProfileTo",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f matchStringOnly) WriteProfileTo(string, io.Writer, int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f matchStringOnly) WriteProfileTo(string, io.Writer, int) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#matchStringOnly.ImportPath",
                    "documentation": {
                      "identifier": "matchStringOnly.ImportPath",
                      "newPage": false,
                      "searchKey": "testing.matchStringOnly.ImportPath",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f matchStringOnly) ImportPath() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f matchStringOnly) ImportPath() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#matchStringOnly.StartTestLog",
                    "documentation": {
                      "identifier": "matchStringOnly.StartTestLog",
                      "newPage": false,
                      "searchKey": "testing.matchStringOnly.StartTestLog",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f matchStringOnly) StartTestLog(io.Writer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f matchStringOnly) StartTestLog(io.Writer)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#matchStringOnly.StopTestLog",
                    "documentation": {
                      "identifier": "matchStringOnly.StopTestLog",
                      "newPage": false,
                      "searchKey": "testing.matchStringOnly.StopTestLog",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f matchStringOnly) StopTestLog() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f matchStringOnly) StopTestLog() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#matchStringOnly.SetPanicOnExit0",
                    "documentation": {
                      "identifier": "matchStringOnly.SetPanicOnExit0",
                      "newPage": false,
                      "searchKey": "testing.matchStringOnly.SetPanicOnExit0",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f matchStringOnly) SetPanicOnExit0(bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f matchStringOnly) SetPanicOnExit0(bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#M",
              "documentation": {
                "identifier": "M",
                "newPage": false,
                "searchKey": "testing.M",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type M struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype M struct {\n\tdeps       testDeps\n\ttests      []InternalTest\n\tbenchmarks []InternalBenchmark\n\texamples   []InternalExample\n\n\ttimer     *time.Timer\n\tafterOnce sync.Once\n\n\tnumRun int\n\n\t// value to pass to os.Exit, the outer test func main\n\t// harness calls os.Exit with this code. See #34129.\n\texitCode int\n}\n```\n\nM is a type passed to a TestMain function to run the actual tests. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#MainStart",
                    "documentation": {
                      "identifier": "MainStart",
                      "newPage": false,
                      "searchKey": "testing.MainStart",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) *M"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample) *M\n```\n\nMainStart is meant for use by tests generated by 'go test'. It is not meant to be called directly and is not subject to the Go 1 compatibility document. It may change signature from release to release. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#M.Run",
                    "documentation": {
                      "identifier": "M.Run",
                      "newPage": false,
                      "searchKey": "testing.M.Run",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *M) Run() (code int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *M) Run() (code int)\n```\n\nRun runs the tests. It returns an exit code to pass to os.Exit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#M.before",
                    "documentation": {
                      "identifier": "M.before",
                      "newPage": false,
                      "searchKey": "testing.M.before",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *M) before()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *M) before()\n```\n\nbefore runs before all testing. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#M.after",
                    "documentation": {
                      "identifier": "M.after",
                      "newPage": false,
                      "searchKey": "testing.M.after",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *M) after()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *M) after()\n```\n\nafter runs after all testing. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#M.writeProfiles",
                    "documentation": {
                      "identifier": "M.writeProfiles",
                      "newPage": false,
                      "searchKey": "testing.M.writeProfiles",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *M) writeProfiles()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *M) writeProfiles()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#M.startAlarm",
                    "documentation": {
                      "identifier": "M.startAlarm",
                      "newPage": false,
                      "searchKey": "testing.M.startAlarm",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *M) startAlarm() time.Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *M) startAlarm() time.Time\n```\n\nstartAlarm starts an alarm if requested. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/testing#M.stopAlarm",
                    "documentation": {
                      "identifier": "M.stopAlarm",
                      "newPage": false,
                      "searchKey": "testing.M.stopAlarm",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *M) stopAlarm()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *M) stopAlarm()\n```\n\nstopAlarm turns off the alarm. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#testDeps",
              "documentation": {
                "identifier": "testDeps",
                "newPage": false,
                "searchKey": "testing.testDeps",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type testDeps interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype testDeps interface {\n\tImportPath() string\n\tMatchString(pat, str string) (bool, error)\n\tSetPanicOnExit0(bool)\n\tStartCPUProfile(io.Writer) error\n\tStopCPUProfile()\n\tStartTestLog(io.Writer)\n\tStopTestLog() error\n\tWriteProfileTo(string, io.Writer, int) error\n}\n```\n\ntestDeps is an internal interface of functionality that is passed into this package by a test's generated main package. The canonical implementation of this interface is testing/internal/testdeps's TestDeps. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#noopWriter",
              "documentation": {
                "identifier": "noopWriter",
                "newPage": false,
                "searchKey": "testing.noopWriter",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type noopWriter int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype noopWriter int\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#noopWriter.Write",
                    "documentation": {
                      "identifier": "noopWriter.Write",
                      "newPage": false,
                      "searchKey": "testing.noopWriter.Write",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (nw *noopWriter) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (nw *noopWriter) Write(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/testing#funcWriter",
              "documentation": {
                "identifier": "funcWriter",
                "newPage": false,
                "searchKey": "testing.funcWriter",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcWriter struct {\n\twrite func([]byte) (int, error)\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/testing#funcWriter.Write",
                    "documentation": {
                      "identifier": "funcWriter.Write",
                      "newPage": false,
                      "searchKey": "testing.funcWriter.Write",
                      "tags": [
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fw *funcWriter) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fw *funcWriter) Write(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/testing#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/testing#AllocsPerRun",
              "documentation": {
                "identifier": "AllocsPerRun",
                "newPage": false,
                "searchKey": "testing.AllocsPerRun",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func AllocsPerRun(runs int, f func()) (avg float64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc AllocsPerRun(runs int, f func()) (avg float64)\n```\n\nAllocsPerRun returns the average number of allocations during calls to f. Although the return value has type float64, it will always be an integral value. \n\nTo compute the number of allocations, the function will first be run once as a warm-up. The average number of allocations over the specified number of runs will then be measured and returned. \n\nAllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore it before returning. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#initBenchmarkFlags",
              "documentation": {
                "identifier": "initBenchmarkFlags",
                "newPage": false,
                "searchKey": "testing.initBenchmarkFlags",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func initBenchmarkFlags()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc initBenchmarkFlags()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#min",
              "documentation": {
                "identifier": "min",
                "newPage": false,
                "searchKey": "testing.min",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func min(x, y int64) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc min(x, y int64) int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#max",
              "documentation": {
                "identifier": "max",
                "newPage": false,
                "searchKey": "testing.max",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func max(x, y int64) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc max(x, y int64) int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#prettyPrint",
              "documentation": {
                "identifier": "prettyPrint",
                "newPage": false,
                "searchKey": "testing.prettyPrint",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func prettyPrint(w io.Writer, x float64, unit string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc prettyPrint(w io.Writer, x float64, unit string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#benchmarkName",
              "documentation": {
                "identifier": "benchmarkName",
                "newPage": false,
                "searchKey": "testing.benchmarkName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func benchmarkName(name string, n int) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc benchmarkName(name string, n int) string\n```\n\nbenchmarkName returns full name of benchmark including procs suffix. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#RunBenchmarks",
              "documentation": {
                "identifier": "RunBenchmarks",
                "newPage": false,
                "searchKey": "testing.RunBenchmarks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark)\n```\n\nRunBenchmarks is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#runBenchmarks",
              "documentation": {
                "identifier": "runBenchmarks",
                "newPage": false,
                "searchKey": "testing.runBenchmarks",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func runBenchmarks(importPath string, matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runBenchmarks(importPath string, matchString func(pat, str string) (bool, error), benchmarks []InternalBenchmark) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#Coverage",
              "documentation": {
                "identifier": "Coverage",
                "newPage": false,
                "searchKey": "testing.Coverage",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Coverage() float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Coverage() float64\n```\n\nCoverage reports the current code coverage as a fraction in the range [0, 1]. If coverage is not enabled, Coverage returns 0. \n\nWhen running a large set of sequential test cases, checking Coverage after each one can be useful for identifying which test cases exercise new code paths. It is not a replacement for the reports generated by 'go test -cover' and 'go tool cover'. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#RegisterCover",
              "documentation": {
                "identifier": "RegisterCover",
                "newPage": false,
                "searchKey": "testing.RegisterCover",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func RegisterCover(c Cover)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc RegisterCover(c Cover)\n```\n\nRegisterCover records the coverage data accumulators for the tests. NOTE: This function is internal to the testing infrastructure and may change. It is not covered (yet) by the Go 1 compatibility guidelines. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#mustBeNil",
              "documentation": {
                "identifier": "mustBeNil",
                "newPage": false,
                "searchKey": "testing.mustBeNil",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func mustBeNil(err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mustBeNil(err error)\n```\n\nmustBeNil checks the error and, if present, reports it and exits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#coverReport",
              "documentation": {
                "identifier": "coverReport",
                "newPage": false,
                "searchKey": "testing.coverReport",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func coverReport()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc coverReport()\n```\n\ncoverReport reports the coverage percentage and writes a coverage profile if requested. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#RunExamples",
              "documentation": {
                "identifier": "RunExamples",
                "newPage": false,
                "searchKey": "testing.RunExamples",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc RunExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ok bool)\n```\n\nRunExamples is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#runExamples",
              "documentation": {
                "identifier": "runExamples",
                "newPage": false,
                "searchKey": "testing.runExamples",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func runExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ran, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runExamples(matchString func(pat, str string) (bool, error), examples []InternalExample) (ran, ok bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#sortLines",
              "documentation": {
                "identifier": "sortLines",
                "newPage": false,
                "searchKey": "testing.sortLines",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sortLines(output string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sortLines(output string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#splitRegexp",
              "documentation": {
                "identifier": "splitRegexp",
                "newPage": false,
                "searchKey": "testing.splitRegexp",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func splitRegexp(s string) []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc splitRegexp(s string) []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#rewrite",
              "documentation": {
                "identifier": "rewrite",
                "newPage": false,
                "searchKey": "testing.rewrite",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func rewrite(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rewrite(s string) string\n```\n\nrewrite rewrites a subname to having only printable characters and no white space. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#isSpace",
              "documentation": {
                "identifier": "isSpace",
                "newPage": false,
                "searchKey": "testing.isSpace",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isSpace(r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isSpace(r rune) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#runExample",
              "documentation": {
                "identifier": "runExample",
                "newPage": false,
                "searchKey": "testing.runExample",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func runExample(eg InternalExample) (ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runExample(eg InternalExample) (ok bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#Init",
              "documentation": {
                "identifier": "Init",
                "newPage": false,
                "searchKey": "testing.Init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Init()\n```\n\nInit registers testing flags. These flags are automatically registered by the \"go test\" command before running test functions, so Init is only needed when calling functions such as Benchmark without using \"go test\". \n\nInit has no effect if it was already called. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#Short",
              "documentation": {
                "identifier": "Short",
                "newPage": false,
                "searchKey": "testing.Short",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Short() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Short() bool\n```\n\nShort reports whether the -test.short flag is set. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#CoverMode",
              "documentation": {
                "identifier": "CoverMode",
                "newPage": false,
                "searchKey": "testing.CoverMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func CoverMode() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc CoverMode() string\n```\n\nCoverMode reports what the test coverage mode is set to. The values are \"set\", \"count\", or \"atomic\". The return value will be empty if test coverage is not enabled. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#Verbose",
              "documentation": {
                "identifier": "Verbose",
                "newPage": false,
                "searchKey": "testing.Verbose",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Verbose() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Verbose() bool\n```\n\nVerbose reports whether the -test.v flag is set. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#fmtDuration",
              "documentation": {
                "identifier": "fmtDuration",
                "newPage": false,
                "searchKey": "testing.fmtDuration",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fmtDuration(d time.Duration) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fmtDuration(d time.Duration) string\n```\n\nfmtDuration returns a string representing d in the form \"87.00s\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#callerName",
              "documentation": {
                "identifier": "callerName",
                "newPage": false,
                "searchKey": "testing.callerName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func callerName(skip int) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc callerName(skip int) string\n```\n\ncallerName gives the function name (qualified with a package path) for the caller after skip frames (where 0 means the current function). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#pcToName",
              "documentation": {
                "identifier": "pcToName",
                "newPage": false,
                "searchKey": "testing.pcToName",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func pcToName(pc uintptr) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pcToName(pc uintptr) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#tRunner",
              "documentation": {
                "identifier": "tRunner",
                "newPage": false,
                "searchKey": "testing.tRunner",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func tRunner(t *T, fn func(t *T))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tRunner(t *T, fn func(t *T))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#Main",
              "documentation": {
                "identifier": "Main",
                "newPage": false,
                "searchKey": "testing.Main",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Main(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n```\n\nMain is an internal function, part of the implementation of the \"go test\" command. It was exported because it is cross-package and predates \"internal\" packages. It is no longer used by \"go test\" but preserved, as much as possible, for other systems that simulate \"go test\" using Main, but Main sometimes cannot be updated as new functionality is added to the testing package. Systems simulating \"go test\" should be updated to use MainStart. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#listTests",
              "documentation": {
                "identifier": "listTests",
                "newPage": false,
                "searchKey": "testing.listTests",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func listTests(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc listTests(matchString func(pat, str string) (bool, error), tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#RunTests",
              "documentation": {
                "identifier": "RunTests",
                "newPage": false,
                "searchKey": "testing.RunTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc RunTests(matchString func(pat, str string) (bool, error), tests []InternalTest) (ok bool)\n```\n\nRunTests is an internal function but exported because it is cross-package; it is part of the implementation of the \"go test\" command. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#runTests",
              "documentation": {
                "identifier": "runTests",
                "newPage": false,
                "searchKey": "testing.runTests",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func runTests(matchString func(pat, str string) (bool, error), tests []InternalTest, deadline time.Time) (ran, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runTests(matchString func(pat, str string) (bool, error), tests []InternalTest, deadline time.Time) (ran, ok bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#toOutputDir",
              "documentation": {
                "identifier": "toOutputDir",
                "newPage": false,
                "searchKey": "testing.toOutputDir",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func toOutputDir(path string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc toOutputDir(path string) string\n```\n\ntoOutputDir returns the file name relocated, if required, to outputDir. Simple implementation to avoid pulling in path/filepath. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#parseCpuList",
              "documentation": {
                "identifier": "parseCpuList",
                "newPage": false,
                "searchKey": "testing.parseCpuList",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseCpuList()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseCpuList()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#shouldFailFast",
              "documentation": {
                "identifier": "shouldFailFast",
                "newPage": false,
                "searchKey": "testing.shouldFailFast",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func shouldFailFast() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc shouldFailFast() bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestTBHelper",
              "documentation": {
                "identifier": "TestTBHelper",
                "newPage": false,
                "searchKey": "testing.TestTBHelper",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTBHelper(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTBHelper(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestTBHelperParallel",
              "documentation": {
                "identifier": "TestTBHelperParallel",
                "newPage": false,
                "searchKey": "testing.TestTBHelperParallel",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTBHelperParallel(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTBHelperParallel(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestTBHelperLineNumer",
              "documentation": {
                "identifier": "TestTBHelperLineNumer",
                "newPage": false,
                "searchKey": "testing.TestTBHelperLineNumer",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTBHelperLineNumer(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTBHelperLineNumer(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#BenchmarkTBHelper",
              "documentation": {
                "identifier": "BenchmarkTBHelper",
                "newPage": false,
                "searchKey": "testing.BenchmarkTBHelper",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTBHelper(b *B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTBHelper(b *B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#notHelper",
              "documentation": {
                "identifier": "notHelper",
                "newPage": false,
                "searchKey": "testing.notHelper",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func notHelper(t *T, msg string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notHelper(t *T, msg string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#helper",
              "documentation": {
                "identifier": "helper",
                "newPage": false,
                "searchKey": "testing.helper",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func helper(t *T, msg string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc helper(t *T, msg string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#notHelperCallingHelper",
              "documentation": {
                "identifier": "notHelperCallingHelper",
                "newPage": false,
                "searchKey": "testing.notHelperCallingHelper",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func notHelperCallingHelper(t *T, msg string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notHelperCallingHelper(t *T, msg string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#helperCallingHelper",
              "documentation": {
                "identifier": "helperCallingHelper",
                "newPage": false,
                "searchKey": "testing.helperCallingHelper",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func helperCallingHelper(t *T, msg string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc helperCallingHelper(t *T, msg string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#testHelper",
              "documentation": {
                "identifier": "testHelper",
                "newPage": false,
                "searchKey": "testing.testHelper",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func testHelper(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testHelper(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#parallelTestHelper",
              "documentation": {
                "identifier": "parallelTestHelper",
                "newPage": false,
                "searchKey": "testing.parallelTestHelper",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parallelTestHelper(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parallelTestHelper(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestIsSpace",
              "documentation": {
                "identifier": "TestIsSpace",
                "newPage": false,
                "searchKey": "testing.TestIsSpace",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIsSpace(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIsSpace(t *T)\n```\n\nVerify that our IsSpace agrees with unicode.IsSpace. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestSplitRegexp",
              "documentation": {
                "identifier": "TestSplitRegexp",
                "newPage": false,
                "searchKey": "testing.TestSplitRegexp",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSplitRegexp(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSplitRegexp(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestMatcher",
              "documentation": {
                "identifier": "TestMatcher",
                "newPage": false,
                "searchKey": "testing.TestMatcher",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMatcher(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMatcher(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestNaming",
              "documentation": {
                "identifier": "TestNaming",
                "newPage": false,
                "searchKey": "testing.TestNaming",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNaming(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNaming(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#init.sub_test.go",
              "documentation": {
                "identifier": "init.sub_test.go",
                "newPage": false,
                "searchKey": "testing.init",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestTestContext",
              "documentation": {
                "identifier": "TestTestContext",
                "newPage": false,
                "searchKey": "testing.TestTestContext",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTestContext(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTestContext(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestTRun",
              "documentation": {
                "identifier": "TestTRun",
                "newPage": false,
                "searchKey": "testing.TestTRun",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTRun(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTRun(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestBRun",
              "documentation": {
                "identifier": "TestBRun",
                "newPage": false,
                "searchKey": "testing.TestBRun",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBRun(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBRun(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#makeRegexp",
              "documentation": {
                "identifier": "makeRegexp",
                "newPage": false,
                "searchKey": "testing.makeRegexp",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func makeRegexp(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makeRegexp(s string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestBenchmarkOutput",
              "documentation": {
                "identifier": "TestBenchmarkOutput",
                "newPage": false,
                "searchKey": "testing.TestBenchmarkOutput",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBenchmarkOutput(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBenchmarkOutput(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestBenchmarkStartsFrom1",
              "documentation": {
                "identifier": "TestBenchmarkStartsFrom1",
                "newPage": false,
                "searchKey": "testing.TestBenchmarkStartsFrom1",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBenchmarkStartsFrom1(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBenchmarkStartsFrom1(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestBenchmarkReadMemStatsBeforeFirstRun",
              "documentation": {
                "identifier": "TestBenchmarkReadMemStatsBeforeFirstRun",
                "newPage": false,
                "searchKey": "testing.TestBenchmarkReadMemStatsBeforeFirstRun",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBenchmarkReadMemStatsBeforeFirstRun(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBenchmarkReadMemStatsBeforeFirstRun(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestParallelSub",
              "documentation": {
                "identifier": "TestParallelSub",
                "newPage": false,
                "searchKey": "testing.TestParallelSub",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParallelSub(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParallelSub(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestRacyOutput",
              "documentation": {
                "identifier": "TestRacyOutput",
                "newPage": false,
                "searchKey": "testing.TestRacyOutput",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRacyOutput(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRacyOutput(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestLogAfterComplete",
              "documentation": {
                "identifier": "TestLogAfterComplete",
                "newPage": false,
                "searchKey": "testing.TestLogAfterComplete",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLogAfterComplete(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLogAfterComplete(t *T)\n```\n\nThe late log message did not include the test name.  Issue 29388. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestBenchmark",
              "documentation": {
                "identifier": "TestBenchmark",
                "newPage": false,
                "searchKey": "testing.TestBenchmark",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBenchmark(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBenchmark(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestCleanup",
              "documentation": {
                "identifier": "TestCleanup",
                "newPage": false,
                "searchKey": "testing.TestCleanup",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCleanup(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCleanup(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestConcurrentCleanup",
              "documentation": {
                "identifier": "TestConcurrentCleanup",
                "newPage": false,
                "searchKey": "testing.TestConcurrentCleanup",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConcurrentCleanup(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConcurrentCleanup(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestCleanupCalledEvenAfterGoexit",
              "documentation": {
                "identifier": "TestCleanupCalledEvenAfterGoexit",
                "newPage": false,
                "searchKey": "testing.TestCleanupCalledEvenAfterGoexit",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCleanupCalledEvenAfterGoexit(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCleanupCalledEvenAfterGoexit(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestRunCleanup",
              "documentation": {
                "identifier": "TestRunCleanup",
                "newPage": false,
                "searchKey": "testing.TestRunCleanup",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRunCleanup(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRunCleanup(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestCleanupParallelSubtests",
              "documentation": {
                "identifier": "TestCleanupParallelSubtests",
                "newPage": false,
                "searchKey": "testing.TestCleanupParallelSubtests",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCleanupParallelSubtests(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCleanupParallelSubtests(t *T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/testing#TestNestedCleanup",
              "documentation": {
                "identifier": "TestNestedCleanup",
                "newPage": false,
                "searchKey": "testing.TestNestedCleanup",
                "tags": [
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNestedCleanup(t *T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNestedCleanup(t *T)\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "pathID": "/testing/fstest"
    },
    {
      "pathID": "/testing/iotest"
    },
    {
      "pathID": "/testing/iotest_test"
    },
    {
      "pathID": "/testing/quick"
    }
  ]
}
