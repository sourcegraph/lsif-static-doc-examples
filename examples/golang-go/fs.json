{
  "pathID": "/fs",
  "documentation": {
    "identifier": "fs",
    "newPage": true,
    "searchKey": "fs",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package fs"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package fs defines basic interfaces to a file system. A file system can be provided by the host operating system but also by other packages. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/fs#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/fs#ModeDir",
              "documentation": {
                "identifier": "ModeDir",
                "newPage": false,
                "searchKey": "fs.ModeDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeDir"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeDir FileMode = 1 << (32 - 1 - iota) // d: is a directory\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\nThe single letters are the abbreviations used by the String method's formatting. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeAppend",
              "documentation": {
                "identifier": "ModeAppend",
                "newPage": false,
                "searchKey": "fs.ModeAppend",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeAppend"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeAppend // a: append-only\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeExclusive",
              "documentation": {
                "identifier": "ModeExclusive",
                "newPage": false,
                "searchKey": "fs.ModeExclusive",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeExclusive"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeExclusive // l: exclusive use\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeTemporary",
              "documentation": {
                "identifier": "ModeTemporary",
                "newPage": false,
                "searchKey": "fs.ModeTemporary",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeTemporary"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeTemporary // T: temporary file; Plan 9 only\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeSymlink",
              "documentation": {
                "identifier": "ModeSymlink",
                "newPage": false,
                "searchKey": "fs.ModeSymlink",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeSymlink"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeSymlink // L: symbolic link\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeDevice",
              "documentation": {
                "identifier": "ModeDevice",
                "newPage": false,
                "searchKey": "fs.ModeDevice",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeDevice"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeDevice // D: device file\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeNamedPipe",
              "documentation": {
                "identifier": "ModeNamedPipe",
                "newPage": false,
                "searchKey": "fs.ModeNamedPipe",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeNamedPipe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeNamedPipe // p: named pipe (FIFO)\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeSocket",
              "documentation": {
                "identifier": "ModeSocket",
                "newPage": false,
                "searchKey": "fs.ModeSocket",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeSocket"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeSocket // S: Unix domain socket\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeSetuid",
              "documentation": {
                "identifier": "ModeSetuid",
                "newPage": false,
                "searchKey": "fs.ModeSetuid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeSetuid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeSetuid // u: setuid\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeSetgid",
              "documentation": {
                "identifier": "ModeSetgid",
                "newPage": false,
                "searchKey": "fs.ModeSetgid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeSetgid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeSetgid // g: setgid\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeCharDevice",
              "documentation": {
                "identifier": "ModeCharDevice",
                "newPage": false,
                "searchKey": "fs.ModeCharDevice",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeCharDevice"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeCharDevice // c: Unix character device, when ModeDevice is set\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeSticky",
              "documentation": {
                "identifier": "ModeSticky",
                "newPage": false,
                "searchKey": "fs.ModeSticky",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeSticky"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeSticky // t: sticky\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeIrregular",
              "documentation": {
                "identifier": "ModeIrregular",
                "newPage": false,
                "searchKey": "fs.ModeIrregular",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeIrregular"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeIrregular // ?: non-regular file; nothing else is known about this file\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModeType",
              "documentation": {
                "identifier": "ModeType",
                "newPage": false,
                "searchKey": "fs.ModeType",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeType = ...\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\nMask for the type bits. For regular files, none will be set. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ModePerm",
              "documentation": {
                "identifier": "ModePerm",
                "newPage": false,
                "searchKey": "fs.ModePerm",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModePerm"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModePerm FileMode = 0777 // Unix permission bits\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/fs#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/fs#ErrInvalid",
              "documentation": {
                "identifier": "ErrInvalid",
                "newPage": false,
                "searchKey": "fs.ErrInvalid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrInvalid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrInvalid = errInvalid() // \"invalid argument\"\n\n```\n\nGeneric file system errors. Errors returned by file systems can be tested against these errors using errors.Is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ErrPermission",
              "documentation": {
                "identifier": "ErrPermission",
                "newPage": false,
                "searchKey": "fs.ErrPermission",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrPermission"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrPermission = errPermission() // \"permission denied\"\n\n```\n\nGeneric file system errors. Errors returned by file systems can be tested against these errors using errors.Is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ErrExist",
              "documentation": {
                "identifier": "ErrExist",
                "newPage": false,
                "searchKey": "fs.ErrExist",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrExist"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrExist = errExist() // \"file already exists\"\n\n```\n\nGeneric file system errors. Errors returned by file systems can be tested against these errors using errors.Is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ErrNotExist",
              "documentation": {
                "identifier": "ErrNotExist",
                "newPage": false,
                "searchKey": "fs.ErrNotExist",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrNotExist"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrNotExist = errNotExist() // \"file does not exist\"\n\n```\n\nGeneric file system errors. Errors returned by file systems can be tested against these errors using errors.Is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ErrClosed",
              "documentation": {
                "identifier": "ErrClosed",
                "newPage": false,
                "searchKey": "fs.ErrClosed",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrClosed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrClosed = errClosed() // \"file already closed\"\n\n```\n\nGeneric file system errors. Errors returned by file systems can be tested against these errors using errors.Is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#SkipDir",
              "documentation": {
                "identifier": "SkipDir",
                "newPage": false,
                "searchKey": "fs.SkipDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var SkipDir"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar SkipDir = errors.New(\"skip this directory\")\n```\n\nSkipDir is used as a return value from WalkDirFuncs to indicate that the directory named in the call is to be skipped. It is not returned as an error by any function. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/fs#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/fs#FS",
              "documentation": {
                "identifier": "FS",
                "newPage": false,
                "searchKey": "fs.FS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type FS interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FS interface {\n\t// Open opens the named file.\n\t//\n\t// When Open returns an error, it should be of type *PathError\n\t// with the Op field set to \"open\", the Path field set to name,\n\t// and the Err field describing the problem.\n\t//\n\t// Open should reject attempts to open names that do not satisfy\n\t// ValidPath(name), returning a *PathError with Err set to\n\t// ErrInvalid or ErrNotExist.\n\tOpen(name string) (File, error)\n}\n```\n\nAn FS provides access to a hierarchical file system. \n\nThe FS interface is the minimum implementation required of the file system. A file system may implement additional interfaces, such as ReadFileFS, to provide additional or optimized functionality. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/fs#Sub",
                    "documentation": {
                      "identifier": "Sub",
                      "newPage": false,
                      "searchKey": "fs.Sub",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Sub(fsys FS, dir string) (FS, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Sub(fsys FS, dir string) (FS, error)\n```\n\nSub returns an FS corresponding to the subtree rooted at fsys's dir. \n\nIf dir is \".\", Sub returns fsys unchanged. Otherwise, if fs implements SubFS, Sub returns fsys.Sub(dir). Otherwise, Sub returns a new FS implementation sub that, in effect, implements sub.Open(name) as fsys.Open(path.Join(dir, name)). The implementation also translates calls to ReadDir, ReadFile, and Glob appropriately. \n\nNote that Sub(os.DirFS(\"/\"), \"prefix\") is equivalent to os.DirFS(\"/prefix\") and that neither of them guarantees to avoid operating system accesses outside \"/prefix\", because the implementation of os.DirFS does not check for symbolic links inside \"/prefix\" that point to other directories. That is, os.DirFS is not a general substitute for a chroot-style security mechanism, and Sub does not change that fact. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/fs#File",
              "documentation": {
                "identifier": "File",
                "newPage": false,
                "searchKey": "fs.File",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type File interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype File interface {\n\tStat() (FileInfo, error)\n\tRead([]byte) (int, error)\n\tClose() error\n}\n```\n\nA File provides access to a single file. The File interface is the minimum implementation required of the file. Directory files should also implement ReadDirFile. A file may implement io.ReaderAt or io.Seeker as optimizations. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#DirEntry",
              "documentation": {
                "identifier": "DirEntry",
                "newPage": false,
                "searchKey": "fs.DirEntry",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type DirEntry interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype DirEntry interface {\n\t// Name returns the name of the file (or subdirectory) described by the entry.\n\t// This name is only the final element of the path (the base name), not the entire path.\n\t// For example, Name would return \"hello.go\" not \"/home/gopher/hello.go\".\n\tName() string\n\n\t// IsDir reports whether the entry describes a directory.\n\tIsDir() bool\n\n\t// Type returns the type bits for the entry.\n\t// The type bits are a subset of the usual FileMode bits, those returned by the FileMode.Type method.\n\tType() FileMode\n\n\t// Info returns the FileInfo for the file or subdirectory described by the entry.\n\t// The returned FileInfo may be from the time of the original directory read\n\t// or from the time of the call to Info. If the file has been removed or renamed\n\t// since the directory read, Info may return an error satisfying errors.Is(err, ErrNotExist).\n\t// If the entry denotes a symbolic link, Info reports the information about the link itself,\n\t// not the link's target.\n\tInfo() (FileInfo, error)\n}\n```\n\nA DirEntry is an entry read from a directory (using the ReadDir function or a ReadDirFile's ReadDir method). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/fs#FileInfoToDirEntry",
                    "documentation": {
                      "identifier": "FileInfoToDirEntry",
                      "newPage": false,
                      "searchKey": "fs.FileInfoToDirEntry",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FileInfoToDirEntry(info FileInfo) DirEntry"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FileInfoToDirEntry(info FileInfo) DirEntry\n```\n\nFileInfoToDirEntry returns a DirEntry that returns information from info. If info is nil, FileInfoToDirEntry returns nil. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/fs#ReadDirFile",
              "documentation": {
                "identifier": "ReadDirFile",
                "newPage": false,
                "searchKey": "fs.ReadDirFile",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ReadDirFile interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ReadDirFile interface {\n\tFile\n\n\t// ReadDir reads the contents of the directory and returns\n\t// a slice of up to n DirEntry values in directory order.\n\t// Subsequent calls on the same file will yield further DirEntry values.\n\t//\n\t// If n > 0, ReadDir returns at most n DirEntry structures.\n\t// In this case, if ReadDir returns an empty slice, it will return\n\t// a non-nil error explaining why.\n\t// At the end of a directory, the error is io.EOF.\n\t//\n\t// If n <= 0, ReadDir returns all the DirEntry values from the directory\n\t// in a single slice. In this case, if ReadDir succeeds (reads all the way\n\t// to the end of the directory), it returns the slice and a nil error.\n\t// If it encounters an error before the end of the directory,\n\t// ReadDir returns the DirEntry list read until that point and a non-nil error.\n\tReadDir(n int) ([]DirEntry, error)\n}\n```\n\nA ReadDirFile is a directory file whose entries can be read with the ReadDir method. Every directory file should implement this interface. (It is permissible for any file to implement this interface, but if so ReadDir should return an error for non-directories.) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#FileInfo",
              "documentation": {
                "identifier": "FileInfo",
                "newPage": false,
                "searchKey": "fs.FileInfo",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type FileInfo interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FileInfo interface {\n\tName() string       // base name of the file\n\tSize() int64        // length in bytes for regular files; system-dependent for others\n\tMode() FileMode     // file mode bits\n\tModTime() time.Time // modification time\n\tIsDir() bool        // abbreviation for Mode().IsDir()\n\tSys() interface{}   // underlying data source (can return nil)\n}\n```\n\nA FileInfo describes a file and is returned by Stat. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/fs#Stat",
                    "documentation": {
                      "identifier": "Stat",
                      "newPage": false,
                      "searchKey": "fs.Stat",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Stat(fsys FS, name string) (FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Stat(fsys FS, name string) (FileInfo, error)\n```\n\nStat returns a FileInfo describing the named file from the file system. \n\nIf fs implements StatFS, Stat calls fs.Stat. Otherwise, Stat opens the file to stat it. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/fs#FileMode",
              "documentation": {
                "identifier": "FileMode",
                "newPage": false,
                "searchKey": "fs.FileMode",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type FileMode uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FileMode uint32\n```\n\nA FileMode represents a file's mode and permission bits. The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is ModeDir for directories. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/fs#FileMode.String",
                    "documentation": {
                      "identifier": "FileMode.String",
                      "newPage": false,
                      "searchKey": "fs.FileMode.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m FileMode) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m FileMode) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#FileMode.IsDir",
                    "documentation": {
                      "identifier": "FileMode.IsDir",
                      "newPage": false,
                      "searchKey": "fs.FileMode.IsDir",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m FileMode) IsDir() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m FileMode) IsDir() bool\n```\n\nIsDir reports whether m describes a directory. That is, it tests for the ModeDir bit being set in m. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#FileMode.IsRegular",
                    "documentation": {
                      "identifier": "FileMode.IsRegular",
                      "newPage": false,
                      "searchKey": "fs.FileMode.IsRegular",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m FileMode) IsRegular() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m FileMode) IsRegular() bool\n```\n\nIsRegular reports whether m describes a regular file. That is, it tests that no mode type bits are set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#FileMode.Perm",
                    "documentation": {
                      "identifier": "FileMode.Perm",
                      "newPage": false,
                      "searchKey": "fs.FileMode.Perm",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m FileMode) Perm() FileMode"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m FileMode) Perm() FileMode\n```\n\nPerm returns the Unix permission bits in m (m & ModePerm). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#FileMode.Type",
                    "documentation": {
                      "identifier": "FileMode.Type",
                      "newPage": false,
                      "searchKey": "fs.FileMode.Type",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m FileMode) Type() FileMode"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m FileMode) Type() FileMode\n```\n\nType returns type bits in m (m & ModeType). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/fs#PathError",
              "documentation": {
                "identifier": "PathError",
                "newPage": false,
                "searchKey": "fs.PathError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type PathError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PathError struct {\n\tOp   string\n\tPath string\n\tErr  error\n}\n```\n\nPathError records an error and the operation and file path that caused it. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/fs#PathError.Error",
                    "documentation": {
                      "identifier": "PathError.Error",
                      "newPage": false,
                      "searchKey": "fs.PathError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *PathError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *PathError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#PathError.Unwrap",
                    "documentation": {
                      "identifier": "PathError.Unwrap",
                      "newPage": false,
                      "searchKey": "fs.PathError.Unwrap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *PathError) Unwrap() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *PathError) Unwrap() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#PathError.Timeout",
                    "documentation": {
                      "identifier": "PathError.Timeout",
                      "newPage": false,
                      "searchKey": "fs.PathError.Timeout",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *PathError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *PathError) Timeout() bool\n```\n\nTimeout reports whether this error represents a timeout. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/fs#GlobFS",
              "documentation": {
                "identifier": "GlobFS",
                "newPage": false,
                "searchKey": "fs.GlobFS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type GlobFS interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype GlobFS interface {\n\tFS\n\n\t// Glob returns the names of all files matching pattern,\n\t// providing an implementation of the top-level\n\t// Glob function.\n\tGlob(pattern string) ([]string, error)\n}\n```\n\nA GlobFS is a file system with a Glob method. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ReadDirFS",
              "documentation": {
                "identifier": "ReadDirFS",
                "newPage": false,
                "searchKey": "fs.ReadDirFS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ReadDirFS interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ReadDirFS interface {\n\tFS\n\n\t// ReadDir reads the named directory\n\t// and returns a list of directory entries sorted by filename.\n\tReadDir(name string) ([]DirEntry, error)\n}\n```\n\nReadDirFS is the interface implemented by a file system that provides an optimized implementation of ReadDir. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#dirInfo",
              "documentation": {
                "identifier": "dirInfo",
                "newPage": false,
                "searchKey": "fs.dirInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type dirInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dirInfo struct {\n\tfileInfo FileInfo\n}\n```\n\ndirInfo is a DirEntry based on a FileInfo. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/fs#dirInfo.IsDir",
                    "documentation": {
                      "identifier": "dirInfo.IsDir",
                      "newPage": false,
                      "searchKey": "fs.dirInfo.IsDir",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (di dirInfo) IsDir() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (di dirInfo) IsDir() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#dirInfo.Type",
                    "documentation": {
                      "identifier": "dirInfo.Type",
                      "newPage": false,
                      "searchKey": "fs.dirInfo.Type",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (di dirInfo) Type() FileMode"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (di dirInfo) Type() FileMode\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#dirInfo.Info",
                    "documentation": {
                      "identifier": "dirInfo.Info",
                      "newPage": false,
                      "searchKey": "fs.dirInfo.Info",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (di dirInfo) Info() (FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (di dirInfo) Info() (FileInfo, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#dirInfo.Name",
                    "documentation": {
                      "identifier": "dirInfo.Name",
                      "newPage": false,
                      "searchKey": "fs.dirInfo.Name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (di dirInfo) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (di dirInfo) Name() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/fs#ReadFileFS",
              "documentation": {
                "identifier": "ReadFileFS",
                "newPage": false,
                "searchKey": "fs.ReadFileFS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ReadFileFS interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ReadFileFS interface {\n\tFS\n\n\t// ReadFile reads the named file and returns its contents.\n\t// A successful call returns a nil error, not io.EOF.\n\t// (Because ReadFile reads the whole file, the expected EOF\n\t// from the final Read is not treated as an error to be reported.)\n\t//\n\t// The caller is permitted to modify the returned byte slice.\n\t// This method should return a copy of the underlying data.\n\tReadFile(name string) ([]byte, error)\n}\n```\n\nReadFileFS is the interface implemented by a file system that provides an optimized implementation of ReadFile. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#StatFS",
              "documentation": {
                "identifier": "StatFS",
                "newPage": false,
                "searchKey": "fs.StatFS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type StatFS interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype StatFS interface {\n\tFS\n\n\t// Stat returns a FileInfo describing the file.\n\t// If there is an error, it should be of type *PathError.\n\tStat(name string) (FileInfo, error)\n}\n```\n\nA StatFS is a file system with a Stat method. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#SubFS",
              "documentation": {
                "identifier": "SubFS",
                "newPage": false,
                "searchKey": "fs.SubFS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type SubFS interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype SubFS interface {\n\tFS\n\n\t// Sub returns an FS corresponding to the subtree rooted at dir.\n\tSub(dir string) (FS, error)\n}\n```\n\nA SubFS is a file system with a Sub method. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#subFS",
              "documentation": {
                "identifier": "subFS",
                "newPage": false,
                "searchKey": "fs.subFS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type subFS struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype subFS struct {\n\tfsys FS\n\tdir  string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/fs#subFS.fullName",
                    "documentation": {
                      "identifier": "subFS.fullName",
                      "newPage": false,
                      "searchKey": "fs.subFS.fullName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *subFS) fullName(op string, name string) (string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *subFS) fullName(op string, name string) (string, error)\n```\n\nfullName maps name to the fully-qualified name dir/name. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#subFS.shorten",
                    "documentation": {
                      "identifier": "subFS.shorten",
                      "newPage": false,
                      "searchKey": "fs.subFS.shorten",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *subFS) shorten(name string) (rel string, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *subFS) shorten(name string) (rel string, ok bool)\n```\n\nshorten maps name, which should start with f.dir, back to the suffix after f.dir. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#subFS.fixErr",
                    "documentation": {
                      "identifier": "subFS.fixErr",
                      "newPage": false,
                      "searchKey": "fs.subFS.fixErr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *subFS) fixErr(err error) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *subFS) fixErr(err error) error\n```\n\nfixErr shortens any reported names in PathErrors by stripping f.dir. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#subFS.Open",
                    "documentation": {
                      "identifier": "subFS.Open",
                      "newPage": false,
                      "searchKey": "fs.subFS.Open",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *subFS) Open(name string) (File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *subFS) Open(name string) (File, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#subFS.ReadDir",
                    "documentation": {
                      "identifier": "subFS.ReadDir",
                      "newPage": false,
                      "searchKey": "fs.subFS.ReadDir",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *subFS) ReadDir(name string) ([]DirEntry, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *subFS) ReadDir(name string) ([]DirEntry, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#subFS.ReadFile",
                    "documentation": {
                      "identifier": "subFS.ReadFile",
                      "newPage": false,
                      "searchKey": "fs.subFS.ReadFile",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *subFS) ReadFile(name string) ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *subFS) ReadFile(name string) ([]byte, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#subFS.Glob",
                    "documentation": {
                      "identifier": "subFS.Glob",
                      "newPage": false,
                      "searchKey": "fs.subFS.Glob",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *subFS) Glob(pattern string) ([]string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *subFS) Glob(pattern string) ([]string, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#subFS.Sub",
                    "documentation": {
                      "identifier": "subFS.Sub",
                      "newPage": false,
                      "searchKey": "fs.subFS.Sub",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *subFS) Sub(dir string) (FS, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *subFS) Sub(dir string) (FS, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/fs#WalkDirFunc",
              "documentation": {
                "identifier": "WalkDirFunc",
                "newPage": false,
                "searchKey": "fs.WalkDirFunc",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type WalkDirFunc func(path string, d std/io/fs.DirEntry, err error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype WalkDirFunc func(path string, d DirEntry, err error) error\n```\n\nWalkDirFunc is the type of the function called by WalkDir to visit each file or directory. \n\nThe path argument contains the argument to WalkDir as a prefix. That is, if WalkDir is called with root argument \"dir\" and finds a file named \"a\" in that directory, the walk function will be called with argument \"dir/a\". \n\nThe d argument is the fs.DirEntry for the named path. \n\nThe error result returned by the function controls how WalkDir continues. If the function returns the special value SkipDir, WalkDir skips the current directory (path if d.IsDir() is true, otherwise path's parent directory). Otherwise, if the function returns a non-nil error, WalkDir stops entirely and returns that error. \n\nThe err argument reports an error related to path, signaling that WalkDir will not walk into that directory. The function can decide how to handle that error; as described earlier, returning the error will cause WalkDir to stop walking the entire tree. \n\nWalkDir calls the function with a non-nil err argument in two cases. \n\nFirst, if the initial fs.Stat on the root directory fails, WalkDir calls the function with path set to root, d set to nil, and err set to the error from fs.Stat. \n\nSecond, if a directory's ReadDir method fails, WalkDir calls the function with path set to the directory's path, d set to an fs.DirEntry describing the directory, and err set to the error from ReadDir. In this second case, the function is called twice with the path of the directory: the first call is before the directory read is attempted and has err set to nil, giving the function a chance to return SkipDir and avoid the ReadDir entirely. The second call is after a failed ReadDir and reports the error from ReadDir. (If ReadDir succeeds, there is no second call.) \n\nThe differences between WalkDirFunc compared to filepath.WalkFunc are: \n\n```\n- The second argument has type fs.DirEntry instead of fs.FileInfo.\n- The function is called before reading a directory, to allow SkipDir\n  to bypass the directory read entirely.\n- If a directory read fails, the function is called a second time\n  for that directory to report the error.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#statDirEntry",
              "documentation": {
                "identifier": "statDirEntry",
                "newPage": false,
                "searchKey": "fs.statDirEntry",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type statDirEntry struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype statDirEntry struct {\n\tinfo FileInfo\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/fs#statDirEntry.Name",
                    "documentation": {
                      "identifier": "statDirEntry.Name",
                      "newPage": false,
                      "searchKey": "fs.statDirEntry.Name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *statDirEntry) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *statDirEntry) Name() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#statDirEntry.IsDir",
                    "documentation": {
                      "identifier": "statDirEntry.IsDir",
                      "newPage": false,
                      "searchKey": "fs.statDirEntry.IsDir",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *statDirEntry) IsDir() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *statDirEntry) IsDir() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#statDirEntry.Type",
                    "documentation": {
                      "identifier": "statDirEntry.Type",
                      "newPage": false,
                      "searchKey": "fs.statDirEntry.Type",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *statDirEntry) Type() FileMode"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *statDirEntry) Type() FileMode\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/fs#statDirEntry.Info",
                    "documentation": {
                      "identifier": "statDirEntry.Info",
                      "newPage": false,
                      "searchKey": "fs.statDirEntry.Info",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *statDirEntry) Info() (FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *statDirEntry) Info() (FileInfo, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/fs#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/fs#ValidPath",
              "documentation": {
                "identifier": "ValidPath",
                "newPage": false,
                "searchKey": "fs.ValidPath",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ValidPath(name string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ValidPath(name string) bool\n```\n\nValidPath reports whether the given path name is valid for use in a call to Open. \n\nPath names passed to open are UTF-8-encoded, unrooted, slash-separated sequences of path elements, like x/y/z. Path names must not contain an element that is . or .. or the empty string, except for the special case that the root directory is named .. Paths must not start or end with a slash: /x and x/ are invalid. \n\nNote that paths are slash-separated on all systems, even Windows. Paths containing other characters such as backslash and colon are accepted as valid, but those characters must never be interpreted by an FS implementation as path element separators. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#errInvalid",
              "documentation": {
                "identifier": "errInvalid",
                "newPage": false,
                "searchKey": "fs.errInvalid",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func errInvalid() error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc errInvalid() error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#errPermission",
              "documentation": {
                "identifier": "errPermission",
                "newPage": false,
                "searchKey": "fs.errPermission",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func errPermission() error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc errPermission() error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#errExist",
              "documentation": {
                "identifier": "errExist",
                "newPage": false,
                "searchKey": "fs.errExist",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func errExist() error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc errExist() error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#errNotExist",
              "documentation": {
                "identifier": "errNotExist",
                "newPage": false,
                "searchKey": "fs.errNotExist",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func errNotExist() error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc errNotExist() error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#errClosed",
              "documentation": {
                "identifier": "errClosed",
                "newPage": false,
                "searchKey": "fs.errClosed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func errClosed() error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc errClosed() error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#Glob",
              "documentation": {
                "identifier": "Glob",
                "newPage": false,
                "searchKey": "fs.Glob",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Glob(fsys FS, pattern string) (matches []string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Glob(fsys FS, pattern string) (matches []string, err error)\n```\n\nGlob returns the names of all files matching pattern or nil if there is no matching file. The syntax of patterns is the same as in path.Match. The pattern may describe hierarchical names such as usr/*/bin/ed. \n\nGlob ignores file system errors such as I/O errors reading directories. The only possible returned error is path.ErrBadPattern, reporting that the pattern is malformed. \n\nIf fs implements GlobFS, Glob calls fs.Glob. Otherwise, Glob uses ReadDir to traverse the directory tree and look for matches for the pattern. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#cleanGlobPath",
              "documentation": {
                "identifier": "cleanGlobPath",
                "newPage": false,
                "searchKey": "fs.cleanGlobPath",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cleanGlobPath(path string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cleanGlobPath(path string) string\n```\n\ncleanGlobPath prepares path for glob matching. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#glob",
              "documentation": {
                "identifier": "glob",
                "newPage": false,
                "searchKey": "fs.glob",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func glob(fs FS, dir, pattern string, matches []string) (m []string, e error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc glob(fs FS, dir, pattern string, matches []string) (m []string, e error)\n```\n\nglob searches for files matching pattern in the directory dir and appends them to matches, returning the updated slice. If the directory cannot be opened, glob returns the existing matches. New matches are added in lexicographical order. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#hasMeta",
              "documentation": {
                "identifier": "hasMeta",
                "newPage": false,
                "searchKey": "fs.hasMeta",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hasMeta(path string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hasMeta(path string) bool\n```\n\nhasMeta reports whether path contains any of the magic characters recognized by path.Match. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ReadDir",
              "documentation": {
                "identifier": "ReadDir",
                "newPage": false,
                "searchKey": "fs.ReadDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ReadDir(fsys FS, name string) ([]DirEntry, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ReadDir(fsys FS, name string) ([]DirEntry, error)\n```\n\nReadDir reads the named directory and returns a list of directory entries sorted by filename. \n\nIf fs implements ReadDirFS, ReadDir calls fs.ReadDir. Otherwise ReadDir calls fs.Open and uses ReadDir and Close on the returned file. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#ReadFile",
              "documentation": {
                "identifier": "ReadFile",
                "newPage": false,
                "searchKey": "fs.ReadFile",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ReadFile(fsys FS, name string) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ReadFile(fsys FS, name string) ([]byte, error)\n```\n\nReadFile reads the named file from the file system fs and returns its contents. A successful call returns a nil error, not io.EOF. (Because ReadFile reads the whole file, the expected EOF from the final Read is not treated as an error to be reported.) \n\nIf fs implements ReadFileFS, ReadFile calls fs.ReadFile. Otherwise ReadFile calls fs.Open and uses Read and Close on the returned file. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#walkDir",
              "documentation": {
                "identifier": "walkDir",
                "newPage": false,
                "searchKey": "fs.walkDir",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func walkDir(fsys FS, name string, d DirEntry, walkDirFn WalkDirFunc) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc walkDir(fsys FS, name string, d DirEntry, walkDirFn WalkDirFunc) error\n```\n\nwalkDir recursively descends path, calling walkDirFn. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/fs#WalkDir",
              "documentation": {
                "identifier": "WalkDir",
                "newPage": false,
                "searchKey": "fs.WalkDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func WalkDir(fsys FS, root string, fn WalkDirFunc) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc WalkDir(fsys FS, root string, fn WalkDirFunc) error\n```\n\nWalkDir walks the file tree rooted at root, calling fn for each file or directory in the tree, including root. \n\nAll errors that arise visiting files and directories are filtered by fn: see the fs.WalkDirFunc documentation for details. \n\nThe files are walked in lexical order, which makes the output deterministic but requires WalkDir to read an entire directory into memory before proceeding to walk that directory. \n\nWalkDir does not follow symbolic links found in directories, but if root itself is a symbolic link, its target will be walked. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
