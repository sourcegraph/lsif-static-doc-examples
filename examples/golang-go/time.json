{
  "pathID": "/time",
  "documentation": {
    "identifier": "time",
    "newPage": true,
    "searchKey": "time",
    "tags": [
      "package"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package time"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package time provides functionality for measuring and displaying time. \n\nThe calendrical calculations always assume a Gregorian calendar, with no leap seconds. \n\n### hdr-Monotonic_ClocksMonotonic Clocks\nOperating systems provide both a “wall clock,” which is subject to changes for clock synchronization, and a “monotonic clock,” which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by time.Now contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading. \n\nFor example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed: \n\n```\nstart := time.Now()\n... operation that takes 20 milliseconds ...\nt := time.Now()\nelapsed := t.Sub(start)\n\n```\nOther idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets. \n\nThe rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package. \n\nThe Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0). \n\nIf Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings. \n\nOn some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u. \n\nBecause the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading. \n\nNote that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values. \n\nFor debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String(). \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/time#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/time#ANSIC",
              "documentation": {
                "identifier": "ANSIC",
                "newPage": false,
                "searchKey": "time.ANSIC",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ANSIC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ANSIC = \"Mon Jan _2 15:04:05 2006\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#April",
              "documentation": {
                "identifier": "April",
                "newPage": false,
                "searchKey": "time.April",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const April"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst April\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#August",
              "documentation": {
                "identifier": "August",
                "newPage": false,
                "searchKey": "time.August",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const August"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst August\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#December",
              "documentation": {
                "identifier": "December",
                "newPage": false,
                "searchKey": "time.December",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const December"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst December\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#February",
              "documentation": {
                "identifier": "February",
                "newPage": false,
                "searchKey": "time.February",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const February"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst February\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Friday",
              "documentation": {
                "identifier": "Friday",
                "newPage": false,
                "searchKey": "time.Friday",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Friday"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Friday\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Hour",
              "documentation": {
                "identifier": "Hour",
                "newPage": false,
                "searchKey": "time.Hour",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Hour"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Hour = 60 * Minute\n```\n\nCommon durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions. \n\nTo count the number of units in a Duration, divide: \n\n```\nsecond := time.Second\nfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\n```\nTo convert an integer number of units to a Duration, multiply: \n\n```\nseconds := 10\nfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#January",
              "documentation": {
                "identifier": "January",
                "newPage": false,
                "searchKey": "time.January",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const January"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst January Month = 1 + iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#July",
              "documentation": {
                "identifier": "July",
                "newPage": false,
                "searchKey": "time.July",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const July"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst July\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#June",
              "documentation": {
                "identifier": "June",
                "newPage": false,
                "searchKey": "time.June",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const June"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst June\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Kitchen",
              "documentation": {
                "identifier": "Kitchen",
                "newPage": false,
                "searchKey": "time.Kitchen",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Kitchen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Kitchen = \"3:04PM\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Layout",
              "documentation": {
                "identifier": "Layout",
                "newPage": false,
                "searchKey": "time.Layout",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Layout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Layout = \"01/02 03:04:05PM '06 -0700\" // The reference time, in numerical order.\n\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#March",
              "documentation": {
                "identifier": "March",
                "newPage": false,
                "searchKey": "time.March",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const March"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst March\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#May",
              "documentation": {
                "identifier": "May",
                "newPage": false,
                "searchKey": "time.May",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const May"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst May\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Microsecond",
              "documentation": {
                "identifier": "Microsecond",
                "newPage": false,
                "searchKey": "time.Microsecond",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Microsecond"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Microsecond = 1000 * Nanosecond\n```\n\nCommon durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions. \n\nTo count the number of units in a Duration, divide: \n\n```\nsecond := time.Second\nfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\n```\nTo convert an integer number of units to a Duration, multiply: \n\n```\nseconds := 10\nfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Millisecond",
              "documentation": {
                "identifier": "Millisecond",
                "newPage": false,
                "searchKey": "time.Millisecond",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Millisecond"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Millisecond = 1000 * Microsecond\n```\n\nCommon durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions. \n\nTo count the number of units in a Duration, divide: \n\n```\nsecond := time.Second\nfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\n```\nTo convert an integer number of units to a Duration, multiply: \n\n```\nseconds := 10\nfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Minute",
              "documentation": {
                "identifier": "Minute",
                "newPage": false,
                "searchKey": "time.Minute",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Minute"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Minute = 60 * Second\n```\n\nCommon durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions. \n\nTo count the number of units in a Duration, divide: \n\n```\nsecond := time.Second\nfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\n```\nTo convert an integer number of units to a Duration, multiply: \n\n```\nseconds := 10\nfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Monday",
              "documentation": {
                "identifier": "Monday",
                "newPage": false,
                "searchKey": "time.Monday",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Monday"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Monday\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Nanosecond",
              "documentation": {
                "identifier": "Nanosecond",
                "newPage": false,
                "searchKey": "time.Nanosecond",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Nanosecond"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Nanosecond Duration = 1\n```\n\nCommon durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions. \n\nTo count the number of units in a Duration, divide: \n\n```\nsecond := time.Second\nfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\n```\nTo convert an integer number of units to a Duration, multiply: \n\n```\nseconds := 10\nfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#November",
              "documentation": {
                "identifier": "November",
                "newPage": false,
                "searchKey": "time.November",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const November"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst November\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#October",
              "documentation": {
                "identifier": "October",
                "newPage": false,
                "searchKey": "time.October",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const October"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst October\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#RFC1123",
              "documentation": {
                "identifier": "RFC1123",
                "newPage": false,
                "searchKey": "time.RFC1123",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RFC1123"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RFC1123 = \"Mon, 02 Jan 2006 15:04:05 MST\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#RFC1123Z",
              "documentation": {
                "identifier": "RFC1123Z",
                "newPage": false,
                "searchKey": "time.RFC1123Z",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RFC1123Z"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RFC1123Z = \"Mon, 02 Jan 2006 15:04:05 -0700\" // RFC1123 with numeric zone\n\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#RFC3339",
              "documentation": {
                "identifier": "RFC3339",
                "newPage": false,
                "searchKey": "time.RFC3339",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RFC3339"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RFC3339 = \"2006-01-02T15:04:05Z07:00\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#RFC3339Nano",
              "documentation": {
                "identifier": "RFC3339Nano",
                "newPage": false,
                "searchKey": "time.RFC3339Nano",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RFC3339Nano"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RFC3339Nano = \"2006-01-02T15:04:05.999999999Z07:00\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#RFC822",
              "documentation": {
                "identifier": "RFC822",
                "newPage": false,
                "searchKey": "time.RFC822",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RFC822"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RFC822 = \"02 Jan 06 15:04 MST\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#RFC822Z",
              "documentation": {
                "identifier": "RFC822Z",
                "newPage": false,
                "searchKey": "time.RFC822Z",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RFC822Z"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RFC822Z = \"02 Jan 06 15:04 -0700\" // RFC822 with numeric zone\n\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#RFC850",
              "documentation": {
                "identifier": "RFC850",
                "newPage": false,
                "searchKey": "time.RFC850",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RFC850"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RFC850 = \"Monday, 02-Jan-06 15:04:05 MST\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#RubyDate",
              "documentation": {
                "identifier": "RubyDate",
                "newPage": false,
                "searchKey": "time.RubyDate",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RubyDate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RubyDate = \"Mon Jan 02 15:04:05 -0700 2006\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#RuleDOY",
              "documentation": {
                "identifier": "RuleDOY",
                "newPage": false,
                "searchKey": "time.RuleDOY",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RuleDOY"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RuleDOY = RuleKind(ruleDOY)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#RuleJulian",
              "documentation": {
                "identifier": "RuleJulian",
                "newPage": false,
                "searchKey": "time.RuleJulian",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RuleJulian"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RuleJulian = RuleKind(ruleJulian)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#RuleMonthWeekDay",
              "documentation": {
                "identifier": "RuleMonthWeekDay",
                "newPage": false,
                "searchKey": "time.RuleMonthWeekDay",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RuleMonthWeekDay"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RuleMonthWeekDay = RuleKind(ruleMonthWeekDay)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Saturday",
              "documentation": {
                "identifier": "Saturday",
                "newPage": false,
                "searchKey": "time.Saturday",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Saturday"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Saturday\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Second",
              "documentation": {
                "identifier": "Second",
                "newPage": false,
                "searchKey": "time.Second",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Second"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Second = 1000 * Millisecond\n```\n\nCommon durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions. \n\nTo count the number of units in a Duration, divide: \n\n```\nsecond := time.Second\nfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\n```\nTo convert an integer number of units to a Duration, multiply: \n\n```\nseconds := 10\nfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#September",
              "documentation": {
                "identifier": "September",
                "newPage": false,
                "searchKey": "time.September",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const September"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst September\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Stamp",
              "documentation": {
                "identifier": "Stamp",
                "newPage": false,
                "searchKey": "time.Stamp",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Stamp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Stamp = \"Jan _2 15:04:05\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\nHandy time stamps. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#StampMicro",
              "documentation": {
                "identifier": "StampMicro",
                "newPage": false,
                "searchKey": "time.StampMicro",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StampMicro"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StampMicro = \"Jan _2 15:04:05.000000\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#StampMilli",
              "documentation": {
                "identifier": "StampMilli",
                "newPage": false,
                "searchKey": "time.StampMilli",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StampMilli"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StampMilli = \"Jan _2 15:04:05.000\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#StampNano",
              "documentation": {
                "identifier": "StampNano",
                "newPage": false,
                "searchKey": "time.StampNano",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const StampNano"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst StampNano = \"Jan _2 15:04:05.000000000\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Sunday",
              "documentation": {
                "identifier": "Sunday",
                "newPage": false,
                "searchKey": "time.Sunday",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Sunday"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Sunday Weekday = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Thursday",
              "documentation": {
                "identifier": "Thursday",
                "newPage": false,
                "searchKey": "time.Thursday",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Thursday"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Thursday\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Tuesday",
              "documentation": {
                "identifier": "Tuesday",
                "newPage": false,
                "searchKey": "time.Tuesday",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Tuesday"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Tuesday\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#UnixDate",
              "documentation": {
                "identifier": "UnixDate",
                "newPage": false,
                "searchKey": "time.UnixDate",
                "tags": [
                  "constant",
                  "string"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const UnixDate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UnixDate = \"Mon Jan _2 15:04:05 MST 2006\"\n```\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: \n\n```\n01/02 03:04:05PM '06 -0700\n\n```\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: \n\n```\nMon Jan 2 15:04:05 MST 2006\n\n```\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. \n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. \n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. \n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. \n\n```\nYear: \"2006\" \"06\"\nMonth: \"Jan\" \"January\"\nTextual day of the week: \"Mon\" \"Monday\"\nNumeric day of the month: \"2\" \"_2\" \"02\"\nNumeric day of the year: \"__2\" \"002\"\nHour: \"15\" \"3\" \"03\" (PM or AM)\nMinute: \"4\" \"04\"\nSecond: \"5\" \"05\"\nAM/PM mark: \"PM\"\n\n```\nNumeric time zone offsets format as follows: \n\n```\n\"-0700\"  ±hhmm\n\"-07:00\" ±hh:mm\n\"-07\"    ±hh\n\n```\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \n\n```\n\"Z0700\"  Z or ±hhmm\n\"Z07:00\" Z or ±hh:mm\n\"Z07\"    Z or ±hh\n\n```\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. \n\nThe formats  and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. \n\nA decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. Either a comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. \n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#UnixToInternal",
              "documentation": {
                "identifier": "UnixToInternal",
                "newPage": false,
                "searchKey": "time.UnixToInternal",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const UnixToInternal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UnixToInternal = unixToInternal\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Wednesday",
              "documentation": {
                "identifier": "Wednesday",
                "newPage": false,
                "searchKey": "time.Wednesday",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Wednesday"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Wednesday\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#absoluteToInternal",
              "documentation": {
                "identifier": "absoluteToInternal",
                "newPage": false,
                "searchKey": "time.absoluteToInternal",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const absoluteToInternal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst absoluteToInternal int64 = (absoluteZeroYear - internalYear) * 365.2425 * secondsPerDay\n```\n\nOffsets to convert between internal and absolute or Unix times. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#absoluteZeroYear",
              "documentation": {
                "identifier": "absoluteZeroYear",
                "newPage": false,
                "searchKey": "time.absoluteZeroYear",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const absoluteZeroYear"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst absoluteZeroYear = -292277022399\n```\n\nThe unsigned zero year for internal calculations. Must be 1 mod 400, and times before it will not compute correctly, but otherwise can be changed at will. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#alpha",
              "documentation": {
                "identifier": "alpha",
                "newPage": false,
                "searchKey": "time.alpha",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const alpha"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alpha = -1 << 63 // math.MinInt64\n\n```\n\nalpha and omega are the beginning and end of time for zone transitions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#daysPer100Years",
              "documentation": {
                "identifier": "daysPer100Years",
                "newPage": false,
                "searchKey": "time.daysPer100Years",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const daysPer100Years"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst daysPer100Years = 365*100 + 24\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#daysPer400Years",
              "documentation": {
                "identifier": "daysPer400Years",
                "newPage": false,
                "searchKey": "time.daysPer400Years",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const daysPer400Years"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst daysPer400Years = 365*400 + 97\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#daysPer4Years",
              "documentation": {
                "identifier": "daysPer4Years",
                "newPage": false,
                "searchKey": "time.daysPer4Years",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const daysPer4Years"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst daysPer4Years = 365*4 + 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#hasMonotonic",
              "documentation": {
                "identifier": "hasMonotonic",
                "newPage": false,
                "searchKey": "time.hasMonotonic",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const hasMonotonic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hasMonotonic = 1 << 63\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#internalToAbsolute",
              "documentation": {
                "identifier": "internalToAbsolute",
                "newPage": false,
                "searchKey": "time.internalToAbsolute",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const internalToAbsolute"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst internalToAbsolute = -absoluteToInternal\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#internalToUnix",
              "documentation": {
                "identifier": "internalToUnix",
                "newPage": false,
                "searchKey": "time.internalToUnix",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const internalToUnix"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst internalToUnix int64 = -unixToInternal\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#internalToWall",
              "documentation": {
                "identifier": "internalToWall",
                "newPage": false,
                "searchKey": "time.internalToWall",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const internalToWall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst internalToWall int64 = -wallToInternal\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#internalYear",
              "documentation": {
                "identifier": "internalYear",
                "newPage": false,
                "searchKey": "time.internalYear",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const internalYear"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst internalYear = 1\n```\n\nThe year of the zero Time. Assumed by the unixToInternal computation below. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#lowerhex",
              "documentation": {
                "identifier": "lowerhex",
                "newPage": false,
                "searchKey": "time.lowerhex",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const lowerhex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lowerhex = \"0123456789abcdef\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#maxDuration",
              "documentation": {
                "identifier": "maxDuration",
                "newPage": false,
                "searchKey": "time.maxDuration",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxDuration"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxDuration Duration = 1<<63 - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#maxFileSize",
              "documentation": {
                "identifier": "maxFileSize",
                "newPage": false,
                "searchKey": "time.maxFileSize",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxFileSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxFileSize = 10 << 20\n```\n\nmaxFileSize is the max permitted size of files read by readFile. As reference, the zoneinfo.zip distributed by Go is ~350 KB, so 10MB is overkill. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#maxWall",
              "documentation": {
                "identifier": "maxWall",
                "newPage": false,
                "searchKey": "time.maxWall",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxWall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxWall = wallToInternal + (1<<33 - 1) // year 2157\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#minDuration",
              "documentation": {
                "identifier": "minDuration",
                "newPage": false,
                "searchKey": "time.minDuration",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const minDuration"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst minDuration Duration = -1 << 63\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#minWall",
              "documentation": {
                "identifier": "minWall",
                "newPage": false,
                "searchKey": "time.minWall",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const minWall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst minWall = wallToInternal // year 1885\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#nsecMask",
              "documentation": {
                "identifier": "nsecMask",
                "newPage": false,
                "searchKey": "time.nsecMask",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const nsecMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst nsecMask = 1<<30 - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#nsecShift",
              "documentation": {
                "identifier": "nsecShift",
                "newPage": false,
                "searchKey": "time.nsecShift",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const nsecShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst nsecShift = 30\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#omega",
              "documentation": {
                "identifier": "omega",
                "newPage": false,
                "searchKey": "time.omega",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const omega"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst omega = 1<<63 - 1 // math.MaxInt64\n\n```\n\nalpha and omega are the beginning and end of time for zone transitions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#ruleDOY",
              "documentation": {
                "identifier": "ruleDOY",
                "newPage": false,
                "searchKey": "time.ruleDOY",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ruleDOY"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ruleDOY\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#ruleJulian",
              "documentation": {
                "identifier": "ruleJulian",
                "newPage": false,
                "searchKey": "time.ruleJulian",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ruleJulian"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ruleJulian ruleKind = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#ruleMonthWeekDay",
              "documentation": {
                "identifier": "ruleMonthWeekDay",
                "newPage": false,
                "searchKey": "time.ruleMonthWeekDay",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ruleMonthWeekDay"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ruleMonthWeekDay\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#runeSelf",
              "documentation": {
                "identifier": "runeSelf",
                "newPage": false,
                "searchKey": "time.runeSelf",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const runeSelf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst runeSelf = 0x80\n```\n\nThese are borrowed from unicode/utf8 and strconv and replicate behavior in that package, since we can't take a dependency on either. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#secondsPerDay",
              "documentation": {
                "identifier": "secondsPerDay",
                "newPage": false,
                "searchKey": "time.secondsPerDay",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const secondsPerDay"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst secondsPerDay = 24 * secondsPerHour\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#secondsPerHour",
              "documentation": {
                "identifier": "secondsPerHour",
                "newPage": false,
                "searchKey": "time.secondsPerHour",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const secondsPerHour"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst secondsPerHour = 60 * secondsPerMinute\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#secondsPerMinute",
              "documentation": {
                "identifier": "secondsPerMinute",
                "newPage": false,
                "searchKey": "time.secondsPerMinute",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const secondsPerMinute"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst secondsPerMinute = 60\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#secondsPerWeek",
              "documentation": {
                "identifier": "secondsPerWeek",
                "newPage": false,
                "searchKey": "time.secondsPerWeek",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const secondsPerWeek"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst secondsPerWeek = 7 * secondsPerDay\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#seekCurrent",
              "documentation": {
                "identifier": "seekCurrent",
                "newPage": false,
                "searchKey": "time.seekCurrent",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const seekCurrent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst seekCurrent = 1\n```\n\nCopies of io.Seek* constants to avoid importing \"io\": \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#seekEnd",
              "documentation": {
                "identifier": "seekEnd",
                "newPage": false,
                "searchKey": "time.seekEnd",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const seekEnd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst seekEnd = 2\n```\n\nCopies of io.Seek* constants to avoid importing \"io\": \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#seekStart",
              "documentation": {
                "identifier": "seekStart",
                "newPage": false,
                "searchKey": "time.seekStart",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const seekStart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst seekStart = 0\n```\n\nCopies of io.Seek* constants to avoid importing \"io\": \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdArgShift",
              "documentation": {
                "identifier": "stdArgShift",
                "newPage": false,
                "searchKey": "time.stdArgShift",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdArgShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdArgShift = 16 // extra argument in high bits, above low stdArgShift\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdDay",
              "documentation": {
                "identifier": "stdDay",
                "newPage": false,
                "searchKey": "time.stdDay",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdDay"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdDay // \"2\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdFracSecond0",
              "documentation": {
                "identifier": "stdFracSecond0",
                "newPage": false,
                "searchKey": "time.stdFracSecond0",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdFracSecond0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdFracSecond0 // \".0\", \".00\", ... , trailing zeros included\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdFracSecond9",
              "documentation": {
                "identifier": "stdFracSecond9",
                "newPage": false,
                "searchKey": "time.stdFracSecond9",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdFracSecond9"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdFracSecond9 // \".9\", \".99\", ..., trailing zeros omitted\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdHour",
              "documentation": {
                "identifier": "stdHour",
                "newPage": false,
                "searchKey": "time.stdHour",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdHour"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdHour = iota + stdNeedClock // \"15\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdHour12",
              "documentation": {
                "identifier": "stdHour12",
                "newPage": false,
                "searchKey": "time.stdHour12",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdHour12"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdHour12 // \"3\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdISO8601ColonSecondsTZ",
              "documentation": {
                "identifier": "stdISO8601ColonSecondsTZ",
                "newPage": false,
                "searchKey": "time.stdISO8601ColonSecondsTZ",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdISO8601ColonSecondsTZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdISO8601ColonSecondsTZ // \"Z07:00:00\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdISO8601ColonTZ",
              "documentation": {
                "identifier": "stdISO8601ColonTZ",
                "newPage": false,
                "searchKey": "time.stdISO8601ColonTZ",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdISO8601ColonTZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdISO8601ColonTZ // \"Z07:00\" // prints Z for UTC\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdISO8601SecondsTZ",
              "documentation": {
                "identifier": "stdISO8601SecondsTZ",
                "newPage": false,
                "searchKey": "time.stdISO8601SecondsTZ",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdISO8601SecondsTZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdISO8601SecondsTZ // \"Z070000\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdISO8601ShortTZ",
              "documentation": {
                "identifier": "stdISO8601ShortTZ",
                "newPage": false,
                "searchKey": "time.stdISO8601ShortTZ",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdISO8601ShortTZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdISO8601ShortTZ // \"Z07\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdISO8601TZ",
              "documentation": {
                "identifier": "stdISO8601TZ",
                "newPage": false,
                "searchKey": "time.stdISO8601TZ",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdISO8601TZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdISO8601TZ // \"Z0700\"  // prints Z for UTC\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdLongMonth",
              "documentation": {
                "identifier": "stdLongMonth",
                "newPage": false,
                "searchKey": "time.stdLongMonth",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdLongMonth"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdLongMonth = iota + stdNeedDate // \"January\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdLongWeekDay",
              "documentation": {
                "identifier": "stdLongWeekDay",
                "newPage": false,
                "searchKey": "time.stdLongWeekDay",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdLongWeekDay"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdLongWeekDay // \"Monday\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdLongYear",
              "documentation": {
                "identifier": "stdLongYear",
                "newPage": false,
                "searchKey": "time.stdLongYear",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdLongYear"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdLongYear = iota + stdNeedDate // \"2006\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdMask",
              "documentation": {
                "identifier": "stdMask",
                "newPage": false,
                "searchKey": "time.stdMask",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdMask = 1<<stdArgShift - 1 // mask out argument\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdMinute",
              "documentation": {
                "identifier": "stdMinute",
                "newPage": false,
                "searchKey": "time.stdMinute",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdMinute"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdMinute // \"4\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdMonth",
              "documentation": {
                "identifier": "stdMonth",
                "newPage": false,
                "searchKey": "time.stdMonth",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdMonth"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdMonth // \"Jan\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdNeedClock",
              "documentation": {
                "identifier": "stdNeedClock",
                "newPage": false,
                "searchKey": "time.stdNeedClock",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdNeedClock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdNeedClock = 2 << 8 // need hour, minute, second\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdNeedDate",
              "documentation": {
                "identifier": "stdNeedDate",
                "newPage": false,
                "searchKey": "time.stdNeedDate",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdNeedDate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdNeedDate = 1 << 8 // need month, day, year\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdNumColonSecondsTZ",
              "documentation": {
                "identifier": "stdNumColonSecondsTZ",
                "newPage": false,
                "searchKey": "time.stdNumColonSecondsTZ",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdNumColonSecondsTZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdNumColonSecondsTZ // \"-07:00:00\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdNumColonTZ",
              "documentation": {
                "identifier": "stdNumColonTZ",
                "newPage": false,
                "searchKey": "time.stdNumColonTZ",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdNumColonTZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdNumColonTZ // \"-07:00\" // always numeric\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdNumMonth",
              "documentation": {
                "identifier": "stdNumMonth",
                "newPage": false,
                "searchKey": "time.stdNumMonth",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdNumMonth"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdNumMonth // \"1\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdNumSecondsTz",
              "documentation": {
                "identifier": "stdNumSecondsTz",
                "newPage": false,
                "searchKey": "time.stdNumSecondsTz",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdNumSecondsTz"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdNumSecondsTz // \"-070000\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdNumShortTZ",
              "documentation": {
                "identifier": "stdNumShortTZ",
                "newPage": false,
                "searchKey": "time.stdNumShortTZ",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdNumShortTZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdNumShortTZ // \"-07\"    // always numeric\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdNumTZ",
              "documentation": {
                "identifier": "stdNumTZ",
                "newPage": false,
                "searchKey": "time.stdNumTZ",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdNumTZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdNumTZ // \"-0700\"  // always numeric\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdPM",
              "documentation": {
                "identifier": "stdPM",
                "newPage": false,
                "searchKey": "time.stdPM",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdPM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdPM = iota + stdNeedClock // \"PM\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdSecond",
              "documentation": {
                "identifier": "stdSecond",
                "newPage": false,
                "searchKey": "time.stdSecond",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdSecond"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdSecond // \"5\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdTZ",
              "documentation": {
                "identifier": "stdTZ",
                "newPage": false,
                "searchKey": "time.stdTZ",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdTZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdTZ = iota // \"MST\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdUnderDay",
              "documentation": {
                "identifier": "stdUnderDay",
                "newPage": false,
                "searchKey": "time.stdUnderDay",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdUnderDay"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdUnderDay // \"_2\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdUnderYearDay",
              "documentation": {
                "identifier": "stdUnderYearDay",
                "newPage": false,
                "searchKey": "time.stdUnderYearDay",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdUnderYearDay"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdUnderYearDay // \"__2\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdWeekDay",
              "documentation": {
                "identifier": "stdWeekDay",
                "newPage": false,
                "searchKey": "time.stdWeekDay",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdWeekDay"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdWeekDay // \"Mon\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdYear",
              "documentation": {
                "identifier": "stdYear",
                "newPage": false,
                "searchKey": "time.stdYear",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdYear"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdYear // \"06\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdZeroDay",
              "documentation": {
                "identifier": "stdZeroDay",
                "newPage": false,
                "searchKey": "time.stdZeroDay",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdZeroDay"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdZeroDay // \"02\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdZeroHour12",
              "documentation": {
                "identifier": "stdZeroHour12",
                "newPage": false,
                "searchKey": "time.stdZeroHour12",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdZeroHour12"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdZeroHour12 // \"03\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdZeroMinute",
              "documentation": {
                "identifier": "stdZeroMinute",
                "newPage": false,
                "searchKey": "time.stdZeroMinute",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdZeroMinute"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdZeroMinute // \"04\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdZeroMonth",
              "documentation": {
                "identifier": "stdZeroMonth",
                "newPage": false,
                "searchKey": "time.stdZeroMonth",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdZeroMonth"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdZeroMonth // \"01\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdZeroSecond",
              "documentation": {
                "identifier": "stdZeroSecond",
                "newPage": false,
                "searchKey": "time.stdZeroSecond",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdZeroSecond"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdZeroSecond // \"05\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdZeroYearDay",
              "documentation": {
                "identifier": "stdZeroYearDay",
                "newPage": false,
                "searchKey": "time.stdZeroYearDay",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdZeroYearDay"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdZeroYearDay // \"002\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stdpm",
              "documentation": {
                "identifier": "stdpm",
                "newPage": false,
                "searchKey": "time.stdpm",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const stdpm"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stdpm // \"pm\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#timeBinaryVersion",
              "documentation": {
                "identifier": "timeBinaryVersion",
                "newPage": false,
                "searchKey": "time.timeBinaryVersion",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const timeBinaryVersion"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timeBinaryVersion byte = 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#unixToInternal",
              "documentation": {
                "identifier": "unixToInternal",
                "newPage": false,
                "searchKey": "time.unixToInternal",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const unixToInternal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst unixToInternal int64 = (1969*365 + 1969/4 - 1969/100 + 1969/400) * secondsPerDay\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#wallToInternal",
              "documentation": {
                "identifier": "wallToInternal",
                "newPage": false,
                "searchKey": "time.wallToInternal",
                "tags": [
                  "constant",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const wallToInternal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst wallToInternal int64 = (1884*365 + 1884/4 - 1884/100 + 1884/400) * secondsPerDay\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/time#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/time#DaysIn",
              "documentation": {
                "identifier": "DaysIn",
                "newPage": false,
                "searchKey": "time.DaysIn",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var DaysIn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar DaysIn = daysIn\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#ErrLocation",
              "documentation": {
                "identifier": "ErrLocation",
                "newPage": false,
                "searchKey": "time.ErrLocation",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrLocation"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrLocation = errLocation\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#ForceZipFileForTesting",
              "documentation": {
                "identifier": "ForceZipFileForTesting",
                "newPage": false,
                "searchKey": "time.ForceZipFileForTesting",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ForceZipFileForTesting"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ForceZipFileForTesting = forceZipFileForTesting\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#GetMono",
              "documentation": {
                "identifier": "GetMono",
                "newPage": false,
                "searchKey": "time.GetMono",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var GetMono"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar GetMono = (*Time).mono\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Interrupt",
              "documentation": {
                "identifier": "Interrupt",
                "newPage": false,
                "searchKey": "time.Interrupt",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Interrupt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Interrupt = interrupt\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#LoadTzinfo",
              "documentation": {
                "identifier": "LoadTzinfo",
                "newPage": false,
                "searchKey": "time.LoadTzinfo",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var LoadTzinfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar LoadTzinfo = loadTzinfo\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Local",
              "documentation": {
                "identifier": "Local",
                "newPage": false,
                "searchKey": "time.Local",
                "tags": [
                  "variable",
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Local"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Local *Location = &localLoc\n```\n\nLocal represents the system's local time zone. On Unix systems, Local consults the TZ environment variable to find the time zone to use. No TZ means use the system default /etc/localtime. TZ=\"\" means use UTC. TZ=\"foo\" means use file foo in the system timezone directory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#MaxMonoTime",
              "documentation": {
                "identifier": "MaxMonoTime",
                "newPage": false,
                "searchKey": "time.MaxMonoTime",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var MaxMonoTime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar MaxMonoTime = Time{wall: 1 << 63, ext: 1<<63 - 1, loc: UTC}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#MinMonoTime",
              "documentation": {
                "identifier": "MinMonoTime",
                "newPage": false,
                "searchKey": "time.MinMonoTime",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var MinMonoTime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar MinMonoTime = Time{wall: 1 << 63, ext: -1 << 63, loc: UTC}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#NextStdChunk",
              "documentation": {
                "identifier": "NextStdChunk",
                "newPage": false,
                "searchKey": "time.NextStdChunk",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var NextStdChunk"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar NextStdChunk = nextStdChunk\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#NotMonoNegativeTime",
              "documentation": {
                "identifier": "NotMonoNegativeTime",
                "newPage": false,
                "searchKey": "time.NotMonoNegativeTime",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var NotMonoNegativeTime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar NotMonoNegativeTime = Time{wall: 0, ext: -1<<63 + 50}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#OrigZoneSources",
              "documentation": {
                "identifier": "OrigZoneSources",
                "newPage": false,
                "searchKey": "time.OrigZoneSources",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var OrigZoneSources"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar OrigZoneSources = zoneSources\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#ParseTimeZone",
              "documentation": {
                "identifier": "ParseTimeZone",
                "newPage": false,
                "searchKey": "time.ParseTimeZone",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ParseTimeZone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ParseTimeZone = parseTimeZone\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Quote",
              "documentation": {
                "identifier": "Quote",
                "newPage": false,
                "searchKey": "time.Quote",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Quote"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Quote = quote\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#ReadFile",
              "documentation": {
                "identifier": "ReadFile",
                "newPage": false,
                "searchKey": "time.ReadFile",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ReadFile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ReadFile = readFile\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#SetMono",
              "documentation": {
                "identifier": "SetMono",
                "newPage": false,
                "searchKey": "time.SetMono",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var SetMono"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar SetMono = (*Time).setMono\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#StdChunkNames",
              "documentation": {
                "identifier": "StdChunkNames",
                "newPage": false,
                "searchKey": "time.StdChunkNames",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var StdChunkNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar StdChunkNames = ...\n```\n\nStdChunkNames maps from nextStdChunk results to the matched strings. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Tzset",
              "documentation": {
                "identifier": "Tzset",
                "newPage": false,
                "searchKey": "time.Tzset",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Tzset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Tzset = tzset\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#TzsetName",
              "documentation": {
                "identifier": "TzsetName",
                "newPage": false,
                "searchKey": "time.TzsetName",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var TzsetName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar TzsetName = tzsetName\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#TzsetOffset",
              "documentation": {
                "identifier": "TzsetOffset",
                "newPage": false,
                "searchKey": "time.TzsetOffset",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var TzsetOffset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar TzsetOffset = tzsetOffset\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#UTC",
              "documentation": {
                "identifier": "UTC",
                "newPage": false,
                "searchKey": "time.UTC",
                "tags": [
                  "variable",
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var UTC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar UTC *Location = &utcLoc\n```\n\nUTC represents Universal Coordinated Time (UTC). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#atoiError",
              "documentation": {
                "identifier": "atoiError",
                "newPage": false,
                "searchKey": "time.atoiError",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var atoiError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar atoiError = errors.New(\"time: invalid number\")\n```\n\nNever printed, just needs to be non-nil for return by atoi. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#badData",
              "documentation": {
                "identifier": "badData",
                "newPage": false,
                "searchKey": "time.badData",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var badData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badData = errors.New(\"malformed time zone information\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#daysBefore",
              "documentation": {
                "identifier": "daysBefore",
                "newPage": false,
                "searchKey": "time.daysBefore",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var daysBefore"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar daysBefore = ...\n```\n\ndaysBefore[m] counts the number of days in a non-leap year before month m begins. There is an entry for m=12, counting the number of days before January of next year (365). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#errBad",
              "documentation": {
                "identifier": "errBad",
                "newPage": false,
                "searchKey": "time.errBad",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errBad"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errBad = errors.New(\"bad value for field\") // placeholder not passed to user\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#errLeadingInt",
              "documentation": {
                "identifier": "errLeadingInt",
                "newPage": false,
                "searchKey": "time.errLeadingInt",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errLeadingInt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errLeadingInt = errors.New(\"time: bad [0-9]*\") // never printed\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#errLocation",
              "documentation": {
                "identifier": "errLocation",
                "newPage": false,
                "searchKey": "time.errLocation",
                "tags": [
                  "variable",
                  "interface",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var errLocation"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errLocation = errors.New(\"time: invalid location name\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#loadFromEmbeddedTZData",
              "documentation": {
                "identifier": "loadFromEmbeddedTZData",
                "newPage": false,
                "searchKey": "time.loadFromEmbeddedTZData",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var loadFromEmbeddedTZData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar loadFromEmbeddedTZData func(zipname string) (string, error)\n```\n\nloadFromEmbeddedTZData is used to load a specific tzdata file from tzdata information embedded in the binary itself. This is set when the time/tzdata package is imported, via registerLoadFromEmbeddedTzdata. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#loadTzinfoFromTzdata",
              "documentation": {
                "identifier": "loadTzinfoFromTzdata",
                "newPage": false,
                "searchKey": "time.loadTzinfoFromTzdata",
                "tags": [
                  "variable",
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var loadTzinfoFromTzdata"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar loadTzinfoFromTzdata func(file, name string) ([]byte, error)\n```\n\nloadTzinfoFromTzdata returns the time zone information of the time zone with the given name, from a tzdata database file as they are typically found on android. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#localLoc",
              "documentation": {
                "identifier": "localLoc",
                "newPage": false,
                "searchKey": "time.localLoc",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var localLoc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar localLoc Location\n```\n\nlocalLoc is separate so that initLocal can initialize it even if a client has changed Local. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#localOnce",
              "documentation": {
                "identifier": "localOnce",
                "newPage": false,
                "searchKey": "time.localOnce",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var localOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar localOnce sync.Once\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#longDayNames",
              "documentation": {
                "identifier": "longDayNames",
                "newPage": false,
                "searchKey": "time.longDayNames",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var longDayNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar longDayNames = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#longMonthNames",
              "documentation": {
                "identifier": "longMonthNames",
                "newPage": false,
                "searchKey": "time.longMonthNames",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var longMonthNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar longMonthNames = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#shortDayNames",
              "documentation": {
                "identifier": "shortDayNames",
                "newPage": false,
                "searchKey": "time.shortDayNames",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var shortDayNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar shortDayNames = []string{\n\t\"Sun\",\n\t\"Mon\",\n\t\"Tue\",\n\t\"Wed\",\n\t\"Thu\",\n\t\"Fri\",\n\t\"Sat\",\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#shortMonthNames",
              "documentation": {
                "identifier": "shortMonthNames",
                "newPage": false,
                "searchKey": "time.shortMonthNames",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var shortMonthNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar shortMonthNames = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#startNano",
              "documentation": {
                "identifier": "startNano",
                "newPage": false,
                "searchKey": "time.startNano",
                "tags": [
                  "variable",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var startNano"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar startNano int64 = runtimeNano() - 1\n```\n\nMonotonic times are reported as offsets from startNano. We initialize startNano to runtimeNano() - 1 so that on systems where monotonic time resolution is fairly low (e.g. Windows 2008 which appears to have a default resolution of 15ms), we avoid ever reporting a monotonic time of 0. (Callers may want to use 0 as \"time not set\".) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#std0x",
              "documentation": {
                "identifier": "std0x",
                "newPage": false,
                "searchKey": "time.std0x",
                "tags": [
                  "variable",
                  "array",
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var std0x"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar std0x = [...]int{stdZeroMonth, stdZeroDay, stdZeroHour12, stdZeroMinute, stdZeroSecond, stdYear}\n```\n\nstd0x records the std values for \"01\", \"02\", ..., \"06\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#unitMap",
              "documentation": {
                "identifier": "unitMap",
                "newPage": false,
                "searchKey": "time.unitMap",
                "tags": [
                  "variable",
                  "object",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var unitMap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar unitMap = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#utcLoc",
              "documentation": {
                "identifier": "utcLoc",
                "newPage": false,
                "searchKey": "time.utcLoc",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var utcLoc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar utcLoc = Location{name: \"UTC\"}\n```\n\nutcLoc is separate so that get can refer to &utcLoc and ensure that it never returns a nil *Location, even if a badly behaved client has changed UTC. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#zoneSources",
              "documentation": {
                "identifier": "zoneSources",
                "newPage": false,
                "searchKey": "time.zoneSources",
                "tags": [
                  "variable",
                  "array",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var zoneSources"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar zoneSources = ...\n```\n\nMany systems use /usr/share/zoneinfo, Solaris 2 has /usr/share/lib/zoneinfo, IRIX 6 has /usr/lib/locale/TZ. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#zoneinfo",
              "documentation": {
                "identifier": "zoneinfo",
                "newPage": false,
                "searchKey": "time.zoneinfo",
                "tags": [
                  "variable",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var zoneinfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar zoneinfo *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#zoneinfoOnce",
              "documentation": {
                "identifier": "zoneinfoOnce",
                "newPage": false,
                "searchKey": "time.zoneinfoOnce",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var zoneinfoOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar zoneinfoOnce sync.Once\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/time#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/time#Duration",
              "documentation": {
                "identifier": "Duration",
                "newPage": false,
                "searchKey": "time.Duration",
                "tags": [
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Duration int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Duration int64\n```\n\nA Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#ParseDuration",
                    "documentation": {
                      "identifier": "ParseDuration",
                      "newPage": false,
                      "searchKey": "time.ParseDuration",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseDuration(s string) (Duration, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseDuration(s string) (Duration, error)\n```\n\nParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Since",
                    "documentation": {
                      "identifier": "Since",
                      "newPage": false,
                      "searchKey": "time.Since",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Since(t Time) Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Since(t Time) Duration\n```\n\nSince returns the time elapsed since t. It is shorthand for time.Now().Sub(t). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Until",
                    "documentation": {
                      "identifier": "Until",
                      "newPage": false,
                      "searchKey": "time.Until",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Until(t Time) Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Until(t Time) Duration\n```\n\nUntil returns the duration until t. It is shorthand for t.Sub(time.Now()). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#div",
                    "documentation": {
                      "identifier": "div",
                      "newPage": false,
                      "searchKey": "time.div",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func div(t Time, d Duration) (qmod2 int, r Duration)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc div(t Time, d Duration) (qmod2 int, r Duration)\n```\n\ndiv divides t by d and returns the quotient parity and remainder. We don't use the quotient parity anymore (round half up instead of round to even) but it's still here in case we change our minds. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Duration.Hours",
                    "documentation": {
                      "identifier": "Duration.Hours",
                      "newPage": false,
                      "searchKey": "time.Duration.Hours",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d Duration) Hours() float64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d Duration) Hours() float64\n```\n\nHours returns the duration as a floating point number of hours. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Duration.Microseconds",
                    "documentation": {
                      "identifier": "Duration.Microseconds",
                      "newPage": false,
                      "searchKey": "time.Duration.Microseconds",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d Duration) Microseconds() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d Duration) Microseconds() int64\n```\n\nMicroseconds returns the duration as an integer microsecond count. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Duration.Milliseconds",
                    "documentation": {
                      "identifier": "Duration.Milliseconds",
                      "newPage": false,
                      "searchKey": "time.Duration.Milliseconds",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d Duration) Milliseconds() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d Duration) Milliseconds() int64\n```\n\nMilliseconds returns the duration as an integer millisecond count. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Duration.Minutes",
                    "documentation": {
                      "identifier": "Duration.Minutes",
                      "newPage": false,
                      "searchKey": "time.Duration.Minutes",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d Duration) Minutes() float64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d Duration) Minutes() float64\n```\n\nMinutes returns the duration as a floating point number of minutes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Duration.Nanoseconds",
                    "documentation": {
                      "identifier": "Duration.Nanoseconds",
                      "newPage": false,
                      "searchKey": "time.Duration.Nanoseconds",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d Duration) Nanoseconds() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d Duration) Nanoseconds() int64\n```\n\nNanoseconds returns the duration as an integer nanosecond count. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Duration.Round",
                    "documentation": {
                      "identifier": "Duration.Round",
                      "newPage": false,
                      "searchKey": "time.Duration.Round",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d Duration) Round(m Duration) Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d Duration) Round(m Duration) Duration\n```\n\nRound returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, Round returns the maximum (or minimum) duration. If m <= 0, Round returns d unchanged. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Duration.Seconds",
                    "documentation": {
                      "identifier": "Duration.Seconds",
                      "newPage": false,
                      "searchKey": "time.Duration.Seconds",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d Duration) Seconds() float64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d Duration) Seconds() float64\n```\n\nSeconds returns the duration as a floating point number of seconds. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Duration.String",
                    "documentation": {
                      "identifier": "Duration.String",
                      "newPage": false,
                      "searchKey": "time.Duration.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d Duration) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d Duration) String() string\n```\n\nString returns a string representing the duration in the form \"72h3m0.5s\". Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Duration.Truncate",
                    "documentation": {
                      "identifier": "Duration.Truncate",
                      "newPage": false,
                      "searchKey": "time.Duration.Truncate",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d Duration) Truncate(m Duration) Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d Duration) Truncate(m Duration) Duration\n```\n\nTruncate returns the result of rounding d toward zero to a multiple of m. If m <= 0, Truncate returns d unchanged. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#Location",
              "documentation": {
                "identifier": "Location",
                "newPage": false,
                "searchKey": "time.Location",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Location struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Location struct {\n\tname string\n\tzone []zone\n\ttx   []zoneTrans\n\n\t// The tzdata information can be followed by a string that describes\n\t// how to handle DST transitions not recorded in zoneTrans.\n\t// The format is the TZ environment variable without a colon; see\n\t// https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html.\n\t// Example string, for America/Los_Angeles: PST8PDT,M3.2.0,M11.1.0\n\textend string\n\n\t// Most lookups will be for the current time.\n\t// To avoid the binary search through tx, keep a\n\t// static one-element cache that gives the correct\n\t// zone for the time when the Location was created.\n\t// if cacheStart <= t < cacheEnd,\n\t// lookup can return cacheZone.\n\t// The units for cacheStart and cacheEnd are seconds\n\t// since January 1, 1970 UTC, to match the argument\n\t// to lookup.\n\tcacheStart int64\n\tcacheEnd   int64\n\tcacheZone  *zone\n}\n```\n\nA Location maps time instants to the zone in use at that time. Typically, the Location represents the collection of time offsets in use in a geographical area. For many Locations the time offset varies depending on whether daylight savings time is in use at the time instant. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#FixedZone",
                    "documentation": {
                      "identifier": "FixedZone",
                      "newPage": false,
                      "searchKey": "time.FixedZone",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FixedZone(name string, offset int) *Location"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FixedZone(name string, offset int) *Location\n```\n\nFixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#LoadLocation",
                    "documentation": {
                      "identifier": "LoadLocation",
                      "newPage": false,
                      "searchKey": "time.LoadLocation",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func LoadLocation(name string) (*Location, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc LoadLocation(name string) (*Location, error)\n```\n\nLoadLocation returns the Location with the given name. \n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC. If the name is \"Local\", LoadLocation returns Local. \n\nOtherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as \"America/New_York\". \n\nThe time zone database needed by LoadLocation may not be present on all systems, especially non-Unix systems. LoadLocation looks in the directory or uncompressed zip file named by the ZONEINFO environment variable, if any, then looks in known installation locations on Unix systems, and finally looks in $GOROOT/lib/time/zoneinfo.zip. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#LoadLocationFromTZData",
                    "documentation": {
                      "identifier": "LoadLocationFromTZData",
                      "newPage": false,
                      "searchKey": "time.LoadLocationFromTZData",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func LoadLocationFromTZData(name string, data []byte) (*Location, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc LoadLocationFromTZData(name string, data []byte) (*Location, error)\n```\n\nLoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#loadLocation",
                    "documentation": {
                      "identifier": "loadLocation",
                      "newPage": false,
                      "searchKey": "time.loadLocation",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func loadLocation(name string, sources []string) (z *Location, firstErr error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc loadLocation(name string, sources []string) (z *Location, firstErr error)\n```\n\nloadLocation returns the Location with the given name from one of the specified sources. See loadTzinfo for a list of supported sources. The first timezone data matching the given name that is successfully loaded and parsed is returned as a Location. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Location.String",
                    "documentation": {
                      "identifier": "Location.String",
                      "newPage": false,
                      "searchKey": "time.Location.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Location) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Location) String() string\n```\n\nString returns a descriptive name for the time zone information, corresponding to the name argument to LoadLocation or FixedZone. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Location.firstZoneUsed",
                    "documentation": {
                      "identifier": "Location.firstZoneUsed",
                      "newPage": false,
                      "searchKey": "time.Location.firstZoneUsed",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Location) firstZoneUsed() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Location) firstZoneUsed() bool\n```\n\nfirstZoneUsed reports whether the first zone is used by some transition. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Location.get",
                    "documentation": {
                      "identifier": "Location.get",
                      "newPage": false,
                      "searchKey": "time.Location.get",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Location) get() *Location"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Location) get() *Location\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Location.lookup",
                    "documentation": {
                      "identifier": "Location.lookup",
                      "newPage": false,
                      "searchKey": "time.Location.lookup",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Location) lookup(sec int64) (name string, offset int, start, end int64, isDST bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Location) lookup(sec int64) (name string, offset int, start, end int64, isDST bool)\n```\n\nlookup returns information about the time zone in use at an instant in time expressed as seconds since January 1, 1970 00:00:00 UTC. \n\nThe returned information gives the name of the zone (such as \"CET\"), the start and end times bracketing sec when that zone is in effect, the offset in seconds east of UTC (such as -5*60*60), and whether the daylight savings is being observed at that time. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Location.lookupFirstZone",
                    "documentation": {
                      "identifier": "Location.lookupFirstZone",
                      "newPage": false,
                      "searchKey": "time.Location.lookupFirstZone",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Location) lookupFirstZone() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Location) lookupFirstZone() int\n```\n\nlookupFirstZone returns the index of the time zone to use for times before the first transition time, or when there are no transition times. \n\nThe reference implementation in localtime.c from [https://www.iana.org/time-zones/repository/releases/tzcode2013g.tar.gz](https://www.iana.org/time-zones/repository/releases/tzcode2013g.tar.gz) implements the following algorithm for these cases: 1) If the first zone is unused by the transitions, use it. 2) Otherwise, if there are transition times, and the first \n\n```\ntransition is to a zone in daylight time, find the first\nnon-daylight-time zone before and closest to the first transition\nzone.\n\n```\n3) Otherwise, use the first zone that is not daylight time, if \n\n```\nthere is one.\n\n```\n4) Otherwise, use the first zone. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Location.lookupName",
                    "documentation": {
                      "identifier": "Location.lookupName",
                      "newPage": false,
                      "searchKey": "time.Location.lookupName",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Location) lookupName(name string, unix int64) (offset int, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Location) lookupName(name string, unix int64) (offset int, ok bool)\n```\n\nlookupName returns information about the time zone with the given name (such as \"EST\") at the given pseudo-Unix time (what the given time of day would be in UTC). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#Month",
              "documentation": {
                "identifier": "Month",
                "newPage": false,
                "searchKey": "time.Month",
                "tags": [
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Month int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Month int\n```\n\nA Month specifies a month of the year (January = 1, ...). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#absDate",
                    "documentation": {
                      "identifier": "absDate",
                      "newPage": false,
                      "searchKey": "time.absDate",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func absDate(abs uint64, full bool) (year int, month Month, day int, yday int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc absDate(abs uint64, full bool) (year int, month Month, day int, yday int)\n```\n\nabsDate is like date but operates on an absolute time. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Month.String",
                    "documentation": {
                      "identifier": "Month.String",
                      "newPage": false,
                      "searchKey": "time.Month.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m Month) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m Month) String() string\n```\n\nString returns the English name of the month (\"January\", \"February\", ...). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#ParseError",
              "documentation": {
                "identifier": "ParseError",
                "newPage": false,
                "searchKey": "time.ParseError",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ParseError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ParseError struct {\n\tLayout     string\n\tValue      string\n\tLayoutElem string\n\tValueElem  string\n\tMessage    string\n}\n```\n\nParseError describes a problem parsing a time string. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#ParseError.Error",
                    "documentation": {
                      "identifier": "ParseError.Error",
                      "newPage": false,
                      "searchKey": "time.ParseError.Error",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *ParseError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *ParseError) Error() string\n```\n\nError returns the string representation of a ParseError. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#Rule",
              "documentation": {
                "identifier": "Rule",
                "newPage": false,
                "searchKey": "time.Rule",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Rule struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Rule struct {\n\tKind RuleKind\n\tDay  int\n\tWeek int\n\tMon  int\n\tTime int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#TzsetRule",
                    "documentation": {
                      "identifier": "TzsetRule",
                      "newPage": false,
                      "searchKey": "time.TzsetRule",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func TzsetRule(s string) (Rule, string, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc TzsetRule(s string) (Rule, string, bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#RuleKind",
              "documentation": {
                "identifier": "RuleKind",
                "newPage": false,
                "searchKey": "time.RuleKind",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RuleKind int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RuleKind int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Ticker",
              "documentation": {
                "identifier": "Ticker",
                "newPage": false,
                "searchKey": "time.Ticker",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Ticker struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Ticker struct {\n\tC <-chan Time // The channel on which the ticks are delivered.\n\tr runtimeTimer\n}\n```\n\nA Ticker holds a channel that delivers `ticks' of a clock at intervals. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#NewTicker",
                    "documentation": {
                      "identifier": "NewTicker",
                      "newPage": false,
                      "searchKey": "time.NewTicker",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewTicker(d Duration) *Ticker"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewTicker(d Duration) *Ticker\n```\n\nNewTicker returns a new Ticker containing a channel that will send the time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Ticker.Reset",
                    "documentation": {
                      "identifier": "Ticker.Reset",
                      "newPage": false,
                      "searchKey": "time.Ticker.Reset",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Ticker) Reset(d Duration)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Ticker) Reset(d Duration)\n```\n\nReset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Ticker.Stop",
                    "documentation": {
                      "identifier": "Ticker.Stop",
                      "newPage": false,
                      "searchKey": "time.Ticker.Stop",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Ticker) Stop()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Ticker) Stop()\n```\n\nStop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous \"tick\". \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#Time",
              "documentation": {
                "identifier": "Time",
                "newPage": false,
                "searchKey": "time.Time",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Time struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Time struct {\n\t// wall and ext encode the wall time seconds, wall time nanoseconds,\n\t// and optional monotonic clock reading in nanoseconds.\n\t//\n\t// From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),\n\t// a 33-bit seconds field, and a 30-bit wall time nanoseconds field.\n\t// The nanoseconds field is in the range [0, 999999999].\n\t// If the hasMonotonic bit is 0, then the 33-bit field must be zero\n\t// and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.\n\t// If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit\n\t// unsigned wall seconds since Jan 1 year 1885, and ext holds a\n\t// signed 64-bit monotonic clock reading, nanoseconds since process start.\n\twall uint64\n\text  int64\n\n\t// loc specifies the Location that should be used to\n\t// determine the minute, hour, month, day, and year\n\t// that correspond to this Time.\n\t// The nil location means UTC.\n\t// All UTC times are represented with loc==nil, never loc==&utcLoc.\n\tloc *Location\n}\n```\n\nA Time represents an instant in time with nanosecond precision. \n\nPrograms using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time. \n\nA Time value can be used by multiple goroutines simultaneously except that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and UnmarshalText are not concurrency-safe. \n\nTime instants can be compared using the Before, After, and Equal methods. The Sub method subtracts two instants, producing a Duration. The Add method adds a Time and a Duration, producing a Time. \n\nThe zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the IsZero method gives a simple way of detecting a time that has not been initialized explicitly. \n\nEach Time has associated with it a Location, consulted when computing the presentation form of the time, such as in the Format, Hour, and Year methods. The methods Local, UTC, and In return a Time with a specific location. Changing the location in this way changes only the presentation; it does not change the instant in time being denoted and therefore does not affect the computations described in earlier paragraphs. \n\nRepresentations of a Time value saved by the GobEncode, MarshalBinary, MarshalJSON, and MarshalText methods store the Time.Location's offset, but not the location name. They therefore lose information about Daylight Saving Time. \n\nIn addition to the required “wall clock” reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the “Monotonic Clocks” section in the package documentation for details. \n\nNote that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#Date",
                    "documentation": {
                      "identifier": "Date",
                      "newPage": false,
                      "searchKey": "time.Date",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time\n```\n\nDate returns the Time corresponding to \n\n```\nyyyy-mm-dd hh:mm:ss + nsec nanoseconds\n\n```\nin the appropriate zone for that time in the given location. \n\nThe month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1. \n\nA daylight savings time transition skips or repeats times. For example, in the United States, March 13, 2011 2:15am never occurred, while November 6, 2011 1:15am occurred twice. In such cases, the choice of time zone, and therefore the time, is not well-defined. Date returns a time that is correct in one of the two zones involved in the transition, but it does not guarantee which. \n\nDate panics if loc is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Now",
                    "documentation": {
                      "identifier": "Now",
                      "newPage": false,
                      "searchKey": "time.Now",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Now() Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Now() Time\n```\n\nNow returns the current local time. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Parse",
                    "documentation": {
                      "identifier": "Parse",
                      "newPage": false,
                      "searchKey": "time.Parse",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Parse(layout, value string) (Time, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Parse(layout, value string) (Time, error)\n```\n\nParse parses a formatted string and returns the time value it represents. See the documentation for the constant called Layout to see how to represent the format. The second argument must be parseable using the format string (layout) provided as the first argument. \n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\nWhen parsing (only), the input may contain a fractional second field immediately after the seconds field, even if the layout does not signify its presence. In that case either a comma or a decimal point followed by a maximal series of digits is parsed as a fractional second. \n\nElements omitted from the layout are assumed to be zero or, when zero is impossible, one, so parsing \"3:04pm\" returns the time corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is 0, this time is before the zero Time). Years must be in the range 0000..9999. The day of the week is checked for syntax but it is otherwise ignored. \n\nFor layouts specifying the two-digit year 06, a value NN >= 69 will be treated as 19NN and a value NN < 69 will be treated as 20NN. \n\nThe remainder of this comment describes the handling of time zones. \n\nIn the absence of a time zone indicator, Parse returns a time in UTC. \n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset. \n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation \"UTC\" is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#ParseInLocation",
                    "documentation": {
                      "identifier": "ParseInLocation",
                      "newPage": false,
                      "searchKey": "time.ParseInLocation",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseInLocation(layout, value string, loc *Location) (Time, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseInLocation(layout, value string, loc *Location) (Time, error)\n```\n\nParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Unix",
                    "documentation": {
                      "identifier": "Unix",
                      "newPage": false,
                      "searchKey": "time.Unix",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Unix(sec int64, nsec int64) Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Unix(sec int64, nsec int64) Time\n```\n\nUnix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1<<63-1 (the largest int64 value). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#UnixMicro",
                    "documentation": {
                      "identifier": "UnixMicro",
                      "newPage": false,
                      "searchKey": "time.UnixMicro",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func UnixMicro(usec int64) Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc UnixMicro(usec int64) Time\n```\n\nUnixMicro returns the local Time corresponding to the given Unix time, usec milliseconds since January 1, 1970 UTC. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#UnixMilli",
                    "documentation": {
                      "identifier": "UnixMilli",
                      "newPage": false,
                      "searchKey": "time.UnixMilli",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func UnixMilli(msec int64) Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc UnixMilli(msec int64) Time\n```\n\nUnixMilli returns the local Time corresponding to the given Unix time, msec milliseconds since January 1, 1970 UTC. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#parse",
                    "documentation": {
                      "identifier": "parse",
                      "newPage": false,
                      "searchKey": "time.parse",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parse(layout, value string, defaultLocation, local *Location) (Time, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parse(layout, value string, defaultLocation, local *Location) (Time, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#unixTime",
                    "documentation": {
                      "identifier": "unixTime",
                      "newPage": false,
                      "searchKey": "time.unixTime",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func unixTime(sec int64, nsec int32) Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc unixTime(sec int64, nsec int32) Time\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Add",
                    "documentation": {
                      "identifier": "Time.Add",
                      "newPage": false,
                      "searchKey": "time.Time.Add",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Add(d Duration) Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Add(d Duration) Time\n```\n\nAdd returns the time t+d. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.AddDate",
                    "documentation": {
                      "identifier": "Time.AddDate",
                      "newPage": false,
                      "searchKey": "time.Time.AddDate",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) AddDate(years int, months int, days int) Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) AddDate(years int, months int, days int) Time\n```\n\nAddDate returns the time corresponding to adding the given number of years, months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010. \n\nAddDate normalizes its result in the same way that Date does, so, for example, adding one month to October 31 yields December 1, the normalized form for November 31. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.After",
                    "documentation": {
                      "identifier": "Time.After",
                      "newPage": false,
                      "searchKey": "time.Time.After",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) After(u Time) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) After(u Time) bool\n```\n\nAfter reports whether the time instant t is after u. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.AppendFormat",
                    "documentation": {
                      "identifier": "Time.AppendFormat",
                      "newPage": false,
                      "searchKey": "time.Time.AppendFormat",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) AppendFormat(b []byte, layout string) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) AppendFormat(b []byte, layout string) []byte\n```\n\nAppendFormat is like Format but appends the textual representation to b and returns the extended buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Before",
                    "documentation": {
                      "identifier": "Time.Before",
                      "newPage": false,
                      "searchKey": "time.Time.Before",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Before(u Time) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Before(u Time) bool\n```\n\nBefore reports whether the time instant t is before u. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Clock",
                    "documentation": {
                      "identifier": "Time.Clock",
                      "newPage": false,
                      "searchKey": "time.Time.Clock",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Clock() (hour, min, sec int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Clock() (hour, min, sec int)\n```\n\nClock returns the hour, minute, and second within the day specified by t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Date",
                    "documentation": {
                      "identifier": "Time.Date",
                      "newPage": false,
                      "searchKey": "time.Time.Date",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Date() (year int, month Month, day int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Date() (year int, month Month, day int)\n```\n\nDate returns the year, month, and day in which t occurs. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Day",
                    "documentation": {
                      "identifier": "Time.Day",
                      "newPage": false,
                      "searchKey": "time.Time.Day",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Day() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Day() int\n```\n\nDay returns the day of the month specified by t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Equal",
                    "documentation": {
                      "identifier": "Time.Equal",
                      "newPage": false,
                      "searchKey": "time.Time.Equal",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Equal(u Time) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Equal(u Time) bool\n```\n\nEqual reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 and 4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of using == with Time values; most code should use Equal instead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Format",
                    "documentation": {
                      "identifier": "Time.Format",
                      "newPage": false,
                      "searchKey": "time.Time.Format",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Format(layout string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Format(layout string) string\n```\n\nFormat returns a textual representation of the time value formatted according to the layout defined by the argument. See the documentation for the constant called Layout to see how to represent the layout format. \n\nThe executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.GoString",
                    "documentation": {
                      "identifier": "Time.GoString",
                      "newPage": false,
                      "searchKey": "time.Time.GoString",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) GoString() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) GoString() string\n```\n\nGoString implements fmt.GoStringer and formats t to be printed in Go source code. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.GobDecode",
                    "documentation": {
                      "identifier": "Time.GobDecode",
                      "newPage": false,
                      "searchKey": "time.Time.GobDecode",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) GobDecode(data []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) GobDecode(data []byte) error\n```\n\nGobDecode implements the gob.GobDecoder interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.GobEncode",
                    "documentation": {
                      "identifier": "Time.GobEncode",
                      "newPage": false,
                      "searchKey": "time.Time.GobEncode",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) GobEncode() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) GobEncode() ([]byte, error)\n```\n\nGobEncode implements the gob.GobEncoder interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Hour",
                    "documentation": {
                      "identifier": "Time.Hour",
                      "newPage": false,
                      "searchKey": "time.Time.Hour",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Hour() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Hour() int\n```\n\nHour returns the hour within the day specified by t, in the range [0, 23]. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.ISOWeek",
                    "documentation": {
                      "identifier": "Time.ISOWeek",
                      "newPage": false,
                      "searchKey": "time.Time.ISOWeek",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) ISOWeek() (year, week int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) ISOWeek() (year, week int)\n```\n\nISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.In",
                    "documentation": {
                      "identifier": "Time.In",
                      "newPage": false,
                      "searchKey": "time.Time.In",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) In(loc *Location) Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) In(loc *Location) Time\n```\n\nIn returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes. \n\nIn panics if loc is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.IsDST",
                    "documentation": {
                      "identifier": "Time.IsDST",
                      "newPage": false,
                      "searchKey": "time.Time.IsDST",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) IsDST() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) IsDST() bool\n```\n\nIsDST reports whether the time in the configured location is in Daylight Savings Time. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.IsZero",
                    "documentation": {
                      "identifier": "Time.IsZero",
                      "newPage": false,
                      "searchKey": "time.Time.IsZero",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) IsZero() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) IsZero() bool\n```\n\nIsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Local",
                    "documentation": {
                      "identifier": "Time.Local",
                      "newPage": false,
                      "searchKey": "time.Time.Local",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Local() Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Local() Time\n```\n\nLocal returns t with the location set to local time. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Location",
                    "documentation": {
                      "identifier": "Time.Location",
                      "newPage": false,
                      "searchKey": "time.Time.Location",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Location() *Location"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Location() *Location\n```\n\nLocation returns the time zone information associated with t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.MarshalBinary",
                    "documentation": {
                      "identifier": "Time.MarshalBinary",
                      "newPage": false,
                      "searchKey": "time.Time.MarshalBinary",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) MarshalBinary() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) MarshalBinary() ([]byte, error)\n```\n\nMarshalBinary implements the encoding.BinaryMarshaler interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.MarshalJSON",
                    "documentation": {
                      "identifier": "Time.MarshalJSON",
                      "newPage": false,
                      "searchKey": "time.Time.MarshalJSON",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) MarshalJSON() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) MarshalJSON() ([]byte, error)\n```\n\nMarshalJSON implements the json.Marshaler interface. The time is a quoted string in RFC 3339 format, with sub-second precision added if present. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.MarshalText",
                    "documentation": {
                      "identifier": "Time.MarshalText",
                      "newPage": false,
                      "searchKey": "time.Time.MarshalText",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) MarshalText() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) MarshalText() ([]byte, error)\n```\n\nMarshalText implements the encoding.TextMarshaler interface. The time is formatted in RFC 3339 format, with sub-second precision added if present. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Minute",
                    "documentation": {
                      "identifier": "Time.Minute",
                      "newPage": false,
                      "searchKey": "time.Time.Minute",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Minute() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Minute() int\n```\n\nMinute returns the minute offset within the hour specified by t, in the range [0, 59]. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Month",
                    "documentation": {
                      "identifier": "Time.Month",
                      "newPage": false,
                      "searchKey": "time.Time.Month",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Month() Month"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Month() Month\n```\n\nMonth returns the month of the year specified by t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Nanosecond",
                    "documentation": {
                      "identifier": "Time.Nanosecond",
                      "newPage": false,
                      "searchKey": "time.Time.Nanosecond",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Nanosecond() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Nanosecond() int\n```\n\nNanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999]. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Round",
                    "documentation": {
                      "identifier": "Time.Round",
                      "newPage": false,
                      "searchKey": "time.Time.Round",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Round(d Duration) Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Round(d Duration) Time\n```\n\nRound returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged. \n\nRound operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Round(Hour) may return a time with a non-zero minute, depending on the time's Location. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Second",
                    "documentation": {
                      "identifier": "Time.Second",
                      "newPage": false,
                      "searchKey": "time.Time.Second",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Second() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Second() int\n```\n\nSecond returns the second offset within the minute specified by t, in the range [0, 59]. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.String",
                    "documentation": {
                      "identifier": "Time.String",
                      "newPage": false,
                      "searchKey": "time.Time.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) String() string\n```\n\nString returns the time formatted using the format string \n\n```\n\"2006-01-02 15:04:05.999999999 -0700 MST\"\n\n```\nIf the time has a monotonic clock reading, the returned string includes a final field \"m=±<value>\", where value is the monotonic clock reading formatted as a decimal number of seconds. \n\nThe returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Sub",
                    "documentation": {
                      "identifier": "Time.Sub",
                      "newPage": false,
                      "searchKey": "time.Time.Sub",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Sub(u Time) Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Sub(u Time) Duration\n```\n\nSub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Truncate",
                    "documentation": {
                      "identifier": "Time.Truncate",
                      "newPage": false,
                      "searchKey": "time.Time.Truncate",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Truncate(d Duration) Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Truncate(d Duration) Time\n```\n\nTruncate returns the result of rounding t down to a multiple of d (since the zero time). If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged. \n\nTruncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.UTC",
                    "documentation": {
                      "identifier": "Time.UTC",
                      "newPage": false,
                      "searchKey": "time.Time.UTC",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) UTC() Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) UTC() Time\n```\n\nUTC returns t with the location set to UTC. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Unix",
                    "documentation": {
                      "identifier": "Time.Unix",
                      "newPage": false,
                      "searchKey": "time.Time.Unix",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Unix() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Unix() int64\n```\n\nUnix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.UnixMicro",
                    "documentation": {
                      "identifier": "Time.UnixMicro",
                      "newPage": false,
                      "searchKey": "time.Time.UnixMicro",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) UnixMicro() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) UnixMicro() int64\n```\n\nUnixMicro returns t as a Unix time, the number of microseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in microseconds cannot be represented by an int64 (a date before year -290307 or after year 294246). The result does not depend on the location associated with t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.UnixMilli",
                    "documentation": {
                      "identifier": "Time.UnixMilli",
                      "newPage": false,
                      "searchKey": "time.Time.UnixMilli",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) UnixMilli() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) UnixMilli() int64\n```\n\nUnixMilli returns t as a Unix time, the number of milliseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in milliseconds cannot be represented by an int64 (a date more than 292 million years before or after 1970). The result does not depend on the location associated with t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.UnixNano",
                    "documentation": {
                      "identifier": "Time.UnixNano",
                      "newPage": false,
                      "searchKey": "time.Time.UnixNano",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) UnixNano() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) UnixNano() int64\n```\n\nUnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.UnmarshalBinary",
                    "documentation": {
                      "identifier": "Time.UnmarshalBinary",
                      "newPage": false,
                      "searchKey": "time.Time.UnmarshalBinary",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) UnmarshalBinary(data []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) UnmarshalBinary(data []byte) error\n```\n\nUnmarshalBinary implements the encoding.BinaryUnmarshaler interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.UnmarshalJSON",
                    "documentation": {
                      "identifier": "Time.UnmarshalJSON",
                      "newPage": false,
                      "searchKey": "time.Time.UnmarshalJSON",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) UnmarshalJSON(data []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) UnmarshalJSON(data []byte) error\n```\n\nUnmarshalJSON implements the json.Unmarshaler interface. The time is expected to be a quoted string in RFC 3339 format. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.UnmarshalText",
                    "documentation": {
                      "identifier": "Time.UnmarshalText",
                      "newPage": false,
                      "searchKey": "time.Time.UnmarshalText",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) UnmarshalText(data []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) UnmarshalText(data []byte) error\n```\n\nUnmarshalText implements the encoding.TextUnmarshaler interface. The time is expected to be in RFC 3339 format. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Weekday",
                    "documentation": {
                      "identifier": "Time.Weekday",
                      "newPage": false,
                      "searchKey": "time.Time.Weekday",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Weekday() Weekday"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Weekday() Weekday\n```\n\nWeekday returns the day of the week specified by t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Year",
                    "documentation": {
                      "identifier": "Time.Year",
                      "newPage": false,
                      "searchKey": "time.Time.Year",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Year() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Year() int\n```\n\nYear returns the year in which t occurs. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.YearDay",
                    "documentation": {
                      "identifier": "Time.YearDay",
                      "newPage": false,
                      "searchKey": "time.Time.YearDay",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) YearDay() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) YearDay() int\n```\n\nYearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.Zone",
                    "documentation": {
                      "identifier": "Time.Zone",
                      "newPage": false,
                      "searchKey": "time.Time.Zone",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) Zone() (name string, offset int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) Zone() (name string, offset int)\n```\n\nZone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as \"CET\") and its offset in seconds east of UTC. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.abs",
                    "documentation": {
                      "identifier": "Time.abs",
                      "newPage": false,
                      "searchKey": "time.Time.abs",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) abs() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) abs() uint64\n```\n\nabs returns the time t as an absolute time, adjusted by the zone offset. It is called when computing a presentation property like Month or Hour. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.addSec",
                    "documentation": {
                      "identifier": "Time.addSec",
                      "newPage": false,
                      "searchKey": "time.Time.addSec",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) addSec(d int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) addSec(d int64)\n```\n\naddSec adds d seconds to the time. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.date",
                    "documentation": {
                      "identifier": "Time.date",
                      "newPage": false,
                      "searchKey": "time.Time.date",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) date(full bool) (year int, month Month, day int, yday int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) date(full bool) (year int, month Month, day int, yday int)\n```\n\ndate computes the year, day of year, and when full=true, the month and day in which t occurs. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.locabs",
                    "documentation": {
                      "identifier": "Time.locabs",
                      "newPage": false,
                      "searchKey": "time.Time.locabs",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t Time) locabs() (name string, offset int, abs uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t Time) locabs() (name string, offset int, abs uint64)\n```\n\nlocabs is a combination of the Zone and abs methods, extracting both return values from a single zone lookup. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.mono",
                    "documentation": {
                      "identifier": "Time.mono",
                      "newPage": false,
                      "searchKey": "time.Time.mono",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) mono() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) mono() int64\n```\n\nmono returns t's monotonic clock reading. It returns 0 for a missing reading. This function is used only for testing, so it's OK that technically 0 is a valid monotonic clock reading as well. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.nsec",
                    "documentation": {
                      "identifier": "Time.nsec",
                      "newPage": false,
                      "searchKey": "time.Time.nsec",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) nsec() int32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) nsec() int32\n```\n\nnsec returns the time's nanoseconds. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.sec",
                    "documentation": {
                      "identifier": "Time.sec",
                      "newPage": false,
                      "searchKey": "time.Time.sec",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) sec() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) sec() int64\n```\n\nsec returns the time's seconds since Jan 1 year 1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.setLoc",
                    "documentation": {
                      "identifier": "Time.setLoc",
                      "newPage": false,
                      "searchKey": "time.Time.setLoc",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) setLoc(loc *Location)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) setLoc(loc *Location)\n```\n\nsetLoc sets the location associated with the time. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.setMono",
                    "documentation": {
                      "identifier": "Time.setMono",
                      "newPage": false,
                      "searchKey": "time.Time.setMono",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) setMono(m int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) setMono(m int64)\n```\n\nsetMono sets the monotonic clock reading in t. If t cannot hold a monotonic clock reading, because its wall time is too large, setMono is a no-op. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.stripMono",
                    "documentation": {
                      "identifier": "Time.stripMono",
                      "newPage": false,
                      "searchKey": "time.Time.stripMono",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) stripMono()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) stripMono()\n```\n\nstripMono strips the monotonic clock reading in t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Time.unixSec",
                    "documentation": {
                      "identifier": "Time.unixSec",
                      "newPage": false,
                      "searchKey": "time.Time.unixSec",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Time) unixSec() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Time) unixSec() int64\n```\n\nunixSec returns the time's seconds since Jan 1 1970 (Unix time). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#Timer",
              "documentation": {
                "identifier": "Timer",
                "newPage": false,
                "searchKey": "time.Timer",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Timer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Timer struct {\n\tC <-chan Time\n\tr runtimeTimer\n}\n```\n\nThe Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#AfterFunc",
                    "documentation": {
                      "identifier": "AfterFunc",
                      "newPage": false,
                      "searchKey": "time.AfterFunc",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func AfterFunc(d Duration, f func()) *Timer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc AfterFunc(d Duration, f func()) *Timer\n```\n\nAfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that can be used to cancel the call using its Stop method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#NewTimer",
                    "documentation": {
                      "identifier": "NewTimer",
                      "newPage": false,
                      "searchKey": "time.NewTimer",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewTimer(d Duration) *Timer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewTimer(d Duration) *Timer\n```\n\nNewTimer creates a new Timer that will send the current time on its channel after at least duration d. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Timer.Reset",
                    "documentation": {
                      "identifier": "Timer.Reset",
                      "newPage": false,
                      "searchKey": "time.Timer.Reset",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Timer) Reset(d Duration) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Timer) Reset(d Duration) bool\n```\n\nReset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped. \n\nFor a Timer created with NewTimer, Reset should be invoked only on stopped or expired timers with drained channels. \n\nIf a program has already received a value from t.C, the timer is known to have expired and the channel drained, so t.Reset can be used directly. If a program has not yet received a value from t.C, however, the timer must be stopped and—if Stop reports that the timer expired before being stopped—the channel explicitly drained: \n\n```\nif !t.Stop() {\n\t<-t.C\n}\nt.Reset(d)\n\n```\nThis should not be done concurrent to other receives from the Timer's channel. \n\nNote that it is not possible to use Reset's return value correctly, as there is a race condition between draining the channel and the new timer expiring. Reset should always be invoked on stopped or expired channels, as described above. The return value exists to preserve compatibility with existing programs. \n\nFor a Timer created with AfterFunc(d, f), Reset either reschedules when f will run, in which case Reset returns true, or schedules f to run again, in which case it returns false. When Reset returns false, Reset neither waits for the prior f to complete before returning nor does it guarantee that the subsequent goroutine running f does not run concurrently with the prior one. If the caller needs to know whether the prior execution of f is completed, it must coordinate with f explicitly. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Timer.Stop",
                    "documentation": {
                      "identifier": "Timer.Stop",
                      "newPage": false,
                      "searchKey": "time.Timer.Stop",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Timer) Stop() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Timer) Stop() bool\n```\n\nStop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. Stop does not close the channel, to prevent a read from the channel succeeding incorrectly. \n\nTo ensure the channel is empty after a call to Stop, check the return value and drain the channel. For example, assuming the program has not received from t.C already: \n\n```\nif !t.Stop() {\n\t<-t.C\n}\n\n```\nThis cannot be done concurrent to other receives from the Timer's channel or other calls to the Timer's Stop method. \n\nFor a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#Weekday",
              "documentation": {
                "identifier": "Weekday",
                "newPage": false,
                "searchKey": "time.Weekday",
                "tags": [
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Weekday int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Weekday int\n```\n\nA Weekday specifies a day of the week (Sunday = 0, ...). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#absWeekday",
                    "documentation": {
                      "identifier": "absWeekday",
                      "newPage": false,
                      "searchKey": "time.absWeekday",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func absWeekday(abs uint64) Weekday"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc absWeekday(abs uint64) Weekday\n```\n\nabsWeekday is like Weekday but operates on an absolute time. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#Weekday.String",
                    "documentation": {
                      "identifier": "Weekday.String",
                      "newPage": false,
                      "searchKey": "time.Weekday.String",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d Weekday) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d Weekday) String() string\n```\n\nString returns the English name of the day (\"Sunday\", \"Monday\", ...). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#dataIO",
              "documentation": {
                "identifier": "dataIO",
                "newPage": false,
                "searchKey": "time.dataIO",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type dataIO struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dataIO struct {\n\tp     []byte\n\terror bool\n}\n```\n\nSimple I/O interface to binary blob of data. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#dataIO.big4",
                    "documentation": {
                      "identifier": "dataIO.big4",
                      "newPage": false,
                      "searchKey": "time.dataIO.big4",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *dataIO) big4() (n uint32, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *dataIO) big4() (n uint32, ok bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#dataIO.big8",
                    "documentation": {
                      "identifier": "dataIO.big8",
                      "newPage": false,
                      "searchKey": "time.dataIO.big8",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *dataIO) big8() (n uint64, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *dataIO) big8() (n uint64, ok bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#dataIO.byte",
                    "documentation": {
                      "identifier": "dataIO.byte",
                      "newPage": false,
                      "searchKey": "time.dataIO.byte",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *dataIO) byte() (n byte, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *dataIO) byte() (n byte, ok bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#dataIO.read",
                    "documentation": {
                      "identifier": "dataIO.read",
                      "newPage": false,
                      "searchKey": "time.dataIO.read",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *dataIO) read(n int) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *dataIO) read(n int) []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/time#dataIO.rest",
                    "documentation": {
                      "identifier": "dataIO.rest",
                      "newPage": false,
                      "searchKey": "time.dataIO.rest",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *dataIO) rest() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *dataIO) rest() []byte\n```\n\nread returns the read of the data in the buffer. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#fileSizeError",
              "documentation": {
                "identifier": "fileSizeError",
                "newPage": false,
                "searchKey": "time.fileSizeError",
                "tags": [
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type fileSizeError string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fileSizeError string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#fileSizeError.Error",
                    "documentation": {
                      "identifier": "fileSizeError.Error",
                      "newPage": false,
                      "searchKey": "time.fileSizeError.Error",
                      "tags": [
                        "function",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f fileSizeError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f fileSizeError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#rule",
              "documentation": {
                "identifier": "rule",
                "newPage": false,
                "searchKey": "time.rule",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type rule struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype rule struct {\n\tkind ruleKind\n\tday  int\n\tweek int\n\tmon  int\n\ttime int // transition time\n}\n```\n\nrule is a rule read from a tzset string. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/time#tzsetRule",
                    "documentation": {
                      "identifier": "tzsetRule",
                      "newPage": false,
                      "searchKey": "time.tzsetRule",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tzsetRule(s string) (rule, string, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tzsetRule(s string) (rule, string, bool)\n```\n\ntzsetRule parses a rule from a tzset string. It returns the rule, and the remainder of the string, and reports success. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/time#ruleKind",
              "documentation": {
                "identifier": "ruleKind",
                "newPage": false,
                "searchKey": "time.ruleKind",
                "tags": [
                  "number",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ruleKind int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ruleKind int\n```\n\nruleKind is the kinds of rules that can be seen in a tzset string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#runtimeTimer",
              "documentation": {
                "identifier": "runtimeTimer",
                "newPage": false,
                "searchKey": "time.runtimeTimer",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type runtimeTimer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype runtimeTimer struct {\n\tpp       uintptr\n\twhen     int64\n\tperiod   int64\n\tf        func(interface{}, uintptr) // NOTE: must not be closure\n\targ      interface{}\n\tseq      uintptr\n\tnextwhen int64\n\tstatus   uint32\n}\n```\n\nInterface to timers implemented in package runtime. Must be in sync with ../runtime/time.go:/^type timer \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#zone",
              "documentation": {
                "identifier": "zone",
                "newPage": false,
                "searchKey": "time.zone",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type zone struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype zone struct {\n\tname   string // abbreviated name, \"CET\"\n\toffset int    // seconds east of UTC\n\tisDST  bool   // is this zone Daylight Savings Time?\n}\n```\n\nA zone represents a single time zone such as CET. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#zoneTrans",
              "documentation": {
                "identifier": "zoneTrans",
                "newPage": false,
                "searchKey": "time.zoneTrans",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type zoneTrans struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype zoneTrans struct {\n\twhen         int64 // transition time, in seconds since 1970 GMT\n\tindex        uint8 // the index of the zone that goes into effect at that time\n\tisstd, isutc bool  // ignored - no idea what these mean\n}\n```\n\nA zoneTrans represents a single time zone transition. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/time#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "package"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/time#After",
              "documentation": {
                "identifier": "After",
                "newPage": false,
                "searchKey": "time.After",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func After(d Duration) <-chan Time"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc After(d Duration) <-chan Time\n```\n\nAfter waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#CheckRuntimeTimerPeriodOverflow",
              "documentation": {
                "identifier": "CheckRuntimeTimerPeriodOverflow",
                "newPage": false,
                "searchKey": "time.CheckRuntimeTimerPeriodOverflow",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func CheckRuntimeTimerPeriodOverflow()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc CheckRuntimeTimerPeriodOverflow()\n```\n\nTest that a runtimeTimer with a period that would overflow when on expiration does not throw or cause other timers to hang. \n\nThis test has to be in internal_test.go since it fiddles with unexported data structures. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#ForceUSPacificForTesting",
              "documentation": {
                "identifier": "ForceUSPacificForTesting",
                "newPage": false,
                "searchKey": "time.ForceUSPacificForTesting",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ForceUSPacificForTesting()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ForceUSPacificForTesting()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#LoadFromEmbeddedTZData",
              "documentation": {
                "identifier": "LoadFromEmbeddedTZData",
                "newPage": false,
                "searchKey": "time.LoadFromEmbeddedTZData",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LoadFromEmbeddedTZData(zone string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LoadFromEmbeddedTZData(zone string) (string, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#ResetLocalOnceForTest",
              "documentation": {
                "identifier": "ResetLocalOnceForTest",
                "newPage": false,
                "searchKey": "time.ResetLocalOnceForTest",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ResetLocalOnceForTest()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ResetLocalOnceForTest()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#ResetZoneinfoForTesting",
              "documentation": {
                "identifier": "ResetZoneinfoForTesting",
                "newPage": false,
                "searchKey": "time.ResetZoneinfoForTesting",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ResetZoneinfoForTesting()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ResetZoneinfoForTesting()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Sleep",
              "documentation": {
                "identifier": "Sleep",
                "newPage": false,
                "searchKey": "time.Sleep",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Sleep(d Duration)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Sleep(d Duration)\n```\n\nSleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#Tick",
              "documentation": {
                "identifier": "Tick",
                "newPage": false,
                "searchKey": "time.Tick",
                "tags": [
                  "method"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Tick(d Duration) <-chan Time"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Tick(d Duration) <-chan Time\n```\n\nTick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it \"leaks\". Unlike NewTicker, Tick will return nil if d <= 0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#ZoneinfoForTesting",
              "documentation": {
                "identifier": "ZoneinfoForTesting",
                "newPage": false,
                "searchKey": "time.ZoneinfoForTesting",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ZoneinfoForTesting() *string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ZoneinfoForTesting() *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#absClock",
              "documentation": {
                "identifier": "absClock",
                "newPage": false,
                "searchKey": "time.absClock",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func absClock(abs uint64) (hour, min, sec int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc absClock(abs uint64) (hour, min, sec int)\n```\n\nabsClock is like clock but operates on an absolute time. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#appendInt",
              "documentation": {
                "identifier": "appendInt",
                "newPage": false,
                "searchKey": "time.appendInt",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendInt(b []byte, x int, width int) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendInt(b []byte, x int, width int) []byte\n```\n\nappendInt appends the decimal form of x to b and returns the result. If the decimal form (excluding sign) is shorter than width, the result is padded with leading 0's. Duplicates functionality in strconv, but avoids dependency. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#atoi",
              "documentation": {
                "identifier": "atoi",
                "newPage": false,
                "searchKey": "time.atoi",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func atoi(s string) (x int, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc atoi(s string) (x int, err error)\n```\n\nDuplicates functionality in strconv, but avoids dependency. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#byteString",
              "documentation": {
                "identifier": "byteString",
                "newPage": false,
                "searchKey": "time.byteString",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func byteString(p []byte) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc byteString(p []byte) string\n```\n\nMake a string by stopping at the first NUL \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#closefd",
              "documentation": {
                "identifier": "closefd",
                "newPage": false,
                "searchKey": "time.closefd",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func closefd(fd uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc closefd(fd uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#commaOrPeriod",
              "documentation": {
                "identifier": "commaOrPeriod",
                "newPage": false,
                "searchKey": "time.commaOrPeriod",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func commaOrPeriod(b byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc commaOrPeriod(b byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#containsDotDot",
              "documentation": {
                "identifier": "containsDotDot",
                "newPage": false,
                "searchKey": "time.containsDotDot",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func containsDotDot(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc containsDotDot(s string) bool\n```\n\ncontainsDotDot reports whether s contains \"..\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#cutspace",
              "documentation": {
                "identifier": "cutspace",
                "newPage": false,
                "searchKey": "time.cutspace",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func cutspace(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cutspace(s string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#daysIn",
              "documentation": {
                "identifier": "daysIn",
                "newPage": false,
                "searchKey": "time.daysIn",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func daysIn(m Month, year int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc daysIn(m Month, year int) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#daysSinceEpoch",
              "documentation": {
                "identifier": "daysSinceEpoch",
                "newPage": false,
                "searchKey": "time.daysSinceEpoch",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func daysSinceEpoch(year int) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc daysSinceEpoch(year int) uint64\n```\n\ndaysSinceEpoch takes a year and returns the number of days from the absolute epoch to the start of that year. This is basically (year - zeroYear) * 365, but accounting for leap days. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#empty",
              "documentation": {
                "identifier": "empty",
                "newPage": false,
                "searchKey": "time.empty",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func empty(arg interface{}, seq uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc empty(arg interface{}, seq uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#findZone",
              "documentation": {
                "identifier": "findZone",
                "newPage": false,
                "searchKey": "time.findZone",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func findZone(zones []zone, name string, offset int, isDST bool) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc findZone(zones []zone, name string, offset int, isDST bool) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#fmtFrac",
              "documentation": {
                "identifier": "fmtFrac",
                "newPage": false,
                "searchKey": "time.fmtFrac",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fmtFrac(buf []byte, v uint64, prec int) (nw int, nv uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fmtFrac(buf []byte, v uint64, prec int) (nw int, nv uint64)\n```\n\nfmtFrac formats the fraction of v/10**prec (e.g., \".12345\") into the tail of buf, omitting trailing zeros. It omits the decimal point too when the fraction is 0. It returns the index where the output bytes begin and the value v/10**prec. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#fmtInt",
              "documentation": {
                "identifier": "fmtInt",
                "newPage": false,
                "searchKey": "time.fmtInt",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func fmtInt(buf []byte, v uint64) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fmtInt(buf []byte, v uint64) int\n```\n\nfmtInt formats v into the tail of buf. It returns the index where the output begins. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#forceZipFileForTesting",
              "documentation": {
                "identifier": "forceZipFileForTesting",
                "newPage": false,
                "searchKey": "time.forceZipFileForTesting",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func forceZipFileForTesting(zipOnly bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc forceZipFileForTesting(zipOnly bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#formatNano",
              "documentation": {
                "identifier": "formatNano",
                "newPage": false,
                "searchKey": "time.formatNano",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func formatNano(b []byte, nanosec uint, n int, trim bool) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc formatNano(b []byte, nanosec uint, n int, trim bool) []byte\n```\n\nformatNano appends a fractional second, as nanoseconds, to b and returns the result. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#get2",
              "documentation": {
                "identifier": "get2",
                "newPage": false,
                "searchKey": "time.get2",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func get2(b []byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc get2(b []byte) int\n```\n\nget2 returns the little-endian 16-bit value in b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#get4",
              "documentation": {
                "identifier": "get4",
                "newPage": false,
                "searchKey": "time.get4",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func get4(b []byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc get4(b []byte) int\n```\n\nget4 returns the little-endian 32-bit value in b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#getnum",
              "documentation": {
                "identifier": "getnum",
                "newPage": false,
                "searchKey": "time.getnum",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func getnum(s string, fixed bool) (int, string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getnum(s string, fixed bool) (int, string, error)\n```\n\ngetnum parses s[0:1] or s[0:2] (fixed forces s[0:2]) as a decimal integer and returns the integer and the remainder of the string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#getnum3",
              "documentation": {
                "identifier": "getnum3",
                "newPage": false,
                "searchKey": "time.getnum3",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func getnum3(s string, fixed bool) (int, string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getnum3(s string, fixed bool) (int, string, error)\n```\n\ngetnum3 parses s[0:1], s[0:2], or s[0:3] (fixed forces s[0:3]) as a decimal integer and returns the integer and the remainder of the string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#goFunc",
              "documentation": {
                "identifier": "goFunc",
                "newPage": false,
                "searchKey": "time.goFunc",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func goFunc(arg interface{}, seq uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goFunc(arg interface{}, seq uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#init.internal_test.go",
              "documentation": {
                "identifier": "init.internal_test.go",
                "newPage": false,
                "searchKey": "time.init",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#initLocal",
              "documentation": {
                "identifier": "initLocal",
                "newPage": false,
                "searchKey": "time.initLocal",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func initLocal()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc initLocal()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#initTestingZone",
              "documentation": {
                "identifier": "initTestingZone",
                "newPage": false,
                "searchKey": "time.initTestingZone",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func initTestingZone()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc initTestingZone()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#interrupt",
              "documentation": {
                "identifier": "interrupt",
                "newPage": false,
                "searchKey": "time.interrupt",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func interrupt()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc interrupt()\n```\n\nfor testing: whatever interrupts a sleep \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#isDigit",
              "documentation": {
                "identifier": "isDigit",
                "newPage": false,
                "searchKey": "time.isDigit",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isDigit(s string, i int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isDigit(s string, i int) bool\n```\n\nisDigit reports whether s[i] is in range and is a decimal digit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#isLeap",
              "documentation": {
                "identifier": "isLeap",
                "newPage": false,
                "searchKey": "time.isLeap",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func isLeap(year int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isLeap(year int) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#leadingFraction",
              "documentation": {
                "identifier": "leadingFraction",
                "newPage": false,
                "searchKey": "time.leadingFraction",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func leadingFraction(s string) (x int64, scale float64, rem string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc leadingFraction(s string) (x int64, scale float64, rem string)\n```\n\nleadingFraction consumes the leading [0-9]* from s. It is used only for fractions, so does not return an error on overflow, it just stops accumulating precision. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#leadingInt",
              "documentation": {
                "identifier": "leadingInt",
                "newPage": false,
                "searchKey": "time.leadingInt",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func leadingInt(s string) (x int64, rem string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc leadingInt(s string) (x int64, rem string, err error)\n```\n\nleadingInt consumes the leading [0-9]* from s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#lessThanHalf",
              "documentation": {
                "identifier": "lessThanHalf",
                "newPage": false,
                "searchKey": "time.lessThanHalf",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func lessThanHalf(x, y Duration) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lessThanHalf(x, y Duration) bool\n```\n\nlessThanHalf reports whether x+x < y but avoids overflow, assuming x and y are both positive (Duration is signed). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#loadTzinfo",
              "documentation": {
                "identifier": "loadTzinfo",
                "newPage": false,
                "searchKey": "time.loadTzinfo",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func loadTzinfo(name string, source string) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc loadTzinfo(name string, source string) ([]byte, error)\n```\n\nloadTzinfo returns the time zone information of the time zone with the given name, from a given source. A source may be a timezone database directory, tzdata database file or an uncompressed zip file, containing the contents of such a directory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#loadTzinfoFromDirOrZip",
              "documentation": {
                "identifier": "loadTzinfoFromDirOrZip",
                "newPage": false,
                "searchKey": "time.loadTzinfoFromDirOrZip",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func loadTzinfoFromDirOrZip(dir, name string) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc loadTzinfoFromDirOrZip(dir, name string) ([]byte, error)\n```\n\nloadTzinfoFromDirOrZip returns the contents of the file with the given name in dir. dir can either be an uncompressed zip file, or a directory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#loadTzinfoFromZip",
              "documentation": {
                "identifier": "loadTzinfoFromZip",
                "newPage": false,
                "searchKey": "time.loadTzinfoFromZip",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func loadTzinfoFromZip(zipfile, name string) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc loadTzinfoFromZip(zipfile, name string) ([]byte, error)\n```\n\nloadTzinfoFromZip returns the contents of the file with the given name in the given uncompressed zip file. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#lookup",
              "documentation": {
                "identifier": "lookup",
                "newPage": false,
                "searchKey": "time.lookup",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func lookup(tab []string, val string) (int, string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lookup(tab []string, val string) (int, string, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#match",
              "documentation": {
                "identifier": "match",
                "newPage": false,
                "searchKey": "time.match",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func match(s1, s2 string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc match(s1, s2 string) bool\n```\n\nmatch reports whether s1 and s2 match ignoring case. It is assumed s1 and s2 are the same length. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#modTimer",
              "documentation": {
                "identifier": "modTimer",
                "newPage": false,
                "searchKey": "time.modTimer",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func modTimer(t *runtimeTimer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc modTimer(t *runtimeTimer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#nextStdChunk",
              "documentation": {
                "identifier": "nextStdChunk",
                "newPage": false,
                "searchKey": "time.nextStdChunk",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func nextStdChunk(layout string) (prefix string, std int, suffix string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nextStdChunk(layout string) (prefix string, std int, suffix string)\n```\n\nnextStdChunk finds the first occurrence of a std string in layout and returns the text before, the std string, and the text after. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#norm",
              "documentation": {
                "identifier": "norm",
                "newPage": false,
                "searchKey": "time.norm",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func norm(hi, lo, base int) (nhi, nlo int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc norm(hi, lo, base int) (nhi, nlo int)\n```\n\nnorm returns nhi, nlo such that \n\n```\nhi * base + lo == nhi * base + nlo\n0 <= nlo < base\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#now",
              "documentation": {
                "identifier": "now",
                "newPage": false,
                "searchKey": "time.now",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func now() (sec int64, nsec int32, mono int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc now() (sec int64, nsec int32, mono int64)\n```\n\nProvided by package runtime. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#open",
              "documentation": {
                "identifier": "open",
                "newPage": false,
                "searchKey": "time.open",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func open(name string) (uintptr, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc open(name string) (uintptr, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#parseGMT",
              "documentation": {
                "identifier": "parseGMT",
                "newPage": false,
                "searchKey": "time.parseGMT",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseGMT(value string) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseGMT(value string) int\n```\n\nparseGMT parses a GMT time zone. The input string is known to start \"GMT\". The function checks whether that is followed by a sign and a number in the range -23 through +23 excluding zero. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#parseNanoseconds",
              "documentation": {
                "identifier": "parseNanoseconds",
                "newPage": false,
                "searchKey": "time.parseNanoseconds",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseNanoseconds(value string, nbytes int) (ns int, rangeErrString string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseNanoseconds(value string, nbytes int) (ns int, rangeErrString string, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#parseSignedOffset",
              "documentation": {
                "identifier": "parseSignedOffset",
                "newPage": false,
                "searchKey": "time.parseSignedOffset",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseSignedOffset(value string) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseSignedOffset(value string) int\n```\n\nparseSignedOffset parses a signed timezone offset (e.g. \"+03\" or \"-04\"). The function checks for a signed number in the range -23 through +23 excluding zero. Returns length of the found offset string or 0 otherwise \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#parseTimeZone",
              "documentation": {
                "identifier": "parseTimeZone",
                "newPage": false,
                "searchKey": "time.parseTimeZone",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseTimeZone(value string) (length int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseTimeZone(value string) (length int, ok bool)\n```\n\nparseTimeZone parses a time zone string and returns its length. Time zones are human-generated and unpredictable. We can't do precise error checking. On the other hand, for a correct parse there must be a time zone at the beginning of the string, so it's almost always true that there's one there. We look at the beginning of the string for a run of upper-case letters. If there are more than 5, it's an error. If there are 4 or 5 and the last is a T, it's a time zone. If there are 3, it's a time zone. Otherwise, other than special cases, it's not a time zone. GMT is special because it can have an hour offset. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#preadn",
              "documentation": {
                "identifier": "preadn",
                "newPage": false,
                "searchKey": "time.preadn",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func preadn(fd uintptr, buf []byte, off int) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc preadn(fd uintptr, buf []byte, off int) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#quote",
              "documentation": {
                "identifier": "quote",
                "newPage": false,
                "searchKey": "time.quote",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func quote(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc quote(s string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#read",
              "documentation": {
                "identifier": "read",
                "newPage": false,
                "searchKey": "time.read",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func read(fd uintptr, buf []byte) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc read(fd uintptr, buf []byte) (int, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#readFile",
              "documentation": {
                "identifier": "readFile",
                "newPage": false,
                "searchKey": "time.readFile",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func readFile(name string) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readFile(name string) ([]byte, error)\n```\n\nreadFile reads and returns the content of the named file. It is a trivial implementation of os.ReadFile, reimplemented here to avoid depending on io/ioutil or os. It returns an error if name exceeds maxFileSize bytes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#registerLoadFromEmbeddedTZData",
              "documentation": {
                "identifier": "registerLoadFromEmbeddedTZData",
                "newPage": false,
                "searchKey": "time.registerLoadFromEmbeddedTZData",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func registerLoadFromEmbeddedTZData(f func(string) (string, error))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc registerLoadFromEmbeddedTZData(f func(string) (string, error))\n```\n\nregisterLoadFromEmbeddedTZData is called by the time/tzdata package, if it is imported. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#resetTimer",
              "documentation": {
                "identifier": "resetTimer",
                "newPage": false,
                "searchKey": "time.resetTimer",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func resetTimer(*runtimeTimer, int64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resetTimer(*runtimeTimer, int64) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#runtimeNano",
              "documentation": {
                "identifier": "runtimeNano",
                "newPage": false,
                "searchKey": "time.runtimeNano",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtimeNano() int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtimeNano() int64\n```\n\nruntimeNano returns the current value of the runtime clock in nanoseconds. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#sendTime",
              "documentation": {
                "identifier": "sendTime",
                "newPage": false,
                "searchKey": "time.sendTime",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func sendTime(c interface{}, seq uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sendTime(c interface{}, seq uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#skip",
              "documentation": {
                "identifier": "skip",
                "newPage": false,
                "searchKey": "time.skip",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func skip(value, prefix string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc skip(value, prefix string) (string, error)\n```\n\nskip removes the given prefix from value, treating runs of space characters as equivalent. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#startTimer",
              "documentation": {
                "identifier": "startTimer",
                "newPage": false,
                "searchKey": "time.startTimer",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func startTimer(*runtimeTimer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc startTimer(*runtimeTimer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#startsWithLowerCase",
              "documentation": {
                "identifier": "startsWithLowerCase",
                "newPage": false,
                "searchKey": "time.startsWithLowerCase",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func startsWithLowerCase(str string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc startsWithLowerCase(str string) bool\n```\n\nstartsWithLowerCase reports whether the string has a lower-case letter at the beginning. Its purpose is to prevent matching strings like \"Month\" when looking for \"Mon\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#stopTimer",
              "documentation": {
                "identifier": "stopTimer",
                "newPage": false,
                "searchKey": "time.stopTimer",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func stopTimer(*runtimeTimer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stopTimer(*runtimeTimer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#tzruleTime",
              "documentation": {
                "identifier": "tzruleTime",
                "newPage": false,
                "searchKey": "time.tzruleTime",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func tzruleTime(year int, r rule, off int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tzruleTime(year int, r rule, off int) int\n```\n\ntzruleTime takes a year, a rule, and a timezone offset, and returns the number of seconds since the start of the year that the rule takes effect. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#tzset",
              "documentation": {
                "identifier": "tzset",
                "newPage": false,
                "searchKey": "time.tzset",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func tzset(s string, initEnd, sec int64) (name string, offset int, start, end int64, isDST, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tzset(s string, initEnd, sec int64) (name string, offset int, start, end int64, isDST, ok bool)\n```\n\ntzset takes a timezone string like the one found in the TZ environment variable, the end of the last time zone transition expressed as seconds since January 1, 1970 00:00:00 UTC, and a time expressed the same way. We call this a tzset string since in C the function tzset reads TZ. The return values are as for lookup, plus ok which reports whether the parse succeeded. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#tzsetName",
              "documentation": {
                "identifier": "tzsetName",
                "newPage": false,
                "searchKey": "time.tzsetName",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func tzsetName(s string) (string, string, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tzsetName(s string) (string, string, bool)\n```\n\ntzsetName returns the timezone name at the start of the tzset string s, and the remainder of s, and reports whether the parsing is OK. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#tzsetNum",
              "documentation": {
                "identifier": "tzsetNum",
                "newPage": false,
                "searchKey": "time.tzsetNum",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func tzsetNum(s string, min, max int) (num int, rest string, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tzsetNum(s string, min, max int) (num int, rest string, ok bool)\n```\n\ntzsetNum parses a number from a tzset string. It returns the number, and the remainder of the string, and reports success. The number must be between min and max. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#tzsetOffset",
              "documentation": {
                "identifier": "tzsetOffset",
                "newPage": false,
                "searchKey": "time.tzsetOffset",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func tzsetOffset(s string) (offset int, rest string, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tzsetOffset(s string) (offset int, rest string, ok bool)\n```\n\ntzsetOffset returns the timezone offset at the start of the tzset string s, and the remainder of s, and reports whether the parsing is OK. The timezone offset is returned as a number of seconds. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/time#when",
              "documentation": {
                "identifier": "when",
                "newPage": false,
                "searchKey": "time.when",
                "tags": [
                  "method",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func when(d Duration) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc when(d Duration) int64\n```\n\nwhen is a helper function for setting the 'when' field of a runtimeTimer. It returns what the time will be, in nanoseconds, Duration d in the future. If d is negative, it is ignored. If the returned value would be less than zero because of an overflow, MaxInt64 is returned. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "pathID": "/time/tzdata"
    }
  ]
}
