# Package multipart

Package multipart implements MIME multipart parsing, as defined in RFC 2046. 

The implementation is sufficient for HTTP (RFC 2388) and the multipart bodies generated by popular browsers. 

## Index

* [Constants](#const)
    * [const peekBufferSize](#peekBufferSize)
    * [const fileaContents](#fileaContents)
    * [const filebContents](#filebContents)
    * [const textaValue](#textaValue)
    * [const textbValue](#textbValue)
    * [const boundary](#boundary)
    * [const messageWithFileWithoutName](#messageWithFileWithoutName)
    * [const messageWithTextContentType](#messageWithTextContentType)
    * [const message](#message)
    * [const maxReadThreshold](#maxReadThreshold)
* [Variables](#var)
    * [var ErrMessageTooLarge](#ErrMessageTooLarge)
    * [var emptyParams](#emptyParams)
    * [var quoteEscaper](#quoteEscaper)
    * [var longLine](#longLine)
    * [var parseTests](#parseTests)
* [Types](#type)
    * [type Form struct](#Form)
        * [func (f *Form) RemoveAll() error](#Form.RemoveAll)
    * [type FileHeader struct](#FileHeader)
        * [func (fh *FileHeader) Open() (File, error)](#FileHeader.Open)
    * [type File interface](#File)
        * [func testFile(t *testing.T, fh *FileHeader, efn, econtent string) File](#testFile)
    * [type sectionReadCloser struct](#sectionReadCloser)
        * [func (rc sectionReadCloser) Close() error](#sectionReadCloser.Close)
    * [type Part struct](#Part)
        * [func newPart(mr *Reader, rawPart bool) (*Part, error)](#newPart)
        * [func (p *Part) FormName() string](#Part.FormName)
        * [func (p *Part) FileName() string](#Part.FileName)
        * [func (p *Part) parseContentDisposition()](#Part.parseContentDisposition)
        * [func (bp *Part) populateHeaders() error](#Part.populateHeaders)
        * [func (p *Part) Read(d []byte) (n int, err error)](#Part.Read)
        * [func (p *Part) Close() error](#Part.Close)
    * [type stickyErrorReader struct](#stickyErrorReader)
        * [func (r *stickyErrorReader) Read(p []byte) (n int, _ error)](#stickyErrorReader.Read)
    * [type partReader struct](#partReader)
        * [func (pr partReader) Read(d []byte) (int, error)](#partReader.Read)
    * [type Reader struct](#Reader)
        * [func NewReader(r io.Reader, boundary string) *Reader](#NewReader)
        * [func (r *Reader) ReadForm(maxMemory int64) (*Form, error)](#Reader.ReadForm)
        * [func (r *Reader) readForm(maxMemory int64) (_ *Form, err error)](#Reader.readForm)
        * [func (r *Reader) NextPart() (*Part, error)](#Reader.NextPart)
        * [func (r *Reader) NextRawPart() (*Part, error)](#Reader.NextRawPart)
        * [func (r *Reader) nextPart(rawPart bool) (*Part, error)](#Reader.nextPart)
        * [func (mr *Reader) isFinalBoundary(line []byte) bool](#Reader.isFinalBoundary)
        * [func (mr *Reader) isBoundaryDelimiterLine(line []byte) (ret bool)](#Reader.isBoundaryDelimiterLine)
    * [type Writer struct](#Writer)
        * [func NewWriter(w io.Writer) *Writer](#NewWriter)
        * [func (w *Writer) Boundary() string](#Writer.Boundary)
        * [func (w *Writer) SetBoundary(boundary string) error](#Writer.SetBoundary)
        * [func (w *Writer) FormDataContentType() string](#Writer.FormDataContentType)
        * [func (w *Writer) CreatePart(header textproto.MIMEHeader) (io.Writer, error)](#Writer.CreatePart)
        * [func (w *Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)](#Writer.CreateFormFile)
        * [func (w *Writer) CreateFormField(fieldname string) (io.Writer, error)](#Writer.CreateFormField)
        * [func (w *Writer) WriteField(fieldname, value string) error](#Writer.WriteField)
        * [func (w *Writer) Close() error](#Writer.Close)
    * [type part struct](#part)
        * [func (p *part) close() error](#part.close)
        * [func (p *part) Write(d []byte) (n int, err error)](#part.Write)
    * [type failOnReadAfterErrorReader struct](#failOnReadAfterErrorReader)
        * [func (r *failOnReadAfterErrorReader) Read(p []byte) (n int, err error)](#failOnReadAfterErrorReader.Read)
    * [type maliciousReader struct](#maliciousReader)
        * [func (mr *maliciousReader) Read(b []byte) (n int, err error)](#maliciousReader.Read)
    * [type slowReader struct](#slowReader)
        * [func (s *slowReader) Read(p []byte) (int, error)](#slowReader.Read)
    * [type sentinelReader struct](#sentinelReader)
        * [func (s *sentinelReader) Read([]byte) (int, error)](#sentinelReader.Read)
    * [type headerBody struct](#headerBody)
        * [func formData(key, value string) headerBody](#formData)
    * [type parseTest struct](#parseTest)
        * [func roundTripParseTest() parseTest](#roundTripParseTest)
* [Functions](#func)
    * [func scanUntilBoundary(buf, dashBoundary, nlDashBoundary []byte, total int64, readErr error) (int, error)](#scanUntilBoundary)
    * [func matchAfterPrefix(buf, prefix []byte, readErr error) int](#matchAfterPrefix)
    * [func skipLWSPChar(b []byte) []byte](#skipLWSPChar)
    * [func randomBoundary() string](#randomBoundary)
    * [func escapeQuotes(s string) string](#escapeQuotes)
    * [func TestReadForm(t *testing.T)](#TestReadForm)
    * [func TestReadFormWithNamelessFile(t *testing.T)](#TestReadFormWithNamelessFile)
    * [func TestReadFormMaxMemoryOverflow(t *testing.T)](#TestReadFormMaxMemoryOverflow)
    * [func TestReadFormWithTextContentType(t *testing.T)](#TestReadFormWithTextContentType)
    * [func TestReadForm_NoReadAfterEOF(t *testing.T)](#TestReadForm_NoReadAfterEOF)
    * [func TestReadForm_NonFileMaxMemory(t *testing.T)](#TestReadForm_NonFileMaxMemory)
    * [func TestBoundaryLine(t *testing.T)](#TestBoundaryLine)
    * [func escapeString(v string) string](#escapeString)
    * [func expectEq(t *testing.T, expected, actual, what string)](#expectEq)
    * [func TestNameAccessors(t *testing.T)](#TestNameAccessors)
    * [func testMultipartBody(sep string) string](#testMultipartBody)
    * [func TestMultipart(t *testing.T)](#TestMultipart)
    * [func TestMultipartOnlyNewlines(t *testing.T)](#TestMultipartOnlyNewlines)
    * [func TestMultipartSlowInput(t *testing.T)](#TestMultipartSlowInput)
    * [func testMultipart(t *testing.T, r io.Reader, onlyNewlines bool)](#testMultipart)
    * [func TestVariousTextLineEndings(t *testing.T)](#TestVariousTextLineEndings)
    * [func TestLineLimit(t *testing.T)](#TestLineLimit)
    * [func TestMultipartTruncated(t *testing.T)](#TestMultipartTruncated)
    * [func TestMultipartStreamReadahead(t *testing.T)](#TestMultipartStreamReadahead)
    * [func TestLineContinuation(t *testing.T)](#TestLineContinuation)
    * [func TestQuotedPrintableEncoding(t *testing.T)](#TestQuotedPrintableEncoding)
    * [func testQuotedPrintableEncoding(t *testing.T, cte string)](#testQuotedPrintableEncoding)
    * [func TestRawPart(t *testing.T)](#TestRawPart)
    * [func TestNested(t *testing.T)](#TestNested)
    * [func TestParse(t *testing.T)](#TestParse)
    * [func partsFromReader(r *Reader) ([]headerBody, error)](#partsFromReader)
    * [func TestParseAllSizes(t *testing.T)](#TestParseAllSizes)
    * [func TestNoBoundary(t *testing.T)](#TestNoBoundary)
    * [func TestWriter(t *testing.T)](#TestWriter)
    * [func TestWriterSetBoundary(t *testing.T)](#TestWriterSetBoundary)
    * [func TestWriterBoundaryGoroutines(t *testing.T)](#TestWriterBoundaryGoroutines)
    * [func TestSortedHeader(t *testing.T)](#TestSortedHeader)


## <a id="const" href="#const">Constants</a>

```
tags: [exported]
```

### <a id="peekBufferSize" href="#peekBufferSize">const peekBufferSize</a>

```
searchKey: multipart.peekBufferSize
```

```Go
const peekBufferSize = 4096
```

This constant needs to be at least 76 for this package to work correctly. This is because \r\n--separator_of_len_70- would fill the buffer and it wouldn't be safe to consume a single byte from it. 

### <a id="fileaContents" href="#fileaContents">const fileaContents</a>

```
searchKey: multipart.fileaContents
```

```Go
const fileaContents = "This is a test file."
```

### <a id="filebContents" href="#filebContents">const filebContents</a>

```
searchKey: multipart.filebContents
```

```Go
const filebContents = "Another test file."
```

### <a id="textaValue" href="#textaValue">const textaValue</a>

```
searchKey: multipart.textaValue
```

```Go
const textaValue = "foo"
```

### <a id="textbValue" href="#textbValue">const textbValue</a>

```
searchKey: multipart.textbValue
```

```Go
const textbValue = "bar"
```

### <a id="boundary" href="#boundary">const boundary</a>

```
searchKey: multipart.boundary
```

```Go
const boundary = `MyBoundary`
```

### <a id="messageWithFileWithoutName" href="#messageWithFileWithoutName">const messageWithFileWithoutName</a>

```
searchKey: multipart.messageWithFileWithoutName
```

```Go
const messageWithFileWithoutName = ...
```

### <a id="messageWithTextContentType" href="#messageWithTextContentType">const messageWithTextContentType</a>

```
searchKey: multipart.messageWithTextContentType
```

```Go
const messageWithTextContentType = ...
```

### <a id="message" href="#message">const message</a>

```
searchKey: multipart.message
```

```Go
const message = ...
```

### <a id="maxReadThreshold" href="#maxReadThreshold">const maxReadThreshold</a>

```
searchKey: multipart.maxReadThreshold
```

```Go
const maxReadThreshold = 1 << 20
```

## <a id="var" href="#var">Variables</a>

```
tags: [exported]
```

### <a id="ErrMessageTooLarge" href="#ErrMessageTooLarge">var ErrMessageTooLarge</a>

```
searchKey: multipart.ErrMessageTooLarge
tags: [exported]
```

```Go
var ErrMessageTooLarge = errors.New("multipart: message too large")
```

ErrMessageTooLarge is returned by ReadForm if the message form data is too large to be processed. 

### <a id="emptyParams" href="#emptyParams">var emptyParams</a>

```
searchKey: multipart.emptyParams
```

```Go
var emptyParams = make(map[string]string)
```

### <a id="quoteEscaper" href="#quoteEscaper">var quoteEscaper</a>

```
searchKey: multipart.quoteEscaper
```

```Go
var quoteEscaper = strings.NewReplacer("\\", "\\\\", `"`, "\\\"")
```

### <a id="longLine" href="#longLine">var longLine</a>

```
searchKey: multipart.longLine
```

```Go
var longLine = strings.Repeat("\n\n\r\r\r\n\r\000", (1<<20)/8)
```

### <a id="parseTests" href="#parseTests">var parseTests</a>

```
searchKey: multipart.parseTests
```

```Go
var parseTests = ...
```

## <a id="type" href="#type">Types</a>

```
tags: [exported]
```

### <a id="Form" href="#Form">type Form struct</a>

```
searchKey: multipart.Form
tags: [exported]
```

```Go
type Form struct {
	Value map[string][]string
	File  map[string][]*FileHeader
}
```

Form is a parsed multipart form. Its File parts are stored either in memory or on disk, and are accessible via the *FileHeader's Open method. Its Value parts are stored as strings. Both are keyed by field name. 

#### <a id="Form.RemoveAll" href="#Form.RemoveAll">func (f *Form) RemoveAll() error</a>

```
searchKey: multipart.Form.RemoveAll
tags: [exported]
```

```Go
func (f *Form) RemoveAll() error
```

RemoveAll removes any temporary files associated with a Form. 

### <a id="FileHeader" href="#FileHeader">type FileHeader struct</a>

```
searchKey: multipart.FileHeader
tags: [exported]
```

```Go
type FileHeader struct {
	Filename string
	Header   textproto.MIMEHeader
	Size     int64

	content []byte
	tmpfile string
}
```

A FileHeader describes a file part of a multipart request. 

#### <a id="FileHeader.Open" href="#FileHeader.Open">func (fh *FileHeader) Open() (File, error)</a>

```
searchKey: multipart.FileHeader.Open
tags: [exported]
```

```Go
func (fh *FileHeader) Open() (File, error)
```

Open opens and returns the FileHeader's associated File. 

### <a id="File" href="#File">type File interface</a>

```
searchKey: multipart.File
tags: [exported]
```

```Go
type File interface {
	io.Reader
	io.ReaderAt
	io.Seeker
	io.Closer
}
```

File is an interface to access the file part of a multipart message. Its contents may be either stored in memory or on disk. If stored on disk, the File's underlying concrete type will be an *os.File. 

#### <a id="testFile" href="#testFile">func testFile(t *testing.T, fh *FileHeader, efn, econtent string) File</a>

```
searchKey: multipart.testFile
```

```Go
func testFile(t *testing.T, fh *FileHeader, efn, econtent string) File
```

### <a id="sectionReadCloser" href="#sectionReadCloser">type sectionReadCloser struct</a>

```
searchKey: multipart.sectionReadCloser
```

```Go
type sectionReadCloser struct {
	*io.SectionReader
}
```

#### <a id="sectionReadCloser.Close" href="#sectionReadCloser.Close">func (rc sectionReadCloser) Close() error</a>

```
searchKey: multipart.sectionReadCloser.Close
```

```Go
func (rc sectionReadCloser) Close() error
```

### <a id="Part" href="#Part">type Part struct</a>

```
searchKey: multipart.Part
tags: [exported]
```

```Go
type Part struct {
	// The headers of the body, if any, with the keys canonicalized
	// in the same fashion that the Go http.Request headers are.
	// For example, "foo-bar" changes case to "Foo-Bar"
	Header textproto.MIMEHeader

	mr *Reader

	disposition       string
	dispositionParams map[string]string

	// r is either a reader directly reading from mr, or it's a
	// wrapper around such a reader, decoding the
	// Content-Transfer-Encoding
	r io.Reader

	n       int   // known data bytes waiting in mr.bufReader
	total   int64 // total data bytes read already
	err     error // error to return when n == 0
	readErr error // read error observed from mr.bufReader
}
```

A Part represents a single part in a multipart body. 

#### <a id="newPart" href="#newPart">func newPart(mr *Reader, rawPart bool) (*Part, error)</a>

```
searchKey: multipart.newPart
```

```Go
func newPart(mr *Reader, rawPart bool) (*Part, error)
```

#### <a id="Part.FormName" href="#Part.FormName">func (p *Part) FormName() string</a>

```
searchKey: multipart.Part.FormName
tags: [exported]
```

```Go
func (p *Part) FormName() string
```

FormName returns the name parameter if p has a Content-Disposition of type "form-data".  Otherwise it returns the empty string. 

#### <a id="Part.FileName" href="#Part.FileName">func (p *Part) FileName() string</a>

```
searchKey: multipart.Part.FileName
tags: [exported]
```

```Go
func (p *Part) FileName() string
```

FileName returns the filename parameter of the Part's Content-Disposition header. If not empty, the filename is passed through filepath.Base (which is platform dependent) before being returned. 

#### <a id="Part.parseContentDisposition" href="#Part.parseContentDisposition">func (p *Part) parseContentDisposition()</a>

```
searchKey: multipart.Part.parseContentDisposition
```

```Go
func (p *Part) parseContentDisposition()
```

#### <a id="Part.populateHeaders" href="#Part.populateHeaders">func (bp *Part) populateHeaders() error</a>

```
searchKey: multipart.Part.populateHeaders
```

```Go
func (bp *Part) populateHeaders() error
```

#### <a id="Part.Read" href="#Part.Read">func (p *Part) Read(d []byte) (n int, err error)</a>

```
searchKey: multipart.Part.Read
tags: [exported]
```

```Go
func (p *Part) Read(d []byte) (n int, err error)
```

Read reads the body of a part, after its headers and before the next part (if any) begins. 

#### <a id="Part.Close" href="#Part.Close">func (p *Part) Close() error</a>

```
searchKey: multipart.Part.Close
tags: [exported]
```

```Go
func (p *Part) Close() error
```

### <a id="stickyErrorReader" href="#stickyErrorReader">type stickyErrorReader struct</a>

```
searchKey: multipart.stickyErrorReader
```

```Go
type stickyErrorReader struct {
	r   io.Reader
	err error
}
```

stickyErrorReader is an io.Reader which never calls Read on its underlying Reader once an error has been seen. (the io.Reader interface's contract promises nothing about the return values of Read calls after an error, yet this package does do multiple Reads after error) 

#### <a id="stickyErrorReader.Read" href="#stickyErrorReader.Read">func (r *stickyErrorReader) Read(p []byte) (n int, _ error)</a>

```
searchKey: multipart.stickyErrorReader.Read
```

```Go
func (r *stickyErrorReader) Read(p []byte) (n int, _ error)
```

### <a id="partReader" href="#partReader">type partReader struct</a>

```
searchKey: multipart.partReader
```

```Go
type partReader struct {
	p *Part
}
```

partReader implements io.Reader by reading raw bytes directly from the wrapped *Part, without doing any Transfer-Encoding decoding. 

#### <a id="partReader.Read" href="#partReader.Read">func (pr partReader) Read(d []byte) (int, error)</a>

```
searchKey: multipart.partReader.Read
```

```Go
func (pr partReader) Read(d []byte) (int, error)
```

### <a id="Reader" href="#Reader">type Reader struct</a>

```
searchKey: multipart.Reader
tags: [exported]
```

```Go
type Reader struct {
	bufReader *bufio.Reader

	currentPart *Part
	partsRead   int

	nl               []byte // "\r\n" or "\n" (set after seeing first boundary line)
	nlDashBoundary   []byte // nl + "--boundary"
	dashBoundaryDash []byte // "--boundary--"
	dashBoundary     []byte // "--boundary"
}
```

Reader is an iterator over parts in a MIME multipart body. Reader's underlying parser consumes its input as needed. Seeking isn't supported. 

#### <a id="NewReader" href="#NewReader">func NewReader(r io.Reader, boundary string) *Reader</a>

```
searchKey: multipart.NewReader
tags: [exported]
```

```Go
func NewReader(r io.Reader, boundary string) *Reader
```

NewReader creates a new multipart Reader reading from r using the given MIME boundary. 

The boundary is usually obtained from the "boundary" parameter of the message's "Content-Type" header. Use mime.ParseMediaType to parse such headers. 

#### <a id="Reader.ReadForm" href="#Reader.ReadForm">func (r *Reader) ReadForm(maxMemory int64) (*Form, error)</a>

```
searchKey: multipart.Reader.ReadForm
tags: [exported]
```

```Go
func (r *Reader) ReadForm(maxMemory int64) (*Form, error)
```

ReadForm parses an entire multipart message whose parts have a Content-Disposition of "form-data". It stores up to maxMemory bytes + 10MB (reserved for non-file parts) in memory. File parts which can't be stored in memory will be stored on disk in temporary files. It returns ErrMessageTooLarge if all non-file parts can't be stored in memory. 

#### <a id="Reader.readForm" href="#Reader.readForm">func (r *Reader) readForm(maxMemory int64) (_ *Form, err error)</a>

```
searchKey: multipart.Reader.readForm
```

```Go
func (r *Reader) readForm(maxMemory int64) (_ *Form, err error)
```

#### <a id="Reader.NextPart" href="#Reader.NextPart">func (r *Reader) NextPart() (*Part, error)</a>

```
searchKey: multipart.Reader.NextPart
tags: [exported]
```

```Go
func (r *Reader) NextPart() (*Part, error)
```

NextPart returns the next part in the multipart or an error. When there are no more parts, the error io.EOF is returned. 

As a special case, if the "Content-Transfer-Encoding" header has a value of "quoted-printable", that header is instead hidden and the body is transparently decoded during Read calls. 

#### <a id="Reader.NextRawPart" href="#Reader.NextRawPart">func (r *Reader) NextRawPart() (*Part, error)</a>

```
searchKey: multipart.Reader.NextRawPart
tags: [exported]
```

```Go
func (r *Reader) NextRawPart() (*Part, error)
```

NextRawPart returns the next part in the multipart or an error. When there are no more parts, the error io.EOF is returned. 

Unlike NextPart, it does not have special handling for "Content-Transfer-Encoding: quoted-printable". 

#### <a id="Reader.nextPart" href="#Reader.nextPart">func (r *Reader) nextPart(rawPart bool) (*Part, error)</a>

```
searchKey: multipart.Reader.nextPart
```

```Go
func (r *Reader) nextPart(rawPart bool) (*Part, error)
```

#### <a id="Reader.isFinalBoundary" href="#Reader.isFinalBoundary">func (mr *Reader) isFinalBoundary(line []byte) bool</a>

```
searchKey: multipart.Reader.isFinalBoundary
```

```Go
func (mr *Reader) isFinalBoundary(line []byte) bool
```

isFinalBoundary reports whether line is the final boundary line indicating that all parts are over. It matches `^--boundary--[ \t]*(\r\n)?$` 

#### <a id="Reader.isBoundaryDelimiterLine" href="#Reader.isBoundaryDelimiterLine">func (mr *Reader) isBoundaryDelimiterLine(line []byte) (ret bool)</a>

```
searchKey: multipart.Reader.isBoundaryDelimiterLine
```

```Go
func (mr *Reader) isBoundaryDelimiterLine(line []byte) (ret bool)
```

### <a id="Writer" href="#Writer">type Writer struct</a>

```
searchKey: multipart.Writer
tags: [exported]
```

```Go
type Writer struct {
	w        io.Writer
	boundary string
	lastpart *part
}
```

A Writer generates multipart messages. 

#### <a id="NewWriter" href="#NewWriter">func NewWriter(w io.Writer) *Writer</a>

```
searchKey: multipart.NewWriter
tags: [exported]
```

```Go
func NewWriter(w io.Writer) *Writer
```

NewWriter returns a new multipart Writer with a random boundary, writing to w. 

#### <a id="Writer.Boundary" href="#Writer.Boundary">func (w *Writer) Boundary() string</a>

```
searchKey: multipart.Writer.Boundary
tags: [exported]
```

```Go
func (w *Writer) Boundary() string
```

Boundary returns the Writer's boundary. 

#### <a id="Writer.SetBoundary" href="#Writer.SetBoundary">func (w *Writer) SetBoundary(boundary string) error</a>

```
searchKey: multipart.Writer.SetBoundary
tags: [exported]
```

```Go
func (w *Writer) SetBoundary(boundary string) error
```

SetBoundary overrides the Writer's default randomly-generated boundary separator with an explicit value. 

SetBoundary must be called before any parts are created, may only contain certain ASCII characters, and must be non-empty and at most 70 bytes long. 

#### <a id="Writer.FormDataContentType" href="#Writer.FormDataContentType">func (w *Writer) FormDataContentType() string</a>

```
searchKey: multipart.Writer.FormDataContentType
tags: [exported]
```

```Go
func (w *Writer) FormDataContentType() string
```

FormDataContentType returns the Content-Type for an HTTP multipart/form-data with this Writer's Boundary. 

#### <a id="Writer.CreatePart" href="#Writer.CreatePart">func (w *Writer) CreatePart(header textproto.MIMEHeader) (io.Writer, error)</a>

```
searchKey: multipart.Writer.CreatePart
tags: [exported]
```

```Go
func (w *Writer) CreatePart(header textproto.MIMEHeader) (io.Writer, error)
```

CreatePart creates a new multipart section with the provided header. The body of the part should be written to the returned Writer. After calling CreatePart, any previous part may no longer be written to. 

#### <a id="Writer.CreateFormFile" href="#Writer.CreateFormFile">func (w *Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)</a>

```
searchKey: multipart.Writer.CreateFormFile
tags: [exported]
```

```Go
func (w *Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)
```

CreateFormFile is a convenience wrapper around CreatePart. It creates a new form-data header with the provided field name and file name. 

#### <a id="Writer.CreateFormField" href="#Writer.CreateFormField">func (w *Writer) CreateFormField(fieldname string) (io.Writer, error)</a>

```
searchKey: multipart.Writer.CreateFormField
tags: [exported]
```

```Go
func (w *Writer) CreateFormField(fieldname string) (io.Writer, error)
```

CreateFormField calls CreatePart with a header using the given field name. 

#### <a id="Writer.WriteField" href="#Writer.WriteField">func (w *Writer) WriteField(fieldname, value string) error</a>

```
searchKey: multipart.Writer.WriteField
tags: [exported]
```

```Go
func (w *Writer) WriteField(fieldname, value string) error
```

WriteField calls CreateFormField and then writes the given value. 

#### <a id="Writer.Close" href="#Writer.Close">func (w *Writer) Close() error</a>

```
searchKey: multipart.Writer.Close
tags: [exported]
```

```Go
func (w *Writer) Close() error
```

Close finishes the multipart message and writes the trailing boundary end line to the output. 

### <a id="part" href="#part">type part struct</a>

```
searchKey: multipart.part
```

```Go
type part struct {
	mw     *Writer
	closed bool
	we     error // last error that occurred writing
}
```

#### <a id="part.close" href="#part.close">func (p *part) close() error</a>

```
searchKey: multipart.part.close
```

```Go
func (p *part) close() error
```

#### <a id="part.Write" href="#part.Write">func (p *part) Write(d []byte) (n int, err error)</a>

```
searchKey: multipart.part.Write
```

```Go
func (p *part) Write(d []byte) (n int, err error)
```

### <a id="failOnReadAfterErrorReader" href="#failOnReadAfterErrorReader">type failOnReadAfterErrorReader struct</a>

```
searchKey: multipart.failOnReadAfterErrorReader
```

```Go
type failOnReadAfterErrorReader struct {
	t      *testing.T
	r      io.Reader
	sawErr error
}
```

failOnReadAfterErrorReader is an io.Reader wrapping r. It fails t if any Read is called after a failing Read. 

#### <a id="failOnReadAfterErrorReader.Read" href="#failOnReadAfterErrorReader.Read">func (r *failOnReadAfterErrorReader) Read(p []byte) (n int, err error)</a>

```
searchKey: multipart.failOnReadAfterErrorReader.Read
```

```Go
func (r *failOnReadAfterErrorReader) Read(p []byte) (n int, err error)
```

### <a id="maliciousReader" href="#maliciousReader">type maliciousReader struct</a>

```
searchKey: multipart.maliciousReader
```

```Go
type maliciousReader struct {
	t *testing.T
	n int
}
```

#### <a id="maliciousReader.Read" href="#maliciousReader.Read">func (mr *maliciousReader) Read(b []byte) (n int, err error)</a>

```
searchKey: multipart.maliciousReader.Read
```

```Go
func (mr *maliciousReader) Read(b []byte) (n int, err error)
```

### <a id="slowReader" href="#slowReader">type slowReader struct</a>

```
searchKey: multipart.slowReader
```

```Go
type slowReader struct {
	r io.Reader
}
```

#### <a id="slowReader.Read" href="#slowReader.Read">func (s *slowReader) Read(p []byte) (int, error)</a>

```
searchKey: multipart.slowReader.Read
```

```Go
func (s *slowReader) Read(p []byte) (int, error)
```

### <a id="sentinelReader" href="#sentinelReader">type sentinelReader struct</a>

```
searchKey: multipart.sentinelReader
```

```Go
type sentinelReader struct {
	// done is closed when this reader is read from.
	done chan struct{}
}
```

#### <a id="sentinelReader.Read" href="#sentinelReader.Read">func (s *sentinelReader) Read([]byte) (int, error)</a>

```
searchKey: multipart.sentinelReader.Read
```

```Go
func (s *sentinelReader) Read([]byte) (int, error)
```

### <a id="headerBody" href="#headerBody">type headerBody struct</a>

```
searchKey: multipart.headerBody
```

```Go
type headerBody struct {
	header textproto.MIMEHeader
	body   string
}
```

#### <a id="formData" href="#formData">func formData(key, value string) headerBody</a>

```
searchKey: multipart.formData
```

```Go
func formData(key, value string) headerBody
```

### <a id="parseTest" href="#parseTest">type parseTest struct</a>

```
searchKey: multipart.parseTest
```

```Go
type parseTest struct {
	name    string
	in, sep string
	want    []headerBody
}
```

#### <a id="roundTripParseTest" href="#roundTripParseTest">func roundTripParseTest() parseTest</a>

```
searchKey: multipart.roundTripParseTest
```

```Go
func roundTripParseTest() parseTest
```

## <a id="func" href="#func">Functions</a>

```
tags: [exported]
```

### <a id="scanUntilBoundary" href="#scanUntilBoundary">func scanUntilBoundary(buf, dashBoundary, nlDashBoundary []byte, total int64, readErr error) (int, error)</a>

```
searchKey: multipart.scanUntilBoundary
```

```Go
func scanUntilBoundary(buf, dashBoundary, nlDashBoundary []byte, total int64, readErr error) (int, error)
```

scanUntilBoundary scans buf to identify how much of it can be safely returned as part of the Part body. dashBoundary is "--boundary". nlDashBoundary is "\r\n--boundary" or "\n--boundary", depending on what mode we are in. The comments below (and the name) assume "\n--boundary", but either is accepted. total is the number of bytes read out so far. If total == 0, then a leading "--boundary" is recognized. readErr is the read error, if any, that followed reading the bytes in buf. scanUntilBoundary returns the number of data bytes from buf that can be returned as part of the Part body and also the error to return (if any) once those data bytes are done. 

### <a id="matchAfterPrefix" href="#matchAfterPrefix">func matchAfterPrefix(buf, prefix []byte, readErr error) int</a>

```
searchKey: multipart.matchAfterPrefix
```

```Go
func matchAfterPrefix(buf, prefix []byte, readErr error) int
```

matchAfterPrefix checks whether buf should be considered to match the boundary. The prefix is "--boundary" or "\r\n--boundary" or "\n--boundary", and the caller has verified already that bytes.HasPrefix(buf, prefix) is true. 

matchAfterPrefix returns +1 if the buffer does match the boundary, meaning the prefix is followed by a dash, space, tab, cr, nl, or end of input. It returns -1 if the buffer definitely does NOT match the boundary, meaning the prefix is followed by some other character. For example, "--foobar" does not match "--foo". It returns 0 more input needs to be read to make the decision, meaning that len(buf) == len(prefix) and readErr == nil. 

### <a id="skipLWSPChar" href="#skipLWSPChar">func skipLWSPChar(b []byte) []byte</a>

```
searchKey: multipart.skipLWSPChar
```

```Go
func skipLWSPChar(b []byte) []byte
```

skipLWSPChar returns b with leading spaces and tabs removed. RFC 822 defines: 

```
LWSP-char = SPACE / HTAB

```
### <a id="randomBoundary" href="#randomBoundary">func randomBoundary() string</a>

```
searchKey: multipart.randomBoundary
```

```Go
func randomBoundary() string
```

### <a id="escapeQuotes" href="#escapeQuotes">func escapeQuotes(s string) string</a>

```
searchKey: multipart.escapeQuotes
```

```Go
func escapeQuotes(s string) string
```

### <a id="TestReadForm" href="#TestReadForm">func TestReadForm(t *testing.T)</a>

```
searchKey: multipart.TestReadForm
```

```Go
func TestReadForm(t *testing.T)
```

### <a id="TestReadFormWithNamelessFile" href="#TestReadFormWithNamelessFile">func TestReadFormWithNamelessFile(t *testing.T)</a>

```
searchKey: multipart.TestReadFormWithNamelessFile
```

```Go
func TestReadFormWithNamelessFile(t *testing.T)
```

### <a id="TestReadFormMaxMemoryOverflow" href="#TestReadFormMaxMemoryOverflow">func TestReadFormMaxMemoryOverflow(t *testing.T)</a>

```
searchKey: multipart.TestReadFormMaxMemoryOverflow
```

```Go
func TestReadFormMaxMemoryOverflow(t *testing.T)
```

Issue 40430: Handle ReadForm(math.MaxInt64) 

### <a id="TestReadFormWithTextContentType" href="#TestReadFormWithTextContentType">func TestReadFormWithTextContentType(t *testing.T)</a>

```
searchKey: multipart.TestReadFormWithTextContentType
```

```Go
func TestReadFormWithTextContentType(t *testing.T)
```

### <a id="TestReadForm_NoReadAfterEOF" href="#TestReadForm_NoReadAfterEOF">func TestReadForm_NoReadAfterEOF(t *testing.T)</a>

```
searchKey: multipart.TestReadForm_NoReadAfterEOF
```

```Go
func TestReadForm_NoReadAfterEOF(t *testing.T)
```

### <a id="TestReadForm_NonFileMaxMemory" href="#TestReadForm_NonFileMaxMemory">func TestReadForm_NonFileMaxMemory(t *testing.T)</a>

```
searchKey: multipart.TestReadForm_NonFileMaxMemory
```

```Go
func TestReadForm_NonFileMaxMemory(t *testing.T)
```

TestReadForm_NonFileMaxMemory asserts that the ReadForm maxMemory limit is applied while processing non-file form data as well as file form data. 

### <a id="TestBoundaryLine" href="#TestBoundaryLine">func TestBoundaryLine(t *testing.T)</a>

```
searchKey: multipart.TestBoundaryLine
```

```Go
func TestBoundaryLine(t *testing.T)
```

### <a id="escapeString" href="#escapeString">func escapeString(v string) string</a>

```
searchKey: multipart.escapeString
```

```Go
func escapeString(v string) string
```

### <a id="expectEq" href="#expectEq">func expectEq(t *testing.T, expected, actual, what string)</a>

```
searchKey: multipart.expectEq
```

```Go
func expectEq(t *testing.T, expected, actual, what string)
```

### <a id="TestNameAccessors" href="#TestNameAccessors">func TestNameAccessors(t *testing.T)</a>

```
searchKey: multipart.TestNameAccessors
```

```Go
func TestNameAccessors(t *testing.T)
```

### <a id="testMultipartBody" href="#testMultipartBody">func testMultipartBody(sep string) string</a>

```
searchKey: multipart.testMultipartBody
```

```Go
func testMultipartBody(sep string) string
```

### <a id="TestMultipart" href="#TestMultipart">func TestMultipart(t *testing.T)</a>

```
searchKey: multipart.TestMultipart
```

```Go
func TestMultipart(t *testing.T)
```

### <a id="TestMultipartOnlyNewlines" href="#TestMultipartOnlyNewlines">func TestMultipartOnlyNewlines(t *testing.T)</a>

```
searchKey: multipart.TestMultipartOnlyNewlines
```

```Go
func TestMultipartOnlyNewlines(t *testing.T)
```

### <a id="TestMultipartSlowInput" href="#TestMultipartSlowInput">func TestMultipartSlowInput(t *testing.T)</a>

```
searchKey: multipart.TestMultipartSlowInput
```

```Go
func TestMultipartSlowInput(t *testing.T)
```

### <a id="testMultipart" href="#testMultipart">func testMultipart(t *testing.T, r io.Reader, onlyNewlines bool)</a>

```
searchKey: multipart.testMultipart
```

```Go
func testMultipart(t *testing.T, r io.Reader, onlyNewlines bool)
```

### <a id="TestVariousTextLineEndings" href="#TestVariousTextLineEndings">func TestVariousTextLineEndings(t *testing.T)</a>

```
searchKey: multipart.TestVariousTextLineEndings
```

```Go
func TestVariousTextLineEndings(t *testing.T)
```

### <a id="TestLineLimit" href="#TestLineLimit">func TestLineLimit(t *testing.T)</a>

```
searchKey: multipart.TestLineLimit
```

```Go
func TestLineLimit(t *testing.T)
```

### <a id="TestMultipartTruncated" href="#TestMultipartTruncated">func TestMultipartTruncated(t *testing.T)</a>

```
searchKey: multipart.TestMultipartTruncated
```

```Go
func TestMultipartTruncated(t *testing.T)
```

### <a id="TestMultipartStreamReadahead" href="#TestMultipartStreamReadahead">func TestMultipartStreamReadahead(t *testing.T)</a>

```
searchKey: multipart.TestMultipartStreamReadahead
```

```Go
func TestMultipartStreamReadahead(t *testing.T)
```

TestMultipartStreamReadahead tests that PartReader does not block on reading past the end of a part, ensuring that it can be used on a stream like multipart/x-mixed-replace. See golang.org/issue/15431 

### <a id="TestLineContinuation" href="#TestLineContinuation">func TestLineContinuation(t *testing.T)</a>

```
searchKey: multipart.TestLineContinuation
```

```Go
func TestLineContinuation(t *testing.T)
```

### <a id="TestQuotedPrintableEncoding" href="#TestQuotedPrintableEncoding">func TestQuotedPrintableEncoding(t *testing.T)</a>

```
searchKey: multipart.TestQuotedPrintableEncoding
```

```Go
func TestQuotedPrintableEncoding(t *testing.T)
```

### <a id="testQuotedPrintableEncoding" href="#testQuotedPrintableEncoding">func testQuotedPrintableEncoding(t *testing.T, cte string)</a>

```
searchKey: multipart.testQuotedPrintableEncoding
```

```Go
func testQuotedPrintableEncoding(t *testing.T, cte string)
```

### <a id="TestRawPart" href="#TestRawPart">func TestRawPart(t *testing.T)</a>

```
searchKey: multipart.TestRawPart
```

```Go
func TestRawPart(t *testing.T)
```

### <a id="TestNested" href="#TestNested">func TestNested(t *testing.T)</a>

```
searchKey: multipart.TestNested
```

```Go
func TestNested(t *testing.T)
```

Test parsing an image attachment from gmail, which previously failed. 

### <a id="TestParse" href="#TestParse">func TestParse(t *testing.T)</a>

```
searchKey: multipart.TestParse
```

```Go
func TestParse(t *testing.T)
```

### <a id="partsFromReader" href="#partsFromReader">func partsFromReader(r *Reader) ([]headerBody, error)</a>

```
searchKey: multipart.partsFromReader
```

```Go
func partsFromReader(r *Reader) ([]headerBody, error)
```

### <a id="TestParseAllSizes" href="#TestParseAllSizes">func TestParseAllSizes(t *testing.T)</a>

```
searchKey: multipart.TestParseAllSizes
```

```Go
func TestParseAllSizes(t *testing.T)
```

### <a id="TestNoBoundary" href="#TestNoBoundary">func TestNoBoundary(t *testing.T)</a>

```
searchKey: multipart.TestNoBoundary
```

```Go
func TestNoBoundary(t *testing.T)
```

### <a id="TestWriter" href="#TestWriter">func TestWriter(t *testing.T)</a>

```
searchKey: multipart.TestWriter
```

```Go
func TestWriter(t *testing.T)
```

### <a id="TestWriterSetBoundary" href="#TestWriterSetBoundary">func TestWriterSetBoundary(t *testing.T)</a>

```
searchKey: multipart.TestWriterSetBoundary
```

```Go
func TestWriterSetBoundary(t *testing.T)
```

### <a id="TestWriterBoundaryGoroutines" href="#TestWriterBoundaryGoroutines">func TestWriterBoundaryGoroutines(t *testing.T)</a>

```
searchKey: multipart.TestWriterBoundaryGoroutines
```

```Go
func TestWriterBoundaryGoroutines(t *testing.T)
```

### <a id="TestSortedHeader" href="#TestSortedHeader">func TestSortedHeader(t *testing.T)</a>

```
searchKey: multipart.TestSortedHeader
```

```Go
func TestSortedHeader(t *testing.T)
```

