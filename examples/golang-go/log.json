{
  "pathID": "/log",
  "documentation": {
    "identifier": "log",
    "newPage": true,
    "searchKey": "log",
    "tags": [
      "package"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package log"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package log implements a simple logging package. It defines a type, Logger, with methods for formatting output. It also has a predefined 'standard' Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and Panic[f|ln], which are easier to use than creating a Logger manually. That logger writes to standard error and prints the date and time of each logged message. Every log message is output on a separate line: if the message being printed does not end in a newline, the logger will add one. The Fatal functions call os.Exit(1) after writing the log message. The Panic functions call panic after writing the log message. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/log#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/log#LUTC",
              "documentation": {
                "identifier": "LUTC",
                "newPage": false,
                "searchKey": "log.LUTC",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const LUTC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst LUTC // if Ldate or Ltime is set, use UTC rather than the local time zone\n\n```\n\nThese flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, \n\n```\n2009/01/23 01:23:23 message\n\n```\nwhile flags Ldate | Ltime | Lmicroseconds | Llongfile produce, \n\n```\n2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Ldate",
              "documentation": {
                "identifier": "Ldate",
                "newPage": false,
                "searchKey": "log.Ldate",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Ldate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Ldate = 1 << iota // the date in the local time zone: 2009/01/23\n\n```\n\nThese flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, \n\n```\n2009/01/23 01:23:23 message\n\n```\nwhile flags Ldate | Ltime | Lmicroseconds | Llongfile produce, \n\n```\n2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Llongfile",
              "documentation": {
                "identifier": "Llongfile",
                "newPage": false,
                "searchKey": "log.Llongfile",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Llongfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Llongfile // full file name and line number: /a/b/c/d.go:23\n\n```\n\nThese flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, \n\n```\n2009/01/23 01:23:23 message\n\n```\nwhile flags Ldate | Ltime | Lmicroseconds | Llongfile produce, \n\n```\n2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Lmicroseconds",
              "documentation": {
                "identifier": "Lmicroseconds",
                "newPage": false,
                "searchKey": "log.Lmicroseconds",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Lmicroseconds"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Lmicroseconds // microsecond resolution: 01:23:23.123123.  assumes Ltime.\n\n```\n\nThese flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, \n\n```\n2009/01/23 01:23:23 message\n\n```\nwhile flags Ldate | Ltime | Lmicroseconds | Llongfile produce, \n\n```\n2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Lmsgprefix",
              "documentation": {
                "identifier": "Lmsgprefix",
                "newPage": false,
                "searchKey": "log.Lmsgprefix",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Lmsgprefix"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Lmsgprefix // move the \"prefix\" from the beginning of the line to before the message\n\n```\n\nThese flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, \n\n```\n2009/01/23 01:23:23 message\n\n```\nwhile flags Ldate | Ltime | Lmicroseconds | Llongfile produce, \n\n```\n2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Lshortfile",
              "documentation": {
                "identifier": "Lshortfile",
                "newPage": false,
                "searchKey": "log.Lshortfile",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Lshortfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Lshortfile // final file name element and line number: d.go:23. overrides Llongfile\n\n```\n\nThese flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, \n\n```\n2009/01/23 01:23:23 message\n\n```\nwhile flags Ldate | Ltime | Lmicroseconds | Llongfile produce, \n\n```\n2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#LstdFlags",
              "documentation": {
                "identifier": "LstdFlags",
                "newPage": false,
                "searchKey": "log.LstdFlags",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const LstdFlags"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst LstdFlags = Ldate | Ltime // initial values for the standard logger\n\n```\n\nThese flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, \n\n```\n2009/01/23 01:23:23 message\n\n```\nwhile flags Ldate | Ltime | Lmicroseconds | Llongfile produce, \n\n```\n2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Ltime",
              "documentation": {
                "identifier": "Ltime",
                "newPage": false,
                "searchKey": "log.Ltime",
                "tags": [
                  "constant",
                  "number"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Ltime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Ltime // the time in the local time zone: 01:23:23\n\n```\n\nThese flags define which text to prefix to each log entry generated by the Logger. Bits are or'ed together to control what's printed. With the exception of the Lmsgprefix flag, there is no control over the order they appear (the order listed here) or the format they present (as described in the comments). The prefix is followed by a colon only when Llongfile or Lshortfile is specified. For example, flags Ldate | Ltime (or LstdFlags) produce, \n\n```\n2009/01/23 01:23:23 message\n\n```\nwhile flags Ldate | Ltime | Lmicroseconds | Llongfile produce, \n\n```\n2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Rdate",
              "documentation": {
                "identifier": "Rdate",
                "newPage": false,
                "searchKey": "log.Rdate",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Rdate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Rdate = `[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9]`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Rline",
              "documentation": {
                "identifier": "Rline",
                "newPage": false,
                "searchKey": "log.Rline",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Rline"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Rline = `(60|62):` // must update if the calls to l.Printf / l.Print below move\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Rlongfile",
              "documentation": {
                "identifier": "Rlongfile",
                "newPage": false,
                "searchKey": "log.Rlongfile",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Rlongfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Rlongfile = `.*/[A-Za-z0-9_\\-]+\\.go:` + Rline\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Rmicroseconds",
              "documentation": {
                "identifier": "Rmicroseconds",
                "newPage": false,
                "searchKey": "log.Rmicroseconds",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Rmicroseconds"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Rmicroseconds = `\\.[0-9][0-9][0-9][0-9][0-9][0-9]`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Rshortfile",
              "documentation": {
                "identifier": "Rshortfile",
                "newPage": false,
                "searchKey": "log.Rshortfile",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Rshortfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Rshortfile = `[A-Za-z0-9_\\-]+\\.go:` + Rline\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Rtime",
              "documentation": {
                "identifier": "Rtime",
                "newPage": false,
                "searchKey": "log.Rtime",
                "tags": [
                  "constant",
                  "string",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Rtime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Rtime = `[0-9][0-9]:[0-9][0-9]:[0-9][0-9]`\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/log#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/log#std",
              "documentation": {
                "identifier": "std",
                "newPage": false,
                "searchKey": "log.std",
                "tags": [
                  "variable",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var std"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar std = New(os.Stderr, \"\", LstdFlags)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#tests",
              "documentation": {
                "identifier": "tests",
                "newPage": false,
                "searchKey": "log.tests",
                "tags": [
                  "variable",
                  "array",
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var tests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tests = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/log#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/log#Logger",
              "documentation": {
                "identifier": "Logger",
                "newPage": false,
                "searchKey": "log.Logger",
                "tags": [
                  "struct"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Logger struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Logger struct {\n\tmu     sync.Mutex // ensures atomic writes; protects the following fields\n\tprefix string     // prefix on each line to identify the logger (but see Lmsgprefix)\n\tflag   int        // properties\n\tout    io.Writer  // destination for output\n\tbuf    []byte     // for accumulating text to write\n}\n```\n\nA Logger represents an active logging object that generates lines of output to an io.Writer. Each logging operation makes a single call to the Writer's Write method. A Logger can be used simultaneously from multiple goroutines; it guarantees to serialize access to the Writer. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/log#Default",
                    "documentation": {
                      "identifier": "Default",
                      "newPage": false,
                      "searchKey": "log.Default",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Default() *Logger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Default() *Logger\n```\n\nDefault returns the standard logger used by the package-level output functions. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#New",
                    "documentation": {
                      "identifier": "New",
                      "newPage": false,
                      "searchKey": "log.New",
                      "tags": [
                        "function"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func New(out io.Writer, prefix string, flag int) *Logger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc New(out io.Writer, prefix string, flag int) *Logger\n```\n\nNew creates a new Logger. The out variable sets the destination to which log data will be written. The prefix appears at the beginning of each generated log line, or after the log header if the Lmsgprefix flag is provided. The flag argument defines the logging properties. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Fatal",
                    "documentation": {
                      "identifier": "Logger.Fatal",
                      "newPage": false,
                      "searchKey": "log.Logger.Fatal",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Fatal(v ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Fatal(v ...interface{})\n```\n\nFatal is equivalent to l.Print() followed by a call to os.Exit(1). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Fatalf",
                    "documentation": {
                      "identifier": "Logger.Fatalf",
                      "newPage": false,
                      "searchKey": "log.Logger.Fatalf",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Fatalf(format string, v ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Fatalf(format string, v ...interface{})\n```\n\nFatalf is equivalent to l.Printf() followed by a call to os.Exit(1). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Fatalln",
                    "documentation": {
                      "identifier": "Logger.Fatalln",
                      "newPage": false,
                      "searchKey": "log.Logger.Fatalln",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Fatalln(v ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Fatalln(v ...interface{})\n```\n\nFatalln is equivalent to l.Println() followed by a call to os.Exit(1). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Flags",
                    "documentation": {
                      "identifier": "Logger.Flags",
                      "newPage": false,
                      "searchKey": "log.Logger.Flags",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Flags() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Flags() int\n```\n\nFlags returns the output flags for the logger. The flag bits are Ldate, Ltime, and so on. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Output",
                    "documentation": {
                      "identifier": "Logger.Output",
                      "newPage": false,
                      "searchKey": "log.Logger.Output",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Output(calldepth int, s string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Output(calldepth int, s string) error\n```\n\nOutput writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is used to recover the PC and is provided for generality, although at the moment on all pre-defined paths it will be 2. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Panic",
                    "documentation": {
                      "identifier": "Logger.Panic",
                      "newPage": false,
                      "searchKey": "log.Logger.Panic",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Panic(v ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Panic(v ...interface{})\n```\n\nPanic is equivalent to l.Print() followed by a call to panic(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Panicf",
                    "documentation": {
                      "identifier": "Logger.Panicf",
                      "newPage": false,
                      "searchKey": "log.Logger.Panicf",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Panicf(format string, v ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Panicf(format string, v ...interface{})\n```\n\nPanicf is equivalent to l.Printf() followed by a call to panic(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Panicln",
                    "documentation": {
                      "identifier": "Logger.Panicln",
                      "newPage": false,
                      "searchKey": "log.Logger.Panicln",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Panicln(v ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Panicln(v ...interface{})\n```\n\nPanicln is equivalent to l.Println() followed by a call to panic(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Prefix",
                    "documentation": {
                      "identifier": "Logger.Prefix",
                      "newPage": false,
                      "searchKey": "log.Logger.Prefix",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Prefix() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Prefix() string\n```\n\nPrefix returns the output prefix for the logger. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Print",
                    "documentation": {
                      "identifier": "Logger.Print",
                      "newPage": false,
                      "searchKey": "log.Logger.Print",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Print(v ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Print(v ...interface{})\n```\n\nPrint calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Print. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Printf",
                    "documentation": {
                      "identifier": "Logger.Printf",
                      "newPage": false,
                      "searchKey": "log.Logger.Printf",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Printf(format string, v ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Printf(format string, v ...interface{})\n```\n\nPrintf calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Printf. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Println",
                    "documentation": {
                      "identifier": "Logger.Println",
                      "newPage": false,
                      "searchKey": "log.Logger.Println",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Println(v ...interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Println(v ...interface{})\n```\n\nPrintln calls l.Output to print to the logger. Arguments are handled in the manner of fmt.Println. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.SetFlags",
                    "documentation": {
                      "identifier": "Logger.SetFlags",
                      "newPage": false,
                      "searchKey": "log.Logger.SetFlags",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) SetFlags(flag int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) SetFlags(flag int)\n```\n\nSetFlags sets the output flags for the logger. The flag bits are Ldate, Ltime, and so on. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.SetOutput",
                    "documentation": {
                      "identifier": "Logger.SetOutput",
                      "newPage": false,
                      "searchKey": "log.Logger.SetOutput",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) SetOutput(w io.Writer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) SetOutput(w io.Writer)\n```\n\nSetOutput sets the output destination for the logger. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.SetPrefix",
                    "documentation": {
                      "identifier": "Logger.SetPrefix",
                      "newPage": false,
                      "searchKey": "log.Logger.SetPrefix",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) SetPrefix(prefix string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) SetPrefix(prefix string)\n```\n\nSetPrefix sets the output prefix for the logger. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.Writer",
                    "documentation": {
                      "identifier": "Logger.Writer",
                      "newPage": false,
                      "searchKey": "log.Logger.Writer",
                      "tags": [
                        "method"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) Writer() io.Writer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) Writer() io.Writer\n```\n\nWriter returns the output destination for the logger. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/log#Logger.formatHeader",
                    "documentation": {
                      "identifier": "Logger.formatHeader",
                      "newPage": false,
                      "searchKey": "log.Logger.formatHeader",
                      "tags": [
                        "method",
                        "private"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int)\n```\n\nformatHeader writes log header to buf in following order: \n\n```\n* l.prefix (if it's not blank and Lmsgprefix is unset),\n* date and/or time (if corresponding flags are provided),\n* file and line number (if corresponding flags are provided),\n* l.prefix (if it's not blank and Lmsgprefix is set).\n\n```\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/log#tester",
              "documentation": {
                "identifier": "tester",
                "newPage": false,
                "searchKey": "log.tester",
                "tags": [
                  "struct",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type tester struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype tester struct {\n\tflag    int\n\tprefix  string\n\tpattern string // regexp that log output must match; we add ^ and expected_text$ always\n}\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/log#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": []
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/log#BenchmarkItoa",
              "documentation": {
                "identifier": "BenchmarkItoa",
                "newPage": false,
                "searchKey": "log.BenchmarkItoa",
                "tags": [
                  "function",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkItoa(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkItoa(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#BenchmarkPrintln",
              "documentation": {
                "identifier": "BenchmarkPrintln",
                "newPage": false,
                "searchKey": "log.BenchmarkPrintln",
                "tags": [
                  "function",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkPrintln(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkPrintln(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#BenchmarkPrintlnNoFlags",
              "documentation": {
                "identifier": "BenchmarkPrintlnNoFlags",
                "newPage": false,
                "searchKey": "log.BenchmarkPrintlnNoFlags",
                "tags": [
                  "function",
                  "private",
                  "benchmark"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkPrintlnNoFlags(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkPrintlnNoFlags(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Fatal",
              "documentation": {
                "identifier": "Fatal",
                "newPage": false,
                "searchKey": "log.Fatal",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Fatal(v ...interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Fatal(v ...interface{})\n```\n\nFatal is equivalent to Print() followed by a call to os.Exit(1). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Fatalf",
              "documentation": {
                "identifier": "Fatalf",
                "newPage": false,
                "searchKey": "log.Fatalf",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Fatalf(format string, v ...interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Fatalf(format string, v ...interface{})\n```\n\nFatalf is equivalent to Printf() followed by a call to os.Exit(1). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Fatalln",
              "documentation": {
                "identifier": "Fatalln",
                "newPage": false,
                "searchKey": "log.Fatalln",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Fatalln(v ...interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Fatalln(v ...interface{})\n```\n\nFatalln is equivalent to Println() followed by a call to os.Exit(1). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Flags",
              "documentation": {
                "identifier": "Flags",
                "newPage": false,
                "searchKey": "log.Flags",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Flags() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Flags() int\n```\n\nFlags returns the output flags for the standard logger. The flag bits are Ldate, Ltime, and so on. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Output",
              "documentation": {
                "identifier": "Output",
                "newPage": false,
                "searchKey": "log.Output",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Output(calldepth int, s string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Output(calldepth int, s string) error\n```\n\nOutput writes the output for a logging event. The string s contains the text to print after the prefix specified by the flags of the Logger. A newline is appended if the last character of s is not already a newline. Calldepth is the count of the number of frames to skip when computing the file name and line number if Llongfile or Lshortfile is set; a value of 1 will print the details for the caller of Output. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Panic",
              "documentation": {
                "identifier": "Panic",
                "newPage": false,
                "searchKey": "log.Panic",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Panic(v ...interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Panic(v ...interface{})\n```\n\nPanic is equivalent to Print() followed by a call to panic(). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Panicf",
              "documentation": {
                "identifier": "Panicf",
                "newPage": false,
                "searchKey": "log.Panicf",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Panicf(format string, v ...interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Panicf(format string, v ...interface{})\n```\n\nPanicf is equivalent to Printf() followed by a call to panic(). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Panicln",
              "documentation": {
                "identifier": "Panicln",
                "newPage": false,
                "searchKey": "log.Panicln",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Panicln(v ...interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Panicln(v ...interface{})\n```\n\nPanicln is equivalent to Println() followed by a call to panic(). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Prefix",
              "documentation": {
                "identifier": "Prefix",
                "newPage": false,
                "searchKey": "log.Prefix",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Prefix() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Prefix() string\n```\n\nPrefix returns the output prefix for the standard logger. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Print",
              "documentation": {
                "identifier": "Print",
                "newPage": false,
                "searchKey": "log.Print",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Print(v ...interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Print(v ...interface{})\n```\n\nPrint calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Print. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Printf",
              "documentation": {
                "identifier": "Printf",
                "newPage": false,
                "searchKey": "log.Printf",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Printf(format string, v ...interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Printf(format string, v ...interface{})\n```\n\nPrintf calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Printf. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Println",
              "documentation": {
                "identifier": "Println",
                "newPage": false,
                "searchKey": "log.Println",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Println(v ...interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Println(v ...interface{})\n```\n\nPrintln calls Output to print to the standard logger. Arguments are handled in the manner of fmt.Println. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#SetFlags",
              "documentation": {
                "identifier": "SetFlags",
                "newPage": false,
                "searchKey": "log.SetFlags",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetFlags(flag int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetFlags(flag int)\n```\n\nSetFlags sets the output flags for the standard logger. The flag bits are Ldate, Ltime, and so on. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#SetOutput",
              "documentation": {
                "identifier": "SetOutput",
                "newPage": false,
                "searchKey": "log.SetOutput",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetOutput(w io.Writer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetOutput(w io.Writer)\n```\n\nSetOutput sets the output destination for the standard logger. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#SetPrefix",
              "documentation": {
                "identifier": "SetPrefix",
                "newPage": false,
                "searchKey": "log.SetPrefix",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetPrefix(prefix string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetPrefix(prefix string)\n```\n\nSetPrefix sets the output prefix for the standard logger. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#TestAll",
              "documentation": {
                "identifier": "TestAll",
                "newPage": false,
                "searchKey": "log.TestAll",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAll(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAll(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#TestDefault",
              "documentation": {
                "identifier": "TestDefault",
                "newPage": false,
                "searchKey": "log.TestDefault",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDefault(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDefault(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#TestEmptyPrintCreatesLine",
              "documentation": {
                "identifier": "TestEmptyPrintCreatesLine",
                "newPage": false,
                "searchKey": "log.TestEmptyPrintCreatesLine",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEmptyPrintCreatesLine(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEmptyPrintCreatesLine(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#TestFlagAndPrefixSetting",
              "documentation": {
                "identifier": "TestFlagAndPrefixSetting",
                "newPage": false,
                "searchKey": "log.TestFlagAndPrefixSetting",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFlagAndPrefixSetting(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFlagAndPrefixSetting(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#TestOutput",
              "documentation": {
                "identifier": "TestOutput",
                "newPage": false,
                "searchKey": "log.TestOutput",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestOutput(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestOutput(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#TestOutputRace",
              "documentation": {
                "identifier": "TestOutputRace",
                "newPage": false,
                "searchKey": "log.TestOutputRace",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestOutputRace(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestOutputRace(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#TestUTCFlag",
              "documentation": {
                "identifier": "TestUTCFlag",
                "newPage": false,
                "searchKey": "log.TestUTCFlag",
                "tags": [
                  "function",
                  "private",
                  "test"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUTCFlag(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUTCFlag(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#Writer",
              "documentation": {
                "identifier": "Writer",
                "newPage": false,
                "searchKey": "log.Writer",
                "tags": [
                  "function"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Writer() io.Writer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Writer() io.Writer\n```\n\nWriter returns the output destination for the standard logger. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#itoa",
              "documentation": {
                "identifier": "itoa",
                "newPage": false,
                "searchKey": "log.itoa",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func itoa(buf *[]byte, i int, wid int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc itoa(buf *[]byte, i int, wid int)\n```\n\nCheap integer to fixed-width decimal ASCII. Give a negative width to avoid zero-padding. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/log#testPrint",
              "documentation": {
                "identifier": "testPrint",
                "newPage": false,
                "searchKey": "log.testPrint",
                "tags": [
                  "function",
                  "private"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func testPrint(t *testing.T, flag int, prefix string, pattern string, useFormat bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testPrint(t *testing.T, flag int, prefix string, pattern string, useFormat bool)\n```\n\nTest using Println(\"hello\", 23, \"world\") or using Printf(\"hello %d world\", 23) \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "pathID": "/log/syslog"
    },
    {
      "pathID": "/log/syslog_test"
    }
  ]
}
