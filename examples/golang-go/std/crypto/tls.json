{
  "pathID": "/std/crypto/tls",
  "documentation": {
    "identifier": "tls",
    "newPage": true,
    "searchKey": "std/crypto/tls",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package tls"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3, as specified in RFC 8446. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/std/crypto/tls#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/crypto/tls#alertLevelWarning",
              "documentation": {
                "identifier": "alertLevelWarning",
                "newPage": false,
                "searchKey": "tls.alertLevelWarning",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertLevelWarning"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertLevelWarning = 1\n```\n\nalert level \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertLevelError",
              "documentation": {
                "identifier": "alertLevelError",
                "newPage": false,
                "searchKey": "tls.alertLevelError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertLevelError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertLevelError = 2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertCloseNotify",
              "documentation": {
                "identifier": "alertCloseNotify",
                "newPage": false,
                "searchKey": "tls.alertCloseNotify",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertCloseNotify"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertCloseNotify alert = 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertUnexpectedMessage",
              "documentation": {
                "identifier": "alertUnexpectedMessage",
                "newPage": false,
                "searchKey": "tls.alertUnexpectedMessage",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertUnexpectedMessage"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertUnexpectedMessage alert = 10\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertBadRecordMAC",
              "documentation": {
                "identifier": "alertBadRecordMAC",
                "newPage": false,
                "searchKey": "tls.alertBadRecordMAC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertBadRecordMAC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertBadRecordMAC alert = 20\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertDecryptionFailed",
              "documentation": {
                "identifier": "alertDecryptionFailed",
                "newPage": false,
                "searchKey": "tls.alertDecryptionFailed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertDecryptionFailed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertDecryptionFailed alert = 21\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertRecordOverflow",
              "documentation": {
                "identifier": "alertRecordOverflow",
                "newPage": false,
                "searchKey": "tls.alertRecordOverflow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertRecordOverflow"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertRecordOverflow alert = 22\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertDecompressionFailure",
              "documentation": {
                "identifier": "alertDecompressionFailure",
                "newPage": false,
                "searchKey": "tls.alertDecompressionFailure",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertDecompressionFailure"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertDecompressionFailure alert = 30\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertHandshakeFailure",
              "documentation": {
                "identifier": "alertHandshakeFailure",
                "newPage": false,
                "searchKey": "tls.alertHandshakeFailure",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertHandshakeFailure"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertHandshakeFailure alert = 40\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertBadCertificate",
              "documentation": {
                "identifier": "alertBadCertificate",
                "newPage": false,
                "searchKey": "tls.alertBadCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertBadCertificate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertBadCertificate alert = 42\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertUnsupportedCertificate",
              "documentation": {
                "identifier": "alertUnsupportedCertificate",
                "newPage": false,
                "searchKey": "tls.alertUnsupportedCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertUnsupportedCertificate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertUnsupportedCertificate alert = 43\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertCertificateRevoked",
              "documentation": {
                "identifier": "alertCertificateRevoked",
                "newPage": false,
                "searchKey": "tls.alertCertificateRevoked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertCertificateRevoked"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertCertificateRevoked alert = 44\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertCertificateExpired",
              "documentation": {
                "identifier": "alertCertificateExpired",
                "newPage": false,
                "searchKey": "tls.alertCertificateExpired",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertCertificateExpired"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertCertificateExpired alert = 45\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertCertificateUnknown",
              "documentation": {
                "identifier": "alertCertificateUnknown",
                "newPage": false,
                "searchKey": "tls.alertCertificateUnknown",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertCertificateUnknown"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertCertificateUnknown alert = 46\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertIllegalParameter",
              "documentation": {
                "identifier": "alertIllegalParameter",
                "newPage": false,
                "searchKey": "tls.alertIllegalParameter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertIllegalParameter"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertIllegalParameter alert = 47\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertUnknownCA",
              "documentation": {
                "identifier": "alertUnknownCA",
                "newPage": false,
                "searchKey": "tls.alertUnknownCA",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertUnknownCA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertUnknownCA alert = 48\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertAccessDenied",
              "documentation": {
                "identifier": "alertAccessDenied",
                "newPage": false,
                "searchKey": "tls.alertAccessDenied",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertAccessDenied"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertAccessDenied alert = 49\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertDecodeError",
              "documentation": {
                "identifier": "alertDecodeError",
                "newPage": false,
                "searchKey": "tls.alertDecodeError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertDecodeError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertDecodeError alert = 50\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertDecryptError",
              "documentation": {
                "identifier": "alertDecryptError",
                "newPage": false,
                "searchKey": "tls.alertDecryptError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertDecryptError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertDecryptError alert = 51\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertExportRestriction",
              "documentation": {
                "identifier": "alertExportRestriction",
                "newPage": false,
                "searchKey": "tls.alertExportRestriction",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertExportRestriction"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertExportRestriction alert = 60\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertProtocolVersion",
              "documentation": {
                "identifier": "alertProtocolVersion",
                "newPage": false,
                "searchKey": "tls.alertProtocolVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertProtocolVersion"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertProtocolVersion alert = 70\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertInsufficientSecurity",
              "documentation": {
                "identifier": "alertInsufficientSecurity",
                "newPage": false,
                "searchKey": "tls.alertInsufficientSecurity",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertInsufficientSecurity"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertInsufficientSecurity alert = 71\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertInternalError",
              "documentation": {
                "identifier": "alertInternalError",
                "newPage": false,
                "searchKey": "tls.alertInternalError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertInternalError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertInternalError alert = 80\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertInappropriateFallback",
              "documentation": {
                "identifier": "alertInappropriateFallback",
                "newPage": false,
                "searchKey": "tls.alertInappropriateFallback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertInappropriateFallback"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertInappropriateFallback alert = 86\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertUserCanceled",
              "documentation": {
                "identifier": "alertUserCanceled",
                "newPage": false,
                "searchKey": "tls.alertUserCanceled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertUserCanceled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertUserCanceled alert = 90\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertNoRenegotiation",
              "documentation": {
                "identifier": "alertNoRenegotiation",
                "newPage": false,
                "searchKey": "tls.alertNoRenegotiation",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertNoRenegotiation"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertNoRenegotiation alert = 100\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertMissingExtension",
              "documentation": {
                "identifier": "alertMissingExtension",
                "newPage": false,
                "searchKey": "tls.alertMissingExtension",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertMissingExtension"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertMissingExtension alert = 109\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertUnsupportedExtension",
              "documentation": {
                "identifier": "alertUnsupportedExtension",
                "newPage": false,
                "searchKey": "tls.alertUnsupportedExtension",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertUnsupportedExtension"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertUnsupportedExtension alert = 110\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertCertificateUnobtainable",
              "documentation": {
                "identifier": "alertCertificateUnobtainable",
                "newPage": false,
                "searchKey": "tls.alertCertificateUnobtainable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertCertificateUnobtainable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertCertificateUnobtainable alert = 111\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertUnrecognizedName",
              "documentation": {
                "identifier": "alertUnrecognizedName",
                "newPage": false,
                "searchKey": "tls.alertUnrecognizedName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertUnrecognizedName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertUnrecognizedName alert = 112\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertBadCertificateStatusResponse",
              "documentation": {
                "identifier": "alertBadCertificateStatusResponse",
                "newPage": false,
                "searchKey": "tls.alertBadCertificateStatusResponse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertBadCertificateStatusResponse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertBadCertificateStatusResponse alert = 113\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertBadCertificateHashValue",
              "documentation": {
                "identifier": "alertBadCertificateHashValue",
                "newPage": false,
                "searchKey": "tls.alertBadCertificateHashValue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertBadCertificateHashValue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertBadCertificateHashValue alert = 114\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertUnknownPSKIdentity",
              "documentation": {
                "identifier": "alertUnknownPSKIdentity",
                "newPage": false,
                "searchKey": "tls.alertUnknownPSKIdentity",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertUnknownPSKIdentity"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertUnknownPSKIdentity alert = 115\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertCertificateRequired",
              "documentation": {
                "identifier": "alertCertificateRequired",
                "newPage": false,
                "searchKey": "tls.alertCertificateRequired",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertCertificateRequired"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertCertificateRequired alert = 116\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#alertNoApplicationProtocol",
              "documentation": {
                "identifier": "alertNoApplicationProtocol",
                "newPage": false,
                "searchKey": "tls.alertNoApplicationProtocol",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alertNoApplicationProtocol"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alertNoApplicationProtocol alert = 120\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#serverSignatureContext",
              "documentation": {
                "identifier": "serverSignatureContext",
                "newPage": false,
                "searchKey": "tls.serverSignatureContext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const serverSignatureContext"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst serverSignatureContext = \"TLS 1.3, server CertificateVerify\\x00\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientSignatureContext",
              "documentation": {
                "identifier": "clientSignatureContext",
                "newPage": false,
                "searchKey": "tls.clientSignatureContext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const clientSignatureContext"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst clientSignatureContext = \"TLS 1.3, client CertificateVerify\\x00\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#suiteECDHE",
              "documentation": {
                "identifier": "suiteECDHE",
                "newPage": false,
                "searchKey": "tls.suiteECDHE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const suiteECDHE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst suiteECDHE = 1 << iota\n```\n\nsuiteECDHE indicates that the cipher suite involves elliptic curve Diffie-Hellman. This means that it should only be selected when the client indicates that it supports ECC with a curve and point format that we're happy with. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#suiteECSign",
              "documentation": {
                "identifier": "suiteECSign",
                "newPage": false,
                "searchKey": "tls.suiteECSign",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const suiteECSign"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst suiteECSign\n```\n\nsuiteECSign indicates that the cipher suite involves an ECDSA or EdDSA signature and therefore may only be selected when the server's certificate is ECDSA or EdDSA. If this is not set then the cipher suite is RSA based. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#suiteTLS12",
              "documentation": {
                "identifier": "suiteTLS12",
                "newPage": false,
                "searchKey": "tls.suiteTLS12",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const suiteTLS12"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst suiteTLS12\n```\n\nsuiteTLS12 indicates that the cipher suite should only be advertised and accepted when using TLS 1.2. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#suiteSHA384",
              "documentation": {
                "identifier": "suiteSHA384",
                "newPage": false,
                "searchKey": "tls.suiteSHA384",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const suiteSHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst suiteSHA384\n```\n\nsuiteSHA384 indicates that the cipher suite uses SHA384 as the handshake hash. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#aeadNonceLength",
              "documentation": {
                "identifier": "aeadNonceLength",
                "newPage": false,
                "searchKey": "tls.aeadNonceLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const aeadNonceLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst aeadNonceLength = 12\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#noncePrefixLength",
              "documentation": {
                "identifier": "noncePrefixLength",
                "newPage": false,
                "searchKey": "tls.noncePrefixLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const noncePrefixLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst noncePrefixLength = 4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_RSA_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "TLS_RSA_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "tls.TLS_RSA_WITH_RC4_128_SHA",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_RSA_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_RSA_WITH_RC4_128_SHA uint16 = 0x0005\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\nTLS 1.0 - 1.2 cipher suites. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_RSA_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_RSA_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0x000a\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_RSA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "TLS_RSA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "tls.TLS_RSA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_RSA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_RSA_WITH_AES_128_CBC_SHA uint16 = 0x002f\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_RSA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "TLS_RSA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "tls.TLS_RSA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_RSA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_RSA_WITH_AES_256_CBC_SHA uint16 = 0x0035\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_RSA_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "TLS_RSA_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "tls.TLS_RSA_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_RSA_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0x003c\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_RSA_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "TLS_RSA_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "tls.TLS_RSA_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_RSA_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0x009c\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_RSA_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "TLS_RSA_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "tls.TLS_RSA_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_RSA_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0x009d\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_ECDSA_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_ECDSA_WITH_RC4_128_SHA uint16 = 0xc007\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA uint16 = 0xc009\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA uint16 = 0xc00a\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_RSA_WITH_RC4_128_SHA",
              "documentation": {
                "identifier": "TLS_ECDHE_RSA_WITH_RC4_128_SHA",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_RSA_WITH_RC4_128_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_RSA_WITH_RC4_128_SHA uint16 = 0xc011\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
              "documentation": {
                "identifier": "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xc012\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
              "documentation": {
                "identifier": "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA uint16 = 0xc013\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
              "documentation": {
                "identifier": "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA uint16 = 0xc014\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 uint16 = 0xc023\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
              "documentation": {
                "identifier": "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 uint16 = 0xc027\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02f\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 uint16 = 0xc02b\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 uint16 = 0xc030\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 uint16 = 0xc02c\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
              "documentation": {
                "identifier": "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xcca8\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
              "documentation": {
                "identifier": "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xcca9\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_AES_128_GCM_SHA256",
              "documentation": {
                "identifier": "TLS_AES_128_GCM_SHA256",
                "newPage": false,
                "searchKey": "tls.TLS_AES_128_GCM_SHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_AES_128_GCM_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_AES_128_GCM_SHA256 uint16 = 0x1301\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\nTLS 1.3 cipher suites. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_AES_256_GCM_SHA384",
              "documentation": {
                "identifier": "TLS_AES_256_GCM_SHA384",
                "newPage": false,
                "searchKey": "tls.TLS_AES_256_GCM_SHA384",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_AES_256_GCM_SHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_AES_256_GCM_SHA384 uint16 = 0x1302\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_CHACHA20_POLY1305_SHA256",
              "documentation": {
                "identifier": "TLS_CHACHA20_POLY1305_SHA256",
                "newPage": false,
                "searchKey": "tls.TLS_CHACHA20_POLY1305_SHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_CHACHA20_POLY1305_SHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_CHACHA20_POLY1305_SHA256 uint16 = 0x1303\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_FALLBACK_SCSV",
              "documentation": {
                "identifier": "TLS_FALLBACK_SCSV",
                "newPage": false,
                "searchKey": "tls.TLS_FALLBACK_SCSV",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_FALLBACK_SCSV"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_FALLBACK_SCSV uint16 = 0x5600\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\nTLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator that the client is doing version fallback. See RFC 7507. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305",
              "documentation": {
                "identifier": "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 = TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\nLegacy names for the corresponding cipher suites with the correct _SHA256 suffix, retained for backward compatibility. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305",
              "documentation": {
                "identifier": "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305",
                "newPage": false,
                "searchKey": "tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\n```\n\nA list of cipher suite IDs that are, or have been, implemented by this package. \n\nSee [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#VersionTLS10",
              "documentation": {
                "identifier": "VersionTLS10",
                "newPage": false,
                "searchKey": "tls.VersionTLS10",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const VersionTLS10"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst VersionTLS10 = 0x0301\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#VersionTLS11",
              "documentation": {
                "identifier": "VersionTLS11",
                "newPage": false,
                "searchKey": "tls.VersionTLS11",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const VersionTLS11"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst VersionTLS11 = 0x0302\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#VersionTLS12",
              "documentation": {
                "identifier": "VersionTLS12",
                "newPage": false,
                "searchKey": "tls.VersionTLS12",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const VersionTLS12"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst VersionTLS12 = 0x0303\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#VersionTLS13",
              "documentation": {
                "identifier": "VersionTLS13",
                "newPage": false,
                "searchKey": "tls.VersionTLS13",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const VersionTLS13"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst VersionTLS13 = 0x0304\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#VersionSSL30",
              "documentation": {
                "identifier": "VersionSSL30",
                "newPage": false,
                "searchKey": "tls.VersionSSL30",
                "tags": [
                  "exported",
                  "deprecated"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const VersionSSL30"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst VersionSSL30 = 0x0300\n```\n\nDeprecated: SSLv3 is cryptographically broken, and is no longer supported by this package. See golang.org/issue/32716. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#maxPlaintext",
              "documentation": {
                "identifier": "maxPlaintext",
                "newPage": false,
                "searchKey": "tls.maxPlaintext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxPlaintext"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxPlaintext = 16384 // maximum plaintext payload length\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#maxCiphertext",
              "documentation": {
                "identifier": "maxCiphertext",
                "newPage": false,
                "searchKey": "tls.maxCiphertext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxCiphertext"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxCiphertext = 16384 + 2048 // maximum ciphertext payload length\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#maxCiphertextTLS13",
              "documentation": {
                "identifier": "maxCiphertextTLS13",
                "newPage": false,
                "searchKey": "tls.maxCiphertextTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxCiphertextTLS13"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxCiphertextTLS13 = 16384 + 256 // maximum ciphertext length in TLS 1.3\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#recordHeaderLen",
              "documentation": {
                "identifier": "recordHeaderLen",
                "newPage": false,
                "searchKey": "tls.recordHeaderLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const recordHeaderLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst recordHeaderLen = 5 // record header length\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#maxHandshake",
              "documentation": {
                "identifier": "maxHandshake",
                "newPage": false,
                "searchKey": "tls.maxHandshake",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxHandshake"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxHandshake = 65536 // maximum handshake we support (protocol max is 16 MB)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#maxUselessRecords",
              "documentation": {
                "identifier": "maxUselessRecords",
                "newPage": false,
                "searchKey": "tls.maxUselessRecords",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxUselessRecords"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxUselessRecords = 16 // maximum number of consecutive non-advancing records\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#recordTypeChangeCipherSpec",
              "documentation": {
                "identifier": "recordTypeChangeCipherSpec",
                "newPage": false,
                "searchKey": "tls.recordTypeChangeCipherSpec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const recordTypeChangeCipherSpec"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst recordTypeChangeCipherSpec recordType = 20\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#recordTypeAlert",
              "documentation": {
                "identifier": "recordTypeAlert",
                "newPage": false,
                "searchKey": "tls.recordTypeAlert",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const recordTypeAlert"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst recordTypeAlert recordType = 21\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#recordTypeHandshake",
              "documentation": {
                "identifier": "recordTypeHandshake",
                "newPage": false,
                "searchKey": "tls.recordTypeHandshake",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const recordTypeHandshake"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst recordTypeHandshake recordType = 22\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#recordTypeApplicationData",
              "documentation": {
                "identifier": "recordTypeApplicationData",
                "newPage": false,
                "searchKey": "tls.recordTypeApplicationData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const recordTypeApplicationData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst recordTypeApplicationData recordType = 23\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeHelloRequest",
              "documentation": {
                "identifier": "typeHelloRequest",
                "newPage": false,
                "searchKey": "tls.typeHelloRequest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeHelloRequest"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeHelloRequest uint8 = 0\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeClientHello",
              "documentation": {
                "identifier": "typeClientHello",
                "newPage": false,
                "searchKey": "tls.typeClientHello",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeClientHello"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeClientHello uint8 = 1\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeServerHello",
              "documentation": {
                "identifier": "typeServerHello",
                "newPage": false,
                "searchKey": "tls.typeServerHello",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeServerHello"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeServerHello uint8 = 2\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeNewSessionTicket",
              "documentation": {
                "identifier": "typeNewSessionTicket",
                "newPage": false,
                "searchKey": "tls.typeNewSessionTicket",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeNewSessionTicket"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeNewSessionTicket uint8 = 4\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeEndOfEarlyData",
              "documentation": {
                "identifier": "typeEndOfEarlyData",
                "newPage": false,
                "searchKey": "tls.typeEndOfEarlyData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeEndOfEarlyData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeEndOfEarlyData uint8 = 5\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeEncryptedExtensions",
              "documentation": {
                "identifier": "typeEncryptedExtensions",
                "newPage": false,
                "searchKey": "tls.typeEncryptedExtensions",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeEncryptedExtensions"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeEncryptedExtensions uint8 = 8\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeCertificate",
              "documentation": {
                "identifier": "typeCertificate",
                "newPage": false,
                "searchKey": "tls.typeCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeCertificate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeCertificate uint8 = 11\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeServerKeyExchange",
              "documentation": {
                "identifier": "typeServerKeyExchange",
                "newPage": false,
                "searchKey": "tls.typeServerKeyExchange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeServerKeyExchange"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeServerKeyExchange uint8 = 12\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeCertificateRequest",
              "documentation": {
                "identifier": "typeCertificateRequest",
                "newPage": false,
                "searchKey": "tls.typeCertificateRequest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeCertificateRequest"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeCertificateRequest uint8 = 13\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeServerHelloDone",
              "documentation": {
                "identifier": "typeServerHelloDone",
                "newPage": false,
                "searchKey": "tls.typeServerHelloDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeServerHelloDone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeServerHelloDone uint8 = 14\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeCertificateVerify",
              "documentation": {
                "identifier": "typeCertificateVerify",
                "newPage": false,
                "searchKey": "tls.typeCertificateVerify",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeCertificateVerify"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeCertificateVerify uint8 = 15\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeClientKeyExchange",
              "documentation": {
                "identifier": "typeClientKeyExchange",
                "newPage": false,
                "searchKey": "tls.typeClientKeyExchange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeClientKeyExchange"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeClientKeyExchange uint8 = 16\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeFinished",
              "documentation": {
                "identifier": "typeFinished",
                "newPage": false,
                "searchKey": "tls.typeFinished",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeFinished"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeFinished uint8 = 20\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeCertificateStatus",
              "documentation": {
                "identifier": "typeCertificateStatus",
                "newPage": false,
                "searchKey": "tls.typeCertificateStatus",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeCertificateStatus"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeCertificateStatus uint8 = 22\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeKeyUpdate",
              "documentation": {
                "identifier": "typeKeyUpdate",
                "newPage": false,
                "searchKey": "tls.typeKeyUpdate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeKeyUpdate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeKeyUpdate uint8 = 24\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeNextProtocol",
              "documentation": {
                "identifier": "typeNextProtocol",
                "newPage": false,
                "searchKey": "tls.typeNextProtocol",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeNextProtocol"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeNextProtocol uint8 = 67 // Not IANA assigned\n\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeMessageHash",
              "documentation": {
                "identifier": "typeMessageHash",
                "newPage": false,
                "searchKey": "tls.typeMessageHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeMessageHash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeMessageHash uint8 = 254 // synthetic message\n\n```\n\nTLS handshake message types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#compressionNone",
              "documentation": {
                "identifier": "compressionNone",
                "newPage": false,
                "searchKey": "tls.compressionNone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const compressionNone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst compressionNone uint8 = 0\n```\n\nTLS compression types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionServerName",
              "documentation": {
                "identifier": "extensionServerName",
                "newPage": false,
                "searchKey": "tls.extensionServerName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionServerName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionServerName uint16 = 0\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionStatusRequest",
              "documentation": {
                "identifier": "extensionStatusRequest",
                "newPage": false,
                "searchKey": "tls.extensionStatusRequest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionStatusRequest"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionStatusRequest uint16 = 5\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionSupportedCurves",
              "documentation": {
                "identifier": "extensionSupportedCurves",
                "newPage": false,
                "searchKey": "tls.extensionSupportedCurves",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionSupportedCurves"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionSupportedCurves uint16 // supported_groups in TLS 1.3, see RFC 8446, Section 4.2.7\n = ...\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionSupportedPoints",
              "documentation": {
                "identifier": "extensionSupportedPoints",
                "newPage": false,
                "searchKey": "tls.extensionSupportedPoints",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionSupportedPoints"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionSupportedPoints uint16 = 11\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionSignatureAlgorithms",
              "documentation": {
                "identifier": "extensionSignatureAlgorithms",
                "newPage": false,
                "searchKey": "tls.extensionSignatureAlgorithms",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionSignatureAlgorithms"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionSignatureAlgorithms uint16 = 13\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionALPN",
              "documentation": {
                "identifier": "extensionALPN",
                "newPage": false,
                "searchKey": "tls.extensionALPN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionALPN"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionALPN uint16 = 16\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionSCT",
              "documentation": {
                "identifier": "extensionSCT",
                "newPage": false,
                "searchKey": "tls.extensionSCT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionSCT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionSCT uint16 = 18\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionSessionTicket",
              "documentation": {
                "identifier": "extensionSessionTicket",
                "newPage": false,
                "searchKey": "tls.extensionSessionTicket",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionSessionTicket"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionSessionTicket uint16 = 35\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionPreSharedKey",
              "documentation": {
                "identifier": "extensionPreSharedKey",
                "newPage": false,
                "searchKey": "tls.extensionPreSharedKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionPreSharedKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionPreSharedKey uint16 = 41\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionEarlyData",
              "documentation": {
                "identifier": "extensionEarlyData",
                "newPage": false,
                "searchKey": "tls.extensionEarlyData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionEarlyData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionEarlyData uint16 = 42\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionSupportedVersions",
              "documentation": {
                "identifier": "extensionSupportedVersions",
                "newPage": false,
                "searchKey": "tls.extensionSupportedVersions",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionSupportedVersions"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionSupportedVersions uint16 = 43\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionCookie",
              "documentation": {
                "identifier": "extensionCookie",
                "newPage": false,
                "searchKey": "tls.extensionCookie",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionCookie"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionCookie uint16 = 44\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionPSKModes",
              "documentation": {
                "identifier": "extensionPSKModes",
                "newPage": false,
                "searchKey": "tls.extensionPSKModes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionPSKModes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionPSKModes uint16 = 45\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionCertificateAuthorities",
              "documentation": {
                "identifier": "extensionCertificateAuthorities",
                "newPage": false,
                "searchKey": "tls.extensionCertificateAuthorities",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionCertificateAuthorities"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionCertificateAuthorities uint16 = 47\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionSignatureAlgorithmsCert",
              "documentation": {
                "identifier": "extensionSignatureAlgorithmsCert",
                "newPage": false,
                "searchKey": "tls.extensionSignatureAlgorithmsCert",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionSignatureAlgorithmsCert"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionSignatureAlgorithmsCert uint16 = 50\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionKeyShare",
              "documentation": {
                "identifier": "extensionKeyShare",
                "newPage": false,
                "searchKey": "tls.extensionKeyShare",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionKeyShare"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionKeyShare uint16 = 51\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extensionRenegotiationInfo",
              "documentation": {
                "identifier": "extensionRenegotiationInfo",
                "newPage": false,
                "searchKey": "tls.extensionRenegotiationInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const extensionRenegotiationInfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst extensionRenegotiationInfo uint16 = 0xff01\n```\n\nTLS extension numbers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#scsvRenegotiation",
              "documentation": {
                "identifier": "scsvRenegotiation",
                "newPage": false,
                "searchKey": "tls.scsvRenegotiation",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const scsvRenegotiation"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst scsvRenegotiation uint16 = 0x00ff\n```\n\nTLS signaling cipher suite values \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#CurveP256",
              "documentation": {
                "identifier": "CurveP256",
                "newPage": false,
                "searchKey": "tls.CurveP256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const CurveP256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst CurveP256 CurveID = 23\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#CurveP384",
              "documentation": {
                "identifier": "CurveP384",
                "newPage": false,
                "searchKey": "tls.CurveP384",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const CurveP384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst CurveP384 CurveID = 24\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#CurveP521",
              "documentation": {
                "identifier": "CurveP521",
                "newPage": false,
                "searchKey": "tls.CurveP521",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const CurveP521"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst CurveP521 CurveID = 25\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#X25519",
              "documentation": {
                "identifier": "X25519",
                "newPage": false,
                "searchKey": "tls.X25519",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const X25519"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst X25519 CurveID = 29\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#pskModePlain",
              "documentation": {
                "identifier": "pskModePlain",
                "newPage": false,
                "searchKey": "tls.pskModePlain",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pskModePlain"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pskModePlain uint8 = 0\n```\n\nTLS 1.3 PSK Key Exchange Modes. See RFC 8446, Section 4.2.9. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#pskModeDHE",
              "documentation": {
                "identifier": "pskModeDHE",
                "newPage": false,
                "searchKey": "tls.pskModeDHE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pskModeDHE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pskModeDHE uint8 = 1\n```\n\nTLS 1.3 PSK Key Exchange Modes. See RFC 8446, Section 4.2.9. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#pointFormatUncompressed",
              "documentation": {
                "identifier": "pointFormatUncompressed",
                "newPage": false,
                "searchKey": "tls.pointFormatUncompressed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pointFormatUncompressed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pointFormatUncompressed uint8 = 0\n```\n\nTLS Elliptic Curve Point Formats [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-9](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-9) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#statusTypeOCSP",
              "documentation": {
                "identifier": "statusTypeOCSP",
                "newPage": false,
                "searchKey": "tls.statusTypeOCSP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const statusTypeOCSP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst statusTypeOCSP uint8 = 1\n```\n\nTLS CertificateStatusType (RFC 3546) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#certTypeRSASign",
              "documentation": {
                "identifier": "certTypeRSASign",
                "newPage": false,
                "searchKey": "tls.certTypeRSASign",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const certTypeRSASign"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst certTypeRSASign = 1\n```\n\nCertificate types (for certificateRequestMsg) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#certTypeECDSASign",
              "documentation": {
                "identifier": "certTypeECDSASign",
                "newPage": false,
                "searchKey": "tls.certTypeECDSASign",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const certTypeECDSASign"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst certTypeECDSASign = 64 // ECDSA or EdDSA keys, see RFC 8422, Section 3.\n\n```\n\nCertificate types (for certificateRequestMsg) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#signaturePKCS1v15",
              "documentation": {
                "identifier": "signaturePKCS1v15",
                "newPage": false,
                "searchKey": "tls.signaturePKCS1v15",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const signaturePKCS1v15"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst signaturePKCS1v15 uint8 = iota + 225\n```\n\nSignature algorithms (for internal signaling use). Starting at 225 to avoid overlap with TLS 1.2 codepoints (RFC 5246, Appendix A.4.1), with which these have nothing to do. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#signatureRSAPSS",
              "documentation": {
                "identifier": "signatureRSAPSS",
                "newPage": false,
                "searchKey": "tls.signatureRSAPSS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const signatureRSAPSS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst signatureRSAPSS\n```\n\nSignature algorithms (for internal signaling use). Starting at 225 to avoid overlap with TLS 1.2 codepoints (RFC 5246, Appendix A.4.1), with which these have nothing to do. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#signatureECDSA",
              "documentation": {
                "identifier": "signatureECDSA",
                "newPage": false,
                "searchKey": "tls.signatureECDSA",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const signatureECDSA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst signatureECDSA\n```\n\nSignature algorithms (for internal signaling use). Starting at 225 to avoid overlap with TLS 1.2 codepoints (RFC 5246, Appendix A.4.1), with which these have nothing to do. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#signatureEd25519",
              "documentation": {
                "identifier": "signatureEd25519",
                "newPage": false,
                "searchKey": "tls.signatureEd25519",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const signatureEd25519"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst signatureEd25519\n```\n\nSignature algorithms (for internal signaling use). Starting at 225 to avoid overlap with TLS 1.2 codepoints (RFC 5246, Appendix A.4.1), with which these have nothing to do. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#downgradeCanaryTLS12",
              "documentation": {
                "identifier": "downgradeCanaryTLS12",
                "newPage": false,
                "searchKey": "tls.downgradeCanaryTLS12",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const downgradeCanaryTLS12"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst downgradeCanaryTLS12 = \"DOWNGRD\\x01\"\n```\n\ndowngradeCanaryTLS12 or downgradeCanaryTLS11 is embedded in the server random as a downgrade protection if the server would be capable of negotiating a higher version. See RFC 8446, Section 4.1.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#downgradeCanaryTLS11",
              "documentation": {
                "identifier": "downgradeCanaryTLS11",
                "newPage": false,
                "searchKey": "tls.downgradeCanaryTLS11",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const downgradeCanaryTLS11"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst downgradeCanaryTLS11 = \"DOWNGRD\\x00\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#NoClientCert",
              "documentation": {
                "identifier": "NoClientCert",
                "newPage": false,
                "searchKey": "tls.NoClientCert",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const NoClientCert"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst NoClientCert ClientAuthType = iota\n```\n\nNoClientCert indicates that no client certificate should be requested during the handshake, and if any certificates are sent they will not be verified. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#RequestClientCert",
              "documentation": {
                "identifier": "RequestClientCert",
                "newPage": false,
                "searchKey": "tls.RequestClientCert",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RequestClientCert"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RequestClientCert\n```\n\nRequestClientCert indicates that a client certificate should be requested during the handshake, but does not require that the client send any certificates. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#RequireAnyClientCert",
              "documentation": {
                "identifier": "RequireAnyClientCert",
                "newPage": false,
                "searchKey": "tls.RequireAnyClientCert",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RequireAnyClientCert"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RequireAnyClientCert\n```\n\nRequireAnyClientCert indicates that a client certificate should be requested during the handshake, and that at least one certificate is required to be sent by the client, but that certificate is not required to be valid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#VerifyClientCertIfGiven",
              "documentation": {
                "identifier": "VerifyClientCertIfGiven",
                "newPage": false,
                "searchKey": "tls.VerifyClientCertIfGiven",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const VerifyClientCertIfGiven"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst VerifyClientCertIfGiven\n```\n\nVerifyClientCertIfGiven indicates that a client certificate should be requested during the handshake, but does not require that the client sends a certificate. If the client does send a certificate it is required to be valid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#RequireAndVerifyClientCert",
              "documentation": {
                "identifier": "RequireAndVerifyClientCert",
                "newPage": false,
                "searchKey": "tls.RequireAndVerifyClientCert",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RequireAndVerifyClientCert"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RequireAndVerifyClientCert\n```\n\nRequireAndVerifyClientCert indicates that a client certificate should be requested during the handshake, and that at least one valid certificate is required to be sent by the client. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#PKCS1WithSHA256",
              "documentation": {
                "identifier": "PKCS1WithSHA256",
                "newPage": false,
                "searchKey": "tls.PKCS1WithSHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const PKCS1WithSHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PKCS1WithSHA256 SignatureScheme = 0x0401\n```\n\nRSASSA-PKCS1-v1_5 algorithms. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#PKCS1WithSHA384",
              "documentation": {
                "identifier": "PKCS1WithSHA384",
                "newPage": false,
                "searchKey": "tls.PKCS1WithSHA384",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const PKCS1WithSHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PKCS1WithSHA384 SignatureScheme = 0x0501\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#PKCS1WithSHA512",
              "documentation": {
                "identifier": "PKCS1WithSHA512",
                "newPage": false,
                "searchKey": "tls.PKCS1WithSHA512",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const PKCS1WithSHA512"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PKCS1WithSHA512 SignatureScheme = 0x0601\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#PSSWithSHA256",
              "documentation": {
                "identifier": "PSSWithSHA256",
                "newPage": false,
                "searchKey": "tls.PSSWithSHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const PSSWithSHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PSSWithSHA256 SignatureScheme = 0x0804\n```\n\nRSASSA-PSS algorithms with public key OID rsaEncryption. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#PSSWithSHA384",
              "documentation": {
                "identifier": "PSSWithSHA384",
                "newPage": false,
                "searchKey": "tls.PSSWithSHA384",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const PSSWithSHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PSSWithSHA384 SignatureScheme = 0x0805\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#PSSWithSHA512",
              "documentation": {
                "identifier": "PSSWithSHA512",
                "newPage": false,
                "searchKey": "tls.PSSWithSHA512",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const PSSWithSHA512"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PSSWithSHA512 SignatureScheme = 0x0806\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ECDSAWithP256AndSHA256",
              "documentation": {
                "identifier": "ECDSAWithP256AndSHA256",
                "newPage": false,
                "searchKey": "tls.ECDSAWithP256AndSHA256",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ECDSAWithP256AndSHA256"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ECDSAWithP256AndSHA256 SignatureScheme = 0x0403\n```\n\nECDSA algorithms. Only constrained to a specific curve in TLS 1.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ECDSAWithP384AndSHA384",
              "documentation": {
                "identifier": "ECDSAWithP384AndSHA384",
                "newPage": false,
                "searchKey": "tls.ECDSAWithP384AndSHA384",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ECDSAWithP384AndSHA384"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ECDSAWithP384AndSHA384 SignatureScheme = 0x0503\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ECDSAWithP521AndSHA512",
              "documentation": {
                "identifier": "ECDSAWithP521AndSHA512",
                "newPage": false,
                "searchKey": "tls.ECDSAWithP521AndSHA512",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ECDSAWithP521AndSHA512"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ECDSAWithP521AndSHA512 SignatureScheme = 0x0603\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#Ed25519",
              "documentation": {
                "identifier": "Ed25519",
                "newPage": false,
                "searchKey": "tls.Ed25519",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Ed25519"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Ed25519 SignatureScheme = 0x0807\n```\n\nEdDSA algorithms. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#PKCS1WithSHA1",
              "documentation": {
                "identifier": "PKCS1WithSHA1",
                "newPage": false,
                "searchKey": "tls.PKCS1WithSHA1",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const PKCS1WithSHA1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PKCS1WithSHA1 SignatureScheme = 0x0201\n```\n\nLegacy signature and hash algorithms for TLS 1.2. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ECDSAWithSHA1",
              "documentation": {
                "identifier": "ECDSAWithSHA1",
                "newPage": false,
                "searchKey": "tls.ECDSAWithSHA1",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ECDSAWithSHA1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ECDSAWithSHA1 SignatureScheme = 0x0203\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#RenegotiateNever",
              "documentation": {
                "identifier": "RenegotiateNever",
                "newPage": false,
                "searchKey": "tls.RenegotiateNever",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RenegotiateNever"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RenegotiateNever RenegotiationSupport = iota\n```\n\nRenegotiateNever disables renegotiation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#RenegotiateOnceAsClient",
              "documentation": {
                "identifier": "RenegotiateOnceAsClient",
                "newPage": false,
                "searchKey": "tls.RenegotiateOnceAsClient",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RenegotiateOnceAsClient"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RenegotiateOnceAsClient\n```\n\nRenegotiateOnceAsClient allows a remote server to request renegotiation once per connection. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#RenegotiateFreelyAsClient",
              "documentation": {
                "identifier": "RenegotiateFreelyAsClient",
                "newPage": false,
                "searchKey": "tls.RenegotiateFreelyAsClient",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const RenegotiateFreelyAsClient"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RenegotiateFreelyAsClient\n```\n\nRenegotiateFreelyAsClient allows a remote server to repeatedly request renegotiation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ticketKeyNameLen",
              "documentation": {
                "identifier": "ticketKeyNameLen",
                "newPage": false,
                "searchKey": "tls.ticketKeyNameLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const ticketKeyNameLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ticketKeyNameLen = 16\n```\n\nticketKeyNameLen is the number of bytes of identifier that is prepended to an encrypted session ticket in order to identify the key used to encrypt it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ticketKeyLifetime",
              "documentation": {
                "identifier": "ticketKeyLifetime",
                "newPage": false,
                "searchKey": "tls.ticketKeyLifetime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const ticketKeyLifetime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ticketKeyLifetime = 7 * 24 * time.Hour // 7 days\n\n```\n\nticketKeyLifetime is how long a ticket key remains valid and can be used to resume a client connection. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ticketKeyRotation",
              "documentation": {
                "identifier": "ticketKeyRotation",
                "newPage": false,
                "searchKey": "tls.ticketKeyRotation",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const ticketKeyRotation"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ticketKeyRotation = 24 * time.Hour\n```\n\nticketKeyRotation is how often the server should rotate the session ticket key that is used for new tickets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#maxSessionTicketLifetime",
              "documentation": {
                "identifier": "maxSessionTicketLifetime",
                "newPage": false,
                "searchKey": "tls.maxSessionTicketLifetime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxSessionTicketLifetime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxSessionTicketLifetime = 7 * 24 * time.Hour\n```\n\nmaxSessionTicketLifetime is the maximum allowed lifetime of a TLS 1.3 session ticket, and the lifetime we set for tickets we send. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyLogLabelTLS12",
              "documentation": {
                "identifier": "keyLogLabelTLS12",
                "newPage": false,
                "searchKey": "tls.keyLogLabelTLS12",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const keyLogLabelTLS12"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst keyLogLabelTLS12 = \"CLIENT_RANDOM\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyLogLabelClientHandshake",
              "documentation": {
                "identifier": "keyLogLabelClientHandshake",
                "newPage": false,
                "searchKey": "tls.keyLogLabelClientHandshake",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const keyLogLabelClientHandshake"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst keyLogLabelClientHandshake = \"CLIENT_HANDSHAKE_TRAFFIC_SECRET\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyLogLabelServerHandshake",
              "documentation": {
                "identifier": "keyLogLabelServerHandshake",
                "newPage": false,
                "searchKey": "tls.keyLogLabelServerHandshake",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const keyLogLabelServerHandshake"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst keyLogLabelServerHandshake = \"SERVER_HANDSHAKE_TRAFFIC_SECRET\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyLogLabelClientTraffic",
              "documentation": {
                "identifier": "keyLogLabelClientTraffic",
                "newPage": false,
                "searchKey": "tls.keyLogLabelClientTraffic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const keyLogLabelClientTraffic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst keyLogLabelClientTraffic = \"CLIENT_TRAFFIC_SECRET_0\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyLogLabelServerTraffic",
              "documentation": {
                "identifier": "keyLogLabelServerTraffic",
                "newPage": false,
                "searchKey": "tls.keyLogLabelServerTraffic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const keyLogLabelServerTraffic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst keyLogLabelServerTraffic = \"SERVER_TRAFFIC_SECRET_0\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_SignatureScheme_name_0",
              "documentation": {
                "identifier": "_SignatureScheme_name_0",
                "newPage": false,
                "searchKey": "tls._SignatureScheme_name_0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SignatureScheme_name_0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SignatureScheme_name_0 = \"PKCS1WithSHA1\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_SignatureScheme_name_1",
              "documentation": {
                "identifier": "_SignatureScheme_name_1",
                "newPage": false,
                "searchKey": "tls._SignatureScheme_name_1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SignatureScheme_name_1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SignatureScheme_name_1 = \"ECDSAWithSHA1\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_SignatureScheme_name_2",
              "documentation": {
                "identifier": "_SignatureScheme_name_2",
                "newPage": false,
                "searchKey": "tls._SignatureScheme_name_2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SignatureScheme_name_2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SignatureScheme_name_2 = \"PKCS1WithSHA256\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_SignatureScheme_name_3",
              "documentation": {
                "identifier": "_SignatureScheme_name_3",
                "newPage": false,
                "searchKey": "tls._SignatureScheme_name_3",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SignatureScheme_name_3"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SignatureScheme_name_3 = \"ECDSAWithP256AndSHA256\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_SignatureScheme_name_4",
              "documentation": {
                "identifier": "_SignatureScheme_name_4",
                "newPage": false,
                "searchKey": "tls._SignatureScheme_name_4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SignatureScheme_name_4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SignatureScheme_name_4 = \"PKCS1WithSHA384\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_SignatureScheme_name_5",
              "documentation": {
                "identifier": "_SignatureScheme_name_5",
                "newPage": false,
                "searchKey": "tls._SignatureScheme_name_5",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SignatureScheme_name_5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SignatureScheme_name_5 = \"ECDSAWithP384AndSHA384\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_SignatureScheme_name_6",
              "documentation": {
                "identifier": "_SignatureScheme_name_6",
                "newPage": false,
                "searchKey": "tls._SignatureScheme_name_6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SignatureScheme_name_6"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SignatureScheme_name_6 = \"PKCS1WithSHA512\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_SignatureScheme_name_7",
              "documentation": {
                "identifier": "_SignatureScheme_name_7",
                "newPage": false,
                "searchKey": "tls._SignatureScheme_name_7",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SignatureScheme_name_7"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SignatureScheme_name_7 = \"ECDSAWithP521AndSHA512\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_SignatureScheme_name_8",
              "documentation": {
                "identifier": "_SignatureScheme_name_8",
                "newPage": false,
                "searchKey": "tls._SignatureScheme_name_8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SignatureScheme_name_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SignatureScheme_name_8 = \"PSSWithSHA256PSSWithSHA384PSSWithSHA512Ed25519\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_CurveID_name_0",
              "documentation": {
                "identifier": "_CurveID_name_0",
                "newPage": false,
                "searchKey": "tls._CurveID_name_0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _CurveID_name_0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _CurveID_name_0 = \"CurveP256CurveP384CurveP521\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_CurveID_name_1",
              "documentation": {
                "identifier": "_CurveID_name_1",
                "newPage": false,
                "searchKey": "tls._CurveID_name_1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _CurveID_name_1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _CurveID_name_1 = \"X25519\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_ClientAuthType_name",
              "documentation": {
                "identifier": "_ClientAuthType_name",
                "newPage": false,
                "searchKey": "tls._ClientAuthType_name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _ClientAuthType_name"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _ClientAuthType_name = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#tcpMSSEstimate",
              "documentation": {
                "identifier": "tcpMSSEstimate",
                "newPage": false,
                "searchKey": "tls.tcpMSSEstimate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tcpMSSEstimate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tcpMSSEstimate = 1208\n```\n\ntcpMSSEstimate is a conservative estimate of the TCP maximum segment size (MSS). A constant is used, rather than querying the kernel for the actual MSS, to avoid complexity. The value here is the IPv6 minimum MTU (1280 bytes) minus the overhead of an IPv6 header (40 bytes) and a TCP header with timestamps (32 bytes). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#recordSizeBoostThreshold",
              "documentation": {
                "identifier": "recordSizeBoostThreshold",
                "newPage": false,
                "searchKey": "tls.recordSizeBoostThreshold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const recordSizeBoostThreshold"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst recordSizeBoostThreshold = 128 * 1024\n```\n\nrecordSizeBoostThreshold is the number of bytes of application data sent after which the TLS record size will be increased to the maximum. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#maxClientPSKIdentities",
              "documentation": {
                "identifier": "maxClientPSKIdentities",
                "newPage": false,
                "searchKey": "tls.maxClientPSKIdentities",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxClientPSKIdentities"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxClientPSKIdentities = 5\n```\n\nmaxClientPSKIdentities is the number of client PSK identities the server will attempt to validate. It will ignore the rest not to let cheap ClientHello messages cause too much work in session ticket decryption attempts. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#resumptionBinderLabel",
              "documentation": {
                "identifier": "resumptionBinderLabel",
                "newPage": false,
                "searchKey": "tls.resumptionBinderLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const resumptionBinderLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst resumptionBinderLabel = \"res binder\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientHandshakeTrafficLabel",
              "documentation": {
                "identifier": "clientHandshakeTrafficLabel",
                "newPage": false,
                "searchKey": "tls.clientHandshakeTrafficLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const clientHandshakeTrafficLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst clientHandshakeTrafficLabel = \"c hs traffic\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#serverHandshakeTrafficLabel",
              "documentation": {
                "identifier": "serverHandshakeTrafficLabel",
                "newPage": false,
                "searchKey": "tls.serverHandshakeTrafficLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const serverHandshakeTrafficLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst serverHandshakeTrafficLabel = \"s hs traffic\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientApplicationTrafficLabel",
              "documentation": {
                "identifier": "clientApplicationTrafficLabel",
                "newPage": false,
                "searchKey": "tls.clientApplicationTrafficLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const clientApplicationTrafficLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst clientApplicationTrafficLabel = \"c ap traffic\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#serverApplicationTrafficLabel",
              "documentation": {
                "identifier": "serverApplicationTrafficLabel",
                "newPage": false,
                "searchKey": "tls.serverApplicationTrafficLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const serverApplicationTrafficLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst serverApplicationTrafficLabel = \"s ap traffic\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#exporterLabel",
              "documentation": {
                "identifier": "exporterLabel",
                "newPage": false,
                "searchKey": "tls.exporterLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const exporterLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst exporterLabel = \"exp master\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#resumptionLabel",
              "documentation": {
                "identifier": "resumptionLabel",
                "newPage": false,
                "searchKey": "tls.resumptionLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const resumptionLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst resumptionLabel = \"res master\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#trafficUpdateLabel",
              "documentation": {
                "identifier": "trafficUpdateLabel",
                "newPage": false,
                "searchKey": "tls.trafficUpdateLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const trafficUpdateLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst trafficUpdateLabel = \"traffic upd\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#masterSecretLength",
              "documentation": {
                "identifier": "masterSecretLength",
                "newPage": false,
                "searchKey": "tls.masterSecretLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const masterSecretLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst masterSecretLength = 48 // Length of a master secret in TLS 1.1.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#finishedVerifyLength",
              "documentation": {
                "identifier": "finishedVerifyLength",
                "newPage": false,
                "searchKey": "tls.finishedVerifyLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const finishedVerifyLength"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst finishedVerifyLength = 12 // Length of verify_data in a Finished message.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#opensslRenegotiate",
              "documentation": {
                "identifier": "opensslRenegotiate",
                "newPage": false,
                "searchKey": "tls.opensslRenegotiate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opensslRenegotiate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opensslRenegotiate opensslInputEvent = iota\n```\n\nopensslRenegotiate causes OpenSSL to request a renegotiation of the connection. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#opensslSendSentinel",
              "documentation": {
                "identifier": "opensslSendSentinel",
                "newPage": false,
                "searchKey": "tls.opensslSendSentinel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opensslSendSentinel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opensslSendSentinel\n```\n\nopensslSendBanner causes OpenSSL to send the contents of opensslSentinel on the connection. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#opensslKeyUpdate",
              "documentation": {
                "identifier": "opensslKeyUpdate",
                "newPage": false,
                "searchKey": "tls.opensslKeyUpdate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opensslKeyUpdate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opensslKeyUpdate\n```\n\nopensslKeyUpdate causes OpenSSL to send a key update message to the client and request one back. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#opensslSentinel",
              "documentation": {
                "identifier": "opensslSentinel",
                "newPage": false,
                "searchKey": "tls.opensslSentinel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opensslSentinel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opensslSentinel = \"SENTINEL\\n\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#opensslEndOfHandshake",
              "documentation": {
                "identifier": "opensslEndOfHandshake",
                "newPage": false,
                "searchKey": "tls.opensslEndOfHandshake",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opensslEndOfHandshake"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opensslEndOfHandshake = \"SSL_accept:SSLv3/TLS write finished\"\n```\n\nopensslEndOfHandshake is a message that the “openssl s_server” tool will print when a handshake completes if run with “-state”. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#opensslReadKeyUpdate",
              "documentation": {
                "identifier": "opensslReadKeyUpdate",
                "newPage": false,
                "searchKey": "tls.opensslReadKeyUpdate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opensslReadKeyUpdate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opensslReadKeyUpdate = \"SSL_accept:TLSv1.3 read client key update\"\n```\n\nopensslReadKeyUpdate is a message that the “openssl s_server” tool will print when a KeyUpdate message is received if run with “-state”. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#sctsBase64",
              "documentation": {
                "identifier": "sctsBase64",
                "newPage": false,
                "searchKey": "tls.sctsBase64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sctsBase64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sctsBase64 = ...\n```\n\nsctsBase64 contains data from `openssl s_client -serverinfo 18 -connect ritter.vg:443` \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#localFlakes",
              "documentation": {
                "identifier": "localFlakes",
                "newPage": false,
                "searchKey": "tls.localFlakes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const localFlakes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst localFlakes = 0 // change to 1 or 2 to exercise localServer/localPipe handling of mismatches\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientCertificatePEM",
              "documentation": {
                "identifier": "clientCertificatePEM",
                "newPage": false,
                "searchKey": "tls.clientCertificatePEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const clientCertificatePEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst clientCertificatePEM = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientECDSACertificatePEM",
              "documentation": {
                "identifier": "clientECDSACertificatePEM",
                "newPage": false,
                "searchKey": "tls.clientECDSACertificatePEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const clientECDSACertificatePEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst clientECDSACertificatePEM = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientEd25519CertificatePEM",
              "documentation": {
                "identifier": "clientEd25519CertificatePEM",
                "newPage": false,
                "searchKey": "tls.clientEd25519CertificatePEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const clientEd25519CertificatePEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst clientEd25519CertificatePEM = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/crypto/tls#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/crypto/tls#alertText",
              "documentation": {
                "identifier": "alertText",
                "newPage": false,
                "searchKey": "tls.alertText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var alertText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar alertText = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#signaturePadding",
              "documentation": {
                "identifier": "signaturePadding",
                "newPage": false,
                "searchKey": "tls.signaturePadding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var signaturePadding"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar signaturePadding = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#rsaSignatureSchemes",
              "documentation": {
                "identifier": "rsaSignatureSchemes",
                "newPage": false,
                "searchKey": "tls.rsaSignatureSchemes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var rsaSignatureSchemes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar rsaSignatureSchemes = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#supportedUpToTLS12",
              "documentation": {
                "identifier": "supportedUpToTLS12",
                "newPage": false,
                "searchKey": "tls.supportedUpToTLS12",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var supportedUpToTLS12"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar supportedUpToTLS12 = []uint16{VersionTLS10, VersionTLS11, VersionTLS12}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#supportedOnlyTLS12",
              "documentation": {
                "identifier": "supportedOnlyTLS12",
                "newPage": false,
                "searchKey": "tls.supportedOnlyTLS12",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var supportedOnlyTLS12"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar supportedOnlyTLS12 = []uint16{VersionTLS12}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#supportedOnlyTLS13",
              "documentation": {
                "identifier": "supportedOnlyTLS13",
                "newPage": false,
                "searchKey": "tls.supportedOnlyTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var supportedOnlyTLS13"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar supportedOnlyTLS13 = []uint16{VersionTLS13}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cipherSuites",
              "documentation": {
                "identifier": "cipherSuites",
                "newPage": false,
                "searchKey": "tls.cipherSuites",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cipherSuites"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cipherSuites = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cipherSuitesTLS13",
              "documentation": {
                "identifier": "cipherSuitesTLS13",
                "newPage": false,
                "searchKey": "tls.cipherSuitesTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cipherSuitesTLS13"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cipherSuitesTLS13 = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cipherSuitesPreferenceOrder",
              "documentation": {
                "identifier": "cipherSuitesPreferenceOrder",
                "newPage": false,
                "searchKey": "tls.cipherSuitesPreferenceOrder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cipherSuitesPreferenceOrder"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cipherSuitesPreferenceOrder = ...\n```\n\ncipherSuitesPreferenceOrder is the order in which we'll select (on the server) or advertise (on the client) TLS 1.0–1.2 cipher suites. \n\nCipher suites are filtered but not reordered based on the application and peer's preferences, meaning we'll never select a suite lower in this list if any higher one is available. This makes it more defensible to keep weaker cipher suites enabled, especially on the server side where we get the last word, since there are no known downgrade attacks on cipher suites selection. \n\nThe list is sorted by applying the following priority rules, stopping at the first (most important) applicable one: \n\n```\n- Anything else comes before RC4\n\n    RC4 has practically exploitable biases. See [https://www.rc4nomore.com](https://www.rc4nomore.com).\n\n- Anything else comes before CBC_SHA256\n\n    SHA-256 variants of the CBC ciphersuites don't implement any Lucky13\n    countermeasures. See [http://www.isg.rhul.ac.uk/tls/Lucky13.html](http://www.isg.rhul.ac.uk/tls/Lucky13.html) and\n    [https://www.imperialviolet.org/2013/02/04/luckythirteen.html](https://www.imperialviolet.org/2013/02/04/luckythirteen.html).\n\n- Anything else comes before 3DES\n\n    3DES has 64-bit blocks, which makes it fundamentally susceptible to\n    birthday attacks. See [https://sweet32.info](https://sweet32.info).\n\n- ECDHE comes before anything else\n\n    Once we got the broken stuff out of the way, the most important\n    property a cipher suite can have is forward secrecy. We don't\n    implement FFDHE, so that means ECDHE.\n\n- AEADs come before CBC ciphers\n\n    Even with Lucky13 countermeasures, MAC-then-Encrypt CBC cipher suites\n    are fundamentally fragile, and suffered from an endless sequence of\n    padding oracle attacks. See [https://eprint.iacr.org/2015/1129](https://eprint.iacr.org/2015/1129),\n    [https://www.imperialviolet.org/2014/12/08/poodleagain.html](https://www.imperialviolet.org/2014/12/08/poodleagain.html), and\n    [https://blog.cloudflare.com/yet-another-padding-oracle-in-openssl-cbc-ciphersuites/](https://blog.cloudflare.com/yet-another-padding-oracle-in-openssl-cbc-ciphersuites/).\n\n- AES comes before ChaCha20\n\n    When AES hardware is available, AES-128-GCM and AES-256-GCM are faster\n    than ChaCha20Poly1305.\n\n    When AES hardware is not available, AES-128-GCM is one or more of: much\n    slower, way more complex, and less safe (because not constant time)\n    than ChaCha20Poly1305.\n\n    We use this list if we think both peers have AES hardware, and\n    cipherSuitesPreferenceOrderNoAES otherwise.\n\n- AES-128 comes before AES-256\n\n    The only potential advantages of AES-256 are better multi-target\n    margins, and hypothetical post-quantum properties. Neither apply to\n    TLS, and AES-256 is slower due to its four extra rounds (which don't\n    contribute to the advantages above).\n\n- ECDSA comes before RSA\n\n    The relative order of ECDSA and RSA cipher suites doesn't matter,\n    as they depend on the certificate. Pick one to get a stable order.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cipherSuitesPreferenceOrderNoAES",
              "documentation": {
                "identifier": "cipherSuitesPreferenceOrderNoAES",
                "newPage": false,
                "searchKey": "tls.cipherSuitesPreferenceOrderNoAES",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cipherSuitesPreferenceOrderNoAES"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cipherSuitesPreferenceOrderNoAES = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#disabledCipherSuites",
              "documentation": {
                "identifier": "disabledCipherSuites",
                "newPage": false,
                "searchKey": "tls.disabledCipherSuites",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var disabledCipherSuites"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar disabledCipherSuites = ...\n```\n\ndisabledCipherSuites are not used unless explicitly listed in Config.CipherSuites. They MUST be at the end of cipherSuitesPreferenceOrder. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#defaultCipherSuitesLen",
              "documentation": {
                "identifier": "defaultCipherSuitesLen",
                "newPage": false,
                "searchKey": "tls.defaultCipherSuitesLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var defaultCipherSuitesLen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar defaultCipherSuitesLen = len(cipherSuitesPreferenceOrder) - len(disabledCipherSuites)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#defaultCipherSuites",
              "documentation": {
                "identifier": "defaultCipherSuites",
                "newPage": false,
                "searchKey": "tls.defaultCipherSuites",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var defaultCipherSuites"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar defaultCipherSuites = cipherSuitesPreferenceOrder[:defaultCipherSuitesLen]\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#defaultCipherSuitesTLS13",
              "documentation": {
                "identifier": "defaultCipherSuitesTLS13",
                "newPage": false,
                "searchKey": "tls.defaultCipherSuitesTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var defaultCipherSuitesTLS13"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar defaultCipherSuitesTLS13 = ...\n```\n\ndefaultCipherSuitesTLS13 is also the preference order, since there are no disabled by default TLS 1.3 cipher suites. The same AES vs ChaCha20 logic as cipherSuitesPreferenceOrder applies. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#defaultCipherSuitesTLS13NoAES",
              "documentation": {
                "identifier": "defaultCipherSuitesTLS13NoAES",
                "newPage": false,
                "searchKey": "tls.defaultCipherSuitesTLS13NoAES",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var defaultCipherSuitesTLS13NoAES"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar defaultCipherSuitesTLS13NoAES = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#hasGCMAsmAMD64",
              "documentation": {
                "identifier": "hasGCMAsmAMD64",
                "newPage": false,
                "searchKey": "tls.hasGCMAsmAMD64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var hasGCMAsmAMD64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar hasGCMAsmAMD64 = cpu.X86.HasAES && cpu.X86.HasPCLMULQDQ\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#hasGCMAsmARM64",
              "documentation": {
                "identifier": "hasGCMAsmARM64",
                "newPage": false,
                "searchKey": "tls.hasGCMAsmARM64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var hasGCMAsmARM64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar hasGCMAsmARM64 = cpu.ARM64.HasAES && cpu.ARM64.HasPMULL\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#hasGCMAsmS390X",
              "documentation": {
                "identifier": "hasGCMAsmS390X",
                "newPage": false,
                "searchKey": "tls.hasGCMAsmS390X",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var hasGCMAsmS390X"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar hasGCMAsmS390X = ...\n```\n\nKeep in sync with crypto/aes/cipher_s390x.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#hasAESGCMHardwareSupport",
              "documentation": {
                "identifier": "hasAESGCMHardwareSupport",
                "newPage": false,
                "searchKey": "tls.hasAESGCMHardwareSupport",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var hasAESGCMHardwareSupport"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar hasAESGCMHardwareSupport = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#aesgcmCiphers",
              "documentation": {
                "identifier": "aesgcmCiphers",
                "newPage": false,
                "searchKey": "tls.aesgcmCiphers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var aesgcmCiphers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar aesgcmCiphers = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#nonAESGCMAEADCiphers",
              "documentation": {
                "identifier": "nonAESGCMAEADCiphers",
                "newPage": false,
                "searchKey": "tls.nonAESGCMAEADCiphers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var nonAESGCMAEADCiphers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar nonAESGCMAEADCiphers = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#directSigning",
              "documentation": {
                "identifier": "directSigning",
                "newPage": false,
                "searchKey": "tls.directSigning",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var directSigning"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar directSigning crypto.Hash = 0\n```\n\ndirectSigning is a standard Hash value that signals that no pre-hashing should be performed, and that the input should be signed directly. It is the hash function associated with the Ed25519 signature scheme. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#supportedSignatureAlgorithms",
              "documentation": {
                "identifier": "supportedSignatureAlgorithms",
                "newPage": false,
                "searchKey": "tls.supportedSignatureAlgorithms",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var supportedSignatureAlgorithms"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar supportedSignatureAlgorithms = ...\n```\n\nsupportedSignatureAlgorithms contains the signature and hash algorithms that the code advertises as supported in a TLS 1.2+ ClientHello and in a TLS 1.2+ CertificateRequest. The two fields are merged to match with TLS 1.3. Note that in TLS 1.2, the ECDSA algorithms are not constrained to P-256, etc. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#helloRetryRequestRandom",
              "documentation": {
                "identifier": "helloRetryRequestRandom",
                "newPage": false,
                "searchKey": "tls.helloRetryRequestRandom",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var helloRetryRequestRandom"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar helloRetryRequestRandom = ...\n```\n\nhelloRetryRequestRandom is set as the Random value of a ServerHello to signal that the message is actually a HelloRetryRequest. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testingOnlyForceDowngradeCanary",
              "documentation": {
                "identifier": "testingOnlyForceDowngradeCanary",
                "newPage": false,
                "searchKey": "tls.testingOnlyForceDowngradeCanary",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testingOnlyForceDowngradeCanary"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testingOnlyForceDowngradeCanary bool\n```\n\ntestingOnlyForceDowngradeCanary is set in tests to force the server side to include downgrade canaries even if it's using its highers supported version. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#deprecatedSessionTicketKey",
              "documentation": {
                "identifier": "deprecatedSessionTicketKey",
                "newPage": false,
                "searchKey": "tls.deprecatedSessionTicketKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var deprecatedSessionTicketKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar deprecatedSessionTicketKey = []byte(\"DEPRECATED\")\n```\n\ndeprecatedSessionTicketKey is set as the prefix of SessionTicketKey if it was randomized for backwards compatibility but is not in use. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#supportedVersions",
              "documentation": {
                "identifier": "supportedVersions",
                "newPage": false,
                "searchKey": "tls.supportedVersions",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var supportedVersions"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar supportedVersions = []uint16{\n\tVersionTLS13,\n\tVersionTLS12,\n\tVersionTLS11,\n\tVersionTLS10,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#defaultCurvePreferences",
              "documentation": {
                "identifier": "defaultCurvePreferences",
                "newPage": false,
                "searchKey": "tls.defaultCurvePreferences",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var defaultCurvePreferences"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar defaultCurvePreferences = []CurveID{X25519, CurveP256, CurveP384, CurveP521}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#errNoCertificates",
              "documentation": {
                "identifier": "errNoCertificates",
                "newPage": false,
                "searchKey": "tls.errNoCertificates",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errNoCertificates"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errNoCertificates = errors.New(\"tls: no certificates configured\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#writerMutex",
              "documentation": {
                "identifier": "writerMutex",
                "newPage": false,
                "searchKey": "tls.writerMutex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var writerMutex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar writerMutex sync.Mutex\n```\n\nwriterMutex protects all KeyLogWriters globally. It is rarely enabled, and is only for debugging, so a global mutex saves space. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#emptyConfig",
              "documentation": {
                "identifier": "emptyConfig",
                "newPage": false,
                "searchKey": "tls.emptyConfig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var emptyConfig"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar emptyConfig Config\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_SignatureScheme_index_8",
              "documentation": {
                "identifier": "_SignatureScheme_index_8",
                "newPage": false,
                "searchKey": "tls._SignatureScheme_index_8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _SignatureScheme_index_8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _SignatureScheme_index_8 = [...]uint8{0, 13, 26, 39, 46}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_CurveID_index_0",
              "documentation": {
                "identifier": "_CurveID_index_0",
                "newPage": false,
                "searchKey": "tls._CurveID_index_0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _CurveID_index_0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _CurveID_index_0 = [...]uint8{0, 9, 18, 27}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_ClientAuthType_index",
              "documentation": {
                "identifier": "_ClientAuthType_index",
                "newPage": false,
                "searchKey": "tls._ClientAuthType_index",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _ClientAuthType_index"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _ClientAuthType_index = [...]uint8{0, 12, 29, 49, 72, 98}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#outBufPool",
              "documentation": {
                "identifier": "outBufPool",
                "newPage": false,
                "searchKey": "tls.outBufPool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var outBufPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar outBufPool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn new([]byte)\n\t},\n}\n```\n\noutBufPool pools the record-sized scratch buffers used by writeRecordLocked. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#errShutdown",
              "documentation": {
                "identifier": "errShutdown",
                "newPage": false,
                "searchKey": "tls.errShutdown",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errShutdown"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errShutdown = errors.New(\"tls: protocol is shutdown\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#errEarlyCloseWrite",
              "documentation": {
                "identifier": "errEarlyCloseWrite",
                "newPage": false,
                "searchKey": "tls.errEarlyCloseWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errEarlyCloseWrite"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errEarlyCloseWrite = errors.New(\"tls: CloseWrite called before handshake complete\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#errClientKeyExchange",
              "documentation": {
                "identifier": "errClientKeyExchange",
                "newPage": false,
                "searchKey": "tls.errClientKeyExchange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errClientKeyExchange"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errClientKeyExchange = errors.New(\"tls: invalid ClientKeyExchange message\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#errServerKeyExchange",
              "documentation": {
                "identifier": "errServerKeyExchange",
                "newPage": false,
                "searchKey": "tls.errServerKeyExchange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errServerKeyExchange"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errServerKeyExchange = errors.New(\"tls: invalid ServerKeyExchange message\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#masterSecretLabel",
              "documentation": {
                "identifier": "masterSecretLabel",
                "newPage": false,
                "searchKey": "tls.masterSecretLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var masterSecretLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar masterSecretLabel = []byte(\"master secret\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyExpansionLabel",
              "documentation": {
                "identifier": "keyExpansionLabel",
                "newPage": false,
                "searchKey": "tls.keyExpansionLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var keyExpansionLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar keyExpansionLabel = []byte(\"key expansion\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientFinishedLabel",
              "documentation": {
                "identifier": "clientFinishedLabel",
                "newPage": false,
                "searchKey": "tls.clientFinishedLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var clientFinishedLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar clientFinishedLabel = []byte(\"client finished\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#serverFinishedLabel",
              "documentation": {
                "identifier": "serverFinishedLabel",
                "newPage": false,
                "searchKey": "tls.serverFinishedLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var serverFinishedLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar serverFinishedLabel = []byte(\"server finished\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#padding255Bad",
              "documentation": {
                "identifier": "padding255Bad",
                "newPage": false,
                "searchKey": "tls.padding255Bad",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var padding255Bad"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar padding255Bad = [256]byte{}\n```\n\nwill be initialized with {0, 255, 255, ..., 255} \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#padding255Good",
              "documentation": {
                "identifier": "padding255Good",
                "newPage": false,
                "searchKey": "tls.padding255Good",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var padding255Good"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar padding255Good = [256]byte{255}\n```\n\nwill be initialized with {255, 255, 255, ..., 255} \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#paddingTests",
              "documentation": {
                "identifier": "paddingTests",
                "newPage": false,
                "searchKey": "tls.paddingTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var paddingTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar paddingTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#certExampleCom",
              "documentation": {
                "identifier": "certExampleCom",
                "newPage": false,
                "searchKey": "tls.certExampleCom",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var certExampleCom"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar certExampleCom = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#certWildcardExampleCom",
              "documentation": {
                "identifier": "certWildcardExampleCom",
                "newPage": false,
                "searchKey": "tls.certWildcardExampleCom",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var certWildcardExampleCom"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar certWildcardExampleCom = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#certFooExampleCom",
              "documentation": {
                "identifier": "certFooExampleCom",
                "newPage": false,
                "searchKey": "tls.certFooExampleCom",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var certFooExampleCom"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar certFooExampleCom = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#serverCommand",
              "documentation": {
                "identifier": "serverCommand",
                "newPage": false,
                "searchKey": "tls.serverCommand",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var serverCommand"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar serverCommand = []string{\"openssl\", \"s_server\", \"-no_ticket\", \"-num_tickets\", \"0\"}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#hostnameInSNITests",
              "documentation": {
                "identifier": "hostnameInSNITests",
                "newPage": false,
                "searchKey": "tls.hostnameInSNITests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var hostnameInSNITests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar hostnameInSNITests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#brokenConnErr",
              "documentation": {
                "identifier": "brokenConnErr",
                "newPage": false,
                "searchKey": "tls.brokenConnErr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var brokenConnErr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar brokenConnErr = errors.New(\"too many writes to brokenConn\")\n```\n\nbrokenConnErr is the error that brokenConn returns once exhausted. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#getClientCertificateTests",
              "documentation": {
                "identifier": "getClientCertificateTests",
                "newPage": false,
                "searchKey": "tls.getClientCertificateTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var getClientCertificateTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar getClientCertificateTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#tests",
              "documentation": {
                "identifier": "tests",
                "newPage": false,
                "searchKey": "tls.tests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#badProtocolVersions",
              "documentation": {
                "identifier": "badProtocolVersions",
                "newPage": false,
                "searchKey": "tls.badProtocolVersions",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var badProtocolVersions"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badProtocolVersions = []uint16{0x0000, 0x0005, 0x0100, 0x0105, 0x0200, 0x0205, VersionSSL30}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#defaultClientCommand",
              "documentation": {
                "identifier": "defaultClientCommand",
                "newPage": false,
                "searchKey": "tls.defaultClientCommand",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var defaultClientCommand"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar defaultClientCommand = []string{\"openssl\", \"s_client\", \"-no_ticket\"}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#getConfigForClientTests",
              "documentation": {
                "identifier": "getConfigForClientTests",
                "newPage": false,
                "searchKey": "tls.getConfigForClientTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var getConfigForClientTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar getConfigForClientTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#update",
              "documentation": {
                "identifier": "update",
                "newPage": false,
                "searchKey": "tls.update",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var update"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar update = flag.Bool(\"update\", false, \"update golden files on failure\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#fast",
              "documentation": {
                "identifier": "fast",
                "newPage": false,
                "searchKey": "tls.fast",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fast"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fast = flag.Bool(\"fast\", false, \"impose a quick, possibly flaky timeout on recorded tests\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyFile",
              "documentation": {
                "identifier": "keyFile",
                "newPage": false,
                "searchKey": "tls.keyFile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var keyFile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar keyFile = flag.String(\"keylog\", \"\", \"destination file for KeyLogWriter\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#localListener",
              "documentation": {
                "identifier": "localListener",
                "newPage": false,
                "searchKey": "tls.localListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var localListener"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar localListener struct {\n\tmu   sync.Mutex\n\taddr net.Addr\n\tch   chan net.Conn\n}\n```\n\nlocalListener is set up by TestMain and used by localPipe to create Conn pairs like net.Pipe, but connected by an actual buffered TCP connection. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#isConnRefused",
              "documentation": {
                "identifier": "isConnRefused",
                "newPage": false,
                "searchKey": "tls.isConnRefused",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var isConnRefused"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar isConnRefused = func(err error) bool { return false }\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testConfig",
              "documentation": {
                "identifier": "testConfig",
                "newPage": false,
                "searchKey": "tls.testConfig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testConfig"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testConfig *Config\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testRSACertificate",
              "documentation": {
                "identifier": "testRSACertificate",
                "newPage": false,
                "searchKey": "tls.testRSACertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testRSACertificate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testRSACertificate = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testRSACertificateIssuer",
              "documentation": {
                "identifier": "testRSACertificateIssuer",
                "newPage": false,
                "searchKey": "tls.testRSACertificateIssuer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testRSACertificateIssuer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testRSACertificateIssuer = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testRSAPSSCertificate",
              "documentation": {
                "identifier": "testRSAPSSCertificate",
                "newPage": false,
                "searchKey": "tls.testRSAPSSCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testRSAPSSCertificate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testRSAPSSCertificate = ...\n```\n\ntestRSAPSSCertificate has signatureAlgorithm rsassaPss, but subjectPublicKeyInfo algorithm rsaEncryption, for use with the rsa_pss_rsae_* SignatureSchemes. See also TestRSAPSSKeyError. testRSAPSSCertificate is self-signed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testECDSACertificate",
              "documentation": {
                "identifier": "testECDSACertificate",
                "newPage": false,
                "searchKey": "tls.testECDSACertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testECDSACertificate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testECDSACertificate = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testEd25519Certificate",
              "documentation": {
                "identifier": "testEd25519Certificate",
                "newPage": false,
                "searchKey": "tls.testEd25519Certificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testEd25519Certificate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testEd25519Certificate = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testSNICertificate",
              "documentation": {
                "identifier": "testSNICertificate",
                "newPage": false,
                "searchKey": "tls.testSNICertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testSNICertificate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testSNICertificate = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testP256Certificate",
              "documentation": {
                "identifier": "testP256Certificate",
                "newPage": false,
                "searchKey": "tls.testP256Certificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testP256Certificate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testP256Certificate = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testRSAPrivateKey",
              "documentation": {
                "identifier": "testRSAPrivateKey",
                "newPage": false,
                "searchKey": "tls.testRSAPrivateKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testRSAPrivateKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testRSAPrivateKey, _ = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testECDSAPrivateKey",
              "documentation": {
                "identifier": "testECDSAPrivateKey",
                "newPage": false,
                "searchKey": "tls.testECDSAPrivateKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testECDSAPrivateKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testECDSAPrivateKey, _ = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testP256PrivateKey",
              "documentation": {
                "identifier": "testP256PrivateKey",
                "newPage": false,
                "searchKey": "tls.testP256PrivateKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testP256PrivateKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testP256PrivateKey, _ = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testEd25519PrivateKey",
              "documentation": {
                "identifier": "testEd25519PrivateKey",
                "newPage": false,
                "searchKey": "tls.testEd25519PrivateKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testEd25519PrivateKey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testEd25519PrivateKey = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientKeyPEM",
              "documentation": {
                "identifier": "clientKeyPEM",
                "newPage": false,
                "searchKey": "tls.clientKeyPEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var clientKeyPEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar clientKeyPEM = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientECDSAKeyPEM",
              "documentation": {
                "identifier": "clientECDSAKeyPEM",
                "newPage": false,
                "searchKey": "tls.clientECDSAKeyPEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var clientECDSAKeyPEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar clientECDSAKeyPEM = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientEd25519KeyPEM",
              "documentation": {
                "identifier": "clientEd25519KeyPEM",
                "newPage": false,
                "searchKey": "tls.clientEd25519KeyPEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var clientEd25519KeyPEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar clientEd25519KeyPEM = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testSplitPreMasterSecretTests",
              "documentation": {
                "identifier": "testSplitPreMasterSecretTests",
                "newPage": false,
                "searchKey": "tls.testSplitPreMasterSecretTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testSplitPreMasterSecretTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testSplitPreMasterSecretTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testKeysFromTests",
              "documentation": {
                "identifier": "testKeysFromTests",
                "newPage": false,
                "searchKey": "tls.testKeysFromTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testKeysFromTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testKeysFromTests = ...\n```\n\nThese test vectors were generated from GnuTLS using `gnutls-cli --insecure -d 9 ` \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#rsaCertPEM",
              "documentation": {
                "identifier": "rsaCertPEM",
                "newPage": false,
                "searchKey": "tls.rsaCertPEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var rsaCertPEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar rsaCertPEM = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#rsaKeyPEM",
              "documentation": {
                "identifier": "rsaKeyPEM",
                "newPage": false,
                "searchKey": "tls.rsaKeyPEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var rsaKeyPEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar rsaKeyPEM = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyPEM",
              "documentation": {
                "identifier": "keyPEM",
                "newPage": false,
                "searchKey": "tls.keyPEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var keyPEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar keyPEM = ...\n```\n\nkeyPEM is the same as rsaKeyPEM, but declares itself as just \"PRIVATE KEY\", not \"RSA PRIVATE KEY\".  [https://golang.org/issue/4477](https://golang.org/issue/4477) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ecdsaCertPEM",
              "documentation": {
                "identifier": "ecdsaCertPEM",
                "newPage": false,
                "searchKey": "tls.ecdsaCertPEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ecdsaCertPEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ecdsaCertPEM = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ecdsaKeyPEM",
              "documentation": {
                "identifier": "ecdsaKeyPEM",
                "newPage": false,
                "searchKey": "tls.ecdsaKeyPEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ecdsaKeyPEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ecdsaKeyPEM = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyPairTests",
              "documentation": {
                "identifier": "keyPairTests",
                "newPage": false,
                "searchKey": "tls.keyPairTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var keyPairTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar keyPairTests = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/crypto/tls#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/crypto/tls#alert",
              "documentation": {
                "identifier": "alert",
                "newPage": false,
                "searchKey": "tls.alert",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type alert uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype alert uint8\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#alert.String",
                    "documentation": {
                      "identifier": "alert.String",
                      "newPage": false,
                      "searchKey": "tls.alert.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e alert) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e alert) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#alert.Error",
                    "documentation": {
                      "identifier": "alert.Error",
                      "newPage": false,
                      "searchKey": "tls.alert.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e alert) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e alert) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#CipherSuite",
              "documentation": {
                "identifier": "CipherSuite",
                "newPage": false,
                "searchKey": "tls.CipherSuite",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type CipherSuite struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype CipherSuite struct {\n\tID   uint16\n\tName string\n\n\t// Supported versions is the list of TLS protocol versions that can\n\t// negotiate this cipher suite.\n\tSupportedVersions []uint16\n\n\t// Insecure is true if the cipher suite has known security issues\n\t// due to its primitives, design, or implementation.\n\tInsecure bool\n}\n```\n\nCipherSuite is a TLS cipher suite. Note that most functions in this package accept and expose cipher suite IDs instead of this type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cipherSuite",
              "documentation": {
                "identifier": "cipherSuite",
                "newPage": false,
                "searchKey": "tls.cipherSuite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cipherSuite struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cipherSuite struct {\n\tid uint16\n\t// the lengths, in bytes, of the key material needed for each component.\n\tkeyLen int\n\tmacLen int\n\tivLen  int\n\tka     func(version uint16) keyAgreement\n\t// flags is a bitmask of the suite* values, above.\n\tflags  int\n\tcipher func(key, iv []byte, isRead bool) interface{}\n\tmac    func(key []byte) hash.Hash\n\taead   func(key, fixedNonce []byte) aead\n}\n```\n\nA cipherSuite is a TLS 1.0–1.2 cipher suite, and defines the key exchange mechanism, as well as the cipher+MAC pair or the AEAD. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#selectCipherSuite",
                    "documentation": {
                      "identifier": "selectCipherSuite",
                      "newPage": false,
                      "searchKey": "tls.selectCipherSuite",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func selectCipherSuite(ids, supportedIDs []uint16, ok func(*cipherSuite) bool) *cipherSuite"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc selectCipherSuite(ids, supportedIDs []uint16, ok func(*cipherSuite) bool) *cipherSuite\n```\n\nselectCipherSuite returns the first TLS 1.0–1.2 cipher suite from ids which is also in supportedIDs and passes the ok filter. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#mutualCipherSuite",
                    "documentation": {
                      "identifier": "mutualCipherSuite",
                      "newPage": false,
                      "searchKey": "tls.mutualCipherSuite",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mutualCipherSuite(have []uint16, want uint16) *cipherSuite"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mutualCipherSuite(have []uint16, want uint16) *cipherSuite\n```\n\nmutualCipherSuite returns a cipherSuite given a list of supported ciphersuites and the id requested by the peer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cipherSuiteByID",
                    "documentation": {
                      "identifier": "cipherSuiteByID",
                      "newPage": false,
                      "searchKey": "tls.cipherSuiteByID",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cipherSuiteByID(id uint16) *cipherSuite"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cipherSuiteByID(id uint16) *cipherSuite\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cipherSuiteTLS13",
              "documentation": {
                "identifier": "cipherSuiteTLS13",
                "newPage": false,
                "searchKey": "tls.cipherSuiteTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cipherSuiteTLS13 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cipherSuiteTLS13 struct {\n\tid     uint16\n\tkeyLen int\n\taead   func(key, fixedNonce []byte) aead\n\thash   crypto.Hash\n}\n```\n\nA cipherSuiteTLS13 defines only the pair of the AEAD algorithm and hash algorithm to be used with HKDF. See RFC 8446, Appendix B.4. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#mutualCipherSuiteTLS13",
                    "documentation": {
                      "identifier": "mutualCipherSuiteTLS13",
                      "newPage": false,
                      "searchKey": "tls.mutualCipherSuiteTLS13",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mutualCipherSuiteTLS13(have []uint16, want uint16) *cipherSuiteTLS13"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mutualCipherSuiteTLS13(have []uint16, want uint16) *cipherSuiteTLS13\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cipherSuiteTLS13ByID",
                    "documentation": {
                      "identifier": "cipherSuiteTLS13ByID",
                      "newPage": false,
                      "searchKey": "tls.cipherSuiteTLS13ByID",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func cipherSuiteTLS13ByID(id uint16) *cipherSuiteTLS13"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc cipherSuiteTLS13ByID(id uint16) *cipherSuiteTLS13\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cipherSuiteTLS13.expandLabel",
                    "documentation": {
                      "identifier": "cipherSuiteTLS13.expandLabel",
                      "newPage": false,
                      "searchKey": "tls.cipherSuiteTLS13.expandLabel",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cipherSuiteTLS13) expandLabel(secret []byte, label string, context []byte, length int) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cipherSuiteTLS13) expandLabel(secret []byte, label string, context []byte, length int) []byte\n```\n\nexpandLabel implements HKDF-Expand-Label from RFC 8446, Section 7.1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cipherSuiteTLS13.deriveSecret",
                    "documentation": {
                      "identifier": "cipherSuiteTLS13.deriveSecret",
                      "newPage": false,
                      "searchKey": "tls.cipherSuiteTLS13.deriveSecret",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cipherSuiteTLS13) deriveSecret(secret []byte, label string, transcript hash.Hash) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cipherSuiteTLS13) deriveSecret(secret []byte, label string, transcript hash.Hash) []byte\n```\n\nderiveSecret implements Derive-Secret from RFC 8446, Section 7.1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cipherSuiteTLS13.extract",
                    "documentation": {
                      "identifier": "cipherSuiteTLS13.extract",
                      "newPage": false,
                      "searchKey": "tls.cipherSuiteTLS13.extract",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cipherSuiteTLS13) extract(newSecret, currentSecret []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cipherSuiteTLS13) extract(newSecret, currentSecret []byte) []byte\n```\n\nextract implements HKDF-Extract with the cipher suite hash. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cipherSuiteTLS13.nextTrafficSecret",
                    "documentation": {
                      "identifier": "cipherSuiteTLS13.nextTrafficSecret",
                      "newPage": false,
                      "searchKey": "tls.cipherSuiteTLS13.nextTrafficSecret",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cipherSuiteTLS13) nextTrafficSecret(trafficSecret []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cipherSuiteTLS13) nextTrafficSecret(trafficSecret []byte) []byte\n```\n\nnextTrafficSecret generates the next traffic secret, given the current one, according to RFC 8446, Section 7.2. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cipherSuiteTLS13.trafficKey",
                    "documentation": {
                      "identifier": "cipherSuiteTLS13.trafficKey",
                      "newPage": false,
                      "searchKey": "tls.cipherSuiteTLS13.trafficKey",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cipherSuiteTLS13) trafficKey(trafficSecret []byte) (key, iv []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cipherSuiteTLS13) trafficKey(trafficSecret []byte) (key, iv []byte)\n```\n\ntrafficKey generates traffic keys according to RFC 8446, Section 7.3. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cipherSuiteTLS13.finishedHash",
                    "documentation": {
                      "identifier": "cipherSuiteTLS13.finishedHash",
                      "newPage": false,
                      "searchKey": "tls.cipherSuiteTLS13.finishedHash",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cipherSuiteTLS13) finishedHash(baseKey []byte, transcript hash.Hash) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cipherSuiteTLS13) finishedHash(baseKey []byte, transcript hash.Hash) []byte\n```\n\nfinishedHash generates the Finished verify_data or PskBinderEntry according to RFC 8446, Section 4.4.4. See sections 4.4 and 4.2.11.2 for the baseKey selection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cipherSuiteTLS13.exportKeyingMaterial",
                    "documentation": {
                      "identifier": "cipherSuiteTLS13.exportKeyingMaterial",
                      "newPage": false,
                      "searchKey": "tls.cipherSuiteTLS13.exportKeyingMaterial",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cipherSuiteTLS13) exportKeyingMaterial(masterSecret []byte, transcript hash.Hash) func(string, []byte, int) ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cipherSuiteTLS13) exportKeyingMaterial(masterSecret []byte, transcript hash.Hash) func(string, []byte, int) ([]byte, error)\n```\n\nexportKeyingMaterial implements RFC5705 exporters for TLS 1.3 according to RFC 8446, Section 7.5. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#aead",
              "documentation": {
                "identifier": "aead",
                "newPage": false,
                "searchKey": "tls.aead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type aead interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype aead interface {\n\tcipher.AEAD\n\n\t// explicitNonceLen returns the number of bytes of explicit nonce\n\t// included in each record. This is eight for older AEADs and\n\t// zero for modern ones.\n\texplicitNonceLen() int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#aeadAESGCM",
                    "documentation": {
                      "identifier": "aeadAESGCM",
                      "newPage": false,
                      "searchKey": "tls.aeadAESGCM",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func aeadAESGCM(key, noncePrefix []byte) aead"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc aeadAESGCM(key, noncePrefix []byte) aead\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#aeadAESGCMTLS13",
                    "documentation": {
                      "identifier": "aeadAESGCMTLS13",
                      "newPage": false,
                      "searchKey": "tls.aeadAESGCMTLS13",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func aeadAESGCMTLS13(key, nonceMask []byte) aead"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc aeadAESGCMTLS13(key, nonceMask []byte) aead\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#aeadChaCha20Poly1305",
                    "documentation": {
                      "identifier": "aeadChaCha20Poly1305",
                      "newPage": false,
                      "searchKey": "tls.aeadChaCha20Poly1305",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func aeadChaCha20Poly1305(key, nonceMask []byte) aead"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc aeadChaCha20Poly1305(key, nonceMask []byte) aead\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#prefixNonceAEAD",
              "documentation": {
                "identifier": "prefixNonceAEAD",
                "newPage": false,
                "searchKey": "tls.prefixNonceAEAD",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type prefixNonceAEAD struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype prefixNonceAEAD struct {\n\t// nonce contains the fixed part of the nonce in the first four bytes.\n\tnonce [aeadNonceLength]byte\n\taead  cipher.AEAD\n}\n```\n\nprefixNonceAEAD wraps an AEAD and prefixes a fixed portion of the nonce to each call. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#prefixNonceAEAD.NonceSize",
                    "documentation": {
                      "identifier": "prefixNonceAEAD.NonceSize",
                      "newPage": false,
                      "searchKey": "tls.prefixNonceAEAD.NonceSize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *prefixNonceAEAD) NonceSize() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *prefixNonceAEAD) NonceSize() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#prefixNonceAEAD.Overhead",
                    "documentation": {
                      "identifier": "prefixNonceAEAD.Overhead",
                      "newPage": false,
                      "searchKey": "tls.prefixNonceAEAD.Overhead",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *prefixNonceAEAD) Overhead() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *prefixNonceAEAD) Overhead() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#prefixNonceAEAD.explicitNonceLen",
                    "documentation": {
                      "identifier": "prefixNonceAEAD.explicitNonceLen",
                      "newPage": false,
                      "searchKey": "tls.prefixNonceAEAD.explicitNonceLen",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *prefixNonceAEAD) explicitNonceLen() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *prefixNonceAEAD) explicitNonceLen() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#prefixNonceAEAD.Seal",
                    "documentation": {
                      "identifier": "prefixNonceAEAD.Seal",
                      "newPage": false,
                      "searchKey": "tls.prefixNonceAEAD.Seal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *prefixNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *prefixNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#prefixNonceAEAD.Open",
                    "documentation": {
                      "identifier": "prefixNonceAEAD.Open",
                      "newPage": false,
                      "searchKey": "tls.prefixNonceAEAD.Open",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *prefixNonceAEAD) Open(out, nonce, ciphertext, additionalData []byte) ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *prefixNonceAEAD) Open(out, nonce, ciphertext, additionalData []byte) ([]byte, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#xorNonceAEAD",
              "documentation": {
                "identifier": "xorNonceAEAD",
                "newPage": false,
                "searchKey": "tls.xorNonceAEAD",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type xorNonceAEAD struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype xorNonceAEAD struct {\n\tnonceMask [aeadNonceLength]byte\n\taead      cipher.AEAD\n}\n```\n\nxoredNonceAEAD wraps an AEAD by XORing in a fixed pattern to the nonce before each call. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#xorNonceAEAD.NonceSize",
                    "documentation": {
                      "identifier": "xorNonceAEAD.NonceSize",
                      "newPage": false,
                      "searchKey": "tls.xorNonceAEAD.NonceSize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *xorNonceAEAD) NonceSize() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *xorNonceAEAD) NonceSize() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#xorNonceAEAD.Overhead",
                    "documentation": {
                      "identifier": "xorNonceAEAD.Overhead",
                      "newPage": false,
                      "searchKey": "tls.xorNonceAEAD.Overhead",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *xorNonceAEAD) Overhead() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *xorNonceAEAD) Overhead() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#xorNonceAEAD.explicitNonceLen",
                    "documentation": {
                      "identifier": "xorNonceAEAD.explicitNonceLen",
                      "newPage": false,
                      "searchKey": "tls.xorNonceAEAD.explicitNonceLen",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *xorNonceAEAD) explicitNonceLen() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *xorNonceAEAD) explicitNonceLen() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#xorNonceAEAD.Seal",
                    "documentation": {
                      "identifier": "xorNonceAEAD.Seal",
                      "newPage": false,
                      "searchKey": "tls.xorNonceAEAD.Seal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *xorNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *xorNonceAEAD) Seal(out, nonce, plaintext, additionalData []byte) []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#xorNonceAEAD.Open",
                    "documentation": {
                      "identifier": "xorNonceAEAD.Open",
                      "newPage": false,
                      "searchKey": "tls.xorNonceAEAD.Open",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *xorNonceAEAD) Open(out, nonce, ciphertext, additionalData []byte) ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *xorNonceAEAD) Open(out, nonce, ciphertext, additionalData []byte) ([]byte, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#constantTimeHash",
              "documentation": {
                "identifier": "constantTimeHash",
                "newPage": false,
                "searchKey": "tls.constantTimeHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type constantTimeHash interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype constantTimeHash interface {\n\thash.Hash\n\tConstantTimeSum(b []byte) []byte\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cthWrapper",
              "documentation": {
                "identifier": "cthWrapper",
                "newPage": false,
                "searchKey": "tls.cthWrapper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cthWrapper struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cthWrapper struct {\n\th constantTimeHash\n}\n```\n\ncthWrapper wraps any hash.Hash that implements ConstantTimeSum, and replaces with that all calls to Sum. It's used to obtain a ConstantTimeSum-based HMAC. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cthWrapper.Size",
                    "documentation": {
                      "identifier": "cthWrapper.Size",
                      "newPage": false,
                      "searchKey": "tls.cthWrapper.Size",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cthWrapper) Size() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cthWrapper) Size() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cthWrapper.BlockSize",
                    "documentation": {
                      "identifier": "cthWrapper.BlockSize",
                      "newPage": false,
                      "searchKey": "tls.cthWrapper.BlockSize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cthWrapper) BlockSize() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cthWrapper) BlockSize() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cthWrapper.Reset",
                    "documentation": {
                      "identifier": "cthWrapper.Reset",
                      "newPage": false,
                      "searchKey": "tls.cthWrapper.Reset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cthWrapper) Reset()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cthWrapper) Reset()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cthWrapper.Write",
                    "documentation": {
                      "identifier": "cthWrapper.Write",
                      "newPage": false,
                      "searchKey": "tls.cthWrapper.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cthWrapper) Write(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cthWrapper) Write(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#cthWrapper.Sum",
                    "documentation": {
                      "identifier": "cthWrapper.Sum",
                      "newPage": false,
                      "searchKey": "tls.cthWrapper.Sum",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *cthWrapper) Sum(b []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *cthWrapper) Sum(b []byte) []byte\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#recordType",
              "documentation": {
                "identifier": "recordType",
                "newPage": false,
                "searchKey": "tls.recordType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type recordType uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype recordType uint8\n```\n\nTLS record types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#CurveID",
              "documentation": {
                "identifier": "CurveID",
                "newPage": false,
                "searchKey": "tls.CurveID",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type CurveID uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype CurveID uint16\n```\n\nCurveID is the type of a TLS identifier for an elliptic curve. See [https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8](https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8). \n\nIn TLS 1.3, this type is called NamedGroup, but at this time this library only supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#CurveID.String",
                    "documentation": {
                      "identifier": "CurveID.String",
                      "newPage": false,
                      "searchKey": "tls.CurveID.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i CurveID) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i CurveID) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyShare",
              "documentation": {
                "identifier": "keyShare",
                "newPage": false,
                "searchKey": "tls.keyShare",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type keyShare struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype keyShare struct {\n\tgroup CurveID\n\tdata  []byte\n}\n```\n\nTLS 1.3 Key Share. See RFC 8446, Section 4.2.8. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#pskIdentity",
              "documentation": {
                "identifier": "pskIdentity",
                "newPage": false,
                "searchKey": "tls.pskIdentity",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pskIdentity struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pskIdentity struct {\n\tlabel               []byte\n\tobfuscatedTicketAge uint32\n}\n```\n\nTLS 1.3 PSK Identity. Can be a Session Ticket, or a reference to a saved session. See RFC 8446, Section 4.2.11. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ConnectionState",
              "documentation": {
                "identifier": "ConnectionState",
                "newPage": false,
                "searchKey": "tls.ConnectionState",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ConnectionState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ConnectionState struct {\n\t// Version is the TLS version used by the connection (e.g. VersionTLS12).\n\tVersion uint16\n\n\t// HandshakeComplete is true if the handshake has concluded.\n\tHandshakeComplete bool\n\n\t// DidResume is true if this connection was successfully resumed from a\n\t// previous session with a session ticket or similar mechanism.\n\tDidResume bool\n\n\t// CipherSuite is the cipher suite negotiated for the connection (e.g.\n\t// TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_AES_128_GCM_SHA256).\n\tCipherSuite uint16\n\n\t// NegotiatedProtocol is the application protocol negotiated with ALPN.\n\tNegotiatedProtocol string\n\n\t// NegotiatedProtocolIsMutual used to indicate a mutual NPN negotiation.\n\t//\n\t// Deprecated: this value is always true.\n\tNegotiatedProtocolIsMutual bool\n\n\t// ServerName is the value of the Server Name Indication extension sent by\n\t// the client. It's available both on the server and on the client side.\n\tServerName string\n\n\t// PeerCertificates are the parsed certificates sent by the peer, in the\n\t// order in which they were sent. The first element is the leaf certificate\n\t// that the connection is verified against.\n\t//\n\t// On the client side, it can't be empty. On the server side, it can be\n\t// empty if Config.ClientAuth is not RequireAnyClientCert or\n\t// RequireAndVerifyClientCert.\n\tPeerCertificates []*x509.Certificate\n\n\t// VerifiedChains is a list of one or more chains where the first element is\n\t// PeerCertificates[0] and the last element is from Config.RootCAs (on the\n\t// client side) or Config.ClientCAs (on the server side).\n\t//\n\t// On the client side, it's set if Config.InsecureSkipVerify is false. On\n\t// the server side, it's set if Config.ClientAuth is VerifyClientCertIfGiven\n\t// (and the peer provided a certificate) or RequireAndVerifyClientCert.\n\tVerifiedChains [][]*x509.Certificate\n\n\t// SignedCertificateTimestamps is a list of SCTs provided by the peer\n\t// through the TLS handshake for the leaf certificate, if any.\n\tSignedCertificateTimestamps [][]byte\n\n\t// OCSPResponse is a stapled Online Certificate Status Protocol (OCSP)\n\t// response provided by the peer for the leaf certificate, if any.\n\tOCSPResponse []byte\n\n\t// TLSUnique contains the \"tls-unique\" channel binding value (see RFC 5929,\n\t// Section 3). This value will be nil for TLS 1.3 connections and for all\n\t// resumed connections.\n\t//\n\t// Deprecated: there are conditions in which this value might not be unique\n\t// to a connection. See the Security Considerations sections of RFC 5705 and\n\t// RFC 7627, and https://mitls.org/pages/attacks/3SHAKE#channelbindings.\n\tTLSUnique []byte\n\n\t// ekm is a closure exposed via ExportKeyingMaterial.\n\tekm func(label string, context []byte, length int) ([]byte, error)\n}\n```\n\nConnectionState records basic TLS details about the connection. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#testHandshake",
                    "documentation": {
                      "identifier": "testHandshake",
                      "newPage": false,
                      "searchKey": "tls.testHandshake",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func testHandshake(t *testing.T, clientConfig, serverConfig *Config) (serverState, clientState ConnectionState, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc testHandshake(t *testing.T, clientConfig, serverConfig *Config) (serverState, clientState ConnectionState, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#ConnectionState.ExportKeyingMaterial",
                    "documentation": {
                      "identifier": "ConnectionState.ExportKeyingMaterial",
                      "newPage": false,
                      "searchKey": "tls.ConnectionState.ExportKeyingMaterial",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cs *ConnectionState) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cs *ConnectionState) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error)\n```\n\nExportKeyingMaterial returns length bytes of exported key material in a new slice as defined in RFC 5705. If context is nil, it is not used as part of the seed. If the connection was set to allow renegotiation via Config.Renegotiation, this function will return an error. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ClientAuthType",
              "documentation": {
                "identifier": "ClientAuthType",
                "newPage": false,
                "searchKey": "tls.ClientAuthType",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ClientAuthType int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ClientAuthType int\n```\n\nClientAuthType declares the policy the server will follow for TLS Client Authentication. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#ClientAuthType.String",
                    "documentation": {
                      "identifier": "ClientAuthType.String",
                      "newPage": false,
                      "searchKey": "tls.ClientAuthType.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i ClientAuthType) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i ClientAuthType) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ClientSessionState",
              "documentation": {
                "identifier": "ClientSessionState",
                "newPage": false,
                "searchKey": "tls.ClientSessionState",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ClientSessionState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ClientSessionState struct {\n\tsessionTicket      []uint8               // Encrypted ticket used for session resumption with server\n\tvers               uint16                // TLS version negotiated for the session\n\tcipherSuite        uint16                // Ciphersuite negotiated for the session\n\tmasterSecret       []byte                // Full handshake MasterSecret, or TLS 1.3 resumption_master_secret\n\tserverCertificates []*x509.Certificate   // Certificate chain presented by the server\n\tverifiedChains     [][]*x509.Certificate // Certificate chains we built for verification\n\treceivedAt         time.Time             // When the session ticket was received from the server\n\tocspResponse       []byte                // Stapled OCSP response presented by the server\n\tscts               [][]byte              // SCTs presented by the server\n\n\t// TLS 1.3 fields.\n\tnonce  []byte    // Ticket nonce sent by the server, to derive PSK\n\tuseBy  time.Time // Expiration of the ticket lifetime as set by the server\n\tageAdd uint32    // Random obfuscation factor for sending the ticket age\n}\n```\n\nClientSessionState contains the state needed by clients to resume TLS sessions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ClientSessionCache",
              "documentation": {
                "identifier": "ClientSessionCache",
                "newPage": false,
                "searchKey": "tls.ClientSessionCache",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ClientSessionCache interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ClientSessionCache interface {\n\t// Get searches for a ClientSessionState associated with the given key.\n\t// On return, ok is true if one was found.\n\tGet(sessionKey string) (session *ClientSessionState, ok bool)\n\n\t// Put adds the ClientSessionState to the cache with the given key. It might\n\t// get called multiple times in a connection if a TLS 1.3 server provides\n\t// more than one session ticket. If called with a nil *ClientSessionState,\n\t// it should remove the cache entry.\n\tPut(sessionKey string, cs *ClientSessionState)\n}\n```\n\nClientSessionCache is a cache of ClientSessionState objects that can be used by a client to resume a TLS session with a given server. ClientSessionCache implementations should expect to be called concurrently from different goroutines. Up to TLS 1.2, only ticket-based resumption is supported, not SessionID-based resumption. In TLS 1.3 they were merged into PSK modes, which are supported via this interface. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#NewLRUClientSessionCache",
                    "documentation": {
                      "identifier": "NewLRUClientSessionCache",
                      "newPage": false,
                      "searchKey": "tls.NewLRUClientSessionCache",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewLRUClientSessionCache(capacity int) ClientSessionCache"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewLRUClientSessionCache(capacity int) ClientSessionCache\n```\n\nNewLRUClientSessionCache returns a ClientSessionCache with the given capacity that uses an LRU strategy. If capacity is < 1, a default capacity is used instead. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#SignatureScheme",
              "documentation": {
                "identifier": "SignatureScheme",
                "newPage": false,
                "searchKey": "tls.SignatureScheme",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type SignatureScheme uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype SignatureScheme uint16\n```\n\nSignatureScheme identifies a signature algorithm supported by TLS. See RFC 8446, Section 4.2.3. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#selectSignatureScheme",
                    "documentation": {
                      "identifier": "selectSignatureScheme",
                      "newPage": false,
                      "searchKey": "tls.selectSignatureScheme",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func selectSignatureScheme(vers uint16, c *Certificate, peerAlgs []SignatureScheme) (SignatureScheme, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc selectSignatureScheme(vers uint16, c *Certificate, peerAlgs []SignatureScheme) (SignatureScheme, error)\n```\n\nselectSignatureScheme picks a SignatureScheme from the peer's preference list that works with the selected certificate. It's only called for protocol versions that support signature algorithms, so TLS 1.2 and 1.3. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#SignatureScheme.String",
                    "documentation": {
                      "identifier": "SignatureScheme.String",
                      "newPage": false,
                      "searchKey": "tls.SignatureScheme.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i SignatureScheme) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i SignatureScheme) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ClientHelloInfo",
              "documentation": {
                "identifier": "ClientHelloInfo",
                "newPage": false,
                "searchKey": "tls.ClientHelloInfo",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ClientHelloInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ClientHelloInfo struct {\n\t// CipherSuites lists the CipherSuites supported by the client (e.g.\n\t// TLS_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256).\n\tCipherSuites []uint16\n\n\t// ServerName indicates the name of the server requested by the client\n\t// in order to support virtual hosting. ServerName is only set if the\n\t// client is using SNI (see RFC 4366, Section 3.1).\n\tServerName string\n\n\t// SupportedCurves lists the elliptic curves supported by the client.\n\t// SupportedCurves is set only if the Supported Elliptic Curves\n\t// Extension is being used (see RFC 4492, Section 5.1.1).\n\tSupportedCurves []CurveID\n\n\t// SupportedPoints lists the point formats supported by the client.\n\t// SupportedPoints is set only if the Supported Point Formats Extension\n\t// is being used (see RFC 4492, Section 5.1.2).\n\tSupportedPoints []uint8\n\n\t// SignatureSchemes lists the signature and hash schemes that the client\n\t// is willing to verify. SignatureSchemes is set only if the Signature\n\t// Algorithms Extension is being used (see RFC 5246, Section 7.4.1.4.1).\n\tSignatureSchemes []SignatureScheme\n\n\t// SupportedProtos lists the application protocols supported by the client.\n\t// SupportedProtos is set only if the Application-Layer Protocol\n\t// Negotiation Extension is being used (see RFC 7301, Section 3.1).\n\t//\n\t// Servers can select a protocol by setting Config.NextProtos in a\n\t// GetConfigForClient return value.\n\tSupportedProtos []string\n\n\t// SupportedVersions lists the TLS versions supported by the client.\n\t// For TLS versions less than 1.3, this is extrapolated from the max\n\t// version advertised by the client, so values other than the greatest\n\t// might be rejected if used.\n\tSupportedVersions []uint16\n\n\t// Conn is the underlying net.Conn for the connection. Do not read\n\t// from, or write to, this connection; that will cause the TLS\n\t// connection to fail.\n\tConn net.Conn\n\n\t// config is embedded by the GetCertificate or GetConfigForClient caller,\n\t// for use with SupportsCertificate.\n\tconfig *Config\n\n\t// ctx is the context of the handshake that is in progress.\n\tctx context.Context\n}\n```\n\nClientHelloInfo contains information from a ClientHello message in order to guide application logic in the GetCertificate and GetConfigForClient callbacks. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHelloInfo",
                    "documentation": {
                      "identifier": "clientHelloInfo",
                      "newPage": false,
                      "searchKey": "tls.clientHelloInfo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func clientHelloInfo(ctx context.Context, c *Conn, clientHello *clientHelloMsg) *ClientHelloInfo"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc clientHelloInfo(ctx context.Context, c *Conn, clientHello *clientHelloMsg) *ClientHelloInfo\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#ClientHelloInfo.Context",
                    "documentation": {
                      "identifier": "ClientHelloInfo.Context",
                      "newPage": false,
                      "searchKey": "tls.ClientHelloInfo.Context",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *ClientHelloInfo) Context() context.Context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *ClientHelloInfo) Context() context.Context\n```\n\nContext returns the context of the handshake that is in progress. This context is a child of the context passed to HandshakeContext, if any, and is canceled when the handshake concludes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#ClientHelloInfo.SupportsCertificate",
                    "documentation": {
                      "identifier": "ClientHelloInfo.SupportsCertificate",
                      "newPage": false,
                      "searchKey": "tls.ClientHelloInfo.SupportsCertificate",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (chi *ClientHelloInfo) SupportsCertificate(c *Certificate) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (chi *ClientHelloInfo) SupportsCertificate(c *Certificate) error\n```\n\nSupportsCertificate returns nil if the provided certificate is supported by the client that sent the ClientHello. Otherwise, it returns an error describing the reason for the incompatibility. \n\nIf this ClientHelloInfo was passed to a GetConfigForClient or GetCertificate callback, this method will take into account the associated Config. Note that if GetConfigForClient returns a different Config, the change can't be accounted for by this method. \n\nThis function will call x509.ParseCertificate unless c.Leaf is set, which can incur a significant performance cost. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#CertificateRequestInfo",
              "documentation": {
                "identifier": "CertificateRequestInfo",
                "newPage": false,
                "searchKey": "tls.CertificateRequestInfo",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type CertificateRequestInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype CertificateRequestInfo struct {\n\t// AcceptableCAs contains zero or more, DER-encoded, X.501\n\t// Distinguished Names. These are the names of root or intermediate CAs\n\t// that the server wishes the returned certificate to be signed by. An\n\t// empty slice indicates that the server has no preference.\n\tAcceptableCAs [][]byte\n\n\t// SignatureSchemes lists the signature schemes that the server is\n\t// willing to verify.\n\tSignatureSchemes []SignatureScheme\n\n\t// Version is the TLS version that was negotiated for this connection.\n\tVersion uint16\n\n\t// ctx is the context of the handshake that is in progress.\n\tctx context.Context\n}\n```\n\nCertificateRequestInfo contains information from a server's CertificateRequest message, which is used to demand a certificate and proof of control from a client. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateRequestInfoFromMsg",
                    "documentation": {
                      "identifier": "certificateRequestInfoFromMsg",
                      "newPage": false,
                      "searchKey": "tls.certificateRequestInfoFromMsg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func certificateRequestInfoFromMsg(ctx context.Context, vers uint16, certReq *certificateRequestMsg) *CertificateRequestInfo"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc certificateRequestInfoFromMsg(ctx context.Context, vers uint16, certReq *certificateRequestMsg) *CertificateRequestInfo\n```\n\ncertificateRequestInfoFromMsg generates a CertificateRequestInfo from a TLS <= 1.2 CertificateRequest, making an effort to fill in missing information. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#CertificateRequestInfo.Context",
                    "documentation": {
                      "identifier": "CertificateRequestInfo.Context",
                      "newPage": false,
                      "searchKey": "tls.CertificateRequestInfo.Context",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *CertificateRequestInfo) Context() context.Context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *CertificateRequestInfo) Context() context.Context\n```\n\nContext returns the context of the handshake that is in progress. This context is a child of the context passed to HandshakeContext, if any, and is canceled when the handshake concludes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#CertificateRequestInfo.SupportsCertificate",
                    "documentation": {
                      "identifier": "CertificateRequestInfo.SupportsCertificate",
                      "newPage": false,
                      "searchKey": "tls.CertificateRequestInfo.SupportsCertificate",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (cri *CertificateRequestInfo) SupportsCertificate(c *Certificate) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (cri *CertificateRequestInfo) SupportsCertificate(c *Certificate) error\n```\n\nSupportsCertificate returns nil if the provided certificate is supported by the server that sent the CertificateRequest. Otherwise, it returns an error describing the reason for the incompatibility. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#RenegotiationSupport",
              "documentation": {
                "identifier": "RenegotiationSupport",
                "newPage": false,
                "searchKey": "tls.RenegotiationSupport",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RenegotiationSupport int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RenegotiationSupport int\n```\n\nRenegotiationSupport enumerates the different levels of support for TLS renegotiation. TLS renegotiation is the act of performing subsequent handshakes on a connection after the first. This significantly complicates the state machine and has been the source of numerous, subtle security issues. Initiating a renegotiation is not supported, but support for accepting renegotiation requests may be enabled. \n\nEven when enabled, the server may not change its identity between handshakes (i.e. the leaf certificate must be the same). Additionally, concurrent handshake and application data flow is not permitted so renegotiation can only be used with protocols that synchronise with the renegotiation, such as HTTPS. \n\nRenegotiation is not defined in TLS 1.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#Config",
              "documentation": {
                "identifier": "Config",
                "newPage": false,
                "searchKey": "tls.Config",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Config struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Config struct {\n\t// Rand provides the source of entropy for nonces and RSA blinding.\n\t// If Rand is nil, TLS uses the cryptographic random reader in package\n\t// crypto/rand.\n\t// The Reader must be safe for use by multiple goroutines.\n\tRand io.Reader\n\n\t// Time returns the current time as the number of seconds since the epoch.\n\t// If Time is nil, TLS uses time.Now.\n\tTime func() time.Time\n\n\t// Certificates contains one or more certificate chains to present to the\n\t// other side of the connection. The first certificate compatible with the\n\t// peer's requirements is selected automatically.\n\t//\n\t// Server configurations must set one of Certificates, GetCertificate or\n\t// GetConfigForClient. Clients doing client-authentication may set either\n\t// Certificates or GetClientCertificate.\n\t//\n\t// Note: if there are multiple Certificates, and they don't have the\n\t// optional field Leaf set, certificate selection will incur a significant\n\t// per-handshake performance cost.\n\tCertificates []Certificate\n\n\t// NameToCertificate maps from a certificate name to an element of\n\t// Certificates. Note that a certificate name can be of the form\n\t// '*.example.com' and so doesn't have to be a domain name as such.\n\t//\n\t// Deprecated: NameToCertificate only allows associating a single\n\t// certificate with a given name. Leave this field nil to let the library\n\t// select the first compatible chain from Certificates.\n\tNameToCertificate map[string]*Certificate\n\n\t// GetCertificate returns a Certificate based on the given\n\t// ClientHelloInfo. It will only be called if the client supplies SNI\n\t// information or if Certificates is empty.\n\t//\n\t// If GetCertificate is nil or returns nil, then the certificate is\n\t// retrieved from NameToCertificate. If NameToCertificate is nil, the\n\t// best element of Certificates will be used.\n\tGetCertificate func(*ClientHelloInfo) (*Certificate, error)\n\n\t// GetClientCertificate, if not nil, is called when a server requests a\n\t// certificate from a client. If set, the contents of Certificates will\n\t// be ignored.\n\t//\n\t// If GetClientCertificate returns an error, the handshake will be\n\t// aborted and that error will be returned. Otherwise\n\t// GetClientCertificate must return a non-nil Certificate. If\n\t// Certificate.Certificate is empty then no certificate will be sent to\n\t// the server. If this is unacceptable to the server then it may abort\n\t// the handshake.\n\t//\n\t// GetClientCertificate may be called multiple times for the same\n\t// connection if renegotiation occurs or if TLS 1.3 is in use.\n\tGetClientCertificate func(*CertificateRequestInfo) (*Certificate, error)\n\n\t// GetConfigForClient, if not nil, is called after a ClientHello is\n\t// received from a client. It may return a non-nil Config in order to\n\t// change the Config that will be used to handle this connection. If\n\t// the returned Config is nil, the original Config will be used. The\n\t// Config returned by this callback may not be subsequently modified.\n\t//\n\t// If GetConfigForClient is nil, the Config passed to Server() will be\n\t// used for all connections.\n\t//\n\t// If SessionTicketKey was explicitly set on the returned Config, or if\n\t// SetSessionTicketKeys was called on the returned Config, those keys will\n\t// be used. Otherwise, the original Config keys will be used (and possibly\n\t// rotated if they are automatically managed).\n\tGetConfigForClient func(*ClientHelloInfo) (*Config, error)\n\n\t// VerifyPeerCertificate, if not nil, is called after normal\n\t// certificate verification by either a TLS client or server. It\n\t// receives the raw ASN.1 certificates provided by the peer and also\n\t// any verified chains that normal processing found. If it returns a\n\t// non-nil error, the handshake is aborted and that error results.\n\t//\n\t// If normal verification fails then the handshake will abort before\n\t// considering this callback. If normal verification is disabled by\n\t// setting InsecureSkipVerify, or (for a server) when ClientAuth is\n\t// RequestClientCert or RequireAnyClientCert, then this callback will\n\t// be considered but the verifiedChains argument will always be nil.\n\tVerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error\n\n\t// VerifyConnection, if not nil, is called after normal certificate\n\t// verification and after VerifyPeerCertificate by either a TLS client\n\t// or server. If it returns a non-nil error, the handshake is aborted\n\t// and that error results.\n\t//\n\t// If normal verification fails then the handshake will abort before\n\t// considering this callback. This callback will run for all connections\n\t// regardless of InsecureSkipVerify or ClientAuth settings.\n\tVerifyConnection func(ConnectionState) error\n\n\t// RootCAs defines the set of root certificate authorities\n\t// that clients use when verifying server certificates.\n\t// If RootCAs is nil, TLS uses the host's root CA set.\n\tRootCAs *x509.CertPool\n\n\t// NextProtos is a list of supported application level protocols, in\n\t// order of preference. If both peers support ALPN, the selected\n\t// protocol will be one from this list, and the connection will fail\n\t// if there is no mutually supported protocol. If NextProtos is empty\n\t// or the peer doesn't support ALPN, the connection will succeed and\n\t// ConnectionState.NegotiatedProtocol will be empty.\n\tNextProtos []string\n\n\t// ServerName is used to verify the hostname on the returned\n\t// certificates unless InsecureSkipVerify is given. It is also included\n\t// in the client's handshake to support virtual hosting unless it is\n\t// an IP address.\n\tServerName string\n\n\t// ClientAuth determines the server's policy for\n\t// TLS Client Authentication. The default is NoClientCert.\n\tClientAuth ClientAuthType\n\n\t// ClientCAs defines the set of root certificate authorities\n\t// that servers use if required to verify a client certificate\n\t// by the policy in ClientAuth.\n\tClientCAs *x509.CertPool\n\n\t// InsecureSkipVerify controls whether a client verifies the server's\n\t// certificate chain and host name. If InsecureSkipVerify is true, crypto/tls\n\t// accepts any certificate presented by the server and any host name in that\n\t// certificate. In this mode, TLS is susceptible to machine-in-the-middle\n\t// attacks unless custom verification is used. This should be used only for\n\t// testing or in combination with VerifyConnection or VerifyPeerCertificate.\n\tInsecureSkipVerify bool\n\n\t// CipherSuites is a list of enabled TLS 1.0–1.2 cipher suites. The order of\n\t// the list is ignored. Note that TLS 1.3 ciphersuites are not configurable.\n\t//\n\t// If CipherSuites is nil, a safe default list is used. The default cipher\n\t// suites might change over time.\n\tCipherSuites []uint16\n\n\t// PreferServerCipherSuites is a legacy field and has no effect.\n\t//\n\t// It used to control whether the server would follow the client's or the\n\t// server's preference. Servers now select the best mutually supported\n\t// cipher suite based on logic that takes into account inferred client\n\t// hardware, server hardware, and security.\n\t//\n\t// Deprected: PreferServerCipherSuites is ignored.\n\tPreferServerCipherSuites bool\n\n\t// SessionTicketsDisabled may be set to true to disable session ticket and\n\t// PSK (resumption) support. Note that on clients, session ticket support is\n\t// also disabled if ClientSessionCache is nil.\n\tSessionTicketsDisabled bool\n\n\t// SessionTicketKey is used by TLS servers to provide session resumption.\n\t// See RFC 5077 and the PSK mode of RFC 8446. If zero, it will be filled\n\t// with random data before the first server handshake.\n\t//\n\t// Deprecated: if this field is left at zero, session ticket keys will be\n\t// automatically rotated every day and dropped after seven days. For\n\t// customizing the rotation schedule or synchronizing servers that are\n\t// terminating connections for the same host, use SetSessionTicketKeys.\n\tSessionTicketKey [32]byte\n\n\t// ClientSessionCache is a cache of ClientSessionState entries for TLS\n\t// session resumption. It is only used by clients.\n\tClientSessionCache ClientSessionCache\n\n\t// MinVersion contains the minimum TLS version that is acceptable.\n\t// If zero, TLS 1.0 is currently taken as the minimum.\n\tMinVersion uint16\n\n\t// MaxVersion contains the maximum TLS version that is acceptable.\n\t// If zero, the maximum version supported by this package is used,\n\t// which is currently TLS 1.3.\n\tMaxVersion uint16\n\n\t// CurvePreferences contains the elliptic curves that will be used in\n\t// an ECDHE handshake, in preference order. If empty, the default will\n\t// be used. The client will use the first preference as the type for\n\t// its key share in TLS 1.3. This may change in the future.\n\tCurvePreferences []CurveID\n\n\t// DynamicRecordSizingDisabled disables adaptive sizing of TLS records.\n\t// When true, the largest possible TLS record size is always used. When\n\t// false, the size of TLS records may be adjusted in an attempt to\n\t// improve latency.\n\tDynamicRecordSizingDisabled bool\n\n\t// Renegotiation controls what types of renegotiation are supported.\n\t// The default, none, is correct for the vast majority of applications.\n\tRenegotiation RenegotiationSupport\n\n\t// KeyLogWriter optionally specifies a destination for TLS master secrets\n\t// in NSS key log format that can be used to allow external programs\n\t// such as Wireshark to decrypt TLS connections.\n\t// See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format.\n\t// Use of KeyLogWriter compromises security and should only be\n\t// used for debugging.\n\tKeyLogWriter io.Writer\n\n\t// mutex protects sessionTicketKeys and autoSessionTicketKeys.\n\tmutex sync.RWMutex\n\t// sessionTicketKeys contains zero or more ticket keys. If set, it means the\n\t// the keys were set with SessionTicketKey or SetSessionTicketKeys. The\n\t// first key is used for new tickets and any subsequent keys can be used to\n\t// decrypt old tickets. The slice contents are not protected by the mutex\n\t// and are immutable.\n\tsessionTicketKeys []ticketKey\n\t// autoSessionTicketKeys is like sessionTicketKeys but is owned by the\n\t// auto-rotation logic. See Config.ticketKeys.\n\tautoSessionTicketKeys []ticketKey\n}\n```\n\nA Config structure is used to configure a TLS client or server. After one has been passed to a TLS function it must not be modified. A Config may be reused; the tls package will also not modify it. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#defaultConfig",
                    "documentation": {
                      "identifier": "defaultConfig",
                      "newPage": false,
                      "searchKey": "tls.defaultConfig",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func defaultConfig() *Config"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc defaultConfig() *Config\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.ticketKeyFromBytes",
                    "documentation": {
                      "identifier": "Config.ticketKeyFromBytes",
                      "newPage": false,
                      "searchKey": "tls.Config.ticketKeyFromBytes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) ticketKeyFromBytes(b [32]byte) (key ticketKey)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) ticketKeyFromBytes(b [32]byte) (key ticketKey)\n```\n\nticketKeyFromBytes converts from the external representation of a session ticket key to a ticketKey. Externally, session ticket keys are 32 random bytes and this function expands that into sufficient name and key material. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.Clone",
                    "documentation": {
                      "identifier": "Config.Clone",
                      "newPage": false,
                      "searchKey": "tls.Config.Clone",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) Clone() *Config"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) Clone() *Config\n```\n\nClone returns a shallow clone of c or nil if c is nil. It is safe to clone a Config that is being used concurrently by a TLS client or server. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.initLegacySessionTicketKeyRLocked",
                    "documentation": {
                      "identifier": "Config.initLegacySessionTicketKeyRLocked",
                      "newPage": false,
                      "searchKey": "tls.Config.initLegacySessionTicketKeyRLocked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) initLegacySessionTicketKeyRLocked()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) initLegacySessionTicketKeyRLocked()\n```\n\ninitLegacySessionTicketKeyRLocked ensures the legacy SessionTicketKey field is randomized if empty, and that sessionTicketKeys is populated from it otherwise. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.ticketKeys",
                    "documentation": {
                      "identifier": "Config.ticketKeys",
                      "newPage": false,
                      "searchKey": "tls.Config.ticketKeys",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) ticketKeys(configForClient *Config) []ticketKey"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) ticketKeys(configForClient *Config) []ticketKey\n```\n\nticketKeys returns the ticketKeys for this connection. If configForClient has explicitly set keys, those will be returned. Otherwise, the keys on c will be used and may be rotated if auto-managed. During rotation, any expired session ticket keys are deleted from c.sessionTicketKeys. If the session ticket key that is currently encrypting tickets (ie. the first ticketKey in c.sessionTicketKeys) is not fresh, then a new session ticket key will be created and prepended to c.sessionTicketKeys. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.SetSessionTicketKeys",
                    "documentation": {
                      "identifier": "Config.SetSessionTicketKeys",
                      "newPage": false,
                      "searchKey": "tls.Config.SetSessionTicketKeys",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) SetSessionTicketKeys(keys [][32]byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) SetSessionTicketKeys(keys [][32]byte)\n```\n\nSetSessionTicketKeys updates the session ticket keys for a server. \n\nThe first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty. \n\nCalling this function will turn off automatic session ticket key rotation. \n\nIf multiple servers are terminating connections for the same host they should all have the same session ticket keys. If the session ticket keys leaks, previously recorded and future TLS connections using those keys might be compromised. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.rand",
                    "documentation": {
                      "identifier": "Config.rand",
                      "newPage": false,
                      "searchKey": "tls.Config.rand",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) rand() io.Reader"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) rand() io.Reader\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.time",
                    "documentation": {
                      "identifier": "Config.time",
                      "newPage": false,
                      "searchKey": "tls.Config.time",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) time() time.Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) time() time.Time\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.cipherSuites",
                    "documentation": {
                      "identifier": "Config.cipherSuites",
                      "newPage": false,
                      "searchKey": "tls.Config.cipherSuites",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) cipherSuites() []uint16"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) cipherSuites() []uint16\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.supportedVersions",
                    "documentation": {
                      "identifier": "Config.supportedVersions",
                      "newPage": false,
                      "searchKey": "tls.Config.supportedVersions",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) supportedVersions() []uint16"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) supportedVersions() []uint16\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.maxSupportedVersion",
                    "documentation": {
                      "identifier": "Config.maxSupportedVersion",
                      "newPage": false,
                      "searchKey": "tls.Config.maxSupportedVersion",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) maxSupportedVersion() uint16"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) maxSupportedVersion() uint16\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.curvePreferences",
                    "documentation": {
                      "identifier": "Config.curvePreferences",
                      "newPage": false,
                      "searchKey": "tls.Config.curvePreferences",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) curvePreferences() []CurveID"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) curvePreferences() []CurveID\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.supportsCurve",
                    "documentation": {
                      "identifier": "Config.supportsCurve",
                      "newPage": false,
                      "searchKey": "tls.Config.supportsCurve",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) supportsCurve(curve CurveID) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) supportsCurve(curve CurveID) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.mutualVersion",
                    "documentation": {
                      "identifier": "Config.mutualVersion",
                      "newPage": false,
                      "searchKey": "tls.Config.mutualVersion",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) mutualVersion(peerVersions []uint16) (uint16, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) mutualVersion(peerVersions []uint16) (uint16, bool)\n```\n\nmutualVersion returns the protocol version to use given the advertised versions of the peer. Priority is given to the peer preference order. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.getCertificate",
                    "documentation": {
                      "identifier": "Config.getCertificate",
                      "newPage": false,
                      "searchKey": "tls.Config.getCertificate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) getCertificate(clientHello *ClientHelloInfo) (*Certificate, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) getCertificate(clientHello *ClientHelloInfo) (*Certificate, error)\n```\n\ngetCertificate returns the best certificate for the given ClientHelloInfo, defaulting to the first element of c.Certificates. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.BuildNameToCertificate",
                    "documentation": {
                      "identifier": "Config.BuildNameToCertificate",
                      "newPage": false,
                      "searchKey": "tls.Config.BuildNameToCertificate",
                      "tags": [
                        "exported",
                        "deprecated"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) BuildNameToCertificate()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) BuildNameToCertificate()\n```\n\nBuildNameToCertificate parses c.Certificates and builds c.NameToCertificate from the CommonName and SubjectAlternateName fields of each of the leaf certificates. \n\nDeprecated: NameToCertificate only allows associating a single certificate with a given name. Leave that field nil to let the library select the first compatible chain from Certificates. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Config.writeKeyLog",
                    "documentation": {
                      "identifier": "Config.writeKeyLog",
                      "newPage": false,
                      "searchKey": "tls.Config.writeKeyLog",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Config) writeKeyLog(label string, clientRandom, secret []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Config) writeKeyLog(label string, clientRandom, secret []byte) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ticketKey",
              "documentation": {
                "identifier": "ticketKey",
                "newPage": false,
                "searchKey": "tls.ticketKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ticketKey struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ticketKey struct {\n\t// keyName is an opaque byte string that serves to identify the session\n\t// ticket key. It's exposed as plaintext in every session ticket.\n\tkeyName [ticketKeyNameLen]byte\n\taesKey  [16]byte\n\thmacKey [16]byte\n\t// created is the time at which this ticket key was created. See Config.ticketKeys.\n\tcreated time.Time\n}\n```\n\nticketKey is the internal representation of a session ticket key. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#Certificate",
              "documentation": {
                "identifier": "Certificate",
                "newPage": false,
                "searchKey": "tls.Certificate",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Certificate struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Certificate struct {\n\tCertificate [][]byte\n\t// PrivateKey contains the private key corresponding to the public key in\n\t// Leaf. This must implement crypto.Signer with an RSA, ECDSA or Ed25519 PublicKey.\n\t// For a server up to TLS 1.2, it can also implement crypto.Decrypter with\n\t// an RSA PublicKey.\n\tPrivateKey crypto.PrivateKey\n\t// SupportedSignatureAlgorithms is an optional list restricting what\n\t// signature algorithms the PrivateKey can be used for.\n\tSupportedSignatureAlgorithms []SignatureScheme\n\t// OCSPStaple contains an optional OCSP response which will be served\n\t// to clients that request it.\n\tOCSPStaple []byte\n\t// SignedCertificateTimestamps contains an optional list of Signed\n\t// Certificate Timestamps which will be served to clients that request it.\n\tSignedCertificateTimestamps [][]byte\n\t// Leaf is the parsed form of the leaf certificate, which may be initialized\n\t// using x509.ParseCertificate to reduce per-handshake processing. If nil,\n\t// the leaf certificate will be parsed as needed.\n\tLeaf *x509.Certificate\n}\n```\n\nA Certificate is a chain of one or more certificates, leaf first. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#LoadX509KeyPair",
                    "documentation": {
                      "identifier": "LoadX509KeyPair",
                      "newPage": false,
                      "searchKey": "tls.LoadX509KeyPair",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc LoadX509KeyPair(certFile, keyFile string) (Certificate, error)\n```\n\nLoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#X509KeyPair",
                    "documentation": {
                      "identifier": "X509KeyPair",
                      "newPage": false,
                      "searchKey": "tls.X509KeyPair",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)\n```\n\nX509KeyPair parses a public/private key pair from a pair of PEM encoded data. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Certificate.leaf",
                    "documentation": {
                      "identifier": "Certificate.leaf",
                      "newPage": false,
                      "searchKey": "tls.Certificate.leaf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Certificate) leaf() (*x509.Certificate, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Certificate) leaf() (*x509.Certificate, error)\n```\n\nleaf returns the parsed leaf certificate, either from c.Leaf or by parsing the corresponding c.Certificate[0]. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#handshakeMessage",
              "documentation": {
                "identifier": "handshakeMessage",
                "newPage": false,
                "searchKey": "tls.handshakeMessage",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type handshakeMessage interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype handshakeMessage interface {\n\tmarshal() []byte\n\tunmarshal([]byte) bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#lruSessionCache",
              "documentation": {
                "identifier": "lruSessionCache",
                "newPage": false,
                "searchKey": "tls.lruSessionCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type lruSessionCache struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype lruSessionCache struct {\n\tsync.Mutex\n\n\tm        map[string]*list.Element\n\tq        *list.List\n\tcapacity int\n}\n```\n\nlruSessionCache is a ClientSessionCache implementation that uses an LRU caching strategy. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#lruSessionCache.Put",
                    "documentation": {
                      "identifier": "lruSessionCache.Put",
                      "newPage": false,
                      "searchKey": "tls.lruSessionCache.Put",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *lruSessionCache) Put(sessionKey string, cs *ClientSessionState)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *lruSessionCache) Put(sessionKey string, cs *ClientSessionState)\n```\n\nPut adds the provided (sessionKey, cs) pair to the cache. If cs is nil, the entry corresponding to sessionKey is removed from the cache instead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#lruSessionCache.Get",
                    "documentation": {
                      "identifier": "lruSessionCache.Get",
                      "newPage": false,
                      "searchKey": "tls.lruSessionCache.Get",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *lruSessionCache) Get(sessionKey string) (*ClientSessionState, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *lruSessionCache) Get(sessionKey string) (*ClientSessionState, bool)\n```\n\nGet returns the ClientSessionState value associated with a given key. It returns (nil, false) if no value is found. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#lruSessionCacheEntry",
              "documentation": {
                "identifier": "lruSessionCacheEntry",
                "newPage": false,
                "searchKey": "tls.lruSessionCacheEntry",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type lruSessionCacheEntry struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype lruSessionCacheEntry struct {\n\tsessionKey string\n\tstate      *ClientSessionState\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#Conn",
              "documentation": {
                "identifier": "Conn",
                "newPage": false,
                "searchKey": "tls.Conn",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Conn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Conn struct {\n\t// constant\n\tconn        net.Conn\n\tisClient    bool\n\thandshakeFn func(context.Context) error // (*Conn).clientHandshake or serverHandshake\n\n\t// handshakeStatus is 1 if the connection is currently transferring\n\t// application data (i.e. is not currently processing a handshake).\n\t// This field is only to be accessed with sync/atomic.\n\thandshakeStatus uint32\n\t// constant after handshake; protected by handshakeMutex\n\thandshakeMutex sync.Mutex\n\thandshakeErr   error   // error resulting from handshake\n\tvers           uint16  // TLS version\n\thaveVers       bool    // version has been negotiated\n\tconfig         *Config // configuration passed to constructor\n\t// handshakes counts the number of handshakes performed on the\n\t// connection so far. If renegotiation is disabled then this is either\n\t// zero or one.\n\thandshakes       int\n\tdidResume        bool // whether this connection was a session resumption\n\tcipherSuite      uint16\n\tocspResponse     []byte   // stapled OCSP response\n\tscts             [][]byte // signed certificate timestamps from server\n\tpeerCertificates []*x509.Certificate\n\t// verifiedChains contains the certificate chains that we built, as\n\t// opposed to the ones presented by the server.\n\tverifiedChains [][]*x509.Certificate\n\t// serverName contains the server name indicated by the client, if any.\n\tserverName string\n\t// secureRenegotiation is true if the server echoed the secure\n\t// renegotiation extension. (This is meaningless as a server because\n\t// renegotiation is not supported in that case.)\n\tsecureRenegotiation bool\n\t// ekm is a closure for exporting keying material.\n\tekm func(label string, context []byte, length int) ([]byte, error)\n\t// resumptionSecret is the resumption_master_secret for handling\n\t// NewSessionTicket messages. nil if config.SessionTicketsDisabled.\n\tresumptionSecret []byte\n\n\t// ticketKeys is the set of active session ticket keys for this\n\t// connection. The first one is used to encrypt new tickets and\n\t// all are tried to decrypt tickets.\n\tticketKeys []ticketKey\n\n\t// clientFinishedIsFirst is true if the client sent the first Finished\n\t// message during the most recent handshake. This is recorded because\n\t// the first transmitted Finished message is the tls-unique\n\t// channel-binding value.\n\tclientFinishedIsFirst bool\n\n\t// closeNotifyErr is any error from sending the alertCloseNotify record.\n\tcloseNotifyErr error\n\t// closeNotifySent is true if the Conn attempted to send an\n\t// alertCloseNotify record.\n\tcloseNotifySent bool\n\n\t// clientFinished and serverFinished contain the Finished message sent\n\t// by the client or server in the most recent handshake. This is\n\t// retained to support the renegotiation extension and tls-unique\n\t// channel-binding.\n\tclientFinished [12]byte\n\tserverFinished [12]byte\n\n\t// clientProtocol is the negotiated ALPN protocol.\n\tclientProtocol string\n\n\t// input/output\n\tin, out   halfConn\n\trawInput  bytes.Buffer // raw input, starting with a record header\n\tinput     bytes.Reader // application data waiting to be read, from rawInput.Next\n\thand      bytes.Buffer // handshake data waiting to be read\n\tbuffering bool         // whether records are buffered in sendBuf\n\tsendBuf   []byte       // a buffer of records waiting to be sent\n\n\t// bytesSent counts the bytes of application data sent.\n\t// packetsSent counts packets.\n\tbytesSent   int64\n\tpacketsSent int64\n\n\t// retryCount counts the number of consecutive non-advancing records\n\t// received by Conn.readRecord. That is, records that neither advance the\n\t// handshake, nor deliver application data. Protected by in.Mutex.\n\tretryCount int\n\n\t// activeCall is an atomic int32; the low bit is whether Close has\n\t// been called. the rest of the bits are the number of goroutines\n\t// in Conn.Write.\n\tactiveCall int32\n\n\ttmp [16]byte\n}\n```\n\nA Conn represents a secured connection. It implements the net.Conn interface. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Server",
                    "documentation": {
                      "identifier": "Server",
                      "newPage": false,
                      "searchKey": "tls.Server",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Server(conn net.Conn, config *Config) *Conn"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Server(conn net.Conn, config *Config) *Conn\n```\n\nServer returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Client",
                    "documentation": {
                      "identifier": "Client",
                      "newPage": false,
                      "searchKey": "tls.Client",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Client(conn net.Conn, config *Config) *Conn"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Client(conn net.Conn, config *Config) *Conn\n```\n\nClient returns a new TLS client side connection using conn as the underlying transport. The config cannot be nil: users must set either ServerName or InsecureSkipVerify in the config. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#DialWithDialer",
                    "documentation": {
                      "identifier": "DialWithDialer",
                      "newPage": false,
                      "searchKey": "tls.DialWithDialer",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)\n```\n\nDialWithDialer connects to the given network address using dialer.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Any timeout or deadline given in the dialer apply to connection and TLS handshake as a whole. \n\nDialWithDialer interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults. \n\nDialWithDialer uses context.Background internally; to specify the context, use Dialer.DialContext with NetDialer set to the desired dialer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#dial",
                    "documentation": {
                      "identifier": "dial",
                      "newPage": false,
                      "searchKey": "tls.dial",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func dial(ctx context.Context, netDialer *net.Dialer, network, addr string, config *Config) (*Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc dial(ctx context.Context, netDialer *net.Dialer, network, addr string, config *Config) (*Conn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Dial",
                    "documentation": {
                      "identifier": "Dial",
                      "newPage": false,
                      "searchKey": "tls.Dial",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Dial(network, addr string, config *Config) (*Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Dial(network, addr string, config *Config) (*Conn, error)\n```\n\nDial connects to the given network address using net.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Dial interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.LocalAddr",
                    "documentation": {
                      "identifier": "Conn.LocalAddr",
                      "newPage": false,
                      "searchKey": "tls.Conn.LocalAddr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) LocalAddr() net.Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) LocalAddr() net.Addr\n```\n\nLocalAddr returns the local network address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.RemoteAddr",
                    "documentation": {
                      "identifier": "Conn.RemoteAddr",
                      "newPage": false,
                      "searchKey": "tls.Conn.RemoteAddr",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) RemoteAddr() net.Addr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) RemoteAddr() net.Addr\n```\n\nRemoteAddr returns the remote network address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.SetDeadline",
                    "documentation": {
                      "identifier": "Conn.SetDeadline",
                      "newPage": false,
                      "searchKey": "tls.Conn.SetDeadline",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) SetDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) SetDeadline(t time.Time) error\n```\n\nSetDeadline sets the read and write deadlines associated with the connection. A zero value for t means Read and Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.SetReadDeadline",
                    "documentation": {
                      "identifier": "Conn.SetReadDeadline",
                      "newPage": false,
                      "searchKey": "tls.Conn.SetReadDeadline",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) SetReadDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) SetReadDeadline(t time.Time) error\n```\n\nSetReadDeadline sets the read deadline on the underlying connection. A zero value for t means Read will not time out. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.SetWriteDeadline",
                    "documentation": {
                      "identifier": "Conn.SetWriteDeadline",
                      "newPage": false,
                      "searchKey": "tls.Conn.SetWriteDeadline",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) SetWriteDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) SetWriteDeadline(t time.Time) error\n```\n\nSetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.newRecordHeaderError",
                    "documentation": {
                      "identifier": "Conn.newRecordHeaderError",
                      "newPage": false,
                      "searchKey": "tls.Conn.newRecordHeaderError",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) newRecordHeaderError(conn net.Conn, msg string) (err RecordHeaderError)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) newRecordHeaderError(conn net.Conn, msg string) (err RecordHeaderError)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.readRecord",
                    "documentation": {
                      "identifier": "Conn.readRecord",
                      "newPage": false,
                      "searchKey": "tls.Conn.readRecord",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) readRecord() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) readRecord() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.readChangeCipherSpec",
                    "documentation": {
                      "identifier": "Conn.readChangeCipherSpec",
                      "newPage": false,
                      "searchKey": "tls.Conn.readChangeCipherSpec",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) readChangeCipherSpec() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) readChangeCipherSpec() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.readRecordOrCCS",
                    "documentation": {
                      "identifier": "Conn.readRecordOrCCS",
                      "newPage": false,
                      "searchKey": "tls.Conn.readRecordOrCCS",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) readRecordOrCCS(expectChangeCipherSpec bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) readRecordOrCCS(expectChangeCipherSpec bool) error\n```\n\nreadRecordOrCCS reads one or more TLS records from the connection and updates the record layer state. Some invariants: \n\n```\n* c.in must be locked\n* c.input must be empty\n\n```\nDuring the handshake one and only one of the following will happen: \n\n```\n- c.hand grows\n- c.in.changeCipherSpec is called\n- an error is returned\n\n```\nAfter the handshake one and only one of the following will happen: \n\n```\n- c.hand grows\n- c.input is set\n- an error is returned\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.retryReadRecord",
                    "documentation": {
                      "identifier": "Conn.retryReadRecord",
                      "newPage": false,
                      "searchKey": "tls.Conn.retryReadRecord",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) retryReadRecord(expectChangeCipherSpec bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) retryReadRecord(expectChangeCipherSpec bool) error\n```\n\nretryReadRecord recurses into readRecordOrCCS to drop a non-advancing record, like a warning alert, empty application_data, or a change_cipher_spec in TLS 1.3. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.readFromUntil",
                    "documentation": {
                      "identifier": "Conn.readFromUntil",
                      "newPage": false,
                      "searchKey": "tls.Conn.readFromUntil",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) readFromUntil(r io.Reader, n int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) readFromUntil(r io.Reader, n int) error\n```\n\nreadFromUntil reads from r into c.rawInput until c.rawInput contains at least n bytes or else returns an error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.sendAlertLocked",
                    "documentation": {
                      "identifier": "Conn.sendAlertLocked",
                      "newPage": false,
                      "searchKey": "tls.Conn.sendAlertLocked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) sendAlertLocked(err alert) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) sendAlertLocked(err alert) error\n```\n\nsendAlert sends a TLS alert message. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.sendAlert",
                    "documentation": {
                      "identifier": "Conn.sendAlert",
                      "newPage": false,
                      "searchKey": "tls.Conn.sendAlert",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) sendAlert(err alert) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) sendAlert(err alert) error\n```\n\nsendAlert sends a TLS alert message. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.maxPayloadSizeForWrite",
                    "documentation": {
                      "identifier": "Conn.maxPayloadSizeForWrite",
                      "newPage": false,
                      "searchKey": "tls.Conn.maxPayloadSizeForWrite",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) maxPayloadSizeForWrite(typ recordType) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) maxPayloadSizeForWrite(typ recordType) int\n```\n\nmaxPayloadSizeForWrite returns the maximum TLS payload size to use for the next application data record. There is the following trade-off: \n\n```\n- For latency-sensitive applications, such as web browsing, each TLS\n  record should fit in one TCP segment.\n- For throughput-sensitive applications, such as large file transfers,\n  larger TLS records better amortize framing and encryption overheads.\n\n```\nA simple heuristic that works well in practice is to use small records for the first 1MB of data, then use larger records for subsequent data, and reset back to smaller records after the connection becomes idle. See \"High Performance Web Networking\", Chapter 4, or: [https://www.igvita.com/2013/10/24/optimizing-tls-record-size-and-buffering-latency/](https://www.igvita.com/2013/10/24/optimizing-tls-record-size-and-buffering-latency/) \n\nIn the interests of simplicity and determinism, this code does not attempt to reset the record size once the connection is idle, however. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.write",
                    "documentation": {
                      "identifier": "Conn.write",
                      "newPage": false,
                      "searchKey": "tls.Conn.write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) write(data []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) write(data []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.flush",
                    "documentation": {
                      "identifier": "Conn.flush",
                      "newPage": false,
                      "searchKey": "tls.Conn.flush",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) flush() (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) flush() (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.writeRecordLocked",
                    "documentation": {
                      "identifier": "Conn.writeRecordLocked",
                      "newPage": false,
                      "searchKey": "tls.Conn.writeRecordLocked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) writeRecordLocked(typ recordType, data []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) writeRecordLocked(typ recordType, data []byte) (int, error)\n```\n\nwriteRecordLocked writes a TLS record with the given type and payload to the connection and updates the record layer state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.writeRecord",
                    "documentation": {
                      "identifier": "Conn.writeRecord",
                      "newPage": false,
                      "searchKey": "tls.Conn.writeRecord",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) writeRecord(typ recordType, data []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) writeRecord(typ recordType, data []byte) (int, error)\n```\n\nwriteRecord writes a TLS record with the given type and payload to the connection and updates the record layer state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.readHandshake",
                    "documentation": {
                      "identifier": "Conn.readHandshake",
                      "newPage": false,
                      "searchKey": "tls.Conn.readHandshake",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) readHandshake() (interface{}, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) readHandshake() (interface{}, error)\n```\n\nreadHandshake reads the next handshake message from the record layer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.Write",
                    "documentation": {
                      "identifier": "Conn.Write",
                      "newPage": false,
                      "searchKey": "tls.Conn.Write",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) Write(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) Write(b []byte) (int, error)\n```\n\nWrite writes data to the connection. \n\nAs Write calls Handshake, in order to prevent indefinite blocking a deadline must be set for both Read and Write before Write is called when the handshake has not yet completed. See SetDeadline, SetReadDeadline, and SetWriteDeadline. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.handleRenegotiation",
                    "documentation": {
                      "identifier": "Conn.handleRenegotiation",
                      "newPage": false,
                      "searchKey": "tls.Conn.handleRenegotiation",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) handleRenegotiation() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) handleRenegotiation() error\n```\n\nhandleRenegotiation processes a HelloRequest handshake message. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.handlePostHandshakeMessage",
                    "documentation": {
                      "identifier": "Conn.handlePostHandshakeMessage",
                      "newPage": false,
                      "searchKey": "tls.Conn.handlePostHandshakeMessage",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) handlePostHandshakeMessage() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) handlePostHandshakeMessage() error\n```\n\nhandlePostHandshakeMessage processes a handshake message arrived after the handshake is complete. Up to TLS 1.2, it indicates the start of a renegotiation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.handleKeyUpdate",
                    "documentation": {
                      "identifier": "Conn.handleKeyUpdate",
                      "newPage": false,
                      "searchKey": "tls.Conn.handleKeyUpdate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) handleKeyUpdate(keyUpdate *keyUpdateMsg) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) handleKeyUpdate(keyUpdate *keyUpdateMsg) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.Read",
                    "documentation": {
                      "identifier": "Conn.Read",
                      "newPage": false,
                      "searchKey": "tls.Conn.Read",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) Read(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) Read(b []byte) (int, error)\n```\n\nRead reads data from the connection. \n\nAs Read calls Handshake, in order to prevent indefinite blocking a deadline must be set for both Read and Write before Read is called when the handshake has not yet completed. See SetDeadline, SetReadDeadline, and SetWriteDeadline. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.Close",
                    "documentation": {
                      "identifier": "Conn.Close",
                      "newPage": false,
                      "searchKey": "tls.Conn.Close",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) Close() error\n```\n\nClose closes the connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.CloseWrite",
                    "documentation": {
                      "identifier": "Conn.CloseWrite",
                      "newPage": false,
                      "searchKey": "tls.Conn.CloseWrite",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) CloseWrite() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) CloseWrite() error\n```\n\nCloseWrite shuts down the writing side of the connection. It should only be called once the handshake has completed and does not call CloseWrite on the underlying connection. Most callers should just use Close. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.closeNotify",
                    "documentation": {
                      "identifier": "Conn.closeNotify",
                      "newPage": false,
                      "searchKey": "tls.Conn.closeNotify",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) closeNotify() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) closeNotify() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.Handshake",
                    "documentation": {
                      "identifier": "Conn.Handshake",
                      "newPage": false,
                      "searchKey": "tls.Conn.Handshake",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) Handshake() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) Handshake() error\n```\n\nHandshake runs the client or server handshake protocol if it has not yet been run. \n\nMost uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically. \n\nFor control over canceling or setting a timeout on a handshake, use HandshakeContext or the Dialer's DialContext method instead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.HandshakeContext",
                    "documentation": {
                      "identifier": "Conn.HandshakeContext",
                      "newPage": false,
                      "searchKey": "tls.Conn.HandshakeContext",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) HandshakeContext(ctx context.Context) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) HandshakeContext(ctx context.Context) error\n```\n\nHandshakeContext runs the client or server handshake protocol if it has not yet been run. \n\nThe provided Context must be non-nil. If the context is canceled before the handshake is complete, the handshake is interrupted and an error is returned. Once the handshake has completed, cancellation of the context will not affect the connection. \n\nMost uses of this package need not call HandshakeContext explicitly: the first Read or Write will call it automatically. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.handshakeContext",
                    "documentation": {
                      "identifier": "Conn.handshakeContext",
                      "newPage": false,
                      "searchKey": "tls.Conn.handshakeContext",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) handshakeContext(ctx context.Context) (ret error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) handshakeContext(ctx context.Context) (ret error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.ConnectionState",
                    "documentation": {
                      "identifier": "Conn.ConnectionState",
                      "newPage": false,
                      "searchKey": "tls.Conn.ConnectionState",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) ConnectionState() ConnectionState"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) ConnectionState() ConnectionState\n```\n\nConnectionState returns basic TLS details about the connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.connectionStateLocked",
                    "documentation": {
                      "identifier": "Conn.connectionStateLocked",
                      "newPage": false,
                      "searchKey": "tls.Conn.connectionStateLocked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) connectionStateLocked() ConnectionState"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) connectionStateLocked() ConnectionState\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.OCSPResponse",
                    "documentation": {
                      "identifier": "Conn.OCSPResponse",
                      "newPage": false,
                      "searchKey": "tls.Conn.OCSPResponse",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) OCSPResponse() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) OCSPResponse() []byte\n```\n\nOCSPResponse returns the stapled OCSP response from the TLS server, if any. (Only valid for client connections.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.VerifyHostname",
                    "documentation": {
                      "identifier": "Conn.VerifyHostname",
                      "newPage": false,
                      "searchKey": "tls.Conn.VerifyHostname",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) VerifyHostname(host string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) VerifyHostname(host string) error\n```\n\nVerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.handshakeComplete",
                    "documentation": {
                      "identifier": "Conn.handshakeComplete",
                      "newPage": false,
                      "searchKey": "tls.Conn.handshakeComplete",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) handshakeComplete() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) handshakeComplete() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.makeClientHello",
                    "documentation": {
                      "identifier": "Conn.makeClientHello",
                      "newPage": false,
                      "searchKey": "tls.Conn.makeClientHello",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) makeClientHello() (*clientHelloMsg, ecdheParameters, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) makeClientHello() (*clientHelloMsg, ecdheParameters, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.clientHandshake",
                    "documentation": {
                      "identifier": "Conn.clientHandshake",
                      "newPage": false,
                      "searchKey": "tls.Conn.clientHandshake",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) clientHandshake(ctx context.Context) (err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) clientHandshake(ctx context.Context) (err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.loadSession",
                    "documentation": {
                      "identifier": "Conn.loadSession",
                      "newPage": false,
                      "searchKey": "tls.Conn.loadSession",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) loadSession(hello *clientHelloMsg) (cacheKey string,..."
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) loadSession(hello *clientHelloMsg) (cacheKey string,\n\tsession *ClientSessionState, earlySecret, binderKey []byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.pickTLSVersion",
                    "documentation": {
                      "identifier": "Conn.pickTLSVersion",
                      "newPage": false,
                      "searchKey": "tls.Conn.pickTLSVersion",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) pickTLSVersion(serverHello *serverHelloMsg) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) pickTLSVersion(serverHello *serverHelloMsg) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.verifyServerCertificate",
                    "documentation": {
                      "identifier": "Conn.verifyServerCertificate",
                      "newPage": false,
                      "searchKey": "tls.Conn.verifyServerCertificate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) verifyServerCertificate(certificates [][]byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) verifyServerCertificate(certificates [][]byte) error\n```\n\nverifyServerCertificate parses and verifies the provided chain, setting c.verifiedChains and c.peerCertificates or sending the appropriate alert. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.getClientCertificate",
                    "documentation": {
                      "identifier": "Conn.getClientCertificate",
                      "newPage": false,
                      "searchKey": "tls.Conn.getClientCertificate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) getClientCertificate(cri *CertificateRequestInfo) (*Certificate, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) getClientCertificate(cri *CertificateRequestInfo) (*Certificate, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.handleNewSessionTicket",
                    "documentation": {
                      "identifier": "Conn.handleNewSessionTicket",
                      "newPage": false,
                      "searchKey": "tls.Conn.handleNewSessionTicket",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) handleNewSessionTicket(msg *newSessionTicketMsgTLS13) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) handleNewSessionTicket(msg *newSessionTicketMsgTLS13) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.serverHandshake",
                    "documentation": {
                      "identifier": "Conn.serverHandshake",
                      "newPage": false,
                      "searchKey": "tls.Conn.serverHandshake",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) serverHandshake(ctx context.Context) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) serverHandshake(ctx context.Context) error\n```\n\nserverHandshake performs a TLS handshake as a server. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.readClientHello",
                    "documentation": {
                      "identifier": "Conn.readClientHello",
                      "newPage": false,
                      "searchKey": "tls.Conn.readClientHello",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) readClientHello(ctx context.Context) (*clientHelloMsg, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) readClientHello(ctx context.Context) (*clientHelloMsg, error)\n```\n\nreadClientHello reads a ClientHello message and selects the protocol version. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.processCertsFromClient",
                    "documentation": {
                      "identifier": "Conn.processCertsFromClient",
                      "newPage": false,
                      "searchKey": "tls.Conn.processCertsFromClient",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) processCertsFromClient(certificate Certificate) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) processCertsFromClient(certificate Certificate) error\n```\n\nprocessCertsFromClient takes a chain of client certificates either from a Certificates message or from a sessionState and verifies them. It returns the public key of the leaf certificate. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.encryptTicket",
                    "documentation": {
                      "identifier": "Conn.encryptTicket",
                      "newPage": false,
                      "searchKey": "tls.Conn.encryptTicket",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) encryptTicket(state []byte) ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) encryptTicket(state []byte) ([]byte, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Conn.decryptTicket",
                    "documentation": {
                      "identifier": "Conn.decryptTicket",
                      "newPage": false,
                      "searchKey": "tls.Conn.decryptTicket",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *Conn) decryptTicket(encrypted []byte) (plaintext []byte, usedOldKey bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *Conn) decryptTicket(encrypted []byte) (plaintext []byte, usedOldKey bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#halfConn",
              "documentation": {
                "identifier": "halfConn",
                "newPage": false,
                "searchKey": "tls.halfConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type halfConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype halfConn struct {\n\tsync.Mutex\n\n\terr     error       // first permanent error\n\tversion uint16      // protocol version\n\tcipher  interface{} // cipher algorithm\n\tmac     hash.Hash\n\tseq     [8]byte // 64-bit sequence number\n\n\tscratchBuf [13]byte // to avoid allocs; interface method args escape\n\n\tnextCipher interface{} // next encryption state\n\tnextMac    hash.Hash   // next MAC algorithm\n\n\ttrafficSecret []byte // current TLS 1.3 traffic secret\n}\n```\n\nA halfConn represents one direction of the record layer connection, either sending or receiving. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#halfConn.setErrorLocked",
                    "documentation": {
                      "identifier": "halfConn.setErrorLocked",
                      "newPage": false,
                      "searchKey": "tls.halfConn.setErrorLocked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hc *halfConn) setErrorLocked(err error) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hc *halfConn) setErrorLocked(err error) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#halfConn.prepareCipherSpec",
                    "documentation": {
                      "identifier": "halfConn.prepareCipherSpec",
                      "newPage": false,
                      "searchKey": "tls.halfConn.prepareCipherSpec",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hc *halfConn) prepareCipherSpec(version uint16, cipher interface{}, mac hash.Hash)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hc *halfConn) prepareCipherSpec(version uint16, cipher interface{}, mac hash.Hash)\n```\n\nprepareCipherSpec sets the encryption and MAC states that a subsequent changeCipherSpec will use. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#halfConn.changeCipherSpec",
                    "documentation": {
                      "identifier": "halfConn.changeCipherSpec",
                      "newPage": false,
                      "searchKey": "tls.halfConn.changeCipherSpec",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hc *halfConn) changeCipherSpec() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hc *halfConn) changeCipherSpec() error\n```\n\nchangeCipherSpec changes the encryption and MAC states to the ones previously passed to prepareCipherSpec. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#halfConn.setTrafficSecret",
                    "documentation": {
                      "identifier": "halfConn.setTrafficSecret",
                      "newPage": false,
                      "searchKey": "tls.halfConn.setTrafficSecret",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hc *halfConn) setTrafficSecret(suite *cipherSuiteTLS13, secret []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hc *halfConn) setTrafficSecret(suite *cipherSuiteTLS13, secret []byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#halfConn.incSeq",
                    "documentation": {
                      "identifier": "halfConn.incSeq",
                      "newPage": false,
                      "searchKey": "tls.halfConn.incSeq",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hc *halfConn) incSeq()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hc *halfConn) incSeq()\n```\n\nincSeq increments the sequence number. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#halfConn.explicitNonceLen",
                    "documentation": {
                      "identifier": "halfConn.explicitNonceLen",
                      "newPage": false,
                      "searchKey": "tls.halfConn.explicitNonceLen",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hc *halfConn) explicitNonceLen() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hc *halfConn) explicitNonceLen() int\n```\n\nexplicitNonceLen returns the number of bytes of explicit nonce or IV included in each record. Explicit nonces are present only in CBC modes after TLS 1.0 and in certain AEAD modes in TLS 1.2. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#halfConn.decrypt",
                    "documentation": {
                      "identifier": "halfConn.decrypt",
                      "newPage": false,
                      "searchKey": "tls.halfConn.decrypt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hc *halfConn) decrypt(record []byte) ([]byte, recordType, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hc *halfConn) decrypt(record []byte) ([]byte, recordType, error)\n```\n\ndecrypt authenticates and decrypts the record if protection is active at this stage. The returned plaintext might overlap with the input. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#halfConn.encrypt",
                    "documentation": {
                      "identifier": "halfConn.encrypt",
                      "newPage": false,
                      "searchKey": "tls.halfConn.encrypt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hc *halfConn) encrypt(record, payload []byte, rand io.Reader) ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hc *halfConn) encrypt(record, payload []byte, rand io.Reader) ([]byte, error)\n```\n\nencrypt encrypts payload, adding the appropriate nonce and/or MAC, and appends it to record, which must already contain the record header. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#permanentError",
              "documentation": {
                "identifier": "permanentError",
                "newPage": false,
                "searchKey": "tls.permanentError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type permanentError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype permanentError struct {\n\terr net.Error\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#permanentError.Error",
                    "documentation": {
                      "identifier": "permanentError.Error",
                      "newPage": false,
                      "searchKey": "tls.permanentError.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *permanentError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *permanentError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#permanentError.Unwrap",
                    "documentation": {
                      "identifier": "permanentError.Unwrap",
                      "newPage": false,
                      "searchKey": "tls.permanentError.Unwrap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *permanentError) Unwrap() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *permanentError) Unwrap() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#permanentError.Timeout",
                    "documentation": {
                      "identifier": "permanentError.Timeout",
                      "newPage": false,
                      "searchKey": "tls.permanentError.Timeout",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *permanentError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *permanentError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#permanentError.Temporary",
                    "documentation": {
                      "identifier": "permanentError.Temporary",
                      "newPage": false,
                      "searchKey": "tls.permanentError.Temporary",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *permanentError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *permanentError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cbcMode",
              "documentation": {
                "identifier": "cbcMode",
                "newPage": false,
                "searchKey": "tls.cbcMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cbcMode interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cbcMode interface {\n\tcipher.BlockMode\n\tSetIV([]byte)\n}\n```\n\ncbcMode is an interface for block ciphers using cipher block chaining. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#RecordHeaderError",
              "documentation": {
                "identifier": "RecordHeaderError",
                "newPage": false,
                "searchKey": "tls.RecordHeaderError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RecordHeaderError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RecordHeaderError struct {\n\t// Msg contains a human readable string that describes the error.\n\tMsg string\n\t// RecordHeader contains the five bytes of TLS record header that\n\t// triggered the error.\n\tRecordHeader [5]byte\n\t// Conn provides the underlying net.Conn in the case that a client\n\t// sent an initial handshake that didn't look like TLS.\n\t// It is nil if there's already been a handshake or a TLS alert has\n\t// been written to the connection.\n\tConn net.Conn\n}\n```\n\nRecordHeaderError is returned when a TLS record header is invalid. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#RecordHeaderError.Error",
                    "documentation": {
                      "identifier": "RecordHeaderError.Error",
                      "newPage": false,
                      "searchKey": "tls.RecordHeaderError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e RecordHeaderError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e RecordHeaderError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#atLeastReader",
              "documentation": {
                "identifier": "atLeastReader",
                "newPage": false,
                "searchKey": "tls.atLeastReader",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type atLeastReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype atLeastReader struct {\n\tR io.Reader\n\tN int64\n}\n```\n\natLeastReader reads from R, stopping with EOF once at least N bytes have been read. It is different from an io.LimitedReader in that it doesn't cut short the last Read call, and in that it considers an early EOF an error. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#atLeastReader.Read",
                    "documentation": {
                      "identifier": "atLeastReader.Read",
                      "newPage": false,
                      "searchKey": "tls.atLeastReader.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *atLeastReader) Read(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *atLeastReader) Read(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientHandshakeState",
              "documentation": {
                "identifier": "clientHandshakeState",
                "newPage": false,
                "searchKey": "tls.clientHandshakeState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type clientHandshakeState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype clientHandshakeState struct {\n\tc            *Conn\n\tctx          context.Context\n\tserverHello  *serverHelloMsg\n\thello        *clientHelloMsg\n\tsuite        *cipherSuite\n\tfinishedHash finishedHash\n\tmasterSecret []byte\n\tsession      *ClientSessionState\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeState.handshake",
                    "documentation": {
                      "identifier": "clientHandshakeState.handshake",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeState.handshake",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeState) handshake() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeState) handshake() error\n```\n\nDoes the handshake, either a full one or resumes old session. Requires hs.c, hs.hello, hs.serverHello, and, optionally, hs.session to be set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeState.pickCipherSuite",
                    "documentation": {
                      "identifier": "clientHandshakeState.pickCipherSuite",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeState.pickCipherSuite",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeState) pickCipherSuite() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeState) pickCipherSuite() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeState.doFullHandshake",
                    "documentation": {
                      "identifier": "clientHandshakeState.doFullHandshake",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeState.doFullHandshake",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeState) doFullHandshake() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeState) doFullHandshake() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeState.establishKeys",
                    "documentation": {
                      "identifier": "clientHandshakeState.establishKeys",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeState.establishKeys",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeState) establishKeys() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeState) establishKeys() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeState.serverResumedSession",
                    "documentation": {
                      "identifier": "clientHandshakeState.serverResumedSession",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeState.serverResumedSession",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeState) serverResumedSession() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeState) serverResumedSession() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeState.processServerHello",
                    "documentation": {
                      "identifier": "clientHandshakeState.processServerHello",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeState.processServerHello",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeState) processServerHello() (bool, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeState) processServerHello() (bool, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeState.readFinished",
                    "documentation": {
                      "identifier": "clientHandshakeState.readFinished",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeState.readFinished",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeState) readFinished(out []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeState) readFinished(out []byte) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeState.readSessionTicket",
                    "documentation": {
                      "identifier": "clientHandshakeState.readSessionTicket",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeState.readSessionTicket",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeState) readSessionTicket() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeState) readSessionTicket() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeState.sendFinished",
                    "documentation": {
                      "identifier": "clientHandshakeState.sendFinished",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeState.sendFinished",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeState) sendFinished(out []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeState) sendFinished(out []byte) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientHandshakeStateTLS13",
              "documentation": {
                "identifier": "clientHandshakeStateTLS13",
                "newPage": false,
                "searchKey": "tls.clientHandshakeStateTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type clientHandshakeStateTLS13 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype clientHandshakeStateTLS13 struct {\n\tc           *Conn\n\tctx         context.Context\n\tserverHello *serverHelloMsg\n\thello       *clientHelloMsg\n\tecdheParams ecdheParameters\n\n\tsession     *ClientSessionState\n\tearlySecret []byte\n\tbinderKey   []byte\n\n\tcertReq       *certificateRequestMsgTLS13\n\tusingPSK      bool\n\tsentDummyCCS  bool\n\tsuite         *cipherSuiteTLS13\n\ttranscript    hash.Hash\n\tmasterSecret  []byte\n\ttrafficSecret []byte // client_application_traffic_secret_0\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeStateTLS13.handshake",
                    "documentation": {
                      "identifier": "clientHandshakeStateTLS13.handshake",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeStateTLS13.handshake",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeStateTLS13) handshake() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeStateTLS13) handshake() error\n```\n\nhandshake requires hs.c, hs.hello, hs.serverHello, hs.ecdheParams, and, optionally, hs.session, hs.earlySecret and hs.binderKey to be set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeStateTLS13.checkServerHelloOrHRR",
                    "documentation": {
                      "identifier": "clientHandshakeStateTLS13.checkServerHelloOrHRR",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeStateTLS13.checkServerHelloOrHRR",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeStateTLS13) checkServerHelloOrHRR() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeStateTLS13) checkServerHelloOrHRR() error\n```\n\ncheckServerHelloOrHRR does validity checks that apply to both ServerHello and HelloRetryRequest messages. It sets hs.suite. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeStateTLS13.sendDummyChangeCipherSpec",
                    "documentation": {
                      "identifier": "clientHandshakeStateTLS13.sendDummyChangeCipherSpec",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeStateTLS13.sendDummyChangeCipherSpec",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeStateTLS13) sendDummyChangeCipherSpec() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeStateTLS13) sendDummyChangeCipherSpec() error\n```\n\nsendDummyChangeCipherSpec sends a ChangeCipherSpec record for compatibility with middleboxes that didn't implement TLS correctly. See RFC 8446, Appendix D.4. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeStateTLS13.processHelloRetryRequest",
                    "documentation": {
                      "identifier": "clientHandshakeStateTLS13.processHelloRetryRequest",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeStateTLS13.processHelloRetryRequest",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeStateTLS13) processHelloRetryRequest() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeStateTLS13) processHelloRetryRequest() error\n```\n\nprocessHelloRetryRequest handles the HRR in hs.serverHello, modifies and resends hs.hello, and reads the new ServerHello into hs.serverHello. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeStateTLS13.processServerHello",
                    "documentation": {
                      "identifier": "clientHandshakeStateTLS13.processServerHello",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeStateTLS13.processServerHello",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeStateTLS13) processServerHello() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeStateTLS13) processServerHello() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeStateTLS13.establishHandshakeKeys",
                    "documentation": {
                      "identifier": "clientHandshakeStateTLS13.establishHandshakeKeys",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeStateTLS13.establishHandshakeKeys",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeStateTLS13) establishHandshakeKeys() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeStateTLS13) establishHandshakeKeys() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeStateTLS13.readServerParameters",
                    "documentation": {
                      "identifier": "clientHandshakeStateTLS13.readServerParameters",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeStateTLS13.readServerParameters",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeStateTLS13) readServerParameters() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeStateTLS13) readServerParameters() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeStateTLS13.readServerCertificate",
                    "documentation": {
                      "identifier": "clientHandshakeStateTLS13.readServerCertificate",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeStateTLS13.readServerCertificate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeStateTLS13) readServerCertificate() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeStateTLS13) readServerCertificate() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeStateTLS13.readServerFinished",
                    "documentation": {
                      "identifier": "clientHandshakeStateTLS13.readServerFinished",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeStateTLS13.readServerFinished",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeStateTLS13) readServerFinished() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeStateTLS13) readServerFinished() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeStateTLS13.sendClientCertificate",
                    "documentation": {
                      "identifier": "clientHandshakeStateTLS13.sendClientCertificate",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeStateTLS13.sendClientCertificate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeStateTLS13) sendClientCertificate() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeStateTLS13) sendClientCertificate() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHandshakeStateTLS13.sendClientFinished",
                    "documentation": {
                      "identifier": "clientHandshakeStateTLS13.sendClientFinished",
                      "newPage": false,
                      "searchKey": "tls.clientHandshakeStateTLS13.sendClientFinished",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *clientHandshakeStateTLS13) sendClientFinished() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *clientHandshakeStateTLS13) sendClientFinished() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#marshalingFunction",
              "documentation": {
                "identifier": "marshalingFunction",
                "newPage": false,
                "searchKey": "tls.marshalingFunction",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type marshalingFunction func(b *golang.org/x/crypto/cryptobyte.Builder) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype marshalingFunction func(b *cryptobyte.Builder) error\n```\n\nThe marshalingFunction type is an adapter to allow the use of ordinary functions as cryptobyte.MarshalingValue. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#marshalingFunction.Marshal",
                    "documentation": {
                      "identifier": "marshalingFunction.Marshal",
                      "newPage": false,
                      "searchKey": "tls.marshalingFunction.Marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f marshalingFunction) Marshal(b *cryptobyte.Builder) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f marshalingFunction) Marshal(b *cryptobyte.Builder) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientHelloMsg",
              "documentation": {
                "identifier": "clientHelloMsg",
                "newPage": false,
                "searchKey": "tls.clientHelloMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type clientHelloMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype clientHelloMsg struct {\n\traw                              []byte\n\tvers                             uint16\n\trandom                           []byte\n\tsessionId                        []byte\n\tcipherSuites                     []uint16\n\tcompressionMethods               []uint8\n\tserverName                       string\n\tocspStapling                     bool\n\tsupportedCurves                  []CurveID\n\tsupportedPoints                  []uint8\n\tticketSupported                  bool\n\tsessionTicket                    []uint8\n\tsupportedSignatureAlgorithms     []SignatureScheme\n\tsupportedSignatureAlgorithmsCert []SignatureScheme\n\tsecureRenegotiationSupported     bool\n\tsecureRenegotiation              []byte\n\talpnProtocols                    []string\n\tscts                             bool\n\tsupportedVersions                []uint16\n\tcookie                           []byte\n\tkeyShares                        []keyShare\n\tearlyData                        bool\n\tpskModes                         []uint8\n\tpskIdentities                    []pskIdentity\n\tpskBinders                       [][]byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHelloMsg.marshal",
                    "documentation": {
                      "identifier": "clientHelloMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.clientHelloMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *clientHelloMsg) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *clientHelloMsg) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHelloMsg.marshalWithoutBinders",
                    "documentation": {
                      "identifier": "clientHelloMsg.marshalWithoutBinders",
                      "newPage": false,
                      "searchKey": "tls.clientHelloMsg.marshalWithoutBinders",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *clientHelloMsg) marshalWithoutBinders() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *clientHelloMsg) marshalWithoutBinders() []byte\n```\n\nmarshalWithoutBinders returns the ClientHello through the PreSharedKeyExtension.identities field, according to RFC 8446, Section 4.2.11.2. Note that m.pskBinders must be set to slices of the correct length. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHelloMsg.updateBinders",
                    "documentation": {
                      "identifier": "clientHelloMsg.updateBinders",
                      "newPage": false,
                      "searchKey": "tls.clientHelloMsg.updateBinders",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *clientHelloMsg) updateBinders(pskBinders [][]byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *clientHelloMsg) updateBinders(pskBinders [][]byte)\n```\n\nupdateBinders updates the m.pskBinders field, if necessary updating the cached marshaled representation. The supplied binders must have the same length as the current m.pskBinders. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHelloMsg.unmarshal",
                    "documentation": {
                      "identifier": "clientHelloMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.clientHelloMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *clientHelloMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *clientHelloMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientHelloMsg.Generate",
                    "documentation": {
                      "identifier": "clientHelloMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.clientHelloMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*clientHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*clientHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#serverHelloMsg",
              "documentation": {
                "identifier": "serverHelloMsg",
                "newPage": false,
                "searchKey": "tls.serverHelloMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type serverHelloMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype serverHelloMsg struct {\n\traw                          []byte\n\tvers                         uint16\n\trandom                       []byte\n\tsessionId                    []byte\n\tcipherSuite                  uint16\n\tcompressionMethod            uint8\n\tocspStapling                 bool\n\tticketSupported              bool\n\tsecureRenegotiationSupported bool\n\tsecureRenegotiation          []byte\n\talpnProtocol                 string\n\tscts                         [][]byte\n\tsupportedVersion             uint16\n\tserverShare                  keyShare\n\tselectedIdentityPresent      bool\n\tselectedIdentity             uint16\n\tsupportedPoints              []uint8\n\n\t// HelloRetryRequest extensions\n\tcookie        []byte\n\tselectedGroup CurveID\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHelloMsg.marshal",
                    "documentation": {
                      "identifier": "serverHelloMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.serverHelloMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *serverHelloMsg) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *serverHelloMsg) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHelloMsg.unmarshal",
                    "documentation": {
                      "identifier": "serverHelloMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.serverHelloMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *serverHelloMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *serverHelloMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHelloMsg.Generate",
                    "documentation": {
                      "identifier": "serverHelloMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.serverHelloMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*serverHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*serverHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#encryptedExtensionsMsg",
              "documentation": {
                "identifier": "encryptedExtensionsMsg",
                "newPage": false,
                "searchKey": "tls.encryptedExtensionsMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type encryptedExtensionsMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype encryptedExtensionsMsg struct {\n\traw          []byte\n\talpnProtocol string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#encryptedExtensionsMsg.marshal",
                    "documentation": {
                      "identifier": "encryptedExtensionsMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.encryptedExtensionsMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *encryptedExtensionsMsg) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *encryptedExtensionsMsg) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#encryptedExtensionsMsg.unmarshal",
                    "documentation": {
                      "identifier": "encryptedExtensionsMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.encryptedExtensionsMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *encryptedExtensionsMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *encryptedExtensionsMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#encryptedExtensionsMsg.Generate",
                    "documentation": {
                      "identifier": "encryptedExtensionsMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.encryptedExtensionsMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*encryptedExtensionsMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*encryptedExtensionsMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#endOfEarlyDataMsg",
              "documentation": {
                "identifier": "endOfEarlyDataMsg",
                "newPage": false,
                "searchKey": "tls.endOfEarlyDataMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type endOfEarlyDataMsg struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype endOfEarlyDataMsg struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#endOfEarlyDataMsg.marshal",
                    "documentation": {
                      "identifier": "endOfEarlyDataMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.endOfEarlyDataMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *endOfEarlyDataMsg) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *endOfEarlyDataMsg) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#endOfEarlyDataMsg.unmarshal",
                    "documentation": {
                      "identifier": "endOfEarlyDataMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.endOfEarlyDataMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *endOfEarlyDataMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *endOfEarlyDataMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#endOfEarlyDataMsg.Generate",
                    "documentation": {
                      "identifier": "endOfEarlyDataMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.endOfEarlyDataMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*endOfEarlyDataMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*endOfEarlyDataMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyUpdateMsg",
              "documentation": {
                "identifier": "keyUpdateMsg",
                "newPage": false,
                "searchKey": "tls.keyUpdateMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type keyUpdateMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype keyUpdateMsg struct {\n\traw             []byte\n\tupdateRequested bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#keyUpdateMsg.marshal",
                    "documentation": {
                      "identifier": "keyUpdateMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.keyUpdateMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *keyUpdateMsg) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *keyUpdateMsg) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#keyUpdateMsg.unmarshal",
                    "documentation": {
                      "identifier": "keyUpdateMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.keyUpdateMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *keyUpdateMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *keyUpdateMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#keyUpdateMsg.Generate",
                    "documentation": {
                      "identifier": "keyUpdateMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.keyUpdateMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*keyUpdateMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*keyUpdateMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#newSessionTicketMsgTLS13",
              "documentation": {
                "identifier": "newSessionTicketMsgTLS13",
                "newPage": false,
                "searchKey": "tls.newSessionTicketMsgTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type newSessionTicketMsgTLS13 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype newSessionTicketMsgTLS13 struct {\n\traw          []byte\n\tlifetime     uint32\n\tageAdd       uint32\n\tnonce        []byte\n\tlabel        []byte\n\tmaxEarlyData uint32\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#newSessionTicketMsgTLS13.marshal",
                    "documentation": {
                      "identifier": "newSessionTicketMsgTLS13.marshal",
                      "newPage": false,
                      "searchKey": "tls.newSessionTicketMsgTLS13.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *newSessionTicketMsgTLS13) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *newSessionTicketMsgTLS13) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#newSessionTicketMsgTLS13.unmarshal",
                    "documentation": {
                      "identifier": "newSessionTicketMsgTLS13.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.newSessionTicketMsgTLS13.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *newSessionTicketMsgTLS13) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *newSessionTicketMsgTLS13) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#newSessionTicketMsgTLS13.Generate",
                    "documentation": {
                      "identifier": "newSessionTicketMsgTLS13.Generate",
                      "newPage": false,
                      "searchKey": "tls.newSessionTicketMsgTLS13.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*newSessionTicketMsgTLS13) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*newSessionTicketMsgTLS13) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#certificateRequestMsgTLS13",
              "documentation": {
                "identifier": "certificateRequestMsgTLS13",
                "newPage": false,
                "searchKey": "tls.certificateRequestMsgTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type certificateRequestMsgTLS13 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype certificateRequestMsgTLS13 struct {\n\traw                              []byte\n\tocspStapling                     bool\n\tscts                             bool\n\tsupportedSignatureAlgorithms     []SignatureScheme\n\tsupportedSignatureAlgorithmsCert []SignatureScheme\n\tcertificateAuthorities           [][]byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateRequestMsgTLS13.marshal",
                    "documentation": {
                      "identifier": "certificateRequestMsgTLS13.marshal",
                      "newPage": false,
                      "searchKey": "tls.certificateRequestMsgTLS13.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateRequestMsgTLS13) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateRequestMsgTLS13) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateRequestMsgTLS13.unmarshal",
                    "documentation": {
                      "identifier": "certificateRequestMsgTLS13.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.certificateRequestMsgTLS13.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateRequestMsgTLS13) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateRequestMsgTLS13) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateRequestMsgTLS13.Generate",
                    "documentation": {
                      "identifier": "certificateRequestMsgTLS13.Generate",
                      "newPage": false,
                      "searchKey": "tls.certificateRequestMsgTLS13.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*certificateRequestMsgTLS13) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*certificateRequestMsgTLS13) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#certificateMsg",
              "documentation": {
                "identifier": "certificateMsg",
                "newPage": false,
                "searchKey": "tls.certificateMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type certificateMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype certificateMsg struct {\n\traw          []byte\n\tcertificates [][]byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateMsg.marshal",
                    "documentation": {
                      "identifier": "certificateMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.certificateMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateMsg) marshal() (x []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateMsg) marshal() (x []byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateMsg.unmarshal",
                    "documentation": {
                      "identifier": "certificateMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.certificateMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateMsg.Generate",
                    "documentation": {
                      "identifier": "certificateMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.certificateMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*certificateMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*certificateMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#certificateMsgTLS13",
              "documentation": {
                "identifier": "certificateMsgTLS13",
                "newPage": false,
                "searchKey": "tls.certificateMsgTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type certificateMsgTLS13 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype certificateMsgTLS13 struct {\n\traw          []byte\n\tcertificate  Certificate\n\tocspStapling bool\n\tscts         bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateMsgTLS13.marshal",
                    "documentation": {
                      "identifier": "certificateMsgTLS13.marshal",
                      "newPage": false,
                      "searchKey": "tls.certificateMsgTLS13.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateMsgTLS13) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateMsgTLS13) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateMsgTLS13.unmarshal",
                    "documentation": {
                      "identifier": "certificateMsgTLS13.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.certificateMsgTLS13.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateMsgTLS13) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateMsgTLS13) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateMsgTLS13.Generate",
                    "documentation": {
                      "identifier": "certificateMsgTLS13.Generate",
                      "newPage": false,
                      "searchKey": "tls.certificateMsgTLS13.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*certificateMsgTLS13) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*certificateMsgTLS13) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#serverKeyExchangeMsg",
              "documentation": {
                "identifier": "serverKeyExchangeMsg",
                "newPage": false,
                "searchKey": "tls.serverKeyExchangeMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type serverKeyExchangeMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype serverKeyExchangeMsg struct {\n\traw []byte\n\tkey []byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverKeyExchangeMsg.marshal",
                    "documentation": {
                      "identifier": "serverKeyExchangeMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.serverKeyExchangeMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *serverKeyExchangeMsg) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *serverKeyExchangeMsg) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverKeyExchangeMsg.unmarshal",
                    "documentation": {
                      "identifier": "serverKeyExchangeMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.serverKeyExchangeMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *serverKeyExchangeMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *serverKeyExchangeMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#certificateStatusMsg",
              "documentation": {
                "identifier": "certificateStatusMsg",
                "newPage": false,
                "searchKey": "tls.certificateStatusMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type certificateStatusMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype certificateStatusMsg struct {\n\traw      []byte\n\tresponse []byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateStatusMsg.marshal",
                    "documentation": {
                      "identifier": "certificateStatusMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.certificateStatusMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateStatusMsg) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateStatusMsg) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateStatusMsg.unmarshal",
                    "documentation": {
                      "identifier": "certificateStatusMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.certificateStatusMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateStatusMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateStatusMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateStatusMsg.Generate",
                    "documentation": {
                      "identifier": "certificateStatusMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.certificateStatusMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*certificateStatusMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*certificateStatusMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#serverHelloDoneMsg",
              "documentation": {
                "identifier": "serverHelloDoneMsg",
                "newPage": false,
                "searchKey": "tls.serverHelloDoneMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type serverHelloDoneMsg struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype serverHelloDoneMsg struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHelloDoneMsg.marshal",
                    "documentation": {
                      "identifier": "serverHelloDoneMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.serverHelloDoneMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *serverHelloDoneMsg) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *serverHelloDoneMsg) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHelloDoneMsg.unmarshal",
                    "documentation": {
                      "identifier": "serverHelloDoneMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.serverHelloDoneMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *serverHelloDoneMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *serverHelloDoneMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientKeyExchangeMsg",
              "documentation": {
                "identifier": "clientKeyExchangeMsg",
                "newPage": false,
                "searchKey": "tls.clientKeyExchangeMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type clientKeyExchangeMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype clientKeyExchangeMsg struct {\n\traw        []byte\n\tciphertext []byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientKeyExchangeMsg.marshal",
                    "documentation": {
                      "identifier": "clientKeyExchangeMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.clientKeyExchangeMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *clientKeyExchangeMsg) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *clientKeyExchangeMsg) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientKeyExchangeMsg.unmarshal",
                    "documentation": {
                      "identifier": "clientKeyExchangeMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.clientKeyExchangeMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *clientKeyExchangeMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *clientKeyExchangeMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientKeyExchangeMsg.Generate",
                    "documentation": {
                      "identifier": "clientKeyExchangeMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.clientKeyExchangeMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*clientKeyExchangeMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*clientKeyExchangeMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#finishedMsg",
              "documentation": {
                "identifier": "finishedMsg",
                "newPage": false,
                "searchKey": "tls.finishedMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type finishedMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype finishedMsg struct {\n\traw        []byte\n\tverifyData []byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#finishedMsg.marshal",
                    "documentation": {
                      "identifier": "finishedMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.finishedMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *finishedMsg) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *finishedMsg) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#finishedMsg.unmarshal",
                    "documentation": {
                      "identifier": "finishedMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.finishedMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *finishedMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *finishedMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#finishedMsg.Generate",
                    "documentation": {
                      "identifier": "finishedMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.finishedMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*finishedMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*finishedMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#certificateRequestMsg",
              "documentation": {
                "identifier": "certificateRequestMsg",
                "newPage": false,
                "searchKey": "tls.certificateRequestMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type certificateRequestMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype certificateRequestMsg struct {\n\traw []byte\n\t// hasSignatureAlgorithm indicates whether this message includes a list of\n\t// supported signature algorithms. This change was introduced with TLS 1.2.\n\thasSignatureAlgorithm bool\n\n\tcertificateTypes             []byte\n\tsupportedSignatureAlgorithms []SignatureScheme\n\tcertificateAuthorities       [][]byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateRequestMsg.marshal",
                    "documentation": {
                      "identifier": "certificateRequestMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.certificateRequestMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateRequestMsg) marshal() (x []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateRequestMsg) marshal() (x []byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateRequestMsg.unmarshal",
                    "documentation": {
                      "identifier": "certificateRequestMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.certificateRequestMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateRequestMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateRequestMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateRequestMsg.Generate",
                    "documentation": {
                      "identifier": "certificateRequestMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.certificateRequestMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*certificateRequestMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*certificateRequestMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#certificateVerifyMsg",
              "documentation": {
                "identifier": "certificateVerifyMsg",
                "newPage": false,
                "searchKey": "tls.certificateVerifyMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type certificateVerifyMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype certificateVerifyMsg struct {\n\traw                   []byte\n\thasSignatureAlgorithm bool // format change introduced in TLS 1.2\n\tsignatureAlgorithm    SignatureScheme\n\tsignature             []byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateVerifyMsg.marshal",
                    "documentation": {
                      "identifier": "certificateVerifyMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.certificateVerifyMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateVerifyMsg) marshal() (x []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateVerifyMsg) marshal() (x []byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateVerifyMsg.unmarshal",
                    "documentation": {
                      "identifier": "certificateVerifyMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.certificateVerifyMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *certificateVerifyMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *certificateVerifyMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#certificateVerifyMsg.Generate",
                    "documentation": {
                      "identifier": "certificateVerifyMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.certificateVerifyMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*certificateVerifyMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*certificateVerifyMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#newSessionTicketMsg",
              "documentation": {
                "identifier": "newSessionTicketMsg",
                "newPage": false,
                "searchKey": "tls.newSessionTicketMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type newSessionTicketMsg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype newSessionTicketMsg struct {\n\traw    []byte\n\tticket []byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#newSessionTicketMsg.marshal",
                    "documentation": {
                      "identifier": "newSessionTicketMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.newSessionTicketMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *newSessionTicketMsg) marshal() (x []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *newSessionTicketMsg) marshal() (x []byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#newSessionTicketMsg.unmarshal",
                    "documentation": {
                      "identifier": "newSessionTicketMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.newSessionTicketMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *newSessionTicketMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *newSessionTicketMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#newSessionTicketMsg.Generate",
                    "documentation": {
                      "identifier": "newSessionTicketMsg.Generate",
                      "newPage": false,
                      "searchKey": "tls.newSessionTicketMsg.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*newSessionTicketMsg) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*newSessionTicketMsg) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#helloRequestMsg",
              "documentation": {
                "identifier": "helloRequestMsg",
                "newPage": false,
                "searchKey": "tls.helloRequestMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type helloRequestMsg struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype helloRequestMsg struct {\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#helloRequestMsg.marshal",
                    "documentation": {
                      "identifier": "helloRequestMsg.marshal",
                      "newPage": false,
                      "searchKey": "tls.helloRequestMsg.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*helloRequestMsg) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*helloRequestMsg) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#helloRequestMsg.unmarshal",
                    "documentation": {
                      "identifier": "helloRequestMsg.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.helloRequestMsg.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*helloRequestMsg) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*helloRequestMsg) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#serverHandshakeState",
              "documentation": {
                "identifier": "serverHandshakeState",
                "newPage": false,
                "searchKey": "tls.serverHandshakeState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type serverHandshakeState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype serverHandshakeState struct {\n\tc            *Conn\n\tctx          context.Context\n\tclientHello  *clientHelloMsg\n\thello        *serverHelloMsg\n\tsuite        *cipherSuite\n\tecdheOk      bool\n\tecSignOk     bool\n\trsaDecryptOk bool\n\trsaSignOk    bool\n\tsessionState *sessionState\n\tfinishedHash finishedHash\n\tmasterSecret []byte\n\tcert         *Certificate\n}\n```\n\nserverHandshakeState contains details of a server handshake in progress. It's discarded once the handshake has completed. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeState.handshake",
                    "documentation": {
                      "identifier": "serverHandshakeState.handshake",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeState.handshake",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeState) handshake() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeState) handshake() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeState.processClientHello",
                    "documentation": {
                      "identifier": "serverHandshakeState.processClientHello",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeState.processClientHello",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeState) processClientHello() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeState) processClientHello() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeState.pickCipherSuite",
                    "documentation": {
                      "identifier": "serverHandshakeState.pickCipherSuite",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeState.pickCipherSuite",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeState) pickCipherSuite() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeState) pickCipherSuite() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeState.cipherSuiteOk",
                    "documentation": {
                      "identifier": "serverHandshakeState.cipherSuiteOk",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeState.cipherSuiteOk",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeState) cipherSuiteOk(c *cipherSuite) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeState) cipherSuiteOk(c *cipherSuite) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeState.checkForResumption",
                    "documentation": {
                      "identifier": "serverHandshakeState.checkForResumption",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeState.checkForResumption",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeState) checkForResumption() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeState) checkForResumption() bool\n```\n\ncheckForResumption reports whether we should perform resumption on this connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeState.doResumeHandshake",
                    "documentation": {
                      "identifier": "serverHandshakeState.doResumeHandshake",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeState.doResumeHandshake",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeState) doResumeHandshake() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeState) doResumeHandshake() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeState.doFullHandshake",
                    "documentation": {
                      "identifier": "serverHandshakeState.doFullHandshake",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeState.doFullHandshake",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeState) doFullHandshake() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeState) doFullHandshake() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeState.establishKeys",
                    "documentation": {
                      "identifier": "serverHandshakeState.establishKeys",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeState.establishKeys",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeState) establishKeys() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeState) establishKeys() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeState.readFinished",
                    "documentation": {
                      "identifier": "serverHandshakeState.readFinished",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeState.readFinished",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeState) readFinished(out []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeState) readFinished(out []byte) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeState.sendSessionTicket",
                    "documentation": {
                      "identifier": "serverHandshakeState.sendSessionTicket",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeState.sendSessionTicket",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeState) sendSessionTicket() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeState) sendSessionTicket() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeState.sendFinished",
                    "documentation": {
                      "identifier": "serverHandshakeState.sendFinished",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeState.sendFinished",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeState) sendFinished(out []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeState) sendFinished(out []byte) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#serverHandshakeStateTLS13",
              "documentation": {
                "identifier": "serverHandshakeStateTLS13",
                "newPage": false,
                "searchKey": "tls.serverHandshakeStateTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type serverHandshakeStateTLS13 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype serverHandshakeStateTLS13 struct {\n\tc               *Conn\n\tctx             context.Context\n\tclientHello     *clientHelloMsg\n\thello           *serverHelloMsg\n\tsentDummyCCS    bool\n\tusingPSK        bool\n\tsuite           *cipherSuiteTLS13\n\tcert            *Certificate\n\tsigAlg          SignatureScheme\n\tearlySecret     []byte\n\tsharedKey       []byte\n\thandshakeSecret []byte\n\tmasterSecret    []byte\n\ttrafficSecret   []byte // client_application_traffic_secret_0\n\ttranscript      hash.Hash\n\tclientFinished  []byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.handshake",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.handshake",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.handshake",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) handshake() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) handshake() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.processClientHello",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.processClientHello",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.processClientHello",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) processClientHello() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) processClientHello() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.checkForResumption",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.checkForResumption",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.checkForResumption",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) checkForResumption() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) checkForResumption() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.pickCertificate",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.pickCertificate",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.pickCertificate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) pickCertificate() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) pickCertificate() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.sendDummyChangeCipherSpec",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.sendDummyChangeCipherSpec",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.sendDummyChangeCipherSpec",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) sendDummyChangeCipherSpec() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) sendDummyChangeCipherSpec() error\n```\n\nsendDummyChangeCipherSpec sends a ChangeCipherSpec record for compatibility with middleboxes that didn't implement TLS correctly. See RFC 8446, Appendix D.4. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.doHelloRetryRequest",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.doHelloRetryRequest",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.doHelloRetryRequest",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) doHelloRetryRequest(selectedGroup CurveID) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) doHelloRetryRequest(selectedGroup CurveID) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.sendServerParameters",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.sendServerParameters",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.sendServerParameters",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) sendServerParameters() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) sendServerParameters() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.requestClientCert",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.requestClientCert",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.requestClientCert",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) requestClientCert() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) requestClientCert() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.sendServerCertificate",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.sendServerCertificate",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.sendServerCertificate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) sendServerCertificate() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) sendServerCertificate() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.sendServerFinished",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.sendServerFinished",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.sendServerFinished",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) sendServerFinished() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) sendServerFinished() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.shouldSendSessionTickets",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.shouldSendSessionTickets",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.shouldSendSessionTickets",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) shouldSendSessionTickets() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) shouldSendSessionTickets() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.sendSessionTickets",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.sendSessionTickets",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.sendSessionTickets",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) sendSessionTickets() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) sendSessionTickets() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.readClientCertificate",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.readClientCertificate",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.readClientCertificate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) readClientCertificate() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) readClientCertificate() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverHandshakeStateTLS13.readClientFinished",
                    "documentation": {
                      "identifier": "serverHandshakeStateTLS13.readClientFinished",
                      "newPage": false,
                      "searchKey": "tls.serverHandshakeStateTLS13.readClientFinished",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (hs *serverHandshakeStateTLS13) readClientFinished() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (hs *serverHandshakeStateTLS13) readClientFinished() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keyAgreement",
              "documentation": {
                "identifier": "keyAgreement",
                "newPage": false,
                "searchKey": "tls.keyAgreement",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type keyAgreement interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype keyAgreement interface {\n\n\t// In the case that the key agreement protocol doesn't use a\n\t// ServerKeyExchange message, generateServerKeyExchange can return nil,\n\t// nil.\n\tgenerateServerKeyExchange(*Config, *Certificate, *clientHelloMsg, *serverHelloMsg) (*serverKeyExchangeMsg, error)\n\tprocessClientKeyExchange(*Config, *Certificate, *clientKeyExchangeMsg, uint16) ([]byte, error)\n\n\t// This method may not be called if the server doesn't send a\n\t// ServerKeyExchange message.\n\tprocessServerKeyExchange(*Config, *clientHelloMsg, *serverHelloMsg, *x509.Certificate, *serverKeyExchangeMsg) error\n\tgenerateClientKeyExchange(*Config, *clientHelloMsg, *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)\n}\n```\n\na keyAgreement implements the client and server side of a TLS key agreement protocol by generating and processing key exchange messages. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#rsaKA",
                    "documentation": {
                      "identifier": "rsaKA",
                      "newPage": false,
                      "searchKey": "tls.rsaKA",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func rsaKA(version uint16) keyAgreement"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc rsaKA(version uint16) keyAgreement\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#ecdheECDSAKA",
                    "documentation": {
                      "identifier": "ecdheECDSAKA",
                      "newPage": false,
                      "searchKey": "tls.ecdheECDSAKA",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ecdheECDSAKA(version uint16) keyAgreement"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ecdheECDSAKA(version uint16) keyAgreement\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#ecdheRSAKA",
                    "documentation": {
                      "identifier": "ecdheRSAKA",
                      "newPage": false,
                      "searchKey": "tls.ecdheRSAKA",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ecdheRSAKA(version uint16) keyAgreement"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ecdheRSAKA(version uint16) keyAgreement\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#rsaKeyAgreement",
              "documentation": {
                "identifier": "rsaKeyAgreement",
                "newPage": false,
                "searchKey": "tls.rsaKeyAgreement",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type rsaKeyAgreement struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype rsaKeyAgreement struct{}\n```\n\nrsaKeyAgreement implements the standard TLS key agreement where the client encrypts the pre-master secret to the server's public key. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#rsaKeyAgreement.generateServerKeyExchange",
                    "documentation": {
                      "identifier": "rsaKeyAgreement.generateServerKeyExchange",
                      "newPage": false,
                      "searchKey": "tls.rsaKeyAgreement.generateServerKeyExchange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ka rsaKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ka rsaKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#rsaKeyAgreement.processClientKeyExchange",
                    "documentation": {
                      "identifier": "rsaKeyAgreement.processClientKeyExchange",
                      "newPage": false,
                      "searchKey": "tls.rsaKeyAgreement.processClientKeyExchange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ka rsaKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#rsaKeyAgreement.processServerKeyExchange",
                    "documentation": {
                      "identifier": "rsaKeyAgreement.processServerKeyExchange",
                      "newPage": false,
                      "searchKey": "tls.rsaKeyAgreement.processServerKeyExchange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ka rsaKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ka rsaKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#rsaKeyAgreement.generateClientKeyExchange",
                    "documentation": {
                      "identifier": "rsaKeyAgreement.generateClientKeyExchange",
                      "newPage": false,
                      "searchKey": "tls.rsaKeyAgreement.generateClientKeyExchange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ka rsaKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ecdheKeyAgreement",
              "documentation": {
                "identifier": "ecdheKeyAgreement",
                "newPage": false,
                "searchKey": "tls.ecdheKeyAgreement",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ecdheKeyAgreement struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ecdheKeyAgreement struct {\n\tversion uint16\n\tisRSA   bool\n\tparams  ecdheParameters\n\n\t// ckx and preMasterSecret are generated in processServerKeyExchange\n\t// and returned in generateClientKeyExchange.\n\tckx             *clientKeyExchangeMsg\n\tpreMasterSecret []byte\n}\n```\n\necdheKeyAgreement implements a TLS key agreement where the server generates an ephemeral EC public/private key pair and signs it. The pre-master secret is then calculated using ECDH. The signature may be ECDSA, Ed25519 or RSA. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#ecdheKeyAgreement.generateServerKeyExchange",
                    "documentation": {
                      "identifier": "ecdheKeyAgreement.generateServerKeyExchange",
                      "newPage": false,
                      "searchKey": "tls.ecdheKeyAgreement.generateServerKeyExchange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ka *ecdheKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ka *ecdheKeyAgreement) generateServerKeyExchange(config *Config, cert *Certificate, clientHello *clientHelloMsg, hello *serverHelloMsg) (*serverKeyExchangeMsg, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#ecdheKeyAgreement.processClientKeyExchange",
                    "documentation": {
                      "identifier": "ecdheKeyAgreement.processClientKeyExchange",
                      "newPage": false,
                      "searchKey": "tls.ecdheKeyAgreement.processClientKeyExchange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ka *ecdheKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ka *ecdheKeyAgreement) processClientKeyExchange(config *Config, cert *Certificate, ckx *clientKeyExchangeMsg, version uint16) ([]byte, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#ecdheKeyAgreement.processServerKeyExchange",
                    "documentation": {
                      "identifier": "ecdheKeyAgreement.processServerKeyExchange",
                      "newPage": false,
                      "searchKey": "tls.ecdheKeyAgreement.processServerKeyExchange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ka *ecdheKeyAgreement) processServerKeyExchange(config *Config, clientHello *clientHelloMsg, serverHello *serverHelloMsg, cert *x509.Certificate, skx *serverKeyExchangeMsg) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#ecdheKeyAgreement.generateClientKeyExchange",
                    "documentation": {
                      "identifier": "ecdheKeyAgreement.generateClientKeyExchange",
                      "newPage": false,
                      "searchKey": "tls.ecdheKeyAgreement.generateClientKeyExchange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ka *ecdheKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ka *ecdheKeyAgreement) generateClientKeyExchange(config *Config, clientHello *clientHelloMsg, cert *x509.Certificate) ([]byte, *clientKeyExchangeMsg, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ecdheParameters",
              "documentation": {
                "identifier": "ecdheParameters",
                "newPage": false,
                "searchKey": "tls.ecdheParameters",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ecdheParameters interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ecdheParameters interface {\n\tCurveID() CurveID\n\tPublicKey() []byte\n\tSharedKey(peerPublicKey []byte) []byte\n}\n```\n\necdheParameters implements Diffie-Hellman with either NIST curves or X25519, according to RFC 8446, Section 4.2.8.2. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#generateECDHEParameters",
                    "documentation": {
                      "identifier": "generateECDHEParameters",
                      "newPage": false,
                      "searchKey": "tls.generateECDHEParameters",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func generateECDHEParameters(rand io.Reader, curveID CurveID) (ecdheParameters, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc generateECDHEParameters(rand io.Reader, curveID CurveID) (ecdheParameters, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#nistParameters",
              "documentation": {
                "identifier": "nistParameters",
                "newPage": false,
                "searchKey": "tls.nistParameters",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type nistParameters struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nistParameters struct {\n\tprivateKey []byte\n\tx, y       *big.Int // public key\n\tcurveID    CurveID\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#nistParameters.CurveID",
                    "documentation": {
                      "identifier": "nistParameters.CurveID",
                      "newPage": false,
                      "searchKey": "tls.nistParameters.CurveID",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *nistParameters) CurveID() CurveID"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *nistParameters) CurveID() CurveID\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#nistParameters.PublicKey",
                    "documentation": {
                      "identifier": "nistParameters.PublicKey",
                      "newPage": false,
                      "searchKey": "tls.nistParameters.PublicKey",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *nistParameters) PublicKey() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *nistParameters) PublicKey() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#nistParameters.SharedKey",
                    "documentation": {
                      "identifier": "nistParameters.SharedKey",
                      "newPage": false,
                      "searchKey": "tls.nistParameters.SharedKey",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *nistParameters) SharedKey(peerPublicKey []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *nistParameters) SharedKey(peerPublicKey []byte) []byte\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#x25519Parameters",
              "documentation": {
                "identifier": "x25519Parameters",
                "newPage": false,
                "searchKey": "tls.x25519Parameters",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type x25519Parameters struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype x25519Parameters struct {\n\tprivateKey []byte\n\tpublicKey  []byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#x25519Parameters.CurveID",
                    "documentation": {
                      "identifier": "x25519Parameters.CurveID",
                      "newPage": false,
                      "searchKey": "tls.x25519Parameters.CurveID",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *x25519Parameters) CurveID() CurveID"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *x25519Parameters) CurveID() CurveID\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#x25519Parameters.PublicKey",
                    "documentation": {
                      "identifier": "x25519Parameters.PublicKey",
                      "newPage": false,
                      "searchKey": "tls.x25519Parameters.PublicKey",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *x25519Parameters) PublicKey() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *x25519Parameters) PublicKey() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#x25519Parameters.SharedKey",
                    "documentation": {
                      "identifier": "x25519Parameters.SharedKey",
                      "newPage": false,
                      "searchKey": "tls.x25519Parameters.SharedKey",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *x25519Parameters) SharedKey(peerPublicKey []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *x25519Parameters) SharedKey(peerPublicKey []byte) []byte\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#finishedHash",
              "documentation": {
                "identifier": "finishedHash",
                "newPage": false,
                "searchKey": "tls.finishedHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type finishedHash struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype finishedHash struct {\n\tclient hash.Hash\n\tserver hash.Hash\n\n\t// Prior to TLS 1.2, an additional MD5 hash is required.\n\tclientMD5 hash.Hash\n\tserverMD5 hash.Hash\n\n\t// In TLS 1.2, a full buffer is sadly required.\n\tbuffer []byte\n\n\tversion uint16\n\tprf     func(result, secret, label, seed []byte)\n}\n```\n\nA finishedHash calculates the hash of a set of handshake messages suitable for including in a Finished message. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#newFinishedHash",
                    "documentation": {
                      "identifier": "newFinishedHash",
                      "newPage": false,
                      "searchKey": "tls.newFinishedHash",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newFinishedHash(version uint16, cipherSuite *cipherSuite) finishedHash"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newFinishedHash(version uint16, cipherSuite *cipherSuite) finishedHash\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#finishedHash.Write",
                    "documentation": {
                      "identifier": "finishedHash.Write",
                      "newPage": false,
                      "searchKey": "tls.finishedHash.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *finishedHash) Write(msg []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *finishedHash) Write(msg []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#finishedHash.Sum",
                    "documentation": {
                      "identifier": "finishedHash.Sum",
                      "newPage": false,
                      "searchKey": "tls.finishedHash.Sum",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h finishedHash) Sum() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h finishedHash) Sum() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#finishedHash.clientSum",
                    "documentation": {
                      "identifier": "finishedHash.clientSum",
                      "newPage": false,
                      "searchKey": "tls.finishedHash.clientSum",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h finishedHash) clientSum(masterSecret []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h finishedHash) clientSum(masterSecret []byte) []byte\n```\n\nclientSum returns the contents of the verify_data member of a client's Finished message. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#finishedHash.serverSum",
                    "documentation": {
                      "identifier": "finishedHash.serverSum",
                      "newPage": false,
                      "searchKey": "tls.finishedHash.serverSum",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h finishedHash) serverSum(masterSecret []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h finishedHash) serverSum(masterSecret []byte) []byte\n```\n\nserverSum returns the contents of the verify_data member of a server's Finished message. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#finishedHash.hashForClientCertificate",
                    "documentation": {
                      "identifier": "finishedHash.hashForClientCertificate",
                      "newPage": false,
                      "searchKey": "tls.finishedHash.hashForClientCertificate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h finishedHash) hashForClientCertificate(sigType uint8, hashAlg crypto.Hash, masterSecret []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h finishedHash) hashForClientCertificate(sigType uint8, hashAlg crypto.Hash, masterSecret []byte) []byte\n```\n\nhashForClientCertificate returns the handshake messages so far, pre-hashed if necessary, suitable for signing by a TLS client certificate. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#finishedHash.discardHandshakeBuffer",
                    "documentation": {
                      "identifier": "finishedHash.discardHandshakeBuffer",
                      "newPage": false,
                      "searchKey": "tls.finishedHash.discardHandshakeBuffer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *finishedHash) discardHandshakeBuffer()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *finishedHash) discardHandshakeBuffer()\n```\n\ndiscardHandshakeBuffer is called when there is no more need to buffer the entirety of the handshake messages. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#sessionState",
              "documentation": {
                "identifier": "sessionState",
                "newPage": false,
                "searchKey": "tls.sessionState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sessionState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sessionState struct {\n\tvers         uint16\n\tcipherSuite  uint16\n\tcreatedAt    uint64\n\tmasterSecret []byte // opaque master_secret<1..2^16-1>;\n\t// struct { opaque certificate<1..2^24-1> } Certificate;\n\tcertificates [][]byte // Certificate certificate_list<0..2^24-1>;\n\n\t// usedOldKey is true if the ticket from which this session came from\n\t// was encrypted with an older key and thus should be refreshed.\n\tusedOldKey bool\n}\n```\n\nsessionState contains the information that is serialized into a session ticket in order to later resume a connection. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#sessionState.marshal",
                    "documentation": {
                      "identifier": "sessionState.marshal",
                      "newPage": false,
                      "searchKey": "tls.sessionState.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *sessionState) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *sessionState) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#sessionState.unmarshal",
                    "documentation": {
                      "identifier": "sessionState.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.sessionState.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *sessionState) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *sessionState) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#sessionState.Generate",
                    "documentation": {
                      "identifier": "sessionState.Generate",
                      "newPage": false,
                      "searchKey": "tls.sessionState.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*sessionState) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*sessionState) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#sessionStateTLS13",
              "documentation": {
                "identifier": "sessionStateTLS13",
                "newPage": false,
                "searchKey": "tls.sessionStateTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sessionStateTLS13 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sessionStateTLS13 struct {\n\t// uint8 version  = 0x0304;\n\t// uint8 revision = 0;\n\tcipherSuite      uint16\n\tcreatedAt        uint64\n\tresumptionSecret []byte      // opaque resumption_master_secret<1..2^8-1>;\n\tcertificate      Certificate // CertificateEntry certificate_list<0..2^24-1>;\n}\n```\n\nsessionStateTLS13 is the content of a TLS 1.3 session ticket. Its first version (revision = 0) doesn't carry any of the information needed for 0-RTT validation and the nonce is always empty. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#sessionStateTLS13.marshal",
                    "documentation": {
                      "identifier": "sessionStateTLS13.marshal",
                      "newPage": false,
                      "searchKey": "tls.sessionStateTLS13.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *sessionStateTLS13) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *sessionStateTLS13) marshal() []byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#sessionStateTLS13.unmarshal",
                    "documentation": {
                      "identifier": "sessionStateTLS13.unmarshal",
                      "newPage": false,
                      "searchKey": "tls.sessionStateTLS13.unmarshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *sessionStateTLS13) unmarshal(data []byte) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *sessionStateTLS13) unmarshal(data []byte) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#sessionStateTLS13.Generate",
                    "documentation": {
                      "identifier": "sessionStateTLS13.Generate",
                      "newPage": false,
                      "searchKey": "tls.sessionStateTLS13.Generate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*sessionStateTLS13) Generate(rand *rand.Rand, size int) reflect.Value"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*sessionStateTLS13) Generate(rand *rand.Rand, size int) reflect.Value\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#listener",
              "documentation": {
                "identifier": "listener",
                "newPage": false,
                "searchKey": "tls.listener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type listener struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype listener struct {\n\tnet.Listener\n\tconfig *Config\n}\n```\n\nA listener implements a network listener (net.Listener) for TLS connections. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#listener.Accept",
                    "documentation": {
                      "identifier": "listener.Accept",
                      "newPage": false,
                      "searchKey": "tls.listener.Accept",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *listener) Accept() (net.Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *listener) Accept() (net.Conn, error)\n```\n\nAccept waits for and returns the next incoming TLS connection. The returned connection is of type *Conn. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#timeoutError",
              "documentation": {
                "identifier": "timeoutError",
                "newPage": false,
                "searchKey": "tls.timeoutError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type timeoutError struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype timeoutError struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#timeoutError.Error",
                    "documentation": {
                      "identifier": "timeoutError.Error",
                      "newPage": false,
                      "searchKey": "tls.timeoutError.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (timeoutError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (timeoutError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#timeoutError.Timeout",
                    "documentation": {
                      "identifier": "timeoutError.Timeout",
                      "newPage": false,
                      "searchKey": "tls.timeoutError.Timeout",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (timeoutError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (timeoutError) Timeout() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#timeoutError.Temporary",
                    "documentation": {
                      "identifier": "timeoutError.Temporary",
                      "newPage": false,
                      "searchKey": "tls.timeoutError.Temporary",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (timeoutError) Temporary() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (timeoutError) Temporary() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#Dialer",
              "documentation": {
                "identifier": "Dialer",
                "newPage": false,
                "searchKey": "tls.Dialer",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Dialer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Dialer struct {\n\t// NetDialer is the optional dialer to use for the TLS connections'\n\t// underlying TCP connections.\n\t// A nil NetDialer is equivalent to the net.Dialer zero value.\n\tNetDialer *net.Dialer\n\n\t// Config is the TLS configuration to use for new connections.\n\t// A nil configuration is equivalent to the zero\n\t// configuration; see the documentation of Config for the\n\t// defaults.\n\tConfig *Config\n}\n```\n\nDialer dials TLS connections given a configuration and a Dialer for the underlying connection. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Dialer.Dial",
                    "documentation": {
                      "identifier": "Dialer.Dial",
                      "newPage": false,
                      "searchKey": "tls.Dialer.Dial",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *Dialer) Dial(network, addr string) (net.Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *Dialer) Dial(network, addr string) (net.Conn, error)\n```\n\nDial connects to the given network address and initiates a TLS handshake, returning the resulting TLS connection. \n\nThe returned Conn, if any, will always be of type *Conn. \n\nDial uses context.Background internally; to specify the context, use DialContext. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Dialer.netDialer",
                    "documentation": {
                      "identifier": "Dialer.netDialer",
                      "newPage": false,
                      "searchKey": "tls.Dialer.netDialer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *Dialer) netDialer() *net.Dialer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *Dialer) netDialer() *net.Dialer\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#Dialer.DialContext",
                    "documentation": {
                      "identifier": "Dialer.DialContext",
                      "newPage": false,
                      "searchKey": "tls.Dialer.DialContext",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *Dialer) DialContext(ctx context.Context, network, addr string) (net.Conn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *Dialer) DialContext(ctx context.Context, network, addr string) (net.Conn, error)\n```\n\nDialContext connects to the given network address and initiates a TLS handshake, returning the resulting TLS connection. \n\nThe provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection. \n\nThe returned Conn, if any, will always be of type *Conn. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#hairpinConn",
              "documentation": {
                "identifier": "hairpinConn",
                "newPage": false,
                "searchKey": "tls.hairpinConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type hairpinConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype hairpinConn struct {\n\tnet.Conn\n\ttlsConn *Conn\n}\n```\n\nhairpinConn is a net.Conn that makes a “hairpin” call when closed, back into the tls.Conn which is calling it. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#hairpinConn.Close",
                    "documentation": {
                      "identifier": "hairpinConn.Close",
                      "newPage": false,
                      "searchKey": "tls.hairpinConn.Close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (conn *hairpinConn) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (conn *hairpinConn) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#opensslInputEvent",
              "documentation": {
                "identifier": "opensslInputEvent",
                "newPage": false,
                "searchKey": "tls.opensslInputEvent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type opensslInputEvent int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype opensslInputEvent int\n```\n\nopensslInputEvent enumerates possible inputs that can be sent to an `openssl s_client` process. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#opensslInput",
              "documentation": {
                "identifier": "opensslInput",
                "newPage": false,
                "searchKey": "tls.opensslInput",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type opensslInput chan tls.opensslInputEvent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype opensslInput chan opensslInputEvent\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#opensslInput.Read",
                    "documentation": {
                      "identifier": "opensslInput.Read",
                      "newPage": false,
                      "searchKey": "tls.opensslInput.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i opensslInput) Read(buf []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i opensslInput) Read(buf []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#opensslOutputSink",
              "documentation": {
                "identifier": "opensslOutputSink",
                "newPage": false,
                "searchKey": "tls.opensslOutputSink",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type opensslOutputSink struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype opensslOutputSink struct {\n\thandshakeComplete chan struct{}\n\treadKeyUpdate     chan struct{}\n\tall               []byte\n\tline              []byte\n}\n```\n\nopensslOutputSink is an io.Writer that receives the stdout and stderr from an `openssl` process and sends a value to handshakeComplete or readKeyUpdate when certain messages are seen. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#newOpensslOutputSink",
                    "documentation": {
                      "identifier": "newOpensslOutputSink",
                      "newPage": false,
                      "searchKey": "tls.newOpensslOutputSink",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newOpensslOutputSink() *opensslOutputSink"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newOpensslOutputSink() *opensslOutputSink\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#opensslOutputSink.Write",
                    "documentation": {
                      "identifier": "opensslOutputSink.Write",
                      "newPage": false,
                      "searchKey": "tls.opensslOutputSink.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (o *opensslOutputSink) Write(data []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (o *opensslOutputSink) Write(data []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#opensslOutputSink.String",
                    "documentation": {
                      "identifier": "opensslOutputSink.String",
                      "newPage": false,
                      "searchKey": "tls.opensslOutputSink.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (o *opensslOutputSink) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (o *opensslOutputSink) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientTest",
              "documentation": {
                "identifier": "clientTest",
                "newPage": false,
                "searchKey": "tls.clientTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type clientTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype clientTest struct {\n\t// name is a freeform string identifying the test and the file in which\n\t// the expected results will be stored.\n\tname string\n\t// args, if not empty, contains a series of arguments for the\n\t// command to run for the reference server.\n\targs []string\n\t// config, if not nil, contains a custom Config to use for this test.\n\tconfig *Config\n\t// cert, if not empty, contains a DER-encoded certificate for the\n\t// reference server.\n\tcert []byte\n\t// key, if not nil, contains either a *rsa.PrivateKey, ed25519.PrivateKey or\n\t// *ecdsa.PrivateKey which is the private key for the reference server.\n\tkey interface{}\n\t// extensions, if not nil, contains a list of extension data to be returned\n\t// from the ServerHello. The data should be in standard TLS format with\n\t// a 2-byte uint16 type, 2-byte data length, followed by the extension data.\n\textensions [][]byte\n\t// validate, if not nil, is a function that will be called with the\n\t// ConnectionState of the resulting connection. It returns a non-nil\n\t// error if the ConnectionState is unacceptable.\n\tvalidate func(ConnectionState) error\n\t// numRenegotiations is the number of times that the connection will be\n\t// renegotiated.\n\tnumRenegotiations int\n\t// renegotiationExpectedToFail, if not zero, is the number of the\n\t// renegotiation attempt that is expected to fail.\n\trenegotiationExpectedToFail int\n\t// checkRenegotiationError, if not nil, is called with any error\n\t// arising from renegotiation. It can map expected errors to nil to\n\t// ignore them.\n\tcheckRenegotiationError func(renegotiationNum int, err error) error\n\t// sendKeyUpdate will cause the server to send a KeyUpdate message.\n\tsendKeyUpdate bool\n}\n```\n\nclientTest represents a test of the TLS client handshake against a reference implementation. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientTest.connFromCommand",
                    "documentation": {
                      "identifier": "clientTest.connFromCommand",
                      "newPage": false,
                      "searchKey": "tls.clientTest.connFromCommand",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (test *clientTest) connFromCommand() (conn *recordingConn, child *exec.Cmd, stdin opensslInput, stdout *opensslOutputSink, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (test *clientTest) connFromCommand() (conn *recordingConn, child *exec.Cmd, stdin opensslInput, stdout *opensslOutputSink, err error)\n```\n\nconnFromCommand starts the reference server process, connects to it and returns a recordingConn for the connection. The stdin return value is an opensslInput for the stdin of the child process. It must be closed before Waiting for child. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientTest.dataPath",
                    "documentation": {
                      "identifier": "clientTest.dataPath",
                      "newPage": false,
                      "searchKey": "tls.clientTest.dataPath",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (test *clientTest) dataPath() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (test *clientTest) dataPath() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientTest.loadData",
                    "documentation": {
                      "identifier": "clientTest.loadData",
                      "newPage": false,
                      "searchKey": "tls.clientTest.loadData",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (test *clientTest) loadData() (flows [][]byte, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (test *clientTest) loadData() (flows [][]byte, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#clientTest.run",
                    "documentation": {
                      "identifier": "clientTest.run",
                      "newPage": false,
                      "searchKey": "tls.clientTest.run",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (test *clientTest) run(t *testing.T, write bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (test *clientTest) run(t *testing.T, write bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#brokenConn",
              "documentation": {
                "identifier": "brokenConn",
                "newPage": false,
                "searchKey": "tls.brokenConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type brokenConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype brokenConn struct {\n\tnet.Conn\n\n\t// breakAfter is the number of successful writes that will be allowed\n\t// before all subsequent writes fail.\n\tbreakAfter int\n\n\t// numWrites is the number of writes that have been done.\n\tnumWrites int\n}\n```\n\nbrokenConn wraps a net.Conn and causes all Writes after a certain number to fail with brokenConnErr. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#brokenConn.Write",
                    "documentation": {
                      "identifier": "brokenConn.Write",
                      "newPage": false,
                      "searchKey": "tls.brokenConn.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *brokenConn) Write(data []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *brokenConn) Write(data []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#writeCountingConn",
              "documentation": {
                "identifier": "writeCountingConn",
                "newPage": false,
                "searchKey": "tls.writeCountingConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type writeCountingConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype writeCountingConn struct {\n\tnet.Conn\n\n\t// numWrites is the number of writes that have been done.\n\tnumWrites int\n}\n```\n\nwriteCountingConn wraps a net.Conn and counts the number of Write calls. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#writeCountingConn.Write",
                    "documentation": {
                      "identifier": "writeCountingConn.Write",
                      "newPage": false,
                      "searchKey": "tls.writeCountingConn.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (wcc *writeCountingConn) Write(data []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (wcc *writeCountingConn) Write(data []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#serverTest",
              "documentation": {
                "identifier": "serverTest",
                "newPage": false,
                "searchKey": "tls.serverTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type serverTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype serverTest struct {\n\t// name is a freeform string identifying the test and the file in which\n\t// the expected results will be stored.\n\tname string\n\t// command, if not empty, contains a series of arguments for the\n\t// command to run for the reference server.\n\tcommand []string\n\t// expectedPeerCerts contains a list of PEM blocks of expected\n\t// certificates from the client.\n\texpectedPeerCerts []string\n\t// config, if not nil, contains a custom Config to use for this test.\n\tconfig *Config\n\t// expectHandshakeErrorIncluding, when not empty, contains a string\n\t// that must be a substring of the error resulting from the handshake.\n\texpectHandshakeErrorIncluding string\n\t// validate, if not nil, is a function that will be called with the\n\t// ConnectionState of the resulting connection. It returns false if the\n\t// ConnectionState is unacceptable.\n\tvalidate func(ConnectionState) error\n\t// wait, if true, prevents this subtest from calling t.Parallel.\n\t// If false, runServerTest* returns immediately.\n\twait bool\n}\n```\n\nserverTest represents a test of the TLS server handshake against a reference implementation. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverTest.connFromCommand",
                    "documentation": {
                      "identifier": "serverTest.connFromCommand",
                      "newPage": false,
                      "searchKey": "tls.serverTest.connFromCommand",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (test *serverTest) connFromCommand() (conn *recordingConn, child *exec.Cmd, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (test *serverTest) connFromCommand() (conn *recordingConn, child *exec.Cmd, err error)\n```\n\nconnFromCommand starts opens a listening socket and starts the reference client to connect to it. It returns a recordingConn that wraps the resulting connection. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverTest.dataPath",
                    "documentation": {
                      "identifier": "serverTest.dataPath",
                      "newPage": false,
                      "searchKey": "tls.serverTest.dataPath",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (test *serverTest) dataPath() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (test *serverTest) dataPath() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverTest.loadData",
                    "documentation": {
                      "identifier": "serverTest.loadData",
                      "newPage": false,
                      "searchKey": "tls.serverTest.loadData",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (test *serverTest) loadData() (flows [][]byte, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (test *serverTest) loadData() (flows [][]byte, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#serverTest.run",
                    "documentation": {
                      "identifier": "serverTest.run",
                      "newPage": false,
                      "searchKey": "tls.serverTest.run",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (test *serverTest) run(t *testing.T, write bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (test *serverTest) run(t *testing.T, write bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#recordingConn",
              "documentation": {
                "identifier": "recordingConn",
                "newPage": false,
                "searchKey": "tls.recordingConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type recordingConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype recordingConn struct {\n\tnet.Conn\n\tsync.Mutex\n\tflows   [][]byte\n\treading bool\n}\n```\n\nrecordingConn is a net.Conn that records the traffic that passes through it. WriteTo can be used to produce output that can be later be loaded with ParseTestData. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#recordingConn.Read",
                    "documentation": {
                      "identifier": "recordingConn.Read",
                      "newPage": false,
                      "searchKey": "tls.recordingConn.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *recordingConn) Read(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *recordingConn) Read(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#recordingConn.Write",
                    "documentation": {
                      "identifier": "recordingConn.Write",
                      "newPage": false,
                      "searchKey": "tls.recordingConn.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *recordingConn) Write(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *recordingConn) Write(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#recordingConn.WriteTo",
                    "documentation": {
                      "identifier": "recordingConn.WriteTo",
                      "newPage": false,
                      "searchKey": "tls.recordingConn.WriteTo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *recordingConn) WriteTo(w io.Writer) (int64, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *recordingConn) WriteTo(w io.Writer) (int64, error)\n```\n\nWriteTo writes Go source code to w that contains the recorded traffic. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#zeroSource",
              "documentation": {
                "identifier": "zeroSource",
                "newPage": false,
                "searchKey": "tls.zeroSource",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type zeroSource struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype zeroSource struct{}\n```\n\nzeroSource is an io.Reader that returns an unlimited number of zero bytes. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#zeroSource.Read",
                    "documentation": {
                      "identifier": "zeroSource.Read",
                      "newPage": false,
                      "searchKey": "tls.zeroSource.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (zeroSource) Read(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (zeroSource) Read(b []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testSplitPreMasterSecretTest",
              "documentation": {
                "identifier": "testSplitPreMasterSecretTest",
                "newPage": false,
                "searchKey": "tls.testSplitPreMasterSecretTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type testSplitPreMasterSecretTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype testSplitPreMasterSecretTest struct {\n\tin, out1, out2 string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testKeysFromTest",
              "documentation": {
                "identifier": "testKeysFromTest",
                "newPage": false,
                "searchKey": "tls.testKeysFromTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type testKeysFromTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype testKeysFromTest struct {\n\tversion                                        uint16\n\tsuite                                          *cipherSuite\n\tpreMasterSecret                                string\n\tclientRandom, serverRandom                     string\n\tmasterSecret                                   string\n\tclientMAC, serverMAC                           string\n\tclientKey, serverKey                           string\n\tmacLen, keyLen                                 int\n\tcontextKeyingMaterial, noContextKeyingMaterial string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#readerFunc",
              "documentation": {
                "identifier": "readerFunc",
                "newPage": false,
                "searchKey": "tls.readerFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type readerFunc func([]byte) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype readerFunc func([]byte) (int, error)\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#readerFunc.Read",
                    "documentation": {
                      "identifier": "readerFunc.Read",
                      "newPage": false,
                      "searchKey": "tls.readerFunc.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f readerFunc) Read(b []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f readerFunc) Read(b []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#changeImplConn",
              "documentation": {
                "identifier": "changeImplConn",
                "newPage": false,
                "searchKey": "tls.changeImplConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type changeImplConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype changeImplConn struct {\n\tnet.Conn\n\twriteFunc func([]byte) (int, error)\n\tcloseFunc func() error\n}\n```\n\nchangeImplConn is a net.Conn which can change its Write and Close methods. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#changeImplConn.Write",
                    "documentation": {
                      "identifier": "changeImplConn.Write",
                      "newPage": false,
                      "searchKey": "tls.changeImplConn.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *changeImplConn) Write(p []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *changeImplConn) Write(p []byte) (n int, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/crypto/tls#changeImplConn.Close",
                    "documentation": {
                      "identifier": "changeImplConn.Close",
                      "newPage": false,
                      "searchKey": "tls.changeImplConn.Close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *changeImplConn) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *changeImplConn) Close() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#slowConn",
              "documentation": {
                "identifier": "slowConn",
                "newPage": false,
                "searchKey": "tls.slowConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type slowConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype slowConn struct {\n\tnet.Conn\n\tbps int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#slowConn.Write",
                    "documentation": {
                      "identifier": "slowConn.Write",
                      "newPage": false,
                      "searchKey": "tls.slowConn.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *slowConn) Write(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *slowConn) Write(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#brokenSigner",
              "documentation": {
                "identifier": "brokenSigner",
                "newPage": false,
                "searchKey": "tls.brokenSigner",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type brokenSigner struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype brokenSigner struct{ crypto.Signer }\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/crypto/tls#brokenSigner.Sign",
                    "documentation": {
                      "identifier": "brokenSigner.Sign",
                      "newPage": false,
                      "searchKey": "tls.brokenSigner.Sign",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s brokenSigner) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) (signature []byte, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s brokenSigner) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) (signature []byte, err error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/crypto/tls#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/crypto/tls#verifyHandshakeSignature",
              "documentation": {
                "identifier": "verifyHandshakeSignature",
                "newPage": false,
                "searchKey": "tls.verifyHandshakeSignature",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func verifyHandshakeSignature(sigType uint8, pubkey crypto.PublicKey, hashFunc crypto.Hash, signed, sig []byte) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc verifyHandshakeSignature(sigType uint8, pubkey crypto.PublicKey, hashFunc crypto.Hash, signed, sig []byte) error\n```\n\nverifyHandshakeSignature verifies a signature against pre-hashed (if required) handshake contents. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#signedMessage",
              "documentation": {
                "identifier": "signedMessage",
                "newPage": false,
                "searchKey": "tls.signedMessage",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signedMessage(sigHash crypto.Hash, context string, transcript hash.Hash) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signedMessage(sigHash crypto.Hash, context string, transcript hash.Hash) []byte\n```\n\nsignedMessage returns the pre-hashed (if necessary) message to be signed by certificate keys in TLS 1.3. See RFC 8446, Section 4.4.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#typeAndHashFromSignatureScheme",
              "documentation": {
                "identifier": "typeAndHashFromSignatureScheme",
                "newPage": false,
                "searchKey": "tls.typeAndHashFromSignatureScheme",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typeAndHashFromSignatureScheme(signatureAlgorithm SignatureScheme) (sigType uint8, hash crypto.Hash, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typeAndHashFromSignatureScheme(signatureAlgorithm SignatureScheme) (sigType uint8, hash crypto.Hash, err error)\n```\n\ntypeAndHashFromSignatureScheme returns the corresponding signature type and crypto.Hash for a given TLS SignatureScheme. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#legacyTypeAndHashFromPublicKey",
              "documentation": {
                "identifier": "legacyTypeAndHashFromPublicKey",
                "newPage": false,
                "searchKey": "tls.legacyTypeAndHashFromPublicKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func legacyTypeAndHashFromPublicKey(pub crypto.PublicKey) (sigType uint8, hash crypto.Hash, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc legacyTypeAndHashFromPublicKey(pub crypto.PublicKey) (sigType uint8, hash crypto.Hash, err error)\n```\n\nlegacyTypeAndHashFromPublicKey returns the fixed signature type and crypto.Hash for a given public key used with TLS 1.0 and 1.1, before the introduction of signature algorithm negotiation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#signatureSchemesForCertificate",
              "documentation": {
                "identifier": "signatureSchemesForCertificate",
                "newPage": false,
                "searchKey": "tls.signatureSchemesForCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signatureSchemesForCertificate(version uint16, cert *Certificate) []SignatureScheme"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signatureSchemesForCertificate(version uint16, cert *Certificate) []SignatureScheme\n```\n\nsignatureSchemesForCertificate returns the list of supported SignatureSchemes for a given certificate, based on the public key and the protocol version, and optionally filtered by its explicit SupportedSignatureAlgorithms. \n\nThis function must be kept in sync with supportedSignatureAlgorithms. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#unsupportedCertificateError",
              "documentation": {
                "identifier": "unsupportedCertificateError",
                "newPage": false,
                "searchKey": "tls.unsupportedCertificateError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unsupportedCertificateError(cert *Certificate) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unsupportedCertificateError(cert *Certificate) error\n```\n\nunsupportedCertificateError returns a helpful error for certificates with an unsupported private key. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#CipherSuites",
              "documentation": {
                "identifier": "CipherSuites",
                "newPage": false,
                "searchKey": "tls.CipherSuites",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func CipherSuites() []*CipherSuite"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc CipherSuites() []*CipherSuite\n```\n\nCipherSuites returns a list of cipher suites currently implemented by this package, excluding those with security issues, which are returned by InsecureCipherSuites. \n\nThe list is sorted by ID. Note that the default cipher suites selected by this package might depend on logic that can't be captured by a static list, and might not match those returned by this function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#InsecureCipherSuites",
              "documentation": {
                "identifier": "InsecureCipherSuites",
                "newPage": false,
                "searchKey": "tls.InsecureCipherSuites",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func InsecureCipherSuites() []*CipherSuite"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc InsecureCipherSuites() []*CipherSuite\n```\n\nInsecureCipherSuites returns a list of cipher suites currently implemented by this package and which have security issues. \n\nMost applications should not use the cipher suites in this list, and should only use those returned by CipherSuites. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#CipherSuiteName",
              "documentation": {
                "identifier": "CipherSuiteName",
                "newPage": false,
                "searchKey": "tls.CipherSuiteName",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func CipherSuiteName(id uint16) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc CipherSuiteName(id uint16) string\n```\n\nCipherSuiteName returns the standard name for the passed cipher suite ID (e.g. \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\"), or a fallback representation of the ID value if the cipher suite is not implemented by this package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#aesgcmPreferred",
              "documentation": {
                "identifier": "aesgcmPreferred",
                "newPage": false,
                "searchKey": "tls.aesgcmPreferred",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func aesgcmPreferred(ciphers []uint16) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc aesgcmPreferred(ciphers []uint16) bool\n```\n\naesgcmPreferred returns whether the first known cipher in the preference list is an AES-GCM cipher, implying the peer has hardware support for it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cipherRC4",
              "documentation": {
                "identifier": "cipherRC4",
                "newPage": false,
                "searchKey": "tls.cipherRC4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cipherRC4(key, iv []byte, isRead bool) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cipherRC4(key, iv []byte, isRead bool) interface{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cipher3DES",
              "documentation": {
                "identifier": "cipher3DES",
                "newPage": false,
                "searchKey": "tls.cipher3DES",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cipher3DES(key, iv []byte, isRead bool) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cipher3DES(key, iv []byte, isRead bool) interface{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cipherAES",
              "documentation": {
                "identifier": "cipherAES",
                "newPage": false,
                "searchKey": "tls.cipherAES",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cipherAES(key, iv []byte, isRead bool) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cipherAES(key, iv []byte, isRead bool) interface{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#macSHA1",
              "documentation": {
                "identifier": "macSHA1",
                "newPage": false,
                "searchKey": "tls.macSHA1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func macSHA1(key []byte) hash.Hash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc macSHA1(key []byte) hash.Hash\n```\n\nmacSHA1 returns a SHA-1 based constant time MAC. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#macSHA256",
              "documentation": {
                "identifier": "macSHA256",
                "newPage": false,
                "searchKey": "tls.macSHA256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func macSHA256(key []byte) hash.Hash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc macSHA256(key []byte) hash.Hash\n```\n\nmacSHA256 returns a SHA-256 based MAC. This is only supported in TLS 1.2 and is currently only used in disabled-by-default cipher suites. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#newConstantTimeHash",
              "documentation": {
                "identifier": "newConstantTimeHash",
                "newPage": false,
                "searchKey": "tls.newConstantTimeHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newConstantTimeHash(h func() hash.Hash) func() hash.Hash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newConstantTimeHash(h func() hash.Hash) func() hash.Hash\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#tls10MAC",
              "documentation": {
                "identifier": "tls10MAC",
                "newPage": false,
                "searchKey": "tls.tls10MAC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tls10MAC(h hash.Hash, out, seq, header, data, extra []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tls10MAC(h hash.Hash, out, seq, header, data, extra []byte) []byte\n```\n\ntls10MAC implements the TLS 1.0 MAC function. RFC 2246, Section 6.2.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#requiresClientCert",
              "documentation": {
                "identifier": "requiresClientCert",
                "newPage": false,
                "searchKey": "tls.requiresClientCert",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func requiresClientCert(c ClientAuthType) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc requiresClientCert(c ClientAuthType) bool\n```\n\nrequiresClientCert reports whether the ClientAuthType requires a client certificate to be provided. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#supportedVersionsFromMax",
              "documentation": {
                "identifier": "supportedVersionsFromMax",
                "newPage": false,
                "searchKey": "tls.supportedVersionsFromMax",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func supportedVersionsFromMax(maxVersion uint16) []uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc supportedVersionsFromMax(maxVersion uint16) []uint16\n```\n\nsupportedVersionsFromMax returns a list of supported versions derived from a legacy maximum version value. Note that only versions supported by this library are returned. Any newer peer will use supportedVersions anyway. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#unexpectedMessageError",
              "documentation": {
                "identifier": "unexpectedMessageError",
                "newPage": false,
                "searchKey": "tls.unexpectedMessageError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unexpectedMessageError(wanted, got interface{}) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unexpectedMessageError(wanted, got interface{}) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#isSupportedSignatureAlgorithm",
              "documentation": {
                "identifier": "isSupportedSignatureAlgorithm",
                "newPage": false,
                "searchKey": "tls.isSupportedSignatureAlgorithm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isSupportedSignatureAlgorithm(sigAlg SignatureScheme, supportedSignatureAlgorithms []SignatureScheme) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isSupportedSignatureAlgorithm(sigAlg SignatureScheme, supportedSignatureAlgorithms []SignatureScheme) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_",
              "documentation": {
                "identifier": "_",
                "newPage": false,
                "searchKey": "tls._",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func _()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc _()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_",
              "documentation": {
                "identifier": "_",
                "newPage": false,
                "searchKey": "tls._",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func _()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc _()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#_",
              "documentation": {
                "identifier": "_",
                "newPage": false,
                "searchKey": "tls._",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func _()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc _()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#extractPadding",
              "documentation": {
                "identifier": "extractPadding",
                "newPage": false,
                "searchKey": "tls.extractPadding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func extractPadding(payload []byte) (toRemove int, good byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc extractPadding(payload []byte) (toRemove int, good byte)\n```\n\nextractPadding returns, in constant time, the length of the padding to remove from the end of payload. It also returns a byte which is equal to 255 if the padding was valid and 0 otherwise. See RFC 2246, Section 6.2.3.2. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#roundUp",
              "documentation": {
                "identifier": "roundUp",
                "newPage": false,
                "searchKey": "tls.roundUp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func roundUp(a, b int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc roundUp(a, b int) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#sliceForAppend",
              "documentation": {
                "identifier": "sliceForAppend",
                "newPage": false,
                "searchKey": "tls.sliceForAppend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sliceForAppend(in []byte, n int) (head, tail []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sliceForAppend(in []byte, n int) (head, tail []byte)\n```\n\nsliceForAppend extends the input slice by n bytes. head is the full extended slice, while tail is the appended part. If the original slice has sufficient capacity no allocation is performed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#checkALPN",
              "documentation": {
                "identifier": "checkALPN",
                "newPage": false,
                "searchKey": "tls.checkALPN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkALPN(clientProtos []string, serverProto string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkALPN(clientProtos []string, serverProto string) error\n```\n\ncheckALPN ensure that the server's choice of ALPN protocol is compatible with the protocols that we advertised in the Client Hello. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#clientSessionCacheKey",
              "documentation": {
                "identifier": "clientSessionCacheKey",
                "newPage": false,
                "searchKey": "tls.clientSessionCacheKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func clientSessionCacheKey(serverAddr net.Addr, config *Config) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc clientSessionCacheKey(serverAddr net.Addr, config *Config) string\n```\n\nclientSessionCacheKey returns a key used to cache sessionTickets that could be used to resume previously negotiated TLS sessions with a server. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#hostnameInSNI",
              "documentation": {
                "identifier": "hostnameInSNI",
                "newPage": false,
                "searchKey": "tls.hostnameInSNI",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hostnameInSNI(name string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hostnameInSNI(name string) string\n```\n\nhostnameInSNI converts name into an appropriate hostname for SNI. Literal IP addresses and absolute FQDNs are not permitted as SNI values. See RFC 6066, Section 3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#addBytesWithLength",
              "documentation": {
                "identifier": "addBytesWithLength",
                "newPage": false,
                "searchKey": "tls.addBytesWithLength",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addBytesWithLength(b *cryptobyte.Builder, v []byte, n int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addBytesWithLength(b *cryptobyte.Builder, v []byte, n int)\n```\n\naddBytesWithLength appends a sequence of bytes to the cryptobyte.Builder. If the length of the sequence is not the value specified, it produces an error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#addUint64",
              "documentation": {
                "identifier": "addUint64",
                "newPage": false,
                "searchKey": "tls.addUint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addUint64(b *cryptobyte.Builder, v uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addUint64(b *cryptobyte.Builder, v uint64)\n```\n\naddUint64 appends a big-endian, 64-bit value to the cryptobyte.Builder. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#readUint64",
              "documentation": {
                "identifier": "readUint64",
                "newPage": false,
                "searchKey": "tls.readUint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readUint64(s *cryptobyte.String, out *uint64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readUint64(s *cryptobyte.String, out *uint64) bool\n```\n\nreadUint64 decodes a big-endian, 64-bit value into out and advances over it. It reports whether the read was successful. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#readUint8LengthPrefixed",
              "documentation": {
                "identifier": "readUint8LengthPrefixed",
                "newPage": false,
                "searchKey": "tls.readUint8LengthPrefixed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readUint8LengthPrefixed(s *cryptobyte.String, out *[]byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readUint8LengthPrefixed(s *cryptobyte.String, out *[]byte) bool\n```\n\nreadUint8LengthPrefixed acts like s.ReadUint8LengthPrefixed, but targets a []byte instead of a cryptobyte.String. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#readUint16LengthPrefixed",
              "documentation": {
                "identifier": "readUint16LengthPrefixed",
                "newPage": false,
                "searchKey": "tls.readUint16LengthPrefixed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readUint16LengthPrefixed(s *cryptobyte.String, out *[]byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readUint16LengthPrefixed(s *cryptobyte.String, out *[]byte) bool\n```\n\nreadUint16LengthPrefixed acts like s.ReadUint16LengthPrefixed, but targets a []byte instead of a cryptobyte.String. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#readUint24LengthPrefixed",
              "documentation": {
                "identifier": "readUint24LengthPrefixed",
                "newPage": false,
                "searchKey": "tls.readUint24LengthPrefixed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readUint24LengthPrefixed(s *cryptobyte.String, out *[]byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readUint24LengthPrefixed(s *cryptobyte.String, out *[]byte) bool\n```\n\nreadUint24LengthPrefixed acts like s.ReadUint24LengthPrefixed, but targets a []byte instead of a cryptobyte.String. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#marshalCertificate",
              "documentation": {
                "identifier": "marshalCertificate",
                "newPage": false,
                "searchKey": "tls.marshalCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func marshalCertificate(b *cryptobyte.Builder, certificate Certificate)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc marshalCertificate(b *cryptobyte.Builder, certificate Certificate)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#unmarshalCertificate",
              "documentation": {
                "identifier": "unmarshalCertificate",
                "newPage": false,
                "searchKey": "tls.unmarshalCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unmarshalCertificate(s *cryptobyte.String, certificate *Certificate) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unmarshalCertificate(s *cryptobyte.String, certificate *Certificate) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#negotiateALPN",
              "documentation": {
                "identifier": "negotiateALPN",
                "newPage": false,
                "searchKey": "tls.negotiateALPN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func negotiateALPN(serverProtos, clientProtos []string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc negotiateALPN(serverProtos, clientProtos []string) (string, error)\n```\n\nnegotiateALPN picks a shared ALPN protocol that both sides support in server preference order. If ALPN is not configured or the peer doesn't support it, it returns \"\" and no error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#supportsECDHE",
              "documentation": {
                "identifier": "supportsECDHE",
                "newPage": false,
                "searchKey": "tls.supportsECDHE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func supportsECDHE(c *Config, supportedCurves []CurveID, supportedPoints []uint8) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc supportsECDHE(c *Config, supportedCurves []CurveID, supportedPoints []uint8) bool\n```\n\nsupportsECDHE returns whether ECDHE key exchanges can be used with this pre-TLS 1.3 client. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#cloneHash",
              "documentation": {
                "identifier": "cloneHash",
                "newPage": false,
                "searchKey": "tls.cloneHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cloneHash(in hash.Hash, h crypto.Hash) hash.Hash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cloneHash(in hash.Hash, h crypto.Hash) hash.Hash\n```\n\ncloneHash uses the encoding.BinaryMarshaler and encoding.BinaryUnmarshaler interfaces implemented by standard library hashes to clone the state of in to a new instance of h. It returns nil if the operation fails. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#illegalClientHelloChange",
              "documentation": {
                "identifier": "illegalClientHelloChange",
                "newPage": false,
                "searchKey": "tls.illegalClientHelloChange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func illegalClientHelloChange(ch, ch1 *clientHelloMsg) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc illegalClientHelloChange(ch, ch1 *clientHelloMsg) bool\n```\n\nillegalClientHelloChange reports whether the two ClientHello messages are different, with the exception of the changes allowed before and after a HelloRetryRequest. See RFC 8446, Section 4.1.2. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#sha1Hash",
              "documentation": {
                "identifier": "sha1Hash",
                "newPage": false,
                "searchKey": "tls.sha1Hash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sha1Hash(slices [][]byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sha1Hash(slices [][]byte) []byte\n```\n\nsha1Hash calculates a SHA1 hash over the given byte slices. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#md5SHA1Hash",
              "documentation": {
                "identifier": "md5SHA1Hash",
                "newPage": false,
                "searchKey": "tls.md5SHA1Hash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func md5SHA1Hash(slices [][]byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc md5SHA1Hash(slices [][]byte) []byte\n```\n\nmd5SHA1Hash implements TLS 1.0's hybrid hash function which consists of the concatenation of an MD5 and SHA1 hash. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#hashForServerKeyExchange",
              "documentation": {
                "identifier": "hashForServerKeyExchange",
                "newPage": false,
                "searchKey": "tls.hashForServerKeyExchange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hashForServerKeyExchange(sigType uint8, hashFunc crypto.Hash, version uint16, slices ...[]byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hashForServerKeyExchange(sigType uint8, hashFunc crypto.Hash, version uint16, slices ...[]byte) []byte\n```\n\nhashForServerKeyExchange hashes the given slices and returns their digest using the given hash function (for >= TLS 1.2) or using a default based on the sigType (for earlier TLS versions). For Ed25519 signatures, which don't do pre-hashing, it returns the concatenation of the slices. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#curveForCurveID",
              "documentation": {
                "identifier": "curveForCurveID",
                "newPage": false,
                "searchKey": "tls.curveForCurveID",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func curveForCurveID(id CurveID) (elliptic.Curve, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc curveForCurveID(id CurveID) (elliptic.Curve, bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#splitPreMasterSecret",
              "documentation": {
                "identifier": "splitPreMasterSecret",
                "newPage": false,
                "searchKey": "tls.splitPreMasterSecret",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func splitPreMasterSecret(secret []byte) (s1, s2 []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc splitPreMasterSecret(secret []byte) (s1, s2 []byte)\n```\n\nSplit a premaster secret in two as specified in RFC 4346, Section 5. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#pHash",
              "documentation": {
                "identifier": "pHash",
                "newPage": false,
                "searchKey": "tls.pHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pHash(result, secret, seed []byte, hash func() hash.Hash)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pHash(result, secret, seed []byte, hash func() hash.Hash)\n```\n\npHash implements the P_hash function, as defined in RFC 4346, Section 5. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#prf10",
              "documentation": {
                "identifier": "prf10",
                "newPage": false,
                "searchKey": "tls.prf10",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func prf10(result, secret, label, seed []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc prf10(result, secret, label, seed []byte)\n```\n\nprf10 implements the TLS 1.0 pseudo-random function, as defined in RFC 2246, Section 5. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#prf12",
              "documentation": {
                "identifier": "prf12",
                "newPage": false,
                "searchKey": "tls.prf12",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func prf12(hashFunc func() hash.Hash) func(result, secret, label, seed []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc prf12(hashFunc func() hash.Hash) func(result, secret, label, seed []byte)\n```\n\nprf12 implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, Section 5. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#prfAndHashForVersion",
              "documentation": {
                "identifier": "prfAndHashForVersion",
                "newPage": false,
                "searchKey": "tls.prfAndHashForVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func prfAndHashForVersion(version uint16, suite *cipherSuite) (func(result, secret, label, seed []byte), crypto.Hash)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc prfAndHashForVersion(version uint16, suite *cipherSuite) (func(result, secret, label, seed []byte), crypto.Hash)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#prfForVersion",
              "documentation": {
                "identifier": "prfForVersion",
                "newPage": false,
                "searchKey": "tls.prfForVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func prfForVersion(version uint16, suite *cipherSuite) func(result, secret, label, seed []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc prfForVersion(version uint16, suite *cipherSuite) func(result, secret, label, seed []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#masterFromPreMasterSecret",
              "documentation": {
                "identifier": "masterFromPreMasterSecret",
                "newPage": false,
                "searchKey": "tls.masterFromPreMasterSecret",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func masterFromPreMasterSecret(version uint16, suite *cipherSuite, preMasterSecret, clientRandom, serverRandom []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc masterFromPreMasterSecret(version uint16, suite *cipherSuite, preMasterSecret, clientRandom, serverRandom []byte) []byte\n```\n\nmasterFromPreMasterSecret generates the master secret from the pre-master secret. See RFC 5246, Section 8.1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#keysFromMasterSecret",
              "documentation": {
                "identifier": "keysFromMasterSecret",
                "newPage": false,
                "searchKey": "tls.keysFromMasterSecret",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func keysFromMasterSecret(version uint16, suite *cipherSuite, masterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc keysFromMasterSecret(version uint16, suite *cipherSuite, masterSecret, clientRandom, serverRandom []byte, macLen, keyLen, ivLen int) (clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV []byte)\n```\n\nkeysFromMasterSecret generates the connection keys from the master secret, given the lengths of the MAC key, cipher key and IV, as defined in RFC 2246, Section 6.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#noExportedKeyingMaterial",
              "documentation": {
                "identifier": "noExportedKeyingMaterial",
                "newPage": false,
                "searchKey": "tls.noExportedKeyingMaterial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func noExportedKeyingMaterial(label string, context []byte, length int) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc noExportedKeyingMaterial(label string, context []byte, length int) ([]byte, error)\n```\n\nnoExportedKeyingMaterial is used as a value of ConnectionState.ekm when renegotiation is enabled and thus we wish to fail all key-material export requests. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#ekmFromMasterSecret",
              "documentation": {
                "identifier": "ekmFromMasterSecret",
                "newPage": false,
                "searchKey": "tls.ekmFromMasterSecret",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ekmFromMasterSecret(version uint16, suite *cipherSuite, masterSecret, clientRandom, serverRandom []byte) func(string, []byte, int) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ekmFromMasterSecret(version uint16, suite *cipherSuite, masterSecret, clientRandom, serverRandom []byte) func(string, []byte, int) ([]byte, error)\n```\n\nekmFromMasterSecret generates exported keying material as defined in RFC 5705. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#NewListener",
              "documentation": {
                "identifier": "NewListener",
                "newPage": false,
                "searchKey": "tls.NewListener",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func NewListener(inner net.Listener, config *Config) net.Listener"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc NewListener(inner net.Listener, config *Config) net.Listener\n```\n\nNewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with Server. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#Listen",
              "documentation": {
                "identifier": "Listen",
                "newPage": false,
                "searchKey": "tls.Listen",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Listen(network, laddr string, config *Config) (net.Listener, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Listen(network, laddr string, config *Config) (net.Listener, error)\n```\n\nListen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#parsePrivateKey",
              "documentation": {
                "identifier": "parsePrivateKey",
                "newPage": false,
                "searchKey": "tls.parsePrivateKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parsePrivateKey(der []byte) (crypto.PrivateKey, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parsePrivateKey(der []byte) (crypto.PrivateKey, error)\n```\n\nAttempt to parse the given private key DER block. OpenSSL 0.9.8 generates PKCS #1 private keys by default, while OpenSSL 1.0.0 generates PKCS #8 keys. OpenSSL ecparam generates SEC1 EC private keys for ECDSA. We try all three. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestSignatureSelection",
              "documentation": {
                "identifier": "TestSignatureSelection",
                "newPage": false,
                "searchKey": "tls.TestSignatureSelection",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSignatureSelection(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSignatureSelection(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestLegacyTypeAndHash",
              "documentation": {
                "identifier": "TestLegacyTypeAndHash",
                "newPage": false,
                "searchKey": "tls.TestLegacyTypeAndHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLegacyTypeAndHash(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLegacyTypeAndHash(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestSupportedSignatureAlgorithms",
              "documentation": {
                "identifier": "TestSupportedSignatureAlgorithms",
                "newPage": false,
                "searchKey": "tls.TestSupportedSignatureAlgorithms",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSupportedSignatureAlgorithms(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSupportedSignatureAlgorithms(t *testing.T)\n```\n\nTestSupportedSignatureAlgorithms checks that all supportedSignatureAlgorithms have valid type and hash information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRoundUp",
              "documentation": {
                "identifier": "TestRoundUp",
                "newPage": false,
                "searchKey": "tls.TestRoundUp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRoundUp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRoundUp(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRemovePadding",
              "documentation": {
                "identifier": "TestRemovePadding",
                "newPage": false,
                "searchKey": "tls.TestRemovePadding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRemovePadding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRemovePadding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestCertificateSelection",
              "documentation": {
                "identifier": "TestCertificateSelection",
                "newPage": false,
                "searchKey": "tls.TestCertificateSelection",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCertificateSelection(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCertificateSelection(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runDynamicRecordSizingTest",
              "documentation": {
                "identifier": "runDynamicRecordSizingTest",
                "newPage": false,
                "searchKey": "tls.runDynamicRecordSizingTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runDynamicRecordSizingTest(t *testing.T, config *Config)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runDynamicRecordSizingTest(t *testing.T, config *Config)\n```\n\nRun with multiple crypto configs to test the logic for computing TLS record overheads. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestDynamicRecordSizingWithStreamCipher",
              "documentation": {
                "identifier": "TestDynamicRecordSizingWithStreamCipher",
                "newPage": false,
                "searchKey": "tls.TestDynamicRecordSizingWithStreamCipher",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDynamicRecordSizingWithStreamCipher(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDynamicRecordSizingWithStreamCipher(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestDynamicRecordSizingWithCBC",
              "documentation": {
                "identifier": "TestDynamicRecordSizingWithCBC",
                "newPage": false,
                "searchKey": "tls.TestDynamicRecordSizingWithCBC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDynamicRecordSizingWithCBC(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDynamicRecordSizingWithCBC(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestDynamicRecordSizingWithAEAD",
              "documentation": {
                "identifier": "TestDynamicRecordSizingWithAEAD",
                "newPage": false,
                "searchKey": "tls.TestDynamicRecordSizingWithAEAD",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDynamicRecordSizingWithAEAD(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDynamicRecordSizingWithAEAD(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestDynamicRecordSizingWithTLSv13",
              "documentation": {
                "identifier": "TestDynamicRecordSizingWithTLSv13",
                "newPage": false,
                "searchKey": "tls.TestDynamicRecordSizingWithTLSv13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDynamicRecordSizingWithTLSv13(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDynamicRecordSizingWithTLSv13(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHairpinInClose",
              "documentation": {
                "identifier": "TestHairpinInClose",
                "newPage": false,
                "searchKey": "tls.TestHairpinInClose",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHairpinInClose(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHairpinInClose(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#peekError",
              "documentation": {
                "identifier": "peekError",
                "newPage": false,
                "searchKey": "tls.peekError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func peekError(conn net.Conn) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc peekError(conn net.Conn) error\n```\n\npeekError does a read with a short timeout to check if the next read would cause an error, for example if there is an alert waiting on the wire. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runClientTestForVersion",
              "documentation": {
                "identifier": "runClientTestForVersion",
                "newPage": false,
                "searchKey": "tls.runClientTestForVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runClientTestForVersion(t *testing.T, template *clientTest, version, option string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runClientTestForVersion(t *testing.T, template *clientTest, version, option string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runClientTestTLS10",
              "documentation": {
                "identifier": "runClientTestTLS10",
                "newPage": false,
                "searchKey": "tls.runClientTestTLS10",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runClientTestTLS10(t *testing.T, template *clientTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runClientTestTLS10(t *testing.T, template *clientTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runClientTestTLS11",
              "documentation": {
                "identifier": "runClientTestTLS11",
                "newPage": false,
                "searchKey": "tls.runClientTestTLS11",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runClientTestTLS11(t *testing.T, template *clientTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runClientTestTLS11(t *testing.T, template *clientTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runClientTestTLS12",
              "documentation": {
                "identifier": "runClientTestTLS12",
                "newPage": false,
                "searchKey": "tls.runClientTestTLS12",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runClientTestTLS12(t *testing.T, template *clientTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runClientTestTLS12(t *testing.T, template *clientTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runClientTestTLS13",
              "documentation": {
                "identifier": "runClientTestTLS13",
                "newPage": false,
                "searchKey": "tls.runClientTestTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runClientTestTLS13(t *testing.T, template *clientTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runClientTestTLS13(t *testing.T, template *clientTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientRSARC4",
              "documentation": {
                "identifier": "TestHandshakeClientRSARC4",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientRSARC4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientRSARC4(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientRSARC4(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientRSAAES128GCM",
              "documentation": {
                "identifier": "TestHandshakeClientRSAAES128GCM",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientRSAAES128GCM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientRSAAES128GCM(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientRSAAES128GCM(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientRSAAES256GCM",
              "documentation": {
                "identifier": "TestHandshakeClientRSAAES256GCM",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientRSAAES256GCM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientRSAAES256GCM(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientRSAAES256GCM(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientECDHERSAAES",
              "documentation": {
                "identifier": "TestHandshakeClientECDHERSAAES",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientECDHERSAAES",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientECDHERSAAES(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientECDHERSAAES(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientECDHEECDSAAES",
              "documentation": {
                "identifier": "TestHandshakeClientECDHEECDSAAES",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientECDHEECDSAAES",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientECDHEECDSAAES(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientECDHEECDSAAES(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientECDHEECDSAAESGCM",
              "documentation": {
                "identifier": "TestHandshakeClientECDHEECDSAAESGCM",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientECDHEECDSAAESGCM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientECDHEECDSAAESGCM(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientECDHEECDSAAESGCM(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientAES256GCMSHA384",
              "documentation": {
                "identifier": "TestHandshakeClientAES256GCMSHA384",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientAES256GCMSHA384",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientAES256GCMSHA384(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientAES256GCMSHA384(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientAES128CBCSHA256",
              "documentation": {
                "identifier": "TestHandshakeClientAES128CBCSHA256",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientAES128CBCSHA256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientAES128CBCSHA256(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientAES128CBCSHA256(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientECDHERSAAES128CBCSHA256",
              "documentation": {
                "identifier": "TestHandshakeClientECDHERSAAES128CBCSHA256",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientECDHERSAAES128CBCSHA256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientECDHERSAAES128CBCSHA256(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientECDHERSAAES128CBCSHA256(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientECDHEECDSAAES128CBCSHA256",
              "documentation": {
                "identifier": "TestHandshakeClientECDHEECDSAAES128CBCSHA256",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientECDHEECDSAAES128CBCSHA256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientECDHEECDSAAES128CBCSHA256(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientECDHEECDSAAES128CBCSHA256(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientX25519",
              "documentation": {
                "identifier": "TestHandshakeClientX25519",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientX25519",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientX25519(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientX25519(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientP256",
              "documentation": {
                "identifier": "TestHandshakeClientP256",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientP256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientP256(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientP256(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientHelloRetryRequest",
              "documentation": {
                "identifier": "TestHandshakeClientHelloRetryRequest",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientHelloRetryRequest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientHelloRetryRequest(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientHelloRetryRequest(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientECDHERSAChaCha20",
              "documentation": {
                "identifier": "TestHandshakeClientECDHERSAChaCha20",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientECDHERSAChaCha20",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientECDHERSAChaCha20(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientECDHERSAChaCha20(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientECDHEECDSAChaCha20",
              "documentation": {
                "identifier": "TestHandshakeClientECDHEECDSAChaCha20",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientECDHEECDSAChaCha20",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientECDHEECDSAChaCha20(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientECDHEECDSAChaCha20(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientAES128SHA256",
              "documentation": {
                "identifier": "TestHandshakeClientAES128SHA256",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientAES128SHA256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientAES128SHA256(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientAES128SHA256(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientAES256SHA384",
              "documentation": {
                "identifier": "TestHandshakeClientAES256SHA384",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientAES256SHA384",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientAES256SHA384(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientAES256SHA384(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientCHACHA20SHA256",
              "documentation": {
                "identifier": "TestHandshakeClientCHACHA20SHA256",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientCHACHA20SHA256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientCHACHA20SHA256(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientCHACHA20SHA256(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientECDSATLS13",
              "documentation": {
                "identifier": "TestHandshakeClientECDSATLS13",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientECDSATLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientECDSATLS13(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientECDSATLS13(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientEd25519",
              "documentation": {
                "identifier": "TestHandshakeClientEd25519",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientEd25519",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientEd25519(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientEd25519(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientCertRSA",
              "documentation": {
                "identifier": "TestHandshakeClientCertRSA",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientCertRSA",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientCertRSA(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientCertRSA(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientCertECDSA",
              "documentation": {
                "identifier": "TestHandshakeClientCertECDSA",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientCertECDSA",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientCertECDSA(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientCertECDSA(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientCertRSAPSS",
              "documentation": {
                "identifier": "TestHandshakeClientCertRSAPSS",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientCertRSAPSS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientCertRSAPSS(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientCertRSAPSS(t *testing.T)\n```\n\nTestHandshakeClientCertRSAPSS tests rsa_pss_rsae_sha256 signatures from both client and server certificates. It also serves from both sides a certificate signed itself with RSA-PSS, mostly to check that crypto/x509 chain validation works. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientCertRSAPKCS1v15",
              "documentation": {
                "identifier": "TestHandshakeClientCertRSAPKCS1v15",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientCertRSAPKCS1v15",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientCertRSAPKCS1v15(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientCertRSAPKCS1v15(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestClientKeyUpdate",
              "documentation": {
                "identifier": "TestClientKeyUpdate",
                "newPage": false,
                "searchKey": "tls.TestClientKeyUpdate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestClientKeyUpdate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestClientKeyUpdate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestResumption",
              "documentation": {
                "identifier": "TestResumption",
                "newPage": false,
                "searchKey": "tls.TestResumption",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResumption(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResumption(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testResumption",
              "documentation": {
                "identifier": "testResumption",
                "newPage": false,
                "searchKey": "tls.testResumption",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testResumption(t *testing.T, version uint16)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testResumption(t *testing.T, version uint16)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestLRUClientSessionCache",
              "documentation": {
                "identifier": "TestLRUClientSessionCache",
                "newPage": false,
                "searchKey": "tls.TestLRUClientSessionCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLRUClientSessionCache(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLRUClientSessionCache(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestKeyLogTLS12",
              "documentation": {
                "identifier": "TestKeyLogTLS12",
                "newPage": false,
                "searchKey": "tls.TestKeyLogTLS12",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestKeyLogTLS12(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestKeyLogTLS12(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestKeyLogTLS13",
              "documentation": {
                "identifier": "TestKeyLogTLS13",
                "newPage": false,
                "searchKey": "tls.TestKeyLogTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestKeyLogTLS13(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestKeyLogTLS13(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientALPNMatch",
              "documentation": {
                "identifier": "TestHandshakeClientALPNMatch",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientALPNMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientALPNMatch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientALPNMatch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestServerSelectingUnconfiguredApplicationProtocol",
              "documentation": {
                "identifier": "TestServerSelectingUnconfiguredApplicationProtocol",
                "newPage": false,
                "searchKey": "tls.TestServerSelectingUnconfiguredApplicationProtocol",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestServerSelectingUnconfiguredApplicationProtocol(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestServerSelectingUnconfiguredApplicationProtocol(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakClientSCTs",
              "documentation": {
                "identifier": "TestHandshakClientSCTs",
                "newPage": false,
                "searchKey": "tls.TestHandshakClientSCTs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakClientSCTs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakClientSCTs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRenegotiationRejected",
              "documentation": {
                "identifier": "TestRenegotiationRejected",
                "newPage": false,
                "searchKey": "tls.TestRenegotiationRejected",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRenegotiationRejected(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRenegotiationRejected(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRenegotiateOnce",
              "documentation": {
                "identifier": "TestRenegotiateOnce",
                "newPage": false,
                "searchKey": "tls.TestRenegotiateOnce",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRenegotiateOnce(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRenegotiateOnce(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRenegotiateTwice",
              "documentation": {
                "identifier": "TestRenegotiateTwice",
                "newPage": false,
                "searchKey": "tls.TestRenegotiateTwice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRenegotiateTwice(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRenegotiateTwice(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRenegotiateTwiceRejected",
              "documentation": {
                "identifier": "TestRenegotiateTwiceRejected",
                "newPage": false,
                "searchKey": "tls.TestRenegotiateTwiceRejected",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRenegotiateTwiceRejected(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRenegotiateTwiceRejected(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeClientExportKeyingMaterial",
              "documentation": {
                "identifier": "TestHandshakeClientExportKeyingMaterial",
                "newPage": false,
                "searchKey": "tls.TestHandshakeClientExportKeyingMaterial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeClientExportKeyingMaterial(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeClientExportKeyingMaterial(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHostnameInSNI",
              "documentation": {
                "identifier": "TestHostnameInSNI",
                "newPage": false,
                "searchKey": "tls.TestHostnameInSNI",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHostnameInSNI(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHostnameInSNI(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestServerSelectingUnconfiguredCipherSuite",
              "documentation": {
                "identifier": "TestServerSelectingUnconfiguredCipherSuite",
                "newPage": false,
                "searchKey": "tls.TestServerSelectingUnconfiguredCipherSuite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestServerSelectingUnconfiguredCipherSuite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestServerSelectingUnconfiguredCipherSuite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestVerifyConnection",
              "documentation": {
                "identifier": "TestVerifyConnection",
                "newPage": false,
                "searchKey": "tls.TestVerifyConnection",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestVerifyConnection(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestVerifyConnection(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testVerifyConnection",
              "documentation": {
                "identifier": "testVerifyConnection",
                "newPage": false,
                "searchKey": "tls.testVerifyConnection",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testVerifyConnection(t *testing.T, version uint16)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testVerifyConnection(t *testing.T, version uint16)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestVerifyPeerCertificate",
              "documentation": {
                "identifier": "TestVerifyPeerCertificate",
                "newPage": false,
                "searchKey": "tls.TestVerifyPeerCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestVerifyPeerCertificate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestVerifyPeerCertificate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testVerifyPeerCertificate",
              "documentation": {
                "identifier": "testVerifyPeerCertificate",
                "newPage": false,
                "searchKey": "tls.testVerifyPeerCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testVerifyPeerCertificate(t *testing.T, version uint16)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testVerifyPeerCertificate(t *testing.T, version uint16)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestFailedWrite",
              "documentation": {
                "identifier": "TestFailedWrite",
                "newPage": false,
                "searchKey": "tls.TestFailedWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFailedWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFailedWrite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestBuffering",
              "documentation": {
                "identifier": "TestBuffering",
                "newPage": false,
                "searchKey": "tls.TestBuffering",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBuffering(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBuffering(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testBuffering",
              "documentation": {
                "identifier": "testBuffering",
                "newPage": false,
                "searchKey": "tls.testBuffering",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testBuffering(t *testing.T, version uint16)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testBuffering(t *testing.T, version uint16)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestAlertFlushing",
              "documentation": {
                "identifier": "TestAlertFlushing",
                "newPage": false,
                "searchKey": "tls.TestAlertFlushing",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAlertFlushing(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAlertFlushing(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeRace",
              "documentation": {
                "identifier": "TestHandshakeRace",
                "newPage": false,
                "searchKey": "tls.TestHandshakeRace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeRace(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeRace(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestGetClientCertificate",
              "documentation": {
                "identifier": "TestGetClientCertificate",
                "newPage": false,
                "searchKey": "tls.TestGetClientCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGetClientCertificate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGetClientCertificate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testGetClientCertificate",
              "documentation": {
                "identifier": "testGetClientCertificate",
                "newPage": false,
                "searchKey": "tls.testGetClientCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testGetClientCertificate(t *testing.T, version uint16)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testGetClientCertificate(t *testing.T, version uint16)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRSAPSSKeyError",
              "documentation": {
                "identifier": "TestRSAPSSKeyError",
                "newPage": false,
                "searchKey": "tls.TestRSAPSSKeyError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRSAPSSKeyError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRSAPSSKeyError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestCloseClientConnectionOnIdleServer",
              "documentation": {
                "identifier": "TestCloseClientConnectionOnIdleServer",
                "newPage": false,
                "searchKey": "tls.TestCloseClientConnectionOnIdleServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloseClientConnectionOnIdleServer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloseClientConnectionOnIdleServer(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testDowngradeCanary",
              "documentation": {
                "identifier": "testDowngradeCanary",
                "newPage": false,
                "searchKey": "tls.testDowngradeCanary",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testDowngradeCanary(t *testing.T, clientVersion, serverVersion uint16) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testDowngradeCanary(t *testing.T, clientVersion, serverVersion uint16) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestDowngradeCanary",
              "documentation": {
                "identifier": "TestDowngradeCanary",
                "newPage": false,
                "searchKey": "tls.TestDowngradeCanary",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDowngradeCanary(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDowngradeCanary(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestResumptionKeepsOCSPAndSCT",
              "documentation": {
                "identifier": "TestResumptionKeepsOCSPAndSCT",
                "newPage": false,
                "searchKey": "tls.TestResumptionKeepsOCSPAndSCT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestResumptionKeepsOCSPAndSCT(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestResumptionKeepsOCSPAndSCT(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testResumptionKeepsOCSPAndSCT",
              "documentation": {
                "identifier": "testResumptionKeepsOCSPAndSCT",
                "newPage": false,
                "searchKey": "tls.testResumptionKeepsOCSPAndSCT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testResumptionKeepsOCSPAndSCT(t *testing.T, ver uint16)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testResumptionKeepsOCSPAndSCT(t *testing.T, ver uint16)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestClientHandshakeContextCancellation",
              "documentation": {
                "identifier": "TestClientHandshakeContextCancellation",
                "newPage": false,
                "searchKey": "tls.TestClientHandshakeContextCancellation",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestClientHandshakeContextCancellation(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestClientHandshakeContextCancellation(t *testing.T)\n```\n\nTestClientHandshakeContextCancellation tests that cancelling the context given to the client side conn.HandshakeContext interrupts the in-progress handshake. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestMarshalUnmarshal",
              "documentation": {
                "identifier": "TestMarshalUnmarshal",
                "newPage": false,
                "searchKey": "tls.TestMarshalUnmarshal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMarshalUnmarshal(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMarshalUnmarshal(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestFuzz",
              "documentation": {
                "identifier": "TestFuzz",
                "newPage": false,
                "searchKey": "tls.TestFuzz",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFuzz(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFuzz(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#randomBytes",
              "documentation": {
                "identifier": "randomBytes",
                "newPage": false,
                "searchKey": "tls.randomBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func randomBytes(n int, rand *rand.Rand) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc randomBytes(n int, rand *rand.Rand) []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#randomString",
              "documentation": {
                "identifier": "randomString",
                "newPage": false,
                "searchKey": "tls.randomString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func randomString(n int, rand *rand.Rand) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc randomString(n int, rand *rand.Rand) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRejectEmptySCTList",
              "documentation": {
                "identifier": "TestRejectEmptySCTList",
                "newPage": false,
                "searchKey": "tls.TestRejectEmptySCTList",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRejectEmptySCTList(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRejectEmptySCTList(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRejectEmptySCT",
              "documentation": {
                "identifier": "TestRejectEmptySCT",
                "newPage": false,
                "searchKey": "tls.TestRejectEmptySCT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRejectEmptySCT(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRejectEmptySCT(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testClientHello",
              "documentation": {
                "identifier": "testClientHello",
                "newPage": false,
                "searchKey": "tls.testClientHello",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testClientHello(t *testing.T, serverConfig *Config, m handshakeMessage)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testClientHello(t *testing.T, serverConfig *Config, m handshakeMessage)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testClientHelloFailure",
              "documentation": {
                "identifier": "testClientHelloFailure",
                "newPage": false,
                "searchKey": "tls.testClientHelloFailure",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testClientHelloFailure(t *testing.T, serverConfig *Config, m handshakeMessage, expectedSubStr string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testClientHelloFailure(t *testing.T, serverConfig *Config, m handshakeMessage, expectedSubStr string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestSimpleError",
              "documentation": {
                "identifier": "TestSimpleError",
                "newPage": false,
                "searchKey": "tls.TestSimpleError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSimpleError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSimpleError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRejectBadProtocolVersion",
              "documentation": {
                "identifier": "TestRejectBadProtocolVersion",
                "newPage": false,
                "searchKey": "tls.TestRejectBadProtocolVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRejectBadProtocolVersion(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRejectBadProtocolVersion(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestNoSuiteOverlap",
              "documentation": {
                "identifier": "TestNoSuiteOverlap",
                "newPage": false,
                "searchKey": "tls.TestNoSuiteOverlap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNoSuiteOverlap(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNoSuiteOverlap(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestNoCompressionOverlap",
              "documentation": {
                "identifier": "TestNoCompressionOverlap",
                "newPage": false,
                "searchKey": "tls.TestNoCompressionOverlap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNoCompressionOverlap(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNoCompressionOverlap(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestNoRC4ByDefault",
              "documentation": {
                "identifier": "TestNoRC4ByDefault",
                "newPage": false,
                "searchKey": "tls.TestNoRC4ByDefault",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNoRC4ByDefault(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNoRC4ByDefault(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRejectSNIWithTrailingDot",
              "documentation": {
                "identifier": "TestRejectSNIWithTrailingDot",
                "newPage": false,
                "searchKey": "tls.TestRejectSNIWithTrailingDot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRejectSNIWithTrailingDot(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRejectSNIWithTrailingDot(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestDontSelectECDSAWithRSAKey",
              "documentation": {
                "identifier": "TestDontSelectECDSAWithRSAKey",
                "newPage": false,
                "searchKey": "tls.TestDontSelectECDSAWithRSAKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDontSelectECDSAWithRSAKey(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDontSelectECDSAWithRSAKey(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestDontSelectRSAWithECDSAKey",
              "documentation": {
                "identifier": "TestDontSelectRSAWithECDSAKey",
                "newPage": false,
                "searchKey": "tls.TestDontSelectRSAWithECDSAKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDontSelectRSAWithECDSAKey(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDontSelectRSAWithECDSAKey(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestRenegotiationExtension",
              "documentation": {
                "identifier": "TestRenegotiationExtension",
                "newPage": false,
                "searchKey": "tls.TestRenegotiationExtension",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRenegotiationExtension(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRenegotiationExtension(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestTLS12OnlyCipherSuites",
              "documentation": {
                "identifier": "TestTLS12OnlyCipherSuites",
                "newPage": false,
                "searchKey": "tls.TestTLS12OnlyCipherSuites",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTLS12OnlyCipherSuites(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTLS12OnlyCipherSuites(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestTLSPointFormats",
              "documentation": {
                "identifier": "TestTLSPointFormats",
                "newPage": false,
                "searchKey": "tls.TestTLSPointFormats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTLSPointFormats(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTLSPointFormats(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestAlertForwarding",
              "documentation": {
                "identifier": "TestAlertForwarding",
                "newPage": false,
                "searchKey": "tls.TestAlertForwarding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAlertForwarding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAlertForwarding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestClose",
              "documentation": {
                "identifier": "TestClose",
                "newPage": false,
                "searchKey": "tls.TestClose",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestClose(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestClose(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestVersion",
              "documentation": {
                "identifier": "TestVersion",
                "newPage": false,
                "searchKey": "tls.TestVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestVersion(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestVersion(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestCipherSuitePreference",
              "documentation": {
                "identifier": "TestCipherSuitePreference",
                "newPage": false,
                "searchKey": "tls.TestCipherSuitePreference",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCipherSuitePreference(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCipherSuitePreference(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestSCTHandshake",
              "documentation": {
                "identifier": "TestSCTHandshake",
                "newPage": false,
                "searchKey": "tls.TestSCTHandshake",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSCTHandshake(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSCTHandshake(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testSCTHandshake",
              "documentation": {
                "identifier": "testSCTHandshake",
                "newPage": false,
                "searchKey": "tls.testSCTHandshake",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testSCTHandshake(t *testing.T, version uint16)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testSCTHandshake(t *testing.T, version uint16)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestCrossVersionResume",
              "documentation": {
                "identifier": "TestCrossVersionResume",
                "newPage": false,
                "searchKey": "tls.TestCrossVersionResume",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCrossVersionResume(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCrossVersionResume(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testCrossVersionResume",
              "documentation": {
                "identifier": "testCrossVersionResume",
                "newPage": false,
                "searchKey": "tls.testCrossVersionResume",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testCrossVersionResume(t *testing.T, version uint16)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testCrossVersionResume(t *testing.T, version uint16)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runServerTestForVersion",
              "documentation": {
                "identifier": "runServerTestForVersion",
                "newPage": false,
                "searchKey": "tls.runServerTestForVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runServerTestForVersion(t *testing.T, template *serverTest, version, option string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runServerTestForVersion(t *testing.T, template *serverTest, version, option string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runServerTestTLS10",
              "documentation": {
                "identifier": "runServerTestTLS10",
                "newPage": false,
                "searchKey": "tls.runServerTestTLS10",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runServerTestTLS10(t *testing.T, template *serverTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runServerTestTLS10(t *testing.T, template *serverTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runServerTestTLS11",
              "documentation": {
                "identifier": "runServerTestTLS11",
                "newPage": false,
                "searchKey": "tls.runServerTestTLS11",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runServerTestTLS11(t *testing.T, template *serverTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runServerTestTLS11(t *testing.T, template *serverTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runServerTestTLS12",
              "documentation": {
                "identifier": "runServerTestTLS12",
                "newPage": false,
                "searchKey": "tls.runServerTestTLS12",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runServerTestTLS12(t *testing.T, template *serverTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runServerTestTLS12(t *testing.T, template *serverTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runServerTestTLS13",
              "documentation": {
                "identifier": "runServerTestTLS13",
                "newPage": false,
                "searchKey": "tls.runServerTestTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runServerTestTLS13(t *testing.T, template *serverTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runServerTestTLS13(t *testing.T, template *serverTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerRSARC4",
              "documentation": {
                "identifier": "TestHandshakeServerRSARC4",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerRSARC4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerRSARC4(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerRSARC4(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerRSA3DES",
              "documentation": {
                "identifier": "TestHandshakeServerRSA3DES",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerRSA3DES",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerRSA3DES(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerRSA3DES(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerRSAAES",
              "documentation": {
                "identifier": "TestHandshakeServerRSAAES",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerRSAAES",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerRSAAES(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerRSAAES(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerAESGCM",
              "documentation": {
                "identifier": "TestHandshakeServerAESGCM",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerAESGCM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerAESGCM(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerAESGCM(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerAES256GCMSHA384",
              "documentation": {
                "identifier": "TestHandshakeServerAES256GCMSHA384",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerAES256GCMSHA384",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerAES256GCMSHA384(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerAES256GCMSHA384(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerAES128SHA256",
              "documentation": {
                "identifier": "TestHandshakeServerAES128SHA256",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerAES128SHA256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerAES128SHA256(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerAES128SHA256(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerAES256SHA384",
              "documentation": {
                "identifier": "TestHandshakeServerAES256SHA384",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerAES256SHA384",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerAES256SHA384(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerAES256SHA384(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerCHACHA20SHA256",
              "documentation": {
                "identifier": "TestHandshakeServerCHACHA20SHA256",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerCHACHA20SHA256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerCHACHA20SHA256(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerCHACHA20SHA256(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerECDHEECDSAAES",
              "documentation": {
                "identifier": "TestHandshakeServerECDHEECDSAAES",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerECDHEECDSAAES",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerECDHEECDSAAES(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerECDHEECDSAAES(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerX25519",
              "documentation": {
                "identifier": "TestHandshakeServerX25519",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerX25519",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerX25519(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerX25519(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerP256",
              "documentation": {
                "identifier": "TestHandshakeServerP256",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerP256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerP256(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerP256(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerHelloRetryRequest",
              "documentation": {
                "identifier": "TestHandshakeServerHelloRetryRequest",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerHelloRetryRequest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerHelloRetryRequest(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerHelloRetryRequest(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerALPN",
              "documentation": {
                "identifier": "TestHandshakeServerALPN",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerALPN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerALPN(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerALPN(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerALPNNoMatch",
              "documentation": {
                "identifier": "TestHandshakeServerALPNNoMatch",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerALPNNoMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerALPNNoMatch(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerALPNNoMatch(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerALPNNotConfigured",
              "documentation": {
                "identifier": "TestHandshakeServerALPNNotConfigured",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerALPNNotConfigured",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerALPNNotConfigured(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerALPNNotConfigured(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerALPNFallback",
              "documentation": {
                "identifier": "TestHandshakeServerALPNFallback",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerALPNFallback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerALPNFallback(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerALPNFallback(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerSNI",
              "documentation": {
                "identifier": "TestHandshakeServerSNI",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerSNI",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerSNI(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerSNI(t *testing.T)\n```\n\nTestHandshakeServerSNI involves a client sending an SNI extension of \"snitest.com\", which happens to match the CN of testSNICertificate. The test verifies that the server correctly selects that certificate. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerSNIGetCertificate",
              "documentation": {
                "identifier": "TestHandshakeServerSNIGetCertificate",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerSNIGetCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerSNIGetCertificate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerSNIGetCertificate(t *testing.T)\n```\n\nTestHandshakeServerSNICertForName is similar to TestHandshakeServerSNI, but tests the dynamic GetCertificate method \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerSNIGetCertificateNotFound",
              "documentation": {
                "identifier": "TestHandshakeServerSNIGetCertificateNotFound",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerSNIGetCertificateNotFound",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerSNIGetCertificateNotFound(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerSNIGetCertificateNotFound(t *testing.T)\n```\n\nTestHandshakeServerSNICertForNameNotFound is similar to TestHandshakeServerSNICertForName, but tests to make sure that when the GetCertificate method doesn't return a cert, we fall back to what's in the NameToCertificate map. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerSNIGetCertificateError",
              "documentation": {
                "identifier": "TestHandshakeServerSNIGetCertificateError",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerSNIGetCertificateError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerSNIGetCertificateError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerSNIGetCertificateError(t *testing.T)\n```\n\nTestHandshakeServerSNICertForNameError tests to make sure that errors in GetCertificate result in a tls alert. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerEmptyCertificates",
              "documentation": {
                "identifier": "TestHandshakeServerEmptyCertificates",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerEmptyCertificates",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerEmptyCertificates(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerEmptyCertificates(t *testing.T)\n```\n\nTestHandshakeServerEmptyCertificates tests that GetCertificates is called in the case that Certificates is empty, even without SNI. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestServerResumption",
              "documentation": {
                "identifier": "TestServerResumption",
                "newPage": false,
                "searchKey": "tls.TestServerResumption",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestServerResumption(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestServerResumption(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestServerResumptionDisabled",
              "documentation": {
                "identifier": "TestServerResumptionDisabled",
                "newPage": false,
                "searchKey": "tls.TestServerResumptionDisabled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestServerResumptionDisabled(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestServerResumptionDisabled(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestFallbackSCSV",
              "documentation": {
                "identifier": "TestFallbackSCSV",
                "newPage": false,
                "searchKey": "tls.TestFallbackSCSV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFallbackSCSV(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFallbackSCSV(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerExportKeyingMaterial",
              "documentation": {
                "identifier": "TestHandshakeServerExportKeyingMaterial",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerExportKeyingMaterial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerExportKeyingMaterial(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerExportKeyingMaterial(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerRSAPKCS1v15",
              "documentation": {
                "identifier": "TestHandshakeServerRSAPKCS1v15",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerRSAPKCS1v15",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerRSAPKCS1v15(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerRSAPKCS1v15(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerRSAPSS",
              "documentation": {
                "identifier": "TestHandshakeServerRSAPSS",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerRSAPSS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerRSAPSS(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerRSAPSS(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeServerEd25519",
              "documentation": {
                "identifier": "TestHandshakeServerEd25519",
                "newPage": false,
                "searchKey": "tls.TestHandshakeServerEd25519",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeServerEd25519(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeServerEd25519(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#benchmarkHandshakeServer",
              "documentation": {
                "identifier": "benchmarkHandshakeServer",
                "newPage": false,
                "searchKey": "tls.benchmarkHandshakeServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func benchmarkHandshakeServer(b *testing.B, version uint16, cipherSuite uint16, curve CurveID, cert []byte, key crypto.PrivateKey)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc benchmarkHandshakeServer(b *testing.B, version uint16, cipherSuite uint16, curve CurveID, cert []byte, key crypto.PrivateKey)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#BenchmarkHandshakeServer",
              "documentation": {
                "identifier": "BenchmarkHandshakeServer",
                "newPage": false,
                "searchKey": "tls.BenchmarkHandshakeServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkHandshakeServer(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkHandshakeServer(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestClientAuth",
              "documentation": {
                "identifier": "TestClientAuth",
                "newPage": false,
                "searchKey": "tls.TestClientAuth",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestClientAuth(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestClientAuth(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestSNIGivenOnFailure",
              "documentation": {
                "identifier": "TestSNIGivenOnFailure",
                "newPage": false,
                "searchKey": "tls.TestSNIGivenOnFailure",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSNIGivenOnFailure(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSNIGivenOnFailure(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestGetConfigForClient",
              "documentation": {
                "identifier": "TestGetConfigForClient",
                "newPage": false,
                "searchKey": "tls.TestGetConfigForClient",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGetConfigForClient(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGetConfigForClient(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestCloseServerConnectionOnIdleClient",
              "documentation": {
                "identifier": "TestCloseServerConnectionOnIdleClient",
                "newPage": false,
                "searchKey": "tls.TestCloseServerConnectionOnIdleClient",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloseServerConnectionOnIdleClient(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloseServerConnectionOnIdleClient(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestCloneHash",
              "documentation": {
                "identifier": "TestCloneHash",
                "newPage": false,
                "searchKey": "tls.TestCloneHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloneHash(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloneHash(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#expectError",
              "documentation": {
                "identifier": "expectError",
                "newPage": false,
                "searchKey": "tls.expectError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func expectError(t *testing.T, err error, sub string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc expectError(t *testing.T, err error, sub string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestKeyTooSmallForRSAPSS",
              "documentation": {
                "identifier": "TestKeyTooSmallForRSAPSS",
                "newPage": false,
                "searchKey": "tls.TestKeyTooSmallForRSAPSS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestKeyTooSmallForRSAPSS(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestKeyTooSmallForRSAPSS(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestMultipleCertificates",
              "documentation": {
                "identifier": "TestMultipleCertificates",
                "newPage": false,
                "searchKey": "tls.TestMultipleCertificates",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMultipleCertificates(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMultipleCertificates(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestAESCipherReordering",
              "documentation": {
                "identifier": "TestAESCipherReordering",
                "newPage": false,
                "searchKey": "tls.TestAESCipherReordering",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAESCipherReordering(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAESCipherReordering(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestAESCipherReorderingTLS13",
              "documentation": {
                "identifier": "TestAESCipherReorderingTLS13",
                "newPage": false,
                "searchKey": "tls.TestAESCipherReorderingTLS13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAESCipherReorderingTLS13(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAESCipherReorderingTLS13(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestServerHandshakeContextCancellation",
              "documentation": {
                "identifier": "TestServerHandshakeContextCancellation",
                "newPage": false,
                "searchKey": "tls.TestServerHandshakeContextCancellation",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestServerHandshakeContextCancellation(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestServerHandshakeContextCancellation(t *testing.T)\n```\n\nTestServerHandshakeContextCancellation tests that cancelling the context given to the server side conn.HandshakeContext interrupts the in-progress handshake. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestHandshakeContextHierarchy",
              "documentation": {
                "identifier": "TestHandshakeContextHierarchy",
                "newPage": false,
                "searchKey": "tls.TestHandshakeContextHierarchy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHandshakeContextHierarchy(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHandshakeContextHierarchy(t *testing.T)\n```\n\nTestHandshakeContextHierarchy tests whether the contexts available to GetClientCertificate and GetCertificate are derived from the context provided to HandshakeContext, and that those contexts are canceled after HandshakeContext has returned. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runTestAndUpdateIfNeeded",
              "documentation": {
                "identifier": "runTestAndUpdateIfNeeded",
                "newPage": false,
                "searchKey": "tls.runTestAndUpdateIfNeeded",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runTestAndUpdateIfNeeded(t *testing.T, name string, run func(t *testing.T, update bool), wait bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runTestAndUpdateIfNeeded(t *testing.T, name string, run func(t *testing.T, update bool), wait bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#checkOpenSSLVersion",
              "documentation": {
                "identifier": "checkOpenSSLVersion",
                "newPage": false,
                "searchKey": "tls.checkOpenSSLVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkOpenSSLVersion() error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkOpenSSLVersion() error\n```\n\ncheckOpenSSLVersion ensures that the version of OpenSSL looks reasonable before updating the test data. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#parseTestData",
              "documentation": {
                "identifier": "parseTestData",
                "newPage": false,
                "searchKey": "tls.parseTestData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseTestData(r io.Reader) (flows [][]byte, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseTestData(r io.Reader) (flows [][]byte, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#tempFile",
              "documentation": {
                "identifier": "tempFile",
                "newPage": false,
                "searchKey": "tls.tempFile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tempFile(contents string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tempFile(contents string) string\n```\n\ntempFile creates a temp file containing contents and returns its path. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#localServer",
              "documentation": {
                "identifier": "localServer",
                "newPage": false,
                "searchKey": "tls.localServer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func localServer(l net.Listener)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc localServer(l net.Listener)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#localPipe",
              "documentation": {
                "identifier": "localPipe",
                "newPage": false,
                "searchKey": "tls.localPipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func localPipe(t testing.TB) (net.Conn, net.Conn)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc localPipe(t testing.TB) (net.Conn, net.Conn)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#allCipherSuites",
              "documentation": {
                "identifier": "allCipherSuites",
                "newPage": false,
                "searchKey": "tls.allCipherSuites",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func allCipherSuites() []uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc allCipherSuites() []uint16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestMain",
              "documentation": {
                "identifier": "TestMain",
                "newPage": false,
                "searchKey": "tls.TestMain",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMain(m *testing.M)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMain(m *testing.M)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#runMain",
              "documentation": {
                "identifier": "runMain",
                "newPage": false,
                "searchKey": "tls.runMain",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runMain(m *testing.M) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runMain(m *testing.M) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#fromHex",
              "documentation": {
                "identifier": "fromHex",
                "newPage": false,
                "searchKey": "tls.fromHex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fromHex(s string) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fromHex(s string) []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "tls.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#parseVector",
              "documentation": {
                "identifier": "parseVector",
                "newPage": false,
                "searchKey": "tls.parseVector",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parseVector(v string) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parseVector(v string) []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestDeriveSecret",
              "documentation": {
                "identifier": "TestDeriveSecret",
                "newPage": false,
                "searchKey": "tls.TestDeriveSecret",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDeriveSecret(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDeriveSecret(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestTrafficKey",
              "documentation": {
                "identifier": "TestTrafficKey",
                "newPage": false,
                "searchKey": "tls.TestTrafficKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTrafficKey(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTrafficKey(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestExtract",
              "documentation": {
                "identifier": "TestExtract",
                "newPage": false,
                "searchKey": "tls.TestExtract",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExtract(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExtract(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestLinkerGC",
              "documentation": {
                "identifier": "TestLinkerGC",
                "newPage": false,
                "searchKey": "tls.TestLinkerGC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLinkerGC(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLinkerGC(t *testing.T)\n```\n\nTests that the linker is able to remove references to the Client or Server if unused. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestSplitPreMasterSecret",
              "documentation": {
                "identifier": "TestSplitPreMasterSecret",
                "newPage": false,
                "searchKey": "tls.TestSplitPreMasterSecret",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSplitPreMasterSecret(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSplitPreMasterSecret(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestKeysFromPreMasterSecret",
              "documentation": {
                "identifier": "TestKeysFromPreMasterSecret",
                "newPage": false,
                "searchKey": "tls.TestKeysFromPreMasterSecret",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestKeysFromPreMasterSecret(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestKeysFromPreMasterSecret(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestX509KeyPair",
              "documentation": {
                "identifier": "TestX509KeyPair",
                "newPage": false,
                "searchKey": "tls.TestX509KeyPair",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestX509KeyPair(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestX509KeyPair(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestX509KeyPairErrors",
              "documentation": {
                "identifier": "TestX509KeyPairErrors",
                "newPage": false,
                "searchKey": "tls.TestX509KeyPairErrors",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestX509KeyPairErrors(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestX509KeyPairErrors(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestX509MixedKeyPair",
              "documentation": {
                "identifier": "TestX509MixedKeyPair",
                "newPage": false,
                "searchKey": "tls.TestX509MixedKeyPair",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestX509MixedKeyPair(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestX509MixedKeyPair(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#newLocalListener",
              "documentation": {
                "identifier": "newLocalListener",
                "newPage": false,
                "searchKey": "tls.newLocalListener",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newLocalListener(t testing.TB) net.Listener"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newLocalListener(t testing.TB) net.Listener\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestDialTimeout",
              "documentation": {
                "identifier": "TestDialTimeout",
                "newPage": false,
                "searchKey": "tls.TestDialTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialTimeout(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialTimeout(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestDeadlineOnWrite",
              "documentation": {
                "identifier": "TestDeadlineOnWrite",
                "newPage": false,
                "searchKey": "tls.TestDeadlineOnWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDeadlineOnWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDeadlineOnWrite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestDialer",
              "documentation": {
                "identifier": "TestDialer",
                "newPage": false,
                "searchKey": "tls.TestDialer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDialer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDialer(t *testing.T)\n```\n\nTestDialer tests that tls.Dialer.DialContext can abort in the middle of a handshake. (The other cases are all handled by the existing dial tests in this package, which all also flow through the same code shared code paths) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#isTimeoutError",
              "documentation": {
                "identifier": "isTimeoutError",
                "newPage": false,
                "searchKey": "tls.isTimeoutError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isTimeoutError(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isTimeoutError(err error) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestConnReadNonzeroAndEOF",
              "documentation": {
                "identifier": "TestConnReadNonzeroAndEOF",
                "newPage": false,
                "searchKey": "tls.TestConnReadNonzeroAndEOF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConnReadNonzeroAndEOF(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConnReadNonzeroAndEOF(t *testing.T)\n```\n\ntests that Conn.Read returns (non-zero, io.EOF) instead of (non-zero, nil) when a Close (alertCloseNotify) is sitting right behind the application data in the buffer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testConnReadNonzeroAndEOF",
              "documentation": {
                "identifier": "testConnReadNonzeroAndEOF",
                "newPage": false,
                "searchKey": "tls.testConnReadNonzeroAndEOF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testConnReadNonzeroAndEOF(t *testing.T, delay time.Duration) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testConnReadNonzeroAndEOF(t *testing.T, delay time.Duration) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestTLSUniqueMatches",
              "documentation": {
                "identifier": "TestTLSUniqueMatches",
                "newPage": false,
                "searchKey": "tls.TestTLSUniqueMatches",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTLSUniqueMatches(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTLSUniqueMatches(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestVerifyHostname",
              "documentation": {
                "identifier": "TestVerifyHostname",
                "newPage": false,
                "searchKey": "tls.TestVerifyHostname",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestVerifyHostname(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestVerifyHostname(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestConnCloseBreakingWrite",
              "documentation": {
                "identifier": "TestConnCloseBreakingWrite",
                "newPage": false,
                "searchKey": "tls.TestConnCloseBreakingWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConnCloseBreakingWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConnCloseBreakingWrite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestConnCloseWrite",
              "documentation": {
                "identifier": "TestConnCloseWrite",
                "newPage": false,
                "searchKey": "tls.TestConnCloseWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConnCloseWrite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConnCloseWrite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestWarningAlertFlood",
              "documentation": {
                "identifier": "TestWarningAlertFlood",
                "newPage": false,
                "searchKey": "tls.TestWarningAlertFlood",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestWarningAlertFlood(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestWarningAlertFlood(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestCloneFuncFields",
              "documentation": {
                "identifier": "TestCloneFuncFields",
                "newPage": false,
                "searchKey": "tls.TestCloneFuncFields",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloneFuncFields(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloneFuncFields(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestCloneNonFuncFields",
              "documentation": {
                "identifier": "TestCloneNonFuncFields",
                "newPage": false,
                "searchKey": "tls.TestCloneNonFuncFields",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloneNonFuncFields(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloneNonFuncFields(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestCloneNilConfig",
              "documentation": {
                "identifier": "TestCloneNilConfig",
                "newPage": false,
                "searchKey": "tls.TestCloneNilConfig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloneNilConfig(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloneNilConfig(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#throughput",
              "documentation": {
                "identifier": "throughput",
                "newPage": false,
                "searchKey": "tls.throughput",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func throughput(b *testing.B, version uint16, totalBytes int64, dynamicRecordSizingDisabled bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc throughput(b *testing.B, version uint16, totalBytes int64, dynamicRecordSizingDisabled bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#BenchmarkThroughput",
              "documentation": {
                "identifier": "BenchmarkThroughput",
                "newPage": false,
                "searchKey": "tls.BenchmarkThroughput",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkThroughput(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkThroughput(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#latency",
              "documentation": {
                "identifier": "latency",
                "newPage": false,
                "searchKey": "tls.latency",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func latency(b *testing.B, version uint16, bps int, dynamicRecordSizingDisabled bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc latency(b *testing.B, version uint16, bps int, dynamicRecordSizingDisabled bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#BenchmarkLatency",
              "documentation": {
                "identifier": "BenchmarkLatency",
                "newPage": false,
                "searchKey": "tls.BenchmarkLatency",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkLatency(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkLatency(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestConnectionStateMarshal",
              "documentation": {
                "identifier": "TestConnectionStateMarshal",
                "newPage": false,
                "searchKey": "tls.TestConnectionStateMarshal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConnectionStateMarshal(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConnectionStateMarshal(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestConnectionState",
              "documentation": {
                "identifier": "TestConnectionState",
                "newPage": false,
                "searchKey": "tls.TestConnectionState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestConnectionState(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestConnectionState(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestBuildNameToCertificate_doesntModifyCertificates",
              "documentation": {
                "identifier": "TestBuildNameToCertificate_doesntModifyCertificates",
                "newPage": false,
                "searchKey": "tls.TestBuildNameToCertificate_doesntModifyCertificates",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBuildNameToCertificate_doesntModifyCertificates(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBuildNameToCertificate_doesntModifyCertificates(t *testing.T)\n```\n\nIssue 28744: Ensure that we don't modify memory that Config doesn't own such as Certificates. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#testingKey",
              "documentation": {
                "identifier": "testingKey",
                "newPage": false,
                "searchKey": "tls.testingKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testingKey(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testingKey(s string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestClientHelloInfo_SupportsCertificate",
              "documentation": {
                "identifier": "TestClientHelloInfo_SupportsCertificate",
                "newPage": false,
                "searchKey": "tls.TestClientHelloInfo_SupportsCertificate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestClientHelloInfo_SupportsCertificate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestClientHelloInfo_SupportsCertificate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestCipherSuites",
              "documentation": {
                "identifier": "TestCipherSuites",
                "newPage": false,
                "searchKey": "tls.TestCipherSuites",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCipherSuites(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCipherSuites(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#http2isBadCipher",
              "documentation": {
                "identifier": "http2isBadCipher",
                "newPage": false,
                "searchKey": "tls.http2isBadCipher",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func http2isBadCipher(cipher uint16) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc http2isBadCipher(cipher uint16) bool\n```\n\nhttp2isBadCipher is copied from net/http. TODO: if it ends up exposed somewhere, use that instead. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/crypto/tls#TestPKCS1OnlyCert",
              "documentation": {
                "identifier": "TestPKCS1OnlyCert",
                "newPage": false,
                "searchKey": "tls.TestPKCS1OnlyCert",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPKCS1OnlyCert(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPKCS1OnlyCert(t *testing.T)\n```\n\nTestPKCS1OnlyCert uses a client certificate with a broken crypto.Signer that always makes PKCS #1 v1.5 signatures, so can't be used with RSA-PSS. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
