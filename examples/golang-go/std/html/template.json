{
  "pathID": "/std/html/template",
  "documentation": {
    "identifier": "template",
    "newPage": true,
    "searchKey": "std/html/template",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package template"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package template (html/template) implements data-driven templates for generating HTML output safe against code injection. It provides the same interface as package text/template and should be used instead of text/template whenever the output is HTML. \n\nThe documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for text/template. \n\n### hdr-IntroductionIntroduction\nThis package wraps package text/template so you can share its template API to parse and execute HTML templates safely. \n\n```\ntmpl, err := template.New(\"name\").Parse(...)\n// Error checking elided\nerr = tmpl.Execute(out, data)\n\n```\nIf successful, tmpl will now be injection-safe. Otherwise, err is an error defined in the docs for ErrorCode. \n\nHTML templates treat data values as plain text which should be encoded so they can be safely embedded in an HTML document. The escaping is contextual, so actions can appear within JavaScript, CSS, and URI contexts. \n\nThe security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below. \n\nExample \n\n```\nimport \"text/template\"\n...\nt, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\nerr = t.ExecuteTemplate(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n\n```\nproduces \n\n```\nHello, <script>alert('you have been pwned')</script>!\n\n```\nbut the contextual autoescaping in html/template \n\n```\nimport \"html/template\"\n...\nt, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\nerr = t.ExecuteTemplate(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n\n```\nproduces safe, escaped HTML output \n\n```\nHello, &lt;script&gt;alert(&#39;you have been pwned&#39;)&lt;/script&gt;!\n\n```\n### hdr-ContextsContexts\nThis package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt \n\n```\n<a href=\"/search?q={{.}}\">{{.}}</a>\n\n```\nAt parse time each {{.}} is overwritten to add escaping functions as necessary. In this case it becomes \n\n```\n<a href=\"/search?q={{. | urlescaper | attrescaper}}\">{{. | htmlescaper}}</a>\n\n```\nwhere urlescaper, attrescaper, and htmlescaper are aliases for internal escaping functions. \n\nFor these internal escaping functions, if an action pipeline evaluates to a nil interface value, it is treated as though it were an empty string. \n\n### hdr-Namespaced_and_data__attributesNamespaced and data- attributes\nAttributes with a namespace are treated as if they had no namespace. Given the excerpt \n\n```\n<a my:href=\"{{.}}\"></a>\n\n```\nAt parse time the attribute will be treated as if it were just \"href\". So at parse time the template becomes: \n\n```\n<a my:href=\"{{. | urlescaper | attrescaper}}\"></a>\n\n```\nSimilarly to attributes with namespaces, attributes with a \"data-\" prefix are treated as if they had no \"data-\" prefix. So given \n\n```\n<a data-href=\"{{.}}\"></a>\n\n```\nAt parse time this becomes \n\n```\n<a data-href=\"{{. | urlescaper | attrescaper}}\"></a>\n\n```\nIf an attribute has both a namespace and a \"data-\" prefix, only the namespace will be removed when determining the context. For example \n\n```\n<a my:data-href=\"{{.}}\"></a>\n\n```\nThis is handled as if \"my:data-href\" was just \"data-href\" and not \"href\" as it would be if the \"data-\" prefix were to be ignored too. Thus at parse time this becomes just \n\n```\n<a my:data-href=\"{{. | attrescaper}}\"></a>\n\n```\nAs a special case, attributes with the namespace \"xmlns\" are always treated as containing URLs. Given the excerpts \n\n```\n<a xmlns:title=\"{{.}}\"></a>\n<a xmlns:href=\"{{.}}\"></a>\n<a xmlns:onclick=\"{{.}}\"></a>\n\n```\nAt parse time they become: \n\n```\n<a xmlns:title=\"{{. | urlescaper | attrescaper}}\"></a>\n<a xmlns:href=\"{{. | urlescaper | attrescaper}}\"></a>\n<a xmlns:onclick=\"{{. | urlescaper | attrescaper}}\"></a>\n\n```\n### hdr-ErrorsErrors\nSee the documentation of ErrorCode for details. \n\n### hdr-A_fuller_pictureA fuller picture\nThe rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details. \n\n### hdr-ContextsContexts\nAssuming {{.}} is `O'Reilly: How are <i>you</i>?`, the table below shows how {{.}} appears when used in the context to the left. \n\n```\nContext                          {{.}} After\n{{.}}                            O'Reilly: How are &lt;i&gt;you&lt;/i&gt;?\n<a title='{{.}}'>                O&#39;Reilly: How are you?\n<a href=\"/{{.}}\">                O&#39;Reilly: How are %3ci%3eyou%3c/i%3e?\n<a href=\"?q={{.}}\">              O&#39;Reilly%3a%20How%20are%3ci%3e...%3f\n<a onx='f(\"{{.}}\")'>             O\\x27Reilly: How are \\x3ci\\x3eyou...?\n<a onx='f({{.}})'>               \"O\\x27Reilly: How are \\x3ci\\x3eyou...?\"\n<a onx='pattern = /{{.}}/;'>     O\\x27Reilly: How are \\x3ci\\x3eyou...\\x3f\n\n```\nIf used in an unsafe context, then the value might be filtered out: \n\n```\nContext                          {{.}} After\n<a href=\"{{.}}\">                 #ZgotmplZ\n\n```\nsince \"O'Reilly:\" is not an allowed protocol like \"http:\". \n\nIf {{.}} is the innocuous word, `left`, then it can appear more widely, \n\n```\nContext                              {{.}} After\n{{.}}                                left\n<a title='{{.}}'>                    left\n<a href='{{.}}'>                     left\n<a href='/{{.}}'>                    left\n<a href='?dir={{.}}'>                left\n<a style=\"border-{{.}}: 4px\">        left\n<a style=\"align: {{.}}\">             left\n<a style=\"background: '{{.}}'>       left\n<a style=\"background: url('{{.}}')>  left\n<style>p.{{.}} {color:red}</style>   left\n\n```\nNon-string values can be used in JavaScript contexts. If {{.}} is \n\n```\nstruct{A,B string}{ \"foo\", \"bar\" }\n\n```\nin the escaped template \n\n```\n<script>var pair = {{.}};</script>\n\n```\nthen the template output is \n\n```\n<script>var pair = {\"A\": \"foo\", \"B\": \"bar\"};</script>\n\n```\nSee package json to understand how non-string content is marshaled for embedding in JavaScript contexts. \n\n### hdr-Typed_StringsTyped Strings\nBy default, this package assumes that all pipelines produce a plain text string. It adds escaping pipeline stages necessary to correctly and safely embed that plain text string in the appropriate context. \n\nWhen a data value is not plain text, you can make sure it is not over-escaped by marking it with its type. \n\nTypes HTML, JS, URL, and others from content.go can carry safe content that is exempted from escaping. \n\nThe template \n\n```\nHello, {{.}}!\n\n```\ncan be invoked with \n\n```\ntmpl.Execute(out, template.HTML(`<b>World</b>`))\n\n```\nto produce \n\n```\nHello, <b>World</b>!\n\n```\ninstead of the \n\n```\nHello, &lt;b&gt;World&lt;b&gt;!\n\n```\nthat would have been produced if {{.}} was a regular string. \n\n### hdr-Security_ModelSecurity Model\n[https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition](https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition) defines \"safe\" as used by this package. \n\nThis package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data: \n\nStructure Preservation Property: \"... when a template author writes an HTML tag in a safe templating language, the browser will interpret the corresponding portion of the output as a tag regardless of the values of untrusted data, and similarly for other structures such as attribute boundaries and JS and CSS string boundaries.\" \n\nCode Effect Property: \"... only code specified by the template author should run as a result of injecting the template output into a page and all code specified by the template author should run as a result of the same.\" \n\nLeast Surprise Property: \"A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who knows that contextual autoescaping happens should be able to look at a {{.}} and correctly infer what sanitization happens.\" \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/std/html/template#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/html/template#_attr_name",
              "documentation": {
                "identifier": "_attr_name",
                "newPage": false,
                "searchKey": "template._attr_name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _attr_name"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _attr_name = \"attrNoneattrScriptattrScriptTypeattrStyleattrURLattrSrcset\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#contentTypePlain",
              "documentation": {
                "identifier": "contentTypePlain",
                "newPage": false,
                "searchKey": "template.contentTypePlain",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const contentTypePlain"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst contentTypePlain contentType = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#contentTypeCSS",
              "documentation": {
                "identifier": "contentTypeCSS",
                "newPage": false,
                "searchKey": "template.contentTypeCSS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const contentTypeCSS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst contentTypeCSS\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#contentTypeHTML",
              "documentation": {
                "identifier": "contentTypeHTML",
                "newPage": false,
                "searchKey": "template.contentTypeHTML",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const contentTypeHTML"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst contentTypeHTML\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#contentTypeHTMLAttr",
              "documentation": {
                "identifier": "contentTypeHTMLAttr",
                "newPage": false,
                "searchKey": "template.contentTypeHTMLAttr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const contentTypeHTMLAttr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst contentTypeHTMLAttr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#contentTypeJS",
              "documentation": {
                "identifier": "contentTypeJS",
                "newPage": false,
                "searchKey": "template.contentTypeJS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const contentTypeJS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst contentTypeJS\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#contentTypeJSStr",
              "documentation": {
                "identifier": "contentTypeJSStr",
                "newPage": false,
                "searchKey": "template.contentTypeJSStr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const contentTypeJSStr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst contentTypeJSStr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#contentTypeURL",
              "documentation": {
                "identifier": "contentTypeURL",
                "newPage": false,
                "searchKey": "template.contentTypeURL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const contentTypeURL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst contentTypeURL\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#contentTypeSrcset",
              "documentation": {
                "identifier": "contentTypeSrcset",
                "newPage": false,
                "searchKey": "template.contentTypeSrcset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const contentTypeSrcset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst contentTypeSrcset\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#contentTypeUnsafe",
              "documentation": {
                "identifier": "contentTypeUnsafe",
                "newPage": false,
                "searchKey": "template.contentTypeUnsafe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const contentTypeUnsafe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst contentTypeUnsafe\n```\n\ncontentTypeUnsafe is used in attr.go for values that affect how embedded content and network messages are formed, vetted, or interpreted; or which credentials network messages carry. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateText",
              "documentation": {
                "identifier": "stateText",
                "newPage": false,
                "searchKey": "template.stateText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateText state = iota\n```\n\nstateText is parsed character data. An HTML parser is in this state when its parse position is outside an HTML tag, directive, comment, and special element body. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateTag",
              "documentation": {
                "identifier": "stateTag",
                "newPage": false,
                "searchKey": "template.stateTag",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateTag"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateTag\n```\n\nstateTag occurs before an HTML attribute or the end of a tag. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateAttrName",
              "documentation": {
                "identifier": "stateAttrName",
                "newPage": false,
                "searchKey": "template.stateAttrName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateAttrName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateAttrName\n```\n\nstateAttrName occurs inside an attribute name. It occurs between the ^'s in ` ^name^ = value`. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateAfterName",
              "documentation": {
                "identifier": "stateAfterName",
                "newPage": false,
                "searchKey": "template.stateAfterName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateAfterName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateAfterName\n```\n\nstateAfterName occurs after an attr name has ended but before any equals sign. It occurs between the ^'s in ` name^ ^= value`. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateBeforeValue",
              "documentation": {
                "identifier": "stateBeforeValue",
                "newPage": false,
                "searchKey": "template.stateBeforeValue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateBeforeValue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateBeforeValue\n```\n\nstateBeforeValue occurs after the equals sign but before the value. It occurs between the ^'s in ` name =^ ^value`. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateHTMLCmt",
              "documentation": {
                "identifier": "stateHTMLCmt",
                "newPage": false,
                "searchKey": "template.stateHTMLCmt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateHTMLCmt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateHTMLCmt\n```\n\nstateHTMLCmt occurs inside an <!-- HTML comment -->. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateRCDATA",
              "documentation": {
                "identifier": "stateRCDATA",
                "newPage": false,
                "searchKey": "template.stateRCDATA",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateRCDATA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateRCDATA\n```\n\nstateRCDATA occurs inside an RCDATA element (<textarea> or <title>) as described at [https://www.w3.org/TR/html5/syntax.html#elements-0](https://www.w3.org/TR/html5/syntax.html#elements-0) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateAttr",
              "documentation": {
                "identifier": "stateAttr",
                "newPage": false,
                "searchKey": "template.stateAttr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateAttr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateAttr\n```\n\nstateAttr occurs inside an HTML attribute whose content is text. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateURL",
              "documentation": {
                "identifier": "stateURL",
                "newPage": false,
                "searchKey": "template.stateURL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateURL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateURL\n```\n\nstateURL occurs inside an HTML attribute whose content is a URL. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateSrcset",
              "documentation": {
                "identifier": "stateSrcset",
                "newPage": false,
                "searchKey": "template.stateSrcset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateSrcset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateSrcset\n```\n\nstateSrcset occurs inside an HTML srcset attribute. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateJS",
              "documentation": {
                "identifier": "stateJS",
                "newPage": false,
                "searchKey": "template.stateJS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateJS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateJS\n```\n\nstateJS occurs inside an event handler or script element. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateJSDqStr",
              "documentation": {
                "identifier": "stateJSDqStr",
                "newPage": false,
                "searchKey": "template.stateJSDqStr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateJSDqStr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateJSDqStr\n```\n\nstateJSDqStr occurs inside a JavaScript double quoted string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateJSSqStr",
              "documentation": {
                "identifier": "stateJSSqStr",
                "newPage": false,
                "searchKey": "template.stateJSSqStr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateJSSqStr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateJSSqStr\n```\n\nstateJSSqStr occurs inside a JavaScript single quoted string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateJSRegexp",
              "documentation": {
                "identifier": "stateJSRegexp",
                "newPage": false,
                "searchKey": "template.stateJSRegexp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateJSRegexp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateJSRegexp\n```\n\nstateJSRegexp occurs inside a JavaScript regexp literal. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateJSBlockCmt",
              "documentation": {
                "identifier": "stateJSBlockCmt",
                "newPage": false,
                "searchKey": "template.stateJSBlockCmt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateJSBlockCmt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateJSBlockCmt\n```\n\nstateJSBlockCmt occurs inside a JavaScript /* block comment */. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateJSLineCmt",
              "documentation": {
                "identifier": "stateJSLineCmt",
                "newPage": false,
                "searchKey": "template.stateJSLineCmt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateJSLineCmt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateJSLineCmt\n```\n\nstateJSLineCmt occurs inside a JavaScript // line comment. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateCSS",
              "documentation": {
                "identifier": "stateCSS",
                "newPage": false,
                "searchKey": "template.stateCSS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateCSS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateCSS\n```\n\nstateCSS occurs inside a <style> element or style attribute. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateCSSDqStr",
              "documentation": {
                "identifier": "stateCSSDqStr",
                "newPage": false,
                "searchKey": "template.stateCSSDqStr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateCSSDqStr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateCSSDqStr\n```\n\nstateCSSDqStr occurs inside a CSS double quoted string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateCSSSqStr",
              "documentation": {
                "identifier": "stateCSSSqStr",
                "newPage": false,
                "searchKey": "template.stateCSSSqStr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateCSSSqStr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateCSSSqStr\n```\n\nstateCSSSqStr occurs inside a CSS single quoted string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateCSSDqURL",
              "documentation": {
                "identifier": "stateCSSDqURL",
                "newPage": false,
                "searchKey": "template.stateCSSDqURL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateCSSDqURL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateCSSDqURL\n```\n\nstateCSSDqURL occurs inside a CSS double quoted url(\"...\"). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateCSSSqURL",
              "documentation": {
                "identifier": "stateCSSSqURL",
                "newPage": false,
                "searchKey": "template.stateCSSSqURL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateCSSSqURL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateCSSSqURL\n```\n\nstateCSSSqURL occurs inside a CSS single quoted url('...'). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateCSSURL",
              "documentation": {
                "identifier": "stateCSSURL",
                "newPage": false,
                "searchKey": "template.stateCSSURL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateCSSURL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateCSSURL\n```\n\nstateCSSURL occurs inside a CSS unquoted url(...). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateCSSBlockCmt",
              "documentation": {
                "identifier": "stateCSSBlockCmt",
                "newPage": false,
                "searchKey": "template.stateCSSBlockCmt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateCSSBlockCmt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateCSSBlockCmt\n```\n\nstateCSSBlockCmt occurs inside a CSS /* block comment */. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateCSSLineCmt",
              "documentation": {
                "identifier": "stateCSSLineCmt",
                "newPage": false,
                "searchKey": "template.stateCSSLineCmt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateCSSLineCmt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateCSSLineCmt\n```\n\nstateCSSLineCmt occurs inside a CSS // line comment. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stateError",
              "documentation": {
                "identifier": "stateError",
                "newPage": false,
                "searchKey": "template.stateError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stateError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stateError\n```\n\nstateError is an infectious error state outside any valid HTML/CSS/JS construct. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#delimNone",
              "documentation": {
                "identifier": "delimNone",
                "newPage": false,
                "searchKey": "template.delimNone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const delimNone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst delimNone delim = iota\n```\n\ndelimNone occurs outside any attribute. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#delimDoubleQuote",
              "documentation": {
                "identifier": "delimDoubleQuote",
                "newPage": false,
                "searchKey": "template.delimDoubleQuote",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const delimDoubleQuote"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst delimDoubleQuote\n```\n\ndelimDoubleQuote occurs when a double quote (\") closes the attribute. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#delimSingleQuote",
              "documentation": {
                "identifier": "delimSingleQuote",
                "newPage": false,
                "searchKey": "template.delimSingleQuote",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const delimSingleQuote"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst delimSingleQuote\n```\n\ndelimSingleQuote occurs when a single quote (') closes the attribute. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#delimSpaceOrTagEnd",
              "documentation": {
                "identifier": "delimSpaceOrTagEnd",
                "newPage": false,
                "searchKey": "template.delimSpaceOrTagEnd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const delimSpaceOrTagEnd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst delimSpaceOrTagEnd\n```\n\ndelimSpaceOrTagEnd occurs when a space or right angle bracket (>) closes the attribute. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#urlPartNone",
              "documentation": {
                "identifier": "urlPartNone",
                "newPage": false,
                "searchKey": "template.urlPartNone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const urlPartNone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst urlPartNone urlPart = iota\n```\n\nurlPartNone occurs when not in a URL, or possibly at the start: ^ in \"^[http://auth/path?k=v#frag](http://auth/path?k=v#frag)\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#urlPartPreQuery",
              "documentation": {
                "identifier": "urlPartPreQuery",
                "newPage": false,
                "searchKey": "template.urlPartPreQuery",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const urlPartPreQuery"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst urlPartPreQuery\n```\n\nurlPartPreQuery occurs in the scheme, authority, or path; between the ^s in \"h^ttp://auth/path^?k=v#frag\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#urlPartQueryOrFrag",
              "documentation": {
                "identifier": "urlPartQueryOrFrag",
                "newPage": false,
                "searchKey": "template.urlPartQueryOrFrag",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const urlPartQueryOrFrag"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst urlPartQueryOrFrag\n```\n\nurlPartQueryOrFrag occurs in the query portion between the ^s in \"[http://auth/path?](http://auth/path?)^k=v#frag^\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#urlPartUnknown",
              "documentation": {
                "identifier": "urlPartUnknown",
                "newPage": false,
                "searchKey": "template.urlPartUnknown",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const urlPartUnknown"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst urlPartUnknown\n```\n\nurlPartUnknown occurs due to joining of contexts both before and after the query separator. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#jsCtxRegexp",
              "documentation": {
                "identifier": "jsCtxRegexp",
                "newPage": false,
                "searchKey": "template.jsCtxRegexp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const jsCtxRegexp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst jsCtxRegexp jsCtx = iota\n```\n\njsCtxRegexp occurs where a '/' would start a regexp literal. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#jsCtxDivOp",
              "documentation": {
                "identifier": "jsCtxDivOp",
                "newPage": false,
                "searchKey": "template.jsCtxDivOp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const jsCtxDivOp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst jsCtxDivOp\n```\n\njsCtxDivOp occurs where a '/' would start a division operator. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#jsCtxUnknown",
              "documentation": {
                "identifier": "jsCtxUnknown",
                "newPage": false,
                "searchKey": "template.jsCtxUnknown",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const jsCtxUnknown"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst jsCtxUnknown\n```\n\njsCtxUnknown occurs where a '/' is ambiguous due to context joining. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#elementNone",
              "documentation": {
                "identifier": "elementNone",
                "newPage": false,
                "searchKey": "template.elementNone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const elementNone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst elementNone element = iota\n```\n\nelementNone occurs outside a special tag or special element body. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#elementScript",
              "documentation": {
                "identifier": "elementScript",
                "newPage": false,
                "searchKey": "template.elementScript",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const elementScript"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst elementScript\n```\n\nelementScript corresponds to the raw text <script> element with JS MIME type or no type attribute. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#elementStyle",
              "documentation": {
                "identifier": "elementStyle",
                "newPage": false,
                "searchKey": "template.elementStyle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const elementStyle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst elementStyle\n```\n\nelementStyle corresponds to the raw text <style> element. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#elementTextarea",
              "documentation": {
                "identifier": "elementTextarea",
                "newPage": false,
                "searchKey": "template.elementTextarea",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const elementTextarea"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst elementTextarea\n```\n\nelementTextarea corresponds to the RCDATA <textarea> element. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#elementTitle",
              "documentation": {
                "identifier": "elementTitle",
                "newPage": false,
                "searchKey": "template.elementTitle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const elementTitle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst elementTitle\n```\n\nelementTitle corresponds to the RCDATA <title> element. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#attrNone",
              "documentation": {
                "identifier": "attrNone",
                "newPage": false,
                "searchKey": "template.attrNone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const attrNone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst attrNone attr = iota\n```\n\nattrNone corresponds to a normal attribute or no attribute. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#attrScript",
              "documentation": {
                "identifier": "attrScript",
                "newPage": false,
                "searchKey": "template.attrScript",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const attrScript"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst attrScript\n```\n\nattrScript corresponds to an event handler attribute. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#attrScriptType",
              "documentation": {
                "identifier": "attrScriptType",
                "newPage": false,
                "searchKey": "template.attrScriptType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const attrScriptType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst attrScriptType\n```\n\nattrScriptType corresponds to the type attribute in script HTML element \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#attrStyle",
              "documentation": {
                "identifier": "attrStyle",
                "newPage": false,
                "searchKey": "template.attrStyle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const attrStyle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst attrStyle\n```\n\nattrStyle corresponds to the style attribute whose value is CSS. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#attrURL",
              "documentation": {
                "identifier": "attrURL",
                "newPage": false,
                "searchKey": "template.attrURL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const attrURL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst attrURL\n```\n\nattrURL corresponds to an attribute whose value is a URL. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#attrSrcset",
              "documentation": {
                "identifier": "attrSrcset",
                "newPage": false,
                "searchKey": "template.attrSrcset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const attrSrcset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst attrSrcset\n```\n\nattrSrcset corresponds to a srcset attribute. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#_delim_name",
              "documentation": {
                "identifier": "_delim_name",
                "newPage": false,
                "searchKey": "template._delim_name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _delim_name"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _delim_name = \"delimNonedelimDoubleQuotedelimSingleQuotedelimSpaceOrTagEnd\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#_element_name",
              "documentation": {
                "identifier": "_element_name",
                "newPage": false,
                "searchKey": "template._element_name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _element_name"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _element_name = \"elementNoneelementScriptelementStyleelementTextareaelementTitle\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#OK",
              "documentation": {
                "identifier": "OK",
                "newPage": false,
                "searchKey": "template.OK",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OK ErrorCode = iota\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nOK indicates the lack of an error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrAmbigContext",
              "documentation": {
                "identifier": "ErrAmbigContext",
                "newPage": false,
                "searchKey": "template.ErrAmbigContext",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrAmbigContext"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrAmbigContext\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nErrAmbigContext: \"... appears in an ambiguous context within a URL\" Example: \n\n```\n<a href=\"\n   {{if .C}}\n     /path/\n   {{else}}\n     /search?q=\n   {{end}}\n   {{.X}}\n\">\n\n```\nDiscussion: \n\n```\n {{.X}} is in an ambiguous URL context since, depending on {{.C}},\nit may be either a URL suffix or a query parameter.\n Moving {{.X}} into the condition removes the ambiguity:\n <a href=\"{{if .C}}/path/{{.X}}{{else}}/search?q={{.X}}\">\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrBadHTML",
              "documentation": {
                "identifier": "ErrBadHTML",
                "newPage": false,
                "searchKey": "template.ErrBadHTML",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrBadHTML"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrBadHTML\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nErrBadHTML: \"expected space, attr name, or end of tag, but got ...\", \n\n```\n\"... in unquoted attr\", \"... in attribute name\"\n\n```\nExample: \n\n```\n<a href = /search?q=foo>\n<href=foo>\n<form na<e=...>\n<option selected<\n\n```\nDiscussion: \n\n```\nThis is often due to a typo in an HTML element, but some runes\nare banned in tag names, attribute names, and unquoted attribute\nvalues because they can tickle parser ambiguities.\nQuoting all attributes is the best policy.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrBranchEnd",
              "documentation": {
                "identifier": "ErrBranchEnd",
                "newPage": false,
                "searchKey": "template.ErrBranchEnd",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrBranchEnd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrBranchEnd\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nErrBranchEnd: \"{{if}} branches end in different contexts\" Example: \n\n```\n{{if .C}}<a href=\"{{end}}{{.X}}\n\n```\nDiscussion: \n\n```\nPackage html/template statically examines each path through an\n{{if}}, {{range}}, or {{with}} to escape any following pipelines.\nThe example is ambiguous since {{.X}} might be an HTML text node,\nor a URL prefix in an HTML attribute. The context of {{.X}} is\nused to figure out how to escape it, but that context depends on\nthe run-time value of {{.C}} which is not statically known.\n\nThe problem is usually something like missing quotes or angle\nbrackets, or can be avoided by refactoring to put the two contexts\ninto different branches of an if, range or with. If the problem\nis in a {{range}} over a collection that should never be empty,\nadding a dummy {{else}} can help.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrEndContext",
              "documentation": {
                "identifier": "ErrEndContext",
                "newPage": false,
                "searchKey": "template.ErrEndContext",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrEndContext"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrEndContext\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nErrEndContext: \"... ends in a non-text context: ...\" Examples: \n\n```\n<div\n<div title=\"no close quote>\n<script>f()\n\n```\nDiscussion: \n\n```\nExecuted templates should produce a DocumentFragment of HTML.\nTemplates that end without closing tags will trigger this error.\nTemplates that should not be used in an HTML context or that\nproduce incomplete Fragments should not be executed directly.\n\n{{define \"main\"}} <script>{{template \"helper\"}}</script> {{end}}\n{{define \"helper\"}} document.write(' <div title=\" ') {{end}}\n\n\"helper\" does not produce a valid document fragment, so should\nnot be Executed directly.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrNoSuchTemplate",
              "documentation": {
                "identifier": "ErrNoSuchTemplate",
                "newPage": false,
                "searchKey": "template.ErrNoSuchTemplate",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrNoSuchTemplate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrNoSuchTemplate\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nErrNoSuchTemplate: \"no such template ...\" Examples: \n\n```\n{{define \"main\"}}<div {{template \"attrs\"}}>{{end}}\n{{define \"attrs\"}}href=\"{{.URL}}\"{{end}}\n\n```\nDiscussion: \n\n```\nPackage html/template looks through template calls to compute the\ncontext.\nHere the {{.URL}} in \"attrs\" must be treated as a URL when called\nfrom \"main\", but you will get this error if \"attrs\" is not defined\nwhen \"main\" is parsed.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrOutputContext",
              "documentation": {
                "identifier": "ErrOutputContext",
                "newPage": false,
                "searchKey": "template.ErrOutputContext",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrOutputContext"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrOutputContext\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nErrOutputContext: \"cannot compute output context for template ...\" Examples: \n\n```\n{{define \"t\"}}{{if .T}}{{template \"t\" .T}}{{end}}{{.H}}\",{{end}}\n\n```\nDiscussion: \n\n```\nA recursive template does not end in the same context in which it\nstarts, and a reliable output context cannot be computed.\nLook for typos in the named template.\nIf the template should not be called in the named start context,\nlook for calls to that template in unexpected contexts.\nMaybe refactor recursive templates to not be recursive.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrPartialCharset",
              "documentation": {
                "identifier": "ErrPartialCharset",
                "newPage": false,
                "searchKey": "template.ErrPartialCharset",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrPartialCharset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrPartialCharset\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nErrPartialCharset: \"unfinished JS regexp charset in ...\" Example: \n\n```\n<script>var pattern = /foo[{{.Chars}}]/</script>\n\n```\nDiscussion: \n\n```\nPackage html/template does not support interpolation into regular\nexpression literal character sets.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrPartialEscape",
              "documentation": {
                "identifier": "ErrPartialEscape",
                "newPage": false,
                "searchKey": "template.ErrPartialEscape",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrPartialEscape"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrPartialEscape\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nErrPartialEscape: \"unfinished escape sequence in ...\" Example: \n\n```\n<script>alert(\"\\{{.X}}\")</script>\n\n```\nDiscussion: \n\n```\nPackage html/template does not support actions following a\nbackslash.\nThis is usually an error and there are better solutions; for\nexample\n  <script>alert(\"{{.X}}\")</script>\nshould work, and if {{.X}} is a partial escape sequence such as\n\"xA0\", mark the whole sequence as safe content: JSStr(`\\xA0`)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrRangeLoopReentry",
              "documentation": {
                "identifier": "ErrRangeLoopReentry",
                "newPage": false,
                "searchKey": "template.ErrRangeLoopReentry",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrRangeLoopReentry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrRangeLoopReentry\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nErrRangeLoopReentry: \"on range loop re-entry: ...\" Example: \n\n```\n<script>var x = [{{range .}}'{{.}},{{end}}]</script>\n\n```\nDiscussion: \n\n```\nIf an iteration through a range would cause it to end in a\ndifferent context than an earlier pass, there is no single context.\nIn the example, there is missing a quote, so it is not clear\nwhether {{.}} is meant to be inside a JS string or in a JS value\ncontext. The second iteration would produce something like\n\n  <script>var x = ['firstValue,'secondValue]</script>\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrSlashAmbig",
              "documentation": {
                "identifier": "ErrSlashAmbig",
                "newPage": false,
                "searchKey": "template.ErrSlashAmbig",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrSlashAmbig"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrSlashAmbig\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nErrSlashAmbig: '/' could start a division or regexp. Example: \n\n```\n<script>\n  {{if .C}}var x = 1{{end}}\n  /-{{.N}}/i.test(x) ? doThis : doThat();\n</script>\n\n```\nDiscussion: \n\n```\nThe example above could produce `var x = 1/-2/i.test(s)...`\nin which the first '/' is a mathematical division operator or it\ncould produce `/-2/i.test(s)` in which the first '/' starts a\nregexp literal.\nLook for missing semicolons inside branches, and maybe add\nparentheses to make it clear which interpretation you intend.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrPredefinedEscaper",
              "documentation": {
                "identifier": "ErrPredefinedEscaper",
                "newPage": false,
                "searchKey": "template.ErrPredefinedEscaper",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrPredefinedEscaper"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrPredefinedEscaper\n```\n\nWe define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. \n\nOutput: \"ZgotmplZ\" Example: \n\n```\n<img src=\"{{.X}}\">\nwhere {{.X}} evaluates to `javascript:...`\n\n```\nDiscussion: \n\n```\n\"ZgotmplZ\" is a special value that indicates that unsafe content reached a\nCSS or URL context at runtime. The output of the example will be\n  <img src=\"#ZgotmplZ\">\nIf the data comes from a trusted source, use content types to exempt it\nfrom filtering: URL(`javascript:...`).\n\n```\nErrPredefinedEscaper: \"predefined escaper ... disallowed in template\" Example: \n\n```\n<div class={{. | html}}>Hello<div>\n\n```\nDiscussion: \n\n```\nPackage html/template already contextually escapes all pipelines to\nproduce HTML output safe against code injection. Manually escaping\npipeline output using the predefined escapers \"html\" or \"urlquery\" is\nunnecessary, and may affect the correctness or safety of the escaped\npipeline output in Go 1.8 and earlier.\n\nIn most cases, such as the given example, this error can be resolved by\nsimply removing the predefined escaper from the pipeline and letting the\ncontextual autoescaper handle the escaping of the pipeline. In other\ninstances, where the predefined escaper occurs in the middle of a\npipeline where subsequent commands expect escaped input, e.g.\n  {{.X | html | makeALink}}\nwhere makeALink does\n  return `<a href=\"`+input+`\">link</a>`\nconsider refactoring the surrounding template to make use of the\ncontextual autoescaper, i.e.\n  <a href=\"{{.X}}\">link</a>\n\nTo ease migration to Go 1.9 and beyond, \"html\" and \"urlquery\" will\ncontinue to be allowed as the last command in a pipeline. However, if the\npipeline occurs in an unquoted attribute value context, \"html\" is\ndisallowed. Avoid using \"html\" and \"urlquery\" entirely in new templates.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#filterFailsafe",
              "documentation": {
                "identifier": "filterFailsafe",
                "newPage": false,
                "searchKey": "template.filterFailsafe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const filterFailsafe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst filterFailsafe = \"ZgotmplZ\"\n```\n\nfilterFailsafe is an innocuous word that is emitted in place of unsafe values by sanitizer functions. It is not a keyword in any programming language, contains no special characters, is not empty, and when it appears in output it is distinct enough that a developer can find the source of the problem via a search engine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#_jsCtx_name",
              "documentation": {
                "identifier": "_jsCtx_name",
                "newPage": false,
                "searchKey": "template._jsCtx_name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _jsCtx_name"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _jsCtx_name = \"jsCtxRegexpjsCtxDivOpjsCtxUnknown\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#_state_name",
              "documentation": {
                "identifier": "_state_name",
                "newPage": false,
                "searchKey": "template._state_name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _state_name"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _state_name = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#htmlSpaceAndASCIIAlnumBytes",
              "documentation": {
                "identifier": "htmlSpaceAndASCIIAlnumBytes",
                "newPage": false,
                "searchKey": "template.htmlSpaceAndASCIIAlnumBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const htmlSpaceAndASCIIAlnumBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst htmlSpaceAndASCIIAlnumBytes = ...\n```\n\nDerived from [https://play.golang.org/p/Dhmj7FORT5](https://play.golang.org/p/Dhmj7FORT5) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#_urlPart_name",
              "documentation": {
                "identifier": "_urlPart_name",
                "newPage": false,
                "searchKey": "template._urlPart_name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _urlPart_name"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _urlPart_name = \"urlPartNoneurlPartPreQueryurlPartQueryOrFragurlPartUnknown\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#execErrorText",
              "documentation": {
                "identifier": "execErrorText",
                "newPage": false,
                "searchKey": "template.execErrorText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const execErrorText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst execErrorText = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#treeTemplate",
              "documentation": {
                "identifier": "treeTemplate",
                "newPage": false,
                "searchKey": "template.treeTemplate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const treeTemplate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst treeTemplate = ...\n```\n\nUse different delimiters to test Set.Delims. Also test the trimming of leading and trailing spaces. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#testTemplates",
              "documentation": {
                "identifier": "testTemplates",
                "newPage": false,
                "searchKey": "template.testTemplates",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const testTemplates"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst testTemplates = `{{define \"one\"}}one{{end}}{{define \"two\"}}two{{end}}`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#alwaysErrorText",
              "documentation": {
                "identifier": "alwaysErrorText",
                "newPage": false,
                "searchKey": "template.alwaysErrorText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const alwaysErrorText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst alwaysErrorText = \"always be failing\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#raceText",
              "documentation": {
                "identifier": "raceText",
                "newPage": false,
                "searchKey": "template.raceText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const raceText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst raceText = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#multiText1",
              "documentation": {
                "identifier": "multiText1",
                "newPage": false,
                "searchKey": "template.multiText1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const multiText1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst multiText1 = `\n\t{{define \"x\"}}TEXT{{end}}\n\t{{define \"dotV\"}}{{.V}}{{end}}\n`\n```\n\nThese strings are also in testdata/*. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#multiText2",
              "documentation": {
                "identifier": "multiText2",
                "newPage": false,
                "searchKey": "template.multiText2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const multiText2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst multiText2 = `\n\t{{define \"dot\"}}{{.}}{{end}}\n\t{{define \"nested\"}}{{template \"dot\" .}}{{end}}\n`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#cloneText1",
              "documentation": {
                "identifier": "cloneText1",
                "newPage": false,
                "searchKey": "template.cloneText1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cloneText1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cloneText1 = `{{define \"a\"}}{{template \"b\"}}{{template \"c\"}}{{end}}`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#cloneText2",
              "documentation": {
                "identifier": "cloneText2",
                "newPage": false,
                "searchKey": "template.cloneText2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cloneText2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cloneText2 = `{{define \"b\"}}b{{end}}`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#cloneText3",
              "documentation": {
                "identifier": "cloneText3",
                "newPage": false,
                "searchKey": "template.cloneText3",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cloneText3"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cloneText3 = `{{define \"c\"}}root{{end}}`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#cloneText4",
              "documentation": {
                "identifier": "cloneText4",
                "newPage": false,
                "searchKey": "template.cloneText4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cloneText4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cloneText4 = `{{define \"c\"}}clone{{end}}`\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/html/template#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/html/template#attrTypeMap",
              "documentation": {
                "identifier": "attrTypeMap",
                "newPage": false,
                "searchKey": "template.attrTypeMap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var attrTypeMap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar attrTypeMap = ...\n```\n\nattrTypeMap[n] describes the value of the given attribute. If an attribute affects (or can mask) the encoding or interpretation of other content, or affects the contents, idempotency, or credentials of a network message, then the value in this map is contentTypeUnsafe. This map is derived from HTML5, specifically [https://www.w3.org/TR/html5/Overview.html#attributes-1](https://www.w3.org/TR/html5/Overview.html#attributes-1) as well as \"%URI\"-typed attributes from [https://www.w3.org/TR/html4/index/attributes.html](https://www.w3.org/TR/html4/index/attributes.html) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#_attr_index",
              "documentation": {
                "identifier": "_attr_index",
                "newPage": false,
                "searchKey": "template._attr_index",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _attr_index"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _attr_index = [...]uint8{0, 8, 18, 32, 41, 48, 58}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#errorType",
              "documentation": {
                "identifier": "errorType",
                "newPage": false,
                "searchKey": "template.errorType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errorType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errorType = reflect.TypeOf((*error)(nil)).Elem()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#fmtStringerType",
              "documentation": {
                "identifier": "fmtStringerType",
                "newPage": false,
                "searchKey": "template.fmtStringerType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fmtStringerType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fmtStringerType = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#cssReplacementTable",
              "documentation": {
                "identifier": "cssReplacementTable",
                "newPage": false,
                "searchKey": "template.cssReplacementTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cssReplacementTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cssReplacementTable = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#expressionBytes",
              "documentation": {
                "identifier": "expressionBytes",
                "newPage": false,
                "searchKey": "template.expressionBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var expressionBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar expressionBytes = []byte(\"expression\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#mozBindingBytes",
              "documentation": {
                "identifier": "mozBindingBytes",
                "newPage": false,
                "searchKey": "template.mozBindingBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mozBindingBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mozBindingBytes = []byte(\"mozbinding\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#_delim_index",
              "documentation": {
                "identifier": "_delim_index",
                "newPage": false,
                "searchKey": "template._delim_index",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _delim_index"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _delim_index = [...]uint8{0, 9, 25, 41, 59}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#_element_index",
              "documentation": {
                "identifier": "_element_index",
                "newPage": false,
                "searchKey": "template._element_index",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _element_index"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _element_index = [...]uint8{0, 11, 24, 36, 51, 63}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#funcMap",
              "documentation": {
                "identifier": "funcMap",
                "newPage": false,
                "searchKey": "template.funcMap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var funcMap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar funcMap = ...\n```\n\nfuncMap maps command names to functions that render their inputs safe. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#predefinedEscapers",
              "documentation": {
                "identifier": "predefinedEscapers",
                "newPage": false,
                "searchKey": "template.predefinedEscapers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var predefinedEscapers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar predefinedEscapers = map[string]bool{\n\t\"html\":     true,\n\t\"urlquery\": true,\n}\n```\n\npredefinedEscapers contains template predefined escapers that are equivalent to some contextual escapers. Keep in sync with equivEscapers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#equivEscapers",
              "documentation": {
                "identifier": "equivEscapers",
                "newPage": false,
                "searchKey": "template.equivEscapers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var equivEscapers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar equivEscapers = ...\n```\n\nequivEscapers matches contextual escapers to equivalent predefined template escapers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#redundantFuncs",
              "documentation": {
                "identifier": "redundantFuncs",
                "newPage": false,
                "searchKey": "template.redundantFuncs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var redundantFuncs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar redundantFuncs = ...\n```\n\nredundantFuncs[a][b] implies that funcMap[b](funcMap[a](x)) == funcMap[a](x) for all x. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#delimEnds",
              "documentation": {
                "identifier": "delimEnds",
                "newPage": false,
                "searchKey": "template.delimEnds",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var delimEnds"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar delimEnds = ...\n```\n\ndelimEnds maps each delim to a string of characters that terminate it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#doctypeBytes",
              "documentation": {
                "identifier": "doctypeBytes",
                "newPage": false,
                "searchKey": "template.doctypeBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var doctypeBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar doctypeBytes = []byte(\"<!DOCTYPE\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#htmlReplacementTable",
              "documentation": {
                "identifier": "htmlReplacementTable",
                "newPage": false,
                "searchKey": "template.htmlReplacementTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var htmlReplacementTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar htmlReplacementTable = ...\n```\n\nhtmlReplacementTable contains the runes that need to be escaped inside a quoted attribute value or in a text node. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#htmlNormReplacementTable",
              "documentation": {
                "identifier": "htmlNormReplacementTable",
                "newPage": false,
                "searchKey": "template.htmlNormReplacementTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var htmlNormReplacementTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar htmlNormReplacementTable = ...\n```\n\nhtmlNormReplacementTable is like htmlReplacementTable but without '&' to avoid over-encoding existing entities. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#htmlNospaceReplacementTable",
              "documentation": {
                "identifier": "htmlNospaceReplacementTable",
                "newPage": false,
                "searchKey": "template.htmlNospaceReplacementTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var htmlNospaceReplacementTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar htmlNospaceReplacementTable = ...\n```\n\nhtmlNospaceReplacementTable contains the runes that need to be escaped inside an unquoted attribute value. The set of runes escaped is the union of the HTML specials and those determined by running the JS below in browsers: <div id=d></div> <script>(function () { var a = [], d = document.getElementById(\"d\"), i, c, s; for (i = 0; i < 0x10000; ++i) { \n\n```\nc = String.fromCharCode(i);\nd.innerHTML = \"<span title=\" + c + \"lt\" + c + \"></span>\"\ns = d.getElementsByTagName(\"SPAN\")[0];\nif (!s || s.title !== c + \"lt\" + c) { a.push(i.toString(16)); }\n\n```\n} document.write(a.join(\", \")); })()</script> \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#htmlNospaceNormReplacementTable",
              "documentation": {
                "identifier": "htmlNospaceNormReplacementTable",
                "newPage": false,
                "searchKey": "template.htmlNospaceNormReplacementTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var htmlNospaceNormReplacementTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar htmlNospaceNormReplacementTable = ...\n```\n\nhtmlNospaceNormReplacementTable is like htmlNospaceReplacementTable but without '&' to avoid over-encoding existing entities. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#regexpPrecederKeywords",
              "documentation": {
                "identifier": "regexpPrecederKeywords",
                "newPage": false,
                "searchKey": "template.regexpPrecederKeywords",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var regexpPrecederKeywords"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar regexpPrecederKeywords = ...\n```\n\nregexpPrecederKeywords is a set of reserved JS keywords that can precede a regular expression in JS source. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#jsonMarshalType",
              "documentation": {
                "identifier": "jsonMarshalType",
                "newPage": false,
                "searchKey": "template.jsonMarshalType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsonMarshalType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsonMarshalType = reflect.TypeOf((*json.Marshaler)(nil)).Elem()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#lowUnicodeReplacementTable",
              "documentation": {
                "identifier": "lowUnicodeReplacementTable",
                "newPage": false,
                "searchKey": "template.lowUnicodeReplacementTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lowUnicodeReplacementTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lowUnicodeReplacementTable = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#jsStrReplacementTable",
              "documentation": {
                "identifier": "jsStrReplacementTable",
                "newPage": false,
                "searchKey": "template.jsStrReplacementTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsStrReplacementTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsStrReplacementTable = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#jsStrNormReplacementTable",
              "documentation": {
                "identifier": "jsStrNormReplacementTable",
                "newPage": false,
                "searchKey": "template.jsStrNormReplacementTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsStrNormReplacementTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsStrNormReplacementTable = ...\n```\n\njsStrNormReplacementTable is like jsStrReplacementTable but does not overencode existing escapes since this table has no entry for `\\`. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#jsRegexpReplacementTable",
              "documentation": {
                "identifier": "jsRegexpReplacementTable",
                "newPage": false,
                "searchKey": "template.jsRegexpReplacementTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var jsRegexpReplacementTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar jsRegexpReplacementTable = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#_jsCtx_index",
              "documentation": {
                "identifier": "_jsCtx_index",
                "newPage": false,
                "searchKey": "template._jsCtx_index",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _jsCtx_index"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _jsCtx_index = [...]uint8{0, 11, 21, 33}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#_state_index",
              "documentation": {
                "identifier": "_state_index",
                "newPage": false,
                "searchKey": "template._state_index",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _state_index"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _state_index = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#escapeOK",
              "documentation": {
                "identifier": "escapeOK",
                "newPage": false,
                "searchKey": "template.escapeOK",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var escapeOK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar escapeOK = fmt.Errorf(\"template escaped correctly\")\n```\n\nescapeOK is a sentinel value used to indicate valid escaping. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#transitionFunc",
              "documentation": {
                "identifier": "transitionFunc",
                "newPage": false,
                "searchKey": "template.transitionFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var transitionFunc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar transitionFunc = ...\n```\n\ntransitionFunc is the array of context transition functions for text nodes. A transition function takes a context and template text input, and returns the updated context and the number of bytes consumed from the front of the input. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#commentStart",
              "documentation": {
                "identifier": "commentStart",
                "newPage": false,
                "searchKey": "template.commentStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var commentStart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar commentStart = []byte(\"<!--\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#commentEnd",
              "documentation": {
                "identifier": "commentEnd",
                "newPage": false,
                "searchKey": "template.commentEnd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var commentEnd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar commentEnd = []byte(\"-->\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#elementContentType",
              "documentation": {
                "identifier": "elementContentType",
                "newPage": false,
                "searchKey": "template.elementContentType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var elementContentType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar elementContentType = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#attrStartStates",
              "documentation": {
                "identifier": "attrStartStates",
                "newPage": false,
                "searchKey": "template.attrStartStates",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var attrStartStates"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar attrStartStates = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#specialTagEndMarkers",
              "documentation": {
                "identifier": "specialTagEndMarkers",
                "newPage": false,
                "searchKey": "template.specialTagEndMarkers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var specialTagEndMarkers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar specialTagEndMarkers = ...\n```\n\nspecialTagEndMarkers maps element types to the character sequence that case-insensitively signals the end of the special tag body. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#specialTagEndPrefix",
              "documentation": {
                "identifier": "specialTagEndPrefix",
                "newPage": false,
                "searchKey": "template.specialTagEndPrefix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var specialTagEndPrefix"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar specialTagEndPrefix = []byte(\"</\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#tagEndSeparators",
              "documentation": {
                "identifier": "tagEndSeparators",
                "newPage": false,
                "searchKey": "template.tagEndSeparators",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tagEndSeparators"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tagEndSeparators = []byte(\"> \\t\\n\\f/\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#blockCommentEnd",
              "documentation": {
                "identifier": "blockCommentEnd",
                "newPage": false,
                "searchKey": "template.blockCommentEnd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var blockCommentEnd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar blockCommentEnd = []byte(\"*/\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#elementNameMap",
              "documentation": {
                "identifier": "elementNameMap",
                "newPage": false,
                "searchKey": "template.elementNameMap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var elementNameMap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar elementNameMap = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#_urlPart_index",
              "documentation": {
                "identifier": "_urlPart_index",
                "newPage": false,
                "searchKey": "template._urlPart_index",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _urlPart_index"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _urlPart_index = [...]uint8{0, 11, 26, 44, 58}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#debug",
              "documentation": {
                "identifier": "debug",
                "newPage": false,
                "searchKey": "template.debug",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var debug"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar debug = flag.Bool(\"debug\", false, \"show the errors produced by the tests\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#siVal",
              "documentation": {
                "identifier": "siVal",
                "newPage": false,
                "searchKey": "template.siVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var siVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar siVal = I(S{\"a\", \"b\"})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#tVal",
              "documentation": {
                "identifier": "tVal",
                "newPage": false,
                "searchKey": "template.tVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tVal = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#tSliceOfNil",
              "documentation": {
                "identifier": "tSliceOfNil",
                "newPage": false,
                "searchKey": "template.tSliceOfNil",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tSliceOfNil"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tSliceOfNil = []*T{nil}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#iVal",
              "documentation": {
                "identifier": "iVal",
                "newPage": false,
                "searchKey": "template.iVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var iVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar iVal I = tVal\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#myError",
              "documentation": {
                "identifier": "myError",
                "newPage": false,
                "searchKey": "template.myError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var myError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar myError = errors.New(\"my error\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#bigInt",
              "documentation": {
                "identifier": "bigInt",
                "newPage": false,
                "searchKey": "template.bigInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bigInt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bigInt = fmt.Sprintf(\"0x%x\", int(1<<uint(reflect.TypeOf(0).Bits()-1)-1))\n```\n\nbigInt and bigUint are hex string representing numbers either side of the max int boundary. We do it this way so the test doesn't depend on ints being 32 bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#bigUint",
              "documentation": {
                "identifier": "bigUint",
                "newPage": false,
                "searchKey": "template.bigUint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bigUint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bigUint = fmt.Sprintf(\"0x%x\", uint(1<<uint(reflect.TypeOf(0).Bits()-1)))\n```\n\nbigInt and bigUint are hex string representing numbers either side of the max int boundary. We do it this way so the test doesn't depend on ints being 32 bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#execTests",
              "documentation": {
                "identifier": "execTests",
                "newPage": false,
                "searchKey": "template.execTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var execTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar execTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#delimPairs",
              "documentation": {
                "identifier": "delimPairs",
                "newPage": false,
                "searchKey": "template.delimPairs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var delimPairs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar delimPairs = []string{\n\t\"\", \"\",\n\t\"{{\", \"}}\",\n\t\"|\", \"|\",\n\t\"(日)\", \"(本)\",\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#cmpTests",
              "documentation": {
                "identifier": "cmpTests",
                "newPage": false,
                "searchKey": "template.cmpTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cmpTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cmpTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#alwaysError",
              "documentation": {
                "identifier": "alwaysError",
                "newPage": false,
                "searchKey": "template.alwaysError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var alwaysError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar alwaysError = errors.New(alwaysErrorText)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#multiExecTests",
              "documentation": {
                "identifier": "multiExecTests",
                "newPage": false,
                "searchKey": "template.multiExecTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var multiExecTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar multiExecTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#templateFileExecTests",
              "documentation": {
                "identifier": "templateFileExecTests",
                "newPage": false,
                "searchKey": "template.templateFileExecTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var templateFileExecTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar templateFileExecTests = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/html/template#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/html/template#CSS",
              "documentation": {
                "identifier": "CSS",
                "newPage": false,
                "searchKey": "template.CSS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type CSS string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype CSS string\n```\n\nStrings of content from a trusted source. \n\nCSS encapsulates known safe content that matches any of: \n\n```\n1. The CSS3 stylesheet production, such as `p { color: purple }`.\n2. The CSS3 rule production, such as `a[href=~\"https:\"].foo#bar`.\n3. CSS3 declaration productions, such as `color: red; margin: 2px`.\n4. The CSS3 value production, such as `rgba(0, 0, 255, 127)`.\n\n```\nSee [https://www.w3.org/TR/css3-syntax/#parsing](https://www.w3.org/TR/css3-syntax/#parsing) and [https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style](https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style) \n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#HTML",
              "documentation": {
                "identifier": "HTML",
                "newPage": false,
                "searchKey": "template.HTML",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type HTML string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype HTML string\n```\n\nStrings of content from a trusted source. \n\nHTML encapsulates a known safe HTML document fragment. It should not be used for HTML from a third-party, or HTML with unclosed tags or comments. The outputs of a sound HTML sanitizer and a template escaped by this package are fine for use with HTML. \n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#HTMLAttr",
              "documentation": {
                "identifier": "HTMLAttr",
                "newPage": false,
                "searchKey": "template.HTMLAttr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type HTMLAttr string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype HTMLAttr string\n```\n\nStrings of content from a trusted source. \n\nHTMLAttr encapsulates an HTML attribute from a trusted source, for example, ` dir=\"ltr\"`. \n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#JS",
              "documentation": {
                "identifier": "JS",
                "newPage": false,
                "searchKey": "template.JS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type JS string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype JS string\n```\n\nStrings of content from a trusted source. \n\nJS encapsulates a known safe EcmaScript5 Expression, for example, `(x + y * z())`. Template authors are responsible for ensuring that typed expressions do not break the intended precedence and that there is no statement/expression ambiguity as when passing an expression like \"{ foo: bar() }\\n['foo']()\", which is both a valid Expression and a valid Program with a very different meaning. \n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. \n\nUsing JS to include valid but untrusted JSON is not safe. A safe alternative is to parse the JSON with json.Unmarshal and then pass the resultant object into the template, where it will be converted to sanitized JSON when presented in a JavaScript context. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#JSStr",
              "documentation": {
                "identifier": "JSStr",
                "newPage": false,
                "searchKey": "template.JSStr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type JSStr string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype JSStr string\n```\n\nStrings of content from a trusted source. \n\nJSStr encapsulates a sequence of characters meant to be embedded between quotes in a JavaScript expression. The string must match a series of StringCharacters: \n\n```\nStringCharacter :: SourceCharacter but not `\\` or LineTerminator\n                 | EscapeSequence\n\n```\nNote that LineContinuations are not allowed. JSStr(\"foo\\\\nbar\") is fine, but JSStr(\"foo\\\\\\nbar\") is not. \n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#URL",
              "documentation": {
                "identifier": "URL",
                "newPage": false,
                "searchKey": "template.URL",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type URL string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype URL string\n```\n\nStrings of content from a trusted source. \n\nURL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted source should go in the page, but by default dynamic `javascript:` URLs are filtered out since they are a frequently exploited injection vector. \n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#Srcset",
              "documentation": {
                "identifier": "Srcset",
                "newPage": false,
                "searchKey": "template.Srcset",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Srcset string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Srcset string\n```\n\nStrings of content from a trusted source. \n\nSrcset encapsulates a known safe srcset attribute (see [https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset](https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset)). \n\nUse of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#contentType",
              "documentation": {
                "identifier": "contentType",
                "newPage": false,
                "searchKey": "template.contentType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type contentType uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype contentType uint8\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#attrType",
                    "documentation": {
                      "identifier": "attrType",
                      "newPage": false,
                      "searchKey": "template.attrType",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func attrType(name string) contentType"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc attrType(name string) contentType\n```\n\nattrType returns a conservative (upper-bound on authority) guess at the type of the lowercase named attribute. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#stringify",
                    "documentation": {
                      "identifier": "stringify",
                      "newPage": false,
                      "searchKey": "template.stringify",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func stringify(args ...interface{}) (string, contentType)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc stringify(args ...interface{}) (string, contentType)\n```\n\nstringify converts its arguments to a string and the type of the content. All pointers are dereferenced, as in the text/template package. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#context",
              "documentation": {
                "identifier": "context",
                "newPage": false,
                "searchKey": "template.context",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type context struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype context struct {\n\tstate   state\n\tdelim   delim\n\turlPart urlPart\n\tjsCtx   jsCtx\n\tattr    attr\n\telement element\n\terr     *Error\n}\n```\n\ncontext describes the state an HTML parser must be in when it reaches the portion of HTML produced by evaluating a particular template node. \n\nThe zero value of type context is the start context for a template that produces an HTML fragment as defined at [https://www.w3.org/TR/html5/syntax.html#the-end](https://www.w3.org/TR/html5/syntax.html#the-end) where the context element is null. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#nudge",
                    "documentation": {
                      "identifier": "nudge",
                      "newPage": false,
                      "searchKey": "template.nudge",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func nudge(c context) context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc nudge(c context) context\n```\n\nnudge returns the context that would result from following empty string transitions from the input context. For example, parsing: \n\n```\n`<a href=`\n\n```\nwill end in context{stateBeforeValue, attrURL}, but parsing one extra rune: \n\n```\n`<a href=x`\n\n```\nwill end in context{stateURL, delimSpaceOrTagEnd, ...}. There are two transitions that happen when the 'x' is seen: (1) Transition from a before-value state to a start-of-value state without \n\n```\nconsuming any character.\n\n```\n(2) Consume 'x' and transition past the first value character. In this case, nudging produces the context after (1) happens. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#join",
                    "documentation": {
                      "identifier": "join",
                      "newPage": false,
                      "searchKey": "template.join",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func join(a, b context, node parse.Node, nodeName string) context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc join(a, b context, node parse.Node, nodeName string) context\n```\n\njoin joins the two contexts of a branch template node. The result is an error context if either of the input contexts are error contexts, or if the input contexts differ. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#contextAfterText",
                    "documentation": {
                      "identifier": "contextAfterText",
                      "newPage": false,
                      "searchKey": "template.contextAfterText",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func contextAfterText(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc contextAfterText(c context, s []byte) (context, int)\n```\n\ncontextAfterText starts in context c, consumes some tokens from the front of s, then returns the context after those tokens and the unprocessed suffix. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tText",
                    "documentation": {
                      "identifier": "tText",
                      "newPage": false,
                      "searchKey": "template.tText",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tText(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tText(c context, s []byte) (context, int)\n```\n\ntText is the context transition function for the text state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tTag",
                    "documentation": {
                      "identifier": "tTag",
                      "newPage": false,
                      "searchKey": "template.tTag",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tTag(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tTag(c context, s []byte) (context, int)\n```\n\ntTag is the context transition function for the tag state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tAttrName",
                    "documentation": {
                      "identifier": "tAttrName",
                      "newPage": false,
                      "searchKey": "template.tAttrName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tAttrName(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tAttrName(c context, s []byte) (context, int)\n```\n\ntAttrName is the context transition function for stateAttrName. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tAfterName",
                    "documentation": {
                      "identifier": "tAfterName",
                      "newPage": false,
                      "searchKey": "template.tAfterName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tAfterName(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tAfterName(c context, s []byte) (context, int)\n```\n\ntAfterName is the context transition function for stateAfterName. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tBeforeValue",
                    "documentation": {
                      "identifier": "tBeforeValue",
                      "newPage": false,
                      "searchKey": "template.tBeforeValue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tBeforeValue(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tBeforeValue(c context, s []byte) (context, int)\n```\n\ntBeforeValue is the context transition function for stateBeforeValue. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tHTMLCmt",
                    "documentation": {
                      "identifier": "tHTMLCmt",
                      "newPage": false,
                      "searchKey": "template.tHTMLCmt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tHTMLCmt(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tHTMLCmt(c context, s []byte) (context, int)\n```\n\ntHTMLCmt is the context transition function for stateHTMLCmt. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tSpecialTagEnd",
                    "documentation": {
                      "identifier": "tSpecialTagEnd",
                      "newPage": false,
                      "searchKey": "template.tSpecialTagEnd",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tSpecialTagEnd(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tSpecialTagEnd(c context, s []byte) (context, int)\n```\n\ntSpecialTagEnd is the context transition function for raw text and RCDATA element states. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tAttr",
                    "documentation": {
                      "identifier": "tAttr",
                      "newPage": false,
                      "searchKey": "template.tAttr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tAttr(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tAttr(c context, s []byte) (context, int)\n```\n\ntAttr is the context transition function for the attribute state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tURL",
                    "documentation": {
                      "identifier": "tURL",
                      "newPage": false,
                      "searchKey": "template.tURL",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tURL(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tURL(c context, s []byte) (context, int)\n```\n\ntURL is the context transition function for the URL state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tJS",
                    "documentation": {
                      "identifier": "tJS",
                      "newPage": false,
                      "searchKey": "template.tJS",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tJS(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tJS(c context, s []byte) (context, int)\n```\n\ntJS is the context transition function for the JS state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tJSDelimited",
                    "documentation": {
                      "identifier": "tJSDelimited",
                      "newPage": false,
                      "searchKey": "template.tJSDelimited",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tJSDelimited(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tJSDelimited(c context, s []byte) (context, int)\n```\n\ntJSDelimited is the context transition function for the JS string and regexp states. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tBlockCmt",
                    "documentation": {
                      "identifier": "tBlockCmt",
                      "newPage": false,
                      "searchKey": "template.tBlockCmt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tBlockCmt(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tBlockCmt(c context, s []byte) (context, int)\n```\n\ntBlockCmt is the context transition function for /*comment*/ states. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tLineCmt",
                    "documentation": {
                      "identifier": "tLineCmt",
                      "newPage": false,
                      "searchKey": "template.tLineCmt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tLineCmt(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tLineCmt(c context, s []byte) (context, int)\n```\n\ntLineCmt is the context transition function for //comment states. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tCSS",
                    "documentation": {
                      "identifier": "tCSS",
                      "newPage": false,
                      "searchKey": "template.tCSS",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tCSS(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tCSS(c context, s []byte) (context, int)\n```\n\ntCSS is the context transition function for the CSS state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tCSSStr",
                    "documentation": {
                      "identifier": "tCSSStr",
                      "newPage": false,
                      "searchKey": "template.tCSSStr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tCSSStr(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tCSSStr(c context, s []byte) (context, int)\n```\n\ntCSSStr is the context transition function for the CSS string and URL states. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#tError",
                    "documentation": {
                      "identifier": "tError",
                      "newPage": false,
                      "searchKey": "template.tError",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tError(c context, s []byte) (context, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tError(c context, s []byte) (context, int)\n```\n\ntError is the context transition function for the error state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#context.String",
                    "documentation": {
                      "identifier": "context.String",
                      "newPage": false,
                      "searchKey": "template.context.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c context) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c context) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#context.eq",
                    "documentation": {
                      "identifier": "context.eq",
                      "newPage": false,
                      "searchKey": "template.context.eq",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c context) eq(d context) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c context) eq(d context) bool\n```\n\neq reports whether two contexts are equal. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#context.mangle",
                    "documentation": {
                      "identifier": "context.mangle",
                      "newPage": false,
                      "searchKey": "template.context.mangle",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c context) mangle(templateName string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c context) mangle(templateName string) string\n```\n\nmangle produces an identifier that includes a suffix that distinguishes it from template names mangled with different contexts. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#state",
              "documentation": {
                "identifier": "state",
                "newPage": false,
                "searchKey": "template.state",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type state uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype state uint8\n```\n\nstate describes a high-level HTML parser state. \n\nIt bounds the top of the element stack, and by extension the HTML insertion mode, but also contains state that does not correspond to anything in the HTML5 parsing algorithm because a single token production in the HTML grammar may contain embedded actions in a template. For instance, the quoted HTML attribute produced by \n\n```\n<div title=\"Hello {{.World}}\">\n\n```\nis a single token in HTML's grammar but in a template spans several nodes. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#state.String",
                    "documentation": {
                      "identifier": "state.String",
                      "newPage": false,
                      "searchKey": "template.state.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i state) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i state) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#delim",
              "documentation": {
                "identifier": "delim",
                "newPage": false,
                "searchKey": "template.delim",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type delim uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype delim uint8\n```\n\ndelim is the delimiter that will end the current HTML attribute. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#delim.String",
                    "documentation": {
                      "identifier": "delim.String",
                      "newPage": false,
                      "searchKey": "template.delim.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i delim) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i delim) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#urlPart",
              "documentation": {
                "identifier": "urlPart",
                "newPage": false,
                "searchKey": "template.urlPart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type urlPart uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype urlPart uint8\n```\n\nurlPart identifies a part in an RFC 3986 hierarchical URL to allow different encoding strategies. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#urlPart.String",
                    "documentation": {
                      "identifier": "urlPart.String",
                      "newPage": false,
                      "searchKey": "template.urlPart.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i urlPart) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i urlPart) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#jsCtx",
              "documentation": {
                "identifier": "jsCtx",
                "newPage": false,
                "searchKey": "template.jsCtx",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type jsCtx uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype jsCtx uint8\n```\n\njsCtx determines whether a '/' starts a regular expression literal or a division operator. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#nextJSCtx",
                    "documentation": {
                      "identifier": "nextJSCtx",
                      "newPage": false,
                      "searchKey": "template.nextJSCtx",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func nextJSCtx(s []byte, preceding jsCtx) jsCtx"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc nextJSCtx(s []byte, preceding jsCtx) jsCtx\n```\n\nnextJSCtx returns the context that determines whether a slash after the given run of tokens starts a regular expression instead of a division operator: / or /=. \n\nThis assumes that the token run does not include any string tokens, comment tokens, regular expression literal tokens, or division operators. \n\nThis fails on some valid but nonsensical JavaScript programs like \"x = ++/foo/i\" which is quite different than \"x++/foo/i\", but is not known to fail on any known useful programs. It is based on the draft JavaScript 2.0 lexical grammar and requires one token of lookbehind: [https://www.mozilla.org/js/language/js20-2000-07/rationale/syntax.html](https://www.mozilla.org/js/language/js20-2000-07/rationale/syntax.html) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#jsCtx.String",
                    "documentation": {
                      "identifier": "jsCtx.String",
                      "newPage": false,
                      "searchKey": "template.jsCtx.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i jsCtx) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i jsCtx) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#element",
              "documentation": {
                "identifier": "element",
                "newPage": false,
                "searchKey": "template.element",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type element uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype element uint8\n```\n\nelement identifies the HTML element when inside a start tag or special body. Certain HTML element (for example <script> and <style>) have bodies that are treated differently from stateText so the element type is necessary to transition into the correct context at the end of a tag and to identify the end delimiter for the body. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#eatTagName",
                    "documentation": {
                      "identifier": "eatTagName",
                      "newPage": false,
                      "searchKey": "template.eatTagName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func eatTagName(s []byte, i int) (int, element)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc eatTagName(s []byte, i int) (int, element)\n```\n\neatTagName returns the largest j such that s[i:j] is a tag name and the tag type. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#element.String",
                    "documentation": {
                      "identifier": "element.String",
                      "newPage": false,
                      "searchKey": "template.element.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i element) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i element) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#attr",
              "documentation": {
                "identifier": "attr",
                "newPage": false,
                "searchKey": "template.attr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type attr uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype attr uint8\n```\n\nattr identifies the current HTML attribute when inside the attribute, that is, starting from stateAttrName until stateTag/stateText (exclusive). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#attr.String",
                    "documentation": {
                      "identifier": "attr.String",
                      "newPage": false,
                      "searchKey": "template.attr.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i attr) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i attr) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#Error",
              "documentation": {
                "identifier": "Error",
                "newPage": false,
                "searchKey": "template.Error",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Error struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Error struct {\n\t// ErrorCode describes the kind of error.\n\tErrorCode ErrorCode\n\t// Node is the node that caused the problem, if known.\n\t// If not nil, it overrides Name and Line.\n\tNode parse.Node\n\t// Name is the name of the template in which the error was encountered.\n\tName string\n\t// Line is the line number of the error in the template source or 0.\n\tLine int\n\t// Description is a human-readable description of the problem.\n\tDescription string\n}\n```\n\nError describes a problem encountered during template Escaping. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#errorf",
                    "documentation": {
                      "identifier": "errorf",
                      "newPage": false,
                      "searchKey": "template.errorf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func errorf(k ErrorCode, node parse.Node, line int, f string, args ...interface{}) *Error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc errorf(k ErrorCode, node parse.Node, line int, f string, args ...interface{}) *Error\n```\n\nerrorf creates an error given a format string f and args. The template Name still needs to be supplied. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#eatAttrName",
                    "documentation": {
                      "identifier": "eatAttrName",
                      "newPage": false,
                      "searchKey": "template.eatAttrName",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func eatAttrName(s []byte, i int) (int, *Error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc eatAttrName(s []byte, i int) (int, *Error)\n```\n\neatAttrName returns the largest j such that s[i:j] is an attribute name. It returns an error if s[i:] does not look like it begins with an attribute name, such as encountering a quote mark without a preceding equals sign. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Error.Error",
                    "documentation": {
                      "identifier": "Error.Error",
                      "newPage": false,
                      "searchKey": "template.Error.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *Error) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *Error) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrorCode",
              "documentation": {
                "identifier": "ErrorCode",
                "newPage": false,
                "searchKey": "template.ErrorCode",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ErrorCode int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ErrorCode int\n```\n\nErrorCode is a code for a kind of error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#escaper",
              "documentation": {
                "identifier": "escaper",
                "newPage": false,
                "searchKey": "template.escaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type escaper struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype escaper struct {\n\t// ns is the nameSpace that this escaper is associated with.\n\tns *nameSpace\n\t// output[templateName] is the output context for a templateName that\n\t// has been mangled to include its input context.\n\toutput map[string]context\n\t// derived[c.mangle(name)] maps to a template derived from the template\n\t// named name templateName for the start context c.\n\tderived map[string]*template.Template\n\t// called[templateName] is a set of called mangled template names.\n\tcalled map[string]bool\n\t// xxxNodeEdits are the accumulated edits to apply during commit.\n\t// Such edits are not applied immediately in case a template set\n\t// executes a given template in different escaping contexts.\n\tactionNodeEdits   map[*parse.ActionNode][]string\n\ttemplateNodeEdits map[*parse.TemplateNode]string\n\ttextNodeEdits     map[*parse.TextNode][]byte\n}\n```\n\nescaper collects type inferences about templates and changes needed to make templates injection safe. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#makeEscaper",
                    "documentation": {
                      "identifier": "makeEscaper",
                      "newPage": false,
                      "searchKey": "template.makeEscaper",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeEscaper(n *nameSpace) escaper"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeEscaper(n *nameSpace) escaper\n```\n\nmakeEscaper creates a blank escaper for the given set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.escape",
                    "documentation": {
                      "identifier": "escaper.escape",
                      "newPage": false,
                      "searchKey": "template.escaper.escape",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) escape(c context, n parse.Node) context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) escape(c context, n parse.Node) context\n```\n\nescape escapes a template node. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.escapeAction",
                    "documentation": {
                      "identifier": "escaper.escapeAction",
                      "newPage": false,
                      "searchKey": "template.escaper.escapeAction",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) escapeAction(c context, n *parse.ActionNode) context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) escapeAction(c context, n *parse.ActionNode) context\n```\n\nescapeAction escapes an action template node. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.escapeBranch",
                    "documentation": {
                      "identifier": "escaper.escapeBranch",
                      "newPage": false,
                      "searchKey": "template.escaper.escapeBranch",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) escapeBranch(c context, n *parse.BranchNode, nodeName string) context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) escapeBranch(c context, n *parse.BranchNode, nodeName string) context\n```\n\nescapeBranch escapes a branch template node: \"if\", \"range\" and \"with\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.escapeList",
                    "documentation": {
                      "identifier": "escaper.escapeList",
                      "newPage": false,
                      "searchKey": "template.escaper.escapeList",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) escapeList(c context, n *parse.ListNode) context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) escapeList(c context, n *parse.ListNode) context\n```\n\nescapeList escapes a list template node. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.escapeListConditionally",
                    "documentation": {
                      "identifier": "escaper.escapeListConditionally",
                      "newPage": false,
                      "searchKey": "template.escaper.escapeListConditionally",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) escapeListConditionally(c context, n *parse.ListNode, filter func(*escaper, context) bool) (context, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) escapeListConditionally(c context, n *parse.ListNode, filter func(*escaper, context) bool) (context, bool)\n```\n\nescapeListConditionally escapes a list node but only preserves edits and inferences in e if the inferences and output context satisfy filter. It returns the best guess at an output context, and the result of the filter which is the same as whether e was updated. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.escapeTemplate",
                    "documentation": {
                      "identifier": "escaper.escapeTemplate",
                      "newPage": false,
                      "searchKey": "template.escaper.escapeTemplate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) escapeTemplate(c context, n *parse.TemplateNode) context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) escapeTemplate(c context, n *parse.TemplateNode) context\n```\n\nescapeTemplate escapes a {{template}} call node. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.escapeTree",
                    "documentation": {
                      "identifier": "escaper.escapeTree",
                      "newPage": false,
                      "searchKey": "template.escaper.escapeTree",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) escapeTree(c context, node parse.Node, name string, line int) (context, string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) escapeTree(c context, node parse.Node, name string, line int) (context, string)\n```\n\nescapeTree escapes the named template starting in the given context as necessary and returns its output context. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.computeOutCtx",
                    "documentation": {
                      "identifier": "escaper.computeOutCtx",
                      "newPage": false,
                      "searchKey": "template.escaper.computeOutCtx",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) computeOutCtx(c context, t *template.Template) context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) computeOutCtx(c context, t *template.Template) context\n```\n\ncomputeOutCtx takes a template and its start context and computes the output context while storing any inferences in e. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.escapeTemplateBody",
                    "documentation": {
                      "identifier": "escaper.escapeTemplateBody",
                      "newPage": false,
                      "searchKey": "template.escaper.escapeTemplateBody",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) escapeTemplateBody(c context, t *template.Template) (context, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) escapeTemplateBody(c context, t *template.Template) (context, bool)\n```\n\nescapeTemplateBody escapes the given template assuming the given output context, and returns the best guess at the output context and whether the assumption was correct. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.escapeText",
                    "documentation": {
                      "identifier": "escaper.escapeText",
                      "newPage": false,
                      "searchKey": "template.escaper.escapeText",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) escapeText(c context, n *parse.TextNode) context"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) escapeText(c context, n *parse.TextNode) context\n```\n\nescapeText escapes a text template node. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.editActionNode",
                    "documentation": {
                      "identifier": "escaper.editActionNode",
                      "newPage": false,
                      "searchKey": "template.escaper.editActionNode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) editActionNode(n *parse.ActionNode, cmds []string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) editActionNode(n *parse.ActionNode, cmds []string)\n```\n\neditActionNode records a change to an action pipeline for later commit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.editTemplateNode",
                    "documentation": {
                      "identifier": "escaper.editTemplateNode",
                      "newPage": false,
                      "searchKey": "template.escaper.editTemplateNode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) editTemplateNode(n *parse.TemplateNode, callee string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) editTemplateNode(n *parse.TemplateNode, callee string)\n```\n\neditTemplateNode records a change to a {{template}} callee for later commit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.editTextNode",
                    "documentation": {
                      "identifier": "escaper.editTextNode",
                      "newPage": false,
                      "searchKey": "template.escaper.editTextNode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) editTextNode(n *parse.TextNode, text []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) editTextNode(n *parse.TextNode, text []byte)\n```\n\neditTextNode records a change to a text node for later commit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.commit",
                    "documentation": {
                      "identifier": "escaper.commit",
                      "newPage": false,
                      "searchKey": "template.escaper.commit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) commit()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) commit()\n```\n\ncommit applies changes to actions and template calls needed to contextually autoescape content and adds any derived templates to the set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.template",
                    "documentation": {
                      "identifier": "escaper.template",
                      "newPage": false,
                      "searchKey": "template.escaper.template",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) template(name string) *template.Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) template(name string) *template.Template\n```\n\ntemplate returns the named template given a mangled template name. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#escaper.arbitraryTemplate",
                    "documentation": {
                      "identifier": "escaper.arbitraryTemplate",
                      "newPage": false,
                      "searchKey": "template.escaper.arbitraryTemplate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *escaper) arbitraryTemplate() *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *escaper) arbitraryTemplate() *Template\n```\n\narbitraryTemplate returns an arbitrary template from the name space associated with e and panics if no templates are found. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#Template",
              "documentation": {
                "identifier": "Template",
                "newPage": false,
                "searchKey": "template.Template",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Template struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Template struct {\n\t// Sticky error if escaping fails, or escapeOK if succeeded.\n\tescapeErr error\n\t// We could embed the text/template field, but it's safer not to because\n\t// we need to keep our version of the name space and the underlying\n\t// template's in sync.\n\ttext *template.Template\n\t// The underlying template's parse tree, updated to be HTML-safe.\n\tTree       *parse.Tree\n\t*nameSpace // common to all associated templates\n}\n```\n\nTemplate is a specialized Template from \"text/template\" that produces a safe HTML document fragment. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#New",
                    "documentation": {
                      "identifier": "New",
                      "newPage": false,
                      "searchKey": "template.New",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func New(name string) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc New(name string) *Template\n```\n\nNew allocates a new HTML template with the given name. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Must",
                    "documentation": {
                      "identifier": "Must",
                      "newPage": false,
                      "searchKey": "template.Must",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Must(t *Template, err error) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Must(t *Template, err error) *Template\n```\n\nMust is a helper that wraps a call to a function returning (*Template, error) and panics if the error is non-nil. It is intended for use in variable initializations such as \n\n```\nvar t = template.Must(template.New(\"name\").Parse(\"html\"))\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#ParseFiles",
                    "documentation": {
                      "identifier": "ParseFiles",
                      "newPage": false,
                      "searchKey": "template.ParseFiles",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseFiles(filenames ...string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseFiles(filenames ...string) (*Template, error)\n```\n\nParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the (base) name and (parsed) contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil. \n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template named \"foo\", while \"a/foo\" is unavailable. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#parseFiles",
                    "documentation": {
                      "identifier": "parseFiles",
                      "newPage": false,
                      "searchKey": "template.parseFiles",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseFiles(t *Template, readFile func(string) (string, []byte, error), filenames ...string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseFiles(t *Template, readFile func(string) (string, []byte, error), filenames ...string) (*Template, error)\n```\n\nparseFiles is the helper for the method and function. If the argument template is nil, it is created from the first file. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#ParseGlob",
                    "documentation": {
                      "identifier": "ParseGlob",
                      "newPage": false,
                      "searchKey": "template.ParseGlob",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseGlob(pattern string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseGlob(pattern string) (*Template, error)\n```\n\nParseGlob creates a new Template and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling ParseFiles with the list of files matched by the pattern. \n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#parseGlob",
                    "documentation": {
                      "identifier": "parseGlob",
                      "newPage": false,
                      "searchKey": "template.parseGlob",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseGlob(t *Template, pattern string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseGlob(t *Template, pattern string) (*Template, error)\n```\n\nparseGlob is the implementation of the function and method ParseGlob. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#ParseFS",
                    "documentation": {
                      "identifier": "ParseFS",
                      "newPage": false,
                      "searchKey": "template.ParseFS",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseFS(fs fs.FS, patterns ...string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseFS(fs fs.FS, patterns ...string) (*Template, error)\n```\n\nParseFS is like ParseFiles or ParseGlob but reads from the file system fs instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#parseFS",
                    "documentation": {
                      "identifier": "parseFS",
                      "newPage": false,
                      "searchKey": "template.parseFS",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func parseFS(t *Template, fsys fs.FS, patterns []string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc parseFS(t *Template, fsys fs.FS, patterns []string) (*Template, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.Templates",
                    "documentation": {
                      "identifier": "Template.Templates",
                      "newPage": false,
                      "searchKey": "template.Template.Templates",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Templates() []*Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Templates() []*Template\n```\n\nTemplates returns a slice of the templates associated with t, including t itself. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.Option",
                    "documentation": {
                      "identifier": "Template.Option",
                      "newPage": false,
                      "searchKey": "template.Template.Option",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Option(opt ...string) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Option(opt ...string) *Template\n```\n\nOption sets options for the template. Options are described by strings, either a simple string or \"key=value\". There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics. \n\nKnown options: \n\nmissingkey: Control the behavior during execution if a map is indexed with a key that is not present in the map. \n\n```\n\"missingkey=default\" or \"missingkey=invalid\"\n\tThe default behavior: Do nothing and continue execution.\n\tIf printed, the result of the index operation is the string\n\t\"<no value>\".\n\"missingkey=zero\"\n\tThe operation returns the zero value for the map type's element.\n\"missingkey=error\"\n\tExecution stops immediately with an error.\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.checkCanParse",
                    "documentation": {
                      "identifier": "Template.checkCanParse",
                      "newPage": false,
                      "searchKey": "template.Template.checkCanParse",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) checkCanParse() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) checkCanParse() error\n```\n\ncheckCanParse checks whether it is OK to parse templates. If not, it returns an error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.escape",
                    "documentation": {
                      "identifier": "Template.escape",
                      "newPage": false,
                      "searchKey": "template.Template.escape",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) escape() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) escape() error\n```\n\nescape escapes all associated templates. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.Execute",
                    "documentation": {
                      "identifier": "Template.Execute",
                      "newPage": false,
                      "searchKey": "template.Template.Execute",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Execute(wr io.Writer, data interface{}) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Execute(wr io.Writer, data interface{}) error\n```\n\nExecute applies a parsed template to the specified data object, writing the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.ExecuteTemplate",
                    "documentation": {
                      "identifier": "Template.ExecuteTemplate",
                      "newPage": false,
                      "searchKey": "template.Template.ExecuteTemplate",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error\n```\n\nExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.lookupAndEscapeTemplate",
                    "documentation": {
                      "identifier": "Template.lookupAndEscapeTemplate",
                      "newPage": false,
                      "searchKey": "template.Template.lookupAndEscapeTemplate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) lookupAndEscapeTemplate(name string) (tmpl *Template, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) lookupAndEscapeTemplate(name string) (tmpl *Template, err error)\n```\n\nlookupAndEscapeTemplate guarantees that the template with the given name is escaped, or returns an error if it cannot be. It returns the named template. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.DefinedTemplates",
                    "documentation": {
                      "identifier": "Template.DefinedTemplates",
                      "newPage": false,
                      "searchKey": "template.Template.DefinedTemplates",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) DefinedTemplates() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) DefinedTemplates() string\n```\n\nDefinedTemplates returns a string listing the defined templates, prefixed by the string \"; defined templates are: \". If there are none, it returns the empty string. Used to generate an error message. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.Parse",
                    "documentation": {
                      "identifier": "Template.Parse",
                      "newPage": false,
                      "searchKey": "template.Template.Parse",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Parse(text string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Parse(text string) (*Template, error)\n```\n\nParse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself. \n\nTemplates can be redefined in successive calls to Parse, before the first use of Execute on t or any associated template. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.AddParseTree",
                    "documentation": {
                      "identifier": "Template.AddParseTree",
                      "newPage": false,
                      "searchKey": "template.Template.AddParseTree",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)\n```\n\nAddParseTree creates a new template with the name and parse tree and associates it with t. \n\nIt returns an error if t or any associated template has already been executed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.Clone",
                    "documentation": {
                      "identifier": "Template.Clone",
                      "newPage": false,
                      "searchKey": "template.Template.Clone",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Clone() (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Clone() (*Template, error)\n```\n\nClone returns a duplicate of the template, including all associated templates. The actual representation is not copied, but the name space of associated templates is, so further calls to Parse in the copy will add templates to the copy but not to the original. Clone can be used to prepare common templates and use them with variant definitions for other templates by adding the variants after the clone is made. \n\nIt returns an error if t has already been executed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.New",
                    "documentation": {
                      "identifier": "Template.New",
                      "newPage": false,
                      "searchKey": "template.Template.New",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) New(name string) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) New(name string) *Template\n```\n\nNew allocates a new HTML template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action. \n\nIf a template with the given name already exists, the new HTML template will replace it. The existing template will be reset and disassociated with t. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.new",
                    "documentation": {
                      "identifier": "Template.new",
                      "newPage": false,
                      "searchKey": "template.Template.new",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) new(name string) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) new(name string) *Template\n```\n\nnew is the implementation of New, without the lock. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.Name",
                    "documentation": {
                      "identifier": "Template.Name",
                      "newPage": false,
                      "searchKey": "template.Template.Name",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Name() string\n```\n\nName returns the name of the template. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.Funcs",
                    "documentation": {
                      "identifier": "Template.Funcs",
                      "newPage": false,
                      "searchKey": "template.Template.Funcs",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Funcs(funcMap FuncMap) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Funcs(funcMap FuncMap) *Template\n```\n\nFuncs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type. However, it is legal to overwrite elements of the map. The return value is the template, so calls can be chained. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.Delims",
                    "documentation": {
                      "identifier": "Template.Delims",
                      "newPage": false,
                      "searchKey": "template.Template.Delims",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Delims(left, right string) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Delims(left, right string) *Template\n```\n\nDelims sets the action delimiters to the specified strings, to be used in subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.Lookup",
                    "documentation": {
                      "identifier": "Template.Lookup",
                      "newPage": false,
                      "searchKey": "template.Template.Lookup",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) Lookup(name string) *Template"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) Lookup(name string) *Template\n```\n\nLookup returns the template with the given name that is associated with t, or nil if there is no such template. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.ParseFiles",
                    "documentation": {
                      "identifier": "Template.ParseFiles",
                      "newPage": false,
                      "searchKey": "template.Template.ParseFiles",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) ParseFiles(filenames ...string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) ParseFiles(filenames ...string) (*Template, error)\n```\n\nParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. \n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. \n\nParseFiles returns an error if t or any associated template has already been executed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.ParseGlob",
                    "documentation": {
                      "identifier": "Template.ParseGlob",
                      "newPage": false,
                      "searchKey": "template.Template.ParseGlob",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) ParseGlob(pattern string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) ParseGlob(pattern string) (*Template, error)\n```\n\nParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern. \n\nWhen parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. \n\nParseGlob returns an error if t or any associated template has already been executed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#Template.ParseFS",
                    "documentation": {
                      "identifier": "Template.ParseFS",
                      "newPage": false,
                      "searchKey": "template.Template.ParseFS",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *Template) ParseFS(fs fs.FS, patterns ...string) (*Template, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *Template) ParseFS(fs fs.FS, patterns ...string) (*Template, error)\n```\n\nParseFS is like ParseFiles or ParseGlob but reads from the file system fs instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.) \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#nameSpace",
              "documentation": {
                "identifier": "nameSpace",
                "newPage": false,
                "searchKey": "template.nameSpace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type nameSpace struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nameSpace struct {\n\tmu      sync.Mutex\n\tset     map[string]*Template\n\tescaped bool\n\tesc     escaper\n}\n```\n\nnameSpace is the data structure shared by all templates in an association. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#FuncMap",
              "documentation": {
                "identifier": "FuncMap",
                "newPage": false,
                "searchKey": "template.FuncMap",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type FuncMap map[string]interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FuncMap map[string]interface{}\n```\n\nFuncMap is the type of the map defining the mapping from names to functions. Each function must have either a single return value, or two return values of which the second has type error. In that case, if the second (error) argument evaluates to non-nil during execution, execution terminates and Execute returns that error. FuncMap has the same base type as FuncMap in \"text/template\", copied here so clients need not import \"text/template\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#myStringer",
              "documentation": {
                "identifier": "myStringer",
                "newPage": false,
                "searchKey": "template.myStringer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type myStringer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype myStringer struct {\n\tv int\n}\n```\n\nTest that we print using the String method. Was issue 3073. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#myStringer.String",
                    "documentation": {
                      "identifier": "myStringer.String",
                      "newPage": false,
                      "searchKey": "template.myStringer.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *myStringer) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *myStringer) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#errorer",
              "documentation": {
                "identifier": "errorer",
                "newPage": false,
                "searchKey": "template.errorer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type errorer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype errorer struct {\n\tv int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#errorer.Error",
                    "documentation": {
                      "identifier": "errorer.Error",
                      "newPage": false,
                      "searchKey": "template.errorer.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *errorer) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *errorer) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#badMarshaler",
              "documentation": {
                "identifier": "badMarshaler",
                "newPage": false,
                "searchKey": "template.badMarshaler",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type badMarshaler struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype badMarshaler struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#badMarshaler.MarshalJSON",
                    "documentation": {
                      "identifier": "badMarshaler.MarshalJSON",
                      "newPage": false,
                      "searchKey": "template.badMarshaler.MarshalJSON",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *badMarshaler) MarshalJSON() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *badMarshaler) MarshalJSON() ([]byte, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#goodMarshaler",
              "documentation": {
                "identifier": "goodMarshaler",
                "newPage": false,
                "searchKey": "template.goodMarshaler",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type goodMarshaler struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype goodMarshaler struct{}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#goodMarshaler.MarshalJSON",
                    "documentation": {
                      "identifier": "goodMarshaler.MarshalJSON",
                      "newPage": false,
                      "searchKey": "template.goodMarshaler.MarshalJSON",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *goodMarshaler) MarshalJSON() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *goodMarshaler) MarshalJSON() ([]byte, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#Issue7379",
              "documentation": {
                "identifier": "Issue7379",
                "newPage": false,
                "searchKey": "template.Issue7379",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Issue7379 int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Issue7379 int\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#Issue7379.SomeMethod",
                    "documentation": {
                      "identifier": "Issue7379.SomeMethod",
                      "newPage": false,
                      "searchKey": "template.Issue7379.SomeMethod",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (Issue7379) SomeMethod(x int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (Issue7379) SomeMethod(x int) string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#T",
              "documentation": {
                "identifier": "T",
                "newPage": false,
                "searchKey": "template.T",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type T struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype T struct {\n\t// Basics\n\tTrue        bool\n\tI           int\n\tU16         uint16\n\tX, S        string\n\tFloatZero   float64\n\tComplexZero complex128\n\t// Nested structs.\n\tU *U\n\t// Struct with String method.\n\tV0     V\n\tV1, V2 *V\n\t// Struct with Error method.\n\tW0     W\n\tW1, W2 *W\n\t// Slices\n\tSI      []int\n\tSICap   []int\n\tSIEmpty []int\n\tSB      []bool\n\t// Arrays\n\tAI [3]int\n\t// Maps\n\tMSI      map[string]int\n\tMSIone   map[string]int // one element, for deterministic output\n\tMSIEmpty map[string]int\n\tMXI      map[interface{}]int\n\tMII      map[int]int\n\tMI32S    map[int32]string\n\tMI64S    map[int64]string\n\tMUI32S   map[uint32]string\n\tMUI64S   map[uint64]string\n\tMI8S     map[int8]string\n\tMUI8S    map[uint8]string\n\tSMSI     []map[string]int\n\t// Empty interfaces; used to see if we can dig inside one.\n\tEmpty0 interface{} // nil\n\tEmpty1 interface{}\n\tEmpty2 interface{}\n\tEmpty3 interface{}\n\tEmpty4 interface{}\n\t// Non-empty interfaces.\n\tNonEmptyInterface         I\n\tNonEmptyInterfacePtS      *I\n\tNonEmptyInterfaceNil      I\n\tNonEmptyInterfaceTypedNil I\n\t// Stringer.\n\tStr fmt.Stringer\n\tErr error\n\t// Pointers\n\tPI  *int\n\tPS  *string\n\tPSI *[]int\n\tNIL *int\n\t// Function (not method)\n\tBinaryFunc      func(string, string) string\n\tVariadicFunc    func(...string) string\n\tVariadicFuncInt func(int, ...string) string\n\tNilOKFunc       func(*int) bool\n\tErrFunc         func() (string, error)\n\tPanicFunc       func() string\n\t// Template to test evaluation of templates.\n\tTmpl *Template\n\t// Unexported field; cannot be accessed by template.\n\tunexported int\n}\n```\n\nT has lots of interesting pieces to use to test execution. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#T.Method0",
                    "documentation": {
                      "identifier": "T.Method0",
                      "newPage": false,
                      "searchKey": "template.T.Method0",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Method0() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Method0() string\n```\n\nSimple methods with and without arguments. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#T.Method1",
                    "documentation": {
                      "identifier": "T.Method1",
                      "newPage": false,
                      "searchKey": "template.T.Method1",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Method1(a int) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Method1(a int) int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#T.Method2",
                    "documentation": {
                      "identifier": "T.Method2",
                      "newPage": false,
                      "searchKey": "template.T.Method2",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Method2(a uint16, b string) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Method2(a uint16, b string) string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#T.Method3",
                    "documentation": {
                      "identifier": "T.Method3",
                      "newPage": false,
                      "searchKey": "template.T.Method3",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Method3(v interface{}) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Method3(v interface{}) string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#T.Copy",
                    "documentation": {
                      "identifier": "T.Copy",
                      "newPage": false,
                      "searchKey": "template.T.Copy",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) Copy() *T"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) Copy() *T\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#T.MAdd",
                    "documentation": {
                      "identifier": "T.MAdd",
                      "newPage": false,
                      "searchKey": "template.T.MAdd",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) MAdd(a int, b []int) []int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) MAdd(a int, b []int) []int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#T.MyError",
                    "documentation": {
                      "identifier": "T.MyError",
                      "newPage": false,
                      "searchKey": "template.T.MyError",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) MyError(error bool) (bool, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) MyError(error bool) (bool, error)\n```\n\nMyError returns a value and an error according to its argument. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/html/template#T.GetU",
                    "documentation": {
                      "identifier": "T.GetU",
                      "newPage": false,
                      "searchKey": "template.T.GetU",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *T) GetU() *U"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *T) GetU() *U\n```\n\nA few methods to test chaining. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#S",
              "documentation": {
                "identifier": "S",
                "newPage": false,
                "searchKey": "template.S",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type S []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype S []string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#S.Method0",
                    "documentation": {
                      "identifier": "S.Method0",
                      "newPage": false,
                      "searchKey": "template.S.Method0",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (S) Method0() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (S) Method0() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#U",
              "documentation": {
                "identifier": "U",
                "newPage": false,
                "searchKey": "template.U",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type U struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype U struct {\n\tV string\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#U.TrueFalse",
                    "documentation": {
                      "identifier": "U.TrueFalse",
                      "newPage": false,
                      "searchKey": "template.U.TrueFalse",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (u *U) TrueFalse(b bool) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (u *U) TrueFalse(b bool) string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#V",
              "documentation": {
                "identifier": "V",
                "newPage": false,
                "searchKey": "template.V",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type V struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype V struct {\n\tj int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#V.String",
                    "documentation": {
                      "identifier": "V.String",
                      "newPage": false,
                      "searchKey": "template.V.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v *V) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v *V) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#W",
              "documentation": {
                "identifier": "W",
                "newPage": false,
                "searchKey": "template.W",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type W struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype W struct {\n\tk int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#W.Error",
                    "documentation": {
                      "identifier": "W.Error",
                      "newPage": false,
                      "searchKey": "template.W.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *W) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *W) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#I",
              "documentation": {
                "identifier": "I",
                "newPage": false,
                "searchKey": "template.I",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type I interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype I interface {\n\tMethod0() string\n}\n```\n\nA non-empty interface. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#execTest",
              "documentation": {
                "identifier": "execTest",
                "newPage": false,
                "searchKey": "template.execTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type execTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype execTest struct {\n\tname   string\n\tinput  string\n\toutput string\n\tdata   interface{}\n\tok     bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#Tree",
              "documentation": {
                "identifier": "Tree",
                "newPage": false,
                "searchKey": "template.Tree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Tree struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Tree struct {\n\tVal         int\n\tLeft, Right *Tree\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#cmpTest",
              "documentation": {
                "identifier": "cmpTest",
                "newPage": false,
                "searchKey": "template.cmpTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cmpTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cmpTest struct {\n\texpr  string\n\ttruth string\n\tok    bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ErrorWriter",
              "documentation": {
                "identifier": "ErrorWriter",
                "newPage": false,
                "searchKey": "template.ErrorWriter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ErrorWriter int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ErrorWriter int\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#ErrorWriter.Write",
                    "documentation": {
                      "identifier": "ErrorWriter.Write",
                      "newPage": false,
                      "searchKey": "template.ErrorWriter.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e ErrorWriter) Write(p []byte) (int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e ErrorWriter) Write(p []byte) (int, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#recursiveInvoker",
              "documentation": {
                "identifier": "recursiveInvoker",
                "newPage": false,
                "searchKey": "template.recursiveInvoker",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type recursiveInvoker struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype recursiveInvoker struct {\n\tt    *testing.T\n\ttmpl *Template\n}\n```\n\nrecursiveInvoker is for TestRecursiveExecuteViaMethod. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/html/template#recursiveInvoker.Recur",
                    "documentation": {
                      "identifier": "recursiveInvoker.Recur",
                      "newPage": false,
                      "searchKey": "template.recursiveInvoker.Recur",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *recursiveInvoker) Recur() (string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *recursiveInvoker) Recur() (string, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/html/template#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/html/template#indirect",
              "documentation": {
                "identifier": "indirect",
                "newPage": false,
                "searchKey": "template.indirect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func indirect(a interface{}) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc indirect(a interface{}) interface{}\n```\n\nindirect returns the value, after dereferencing as many times as necessary to reach the base type (or nil). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#indirectToStringerOrError",
              "documentation": {
                "identifier": "indirectToStringerOrError",
                "newPage": false,
                "searchKey": "template.indirectToStringerOrError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func indirectToStringerOrError(a interface{}) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc indirectToStringerOrError(a interface{}) interface{}\n```\n\nindirectToStringerOrError returns the value, after dereferencing as many times as necessary to reach the base type (or nil) or an implementation of fmt.Stringer or error, \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#isComment",
              "documentation": {
                "identifier": "isComment",
                "newPage": false,
                "searchKey": "template.isComment",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isComment(s state) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isComment(s state) bool\n```\n\nisComment is true for any state that contains content meant for template authors & maintainers, not for end-users or machines. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#isInTag",
              "documentation": {
                "identifier": "isInTag",
                "newPage": false,
                "searchKey": "template.isInTag",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isInTag(s state) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isInTag(s state) bool\n```\n\nisInTag return whether s occurs solely inside an HTML tag. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#endsWithCSSKeyword",
              "documentation": {
                "identifier": "endsWithCSSKeyword",
                "newPage": false,
                "searchKey": "template.endsWithCSSKeyword",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func endsWithCSSKeyword(b []byte, kw string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc endsWithCSSKeyword(b []byte, kw string) bool\n```\n\nendsWithCSSKeyword reports whether b ends with an ident that case-insensitively matches the lower-case kw. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#isCSSNmchar",
              "documentation": {
                "identifier": "isCSSNmchar",
                "newPage": false,
                "searchKey": "template.isCSSNmchar",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isCSSNmchar(r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isCSSNmchar(r rune) bool\n```\n\nisCSSNmchar reports whether rune is allowed anywhere in a CSS identifier. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#decodeCSS",
              "documentation": {
                "identifier": "decodeCSS",
                "newPage": false,
                "searchKey": "template.decodeCSS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func decodeCSS(s []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc decodeCSS(s []byte) []byte\n```\n\ndecodeCSS decodes CSS3 escapes given a sequence of stringchars. If there is no change, it returns the input, otherwise it returns a slice backed by a new array. [https://www.w3.org/TR/css3-syntax/#SUBTOK-stringchar](https://www.w3.org/TR/css3-syntax/#SUBTOK-stringchar) defines stringchar. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#isHex",
              "documentation": {
                "identifier": "isHex",
                "newPage": false,
                "searchKey": "template.isHex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isHex(c byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isHex(c byte) bool\n```\n\nisHex reports whether the given character is a hex digit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#hexDecode",
              "documentation": {
                "identifier": "hexDecode",
                "newPage": false,
                "searchKey": "template.hexDecode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hexDecode(s []byte) rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hexDecode(s []byte) rune\n```\n\nhexDecode decodes a short hex digit sequence: \"10\" -> 16. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#skipCSSSpace",
              "documentation": {
                "identifier": "skipCSSSpace",
                "newPage": false,
                "searchKey": "template.skipCSSSpace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func skipCSSSpace(c []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc skipCSSSpace(c []byte) []byte\n```\n\nskipCSSSpace returns a suffix of c, skipping over a single space. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#isCSSSpace",
              "documentation": {
                "identifier": "isCSSSpace",
                "newPage": false,
                "searchKey": "template.isCSSSpace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isCSSSpace(b byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isCSSSpace(b byte) bool\n```\n\nisCSSSpace reports whether b is a CSS space char as defined in wc. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#cssEscaper",
              "documentation": {
                "identifier": "cssEscaper",
                "newPage": false,
                "searchKey": "template.cssEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cssEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cssEscaper(args ...interface{}) string\n```\n\ncssEscaper escapes HTML and CSS special characters using \\<hex>+ escapes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#cssValueFilter",
              "documentation": {
                "identifier": "cssValueFilter",
                "newPage": false,
                "searchKey": "template.cssValueFilter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cssValueFilter(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cssValueFilter(args ...interface{}) string\n```\n\ncssValueFilter allows innocuous CSS values in the output including CSS quantities (10px or 25%), ID or class literals (#foo, .bar), keyword values (inherit, blue), and colors (#888). It filters out unsafe values, such as those that affect token boundaries, and anything that might execute scripts. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#escapeTemplate",
              "documentation": {
                "identifier": "escapeTemplate",
                "newPage": false,
                "searchKey": "template.escapeTemplate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func escapeTemplate(tmpl *Template, node parse.Node, name string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc escapeTemplate(tmpl *Template, node parse.Node, name string) error\n```\n\nescapeTemplate rewrites the named template, which must be associated with t, to guarantee that the output of any of the named templates is properly escaped. If no error is returned, then the named templates have been modified. Otherwise the named templates have been rendered unusable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#evalArgs",
              "documentation": {
                "identifier": "evalArgs",
                "newPage": false,
                "searchKey": "template.evalArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func evalArgs(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc evalArgs(args ...interface{}) string\n```\n\nevalArgs formats the list of arguments into a string. It is equivalent to fmt.Sprint(args...), except that it deferences all pointers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#ensurePipelineContains",
              "documentation": {
                "identifier": "ensurePipelineContains",
                "newPage": false,
                "searchKey": "template.ensurePipelineContains",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ensurePipelineContains(p *parse.PipeNode, s []string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ensurePipelineContains(p *parse.PipeNode, s []string)\n```\n\nensurePipelineContains ensures that the pipeline ends with the commands with the identifiers in s in order. If the pipeline ends with a predefined escaper (i.e. \"html\" or \"urlquery\"), merge it with the identifiers in s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#escFnsEq",
              "documentation": {
                "identifier": "escFnsEq",
                "newPage": false,
                "searchKey": "template.escFnsEq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func escFnsEq(a, b string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc escFnsEq(a, b string) bool\n```\n\nescFnsEq reports whether the two escaping functions are equivalent. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#normalizeEscFn",
              "documentation": {
                "identifier": "normalizeEscFn",
                "newPage": false,
                "searchKey": "template.normalizeEscFn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func normalizeEscFn(e string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc normalizeEscFn(e string) string\n```\n\nnormalizeEscFn(a) is equal to normalizeEscFn(b) for any pair of names of escaper functions a and b that are equivalent. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#appendCmd",
              "documentation": {
                "identifier": "appendCmd",
                "newPage": false,
                "searchKey": "template.appendCmd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendCmd(cmds []*parse.CommandNode, cmd *parse.CommandNode) []*parse.CommandNode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendCmd(cmds []*parse.CommandNode, cmd *parse.CommandNode) []*parse.CommandNode\n```\n\nappendCmd appends the given command to the end of the command pipeline unless it is redundant with the last command. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#newIdentCmd",
              "documentation": {
                "identifier": "newIdentCmd",
                "newPage": false,
                "searchKey": "template.newIdentCmd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newIdentCmd(identifier string, pos parse.Pos) *parse.CommandNode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newIdentCmd(identifier string, pos parse.Pos) *parse.CommandNode\n```\n\nnewIdentCmd produces a command containing a single identifier node. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#HTMLEscape",
              "documentation": {
                "identifier": "HTMLEscape",
                "newPage": false,
                "searchKey": "template.HTMLEscape",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func HTMLEscape(w io.Writer, b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc HTMLEscape(w io.Writer, b []byte)\n```\n\nHTMLEscape writes to w the escaped HTML equivalent of the plain text data b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#HTMLEscapeString",
              "documentation": {
                "identifier": "HTMLEscapeString",
                "newPage": false,
                "searchKey": "template.HTMLEscapeString",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func HTMLEscapeString(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc HTMLEscapeString(s string) string\n```\n\nHTMLEscapeString returns the escaped HTML equivalent of the plain text data s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#HTMLEscaper",
              "documentation": {
                "identifier": "HTMLEscaper",
                "newPage": false,
                "searchKey": "template.HTMLEscaper",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func HTMLEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc HTMLEscaper(args ...interface{}) string\n```\n\nHTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#JSEscape",
              "documentation": {
                "identifier": "JSEscape",
                "newPage": false,
                "searchKey": "template.JSEscape",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func JSEscape(w io.Writer, b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc JSEscape(w io.Writer, b []byte)\n```\n\nJSEscape writes to w the escaped JavaScript equivalent of the plain text data b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#JSEscapeString",
              "documentation": {
                "identifier": "JSEscapeString",
                "newPage": false,
                "searchKey": "template.JSEscapeString",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func JSEscapeString(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc JSEscapeString(s string) string\n```\n\nJSEscapeString returns the escaped JavaScript equivalent of the plain text data s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#JSEscaper",
              "documentation": {
                "identifier": "JSEscaper",
                "newPage": false,
                "searchKey": "template.JSEscaper",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func JSEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc JSEscaper(args ...interface{}) string\n```\n\nJSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#URLQueryEscaper",
              "documentation": {
                "identifier": "URLQueryEscaper",
                "newPage": false,
                "searchKey": "template.URLQueryEscaper",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func URLQueryEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc URLQueryEscaper(args ...interface{}) string\n```\n\nURLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#htmlNospaceEscaper",
              "documentation": {
                "identifier": "htmlNospaceEscaper",
                "newPage": false,
                "searchKey": "template.htmlNospaceEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func htmlNospaceEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc htmlNospaceEscaper(args ...interface{}) string\n```\n\nhtmlNospaceEscaper escapes for inclusion in unquoted attribute values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#attrEscaper",
              "documentation": {
                "identifier": "attrEscaper",
                "newPage": false,
                "searchKey": "template.attrEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func attrEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc attrEscaper(args ...interface{}) string\n```\n\nattrEscaper escapes for inclusion in quoted attribute values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#rcdataEscaper",
              "documentation": {
                "identifier": "rcdataEscaper",
                "newPage": false,
                "searchKey": "template.rcdataEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func rcdataEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rcdataEscaper(args ...interface{}) string\n```\n\nrcdataEscaper escapes for inclusion in an RCDATA element body. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#htmlEscaper",
              "documentation": {
                "identifier": "htmlEscaper",
                "newPage": false,
                "searchKey": "template.htmlEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func htmlEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc htmlEscaper(args ...interface{}) string\n```\n\nhtmlEscaper escapes for inclusion in HTML text. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#htmlReplacer",
              "documentation": {
                "identifier": "htmlReplacer",
                "newPage": false,
                "searchKey": "template.htmlReplacer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func htmlReplacer(s string, replacementTable []string, badRunes bool) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc htmlReplacer(s string, replacementTable []string, badRunes bool) string\n```\n\nhtmlReplacer returns s with runes replaced according to replacementTable and when badRunes is true, certain bad runes are allowed through unescaped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stripTags",
              "documentation": {
                "identifier": "stripTags",
                "newPage": false,
                "searchKey": "template.stripTags",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stripTags(html string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stripTags(html string) string\n```\n\nstripTags takes a snippet of HTML and returns only the text content. For example, `<b>&iexcl;Hi!</b> <script>...</script>` -> `&iexcl;Hi! `. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#htmlNameFilter",
              "documentation": {
                "identifier": "htmlNameFilter",
                "newPage": false,
                "searchKey": "template.htmlNameFilter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func htmlNameFilter(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc htmlNameFilter(args ...interface{}) string\n```\n\nhtmlNameFilter accepts valid parts of an HTML attribute or tag name or a known-safe HTML attribute. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#commentEscaper",
              "documentation": {
                "identifier": "commentEscaper",
                "newPage": false,
                "searchKey": "template.commentEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func commentEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc commentEscaper(args ...interface{}) string\n```\n\ncommentEscaper returns the empty string regardless of input. Comment content does not correspond to any parsed structure or human-readable content, so the simplest and most secure policy is to drop content interpolated into comments. This approach is equally valid whether or not static comment content is removed from the template. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#indirectToJSONMarshaler",
              "documentation": {
                "identifier": "indirectToJSONMarshaler",
                "newPage": false,
                "searchKey": "template.indirectToJSONMarshaler",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func indirectToJSONMarshaler(a interface{}) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc indirectToJSONMarshaler(a interface{}) interface{}\n```\n\nindirectToJSONMarshaler returns the value, after dereferencing as many times as necessary to reach the base type (or nil) or an implementation of json.Marshal. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#jsValEscaper",
              "documentation": {
                "identifier": "jsValEscaper",
                "newPage": false,
                "searchKey": "template.jsValEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func jsValEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc jsValEscaper(args ...interface{}) string\n```\n\njsValEscaper escapes its inputs to a JS Expression (section 11.14) that has neither side-effects nor free variables outside (NaN, Infinity). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#jsStrEscaper",
              "documentation": {
                "identifier": "jsStrEscaper",
                "newPage": false,
                "searchKey": "template.jsStrEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func jsStrEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc jsStrEscaper(args ...interface{}) string\n```\n\njsStrEscaper produces a string that can be included between quotes in JavaScript source, in JavaScript embedded in an HTML5 <script> element, or in an HTML5 event handler attribute such as onclick. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#jsRegexpEscaper",
              "documentation": {
                "identifier": "jsRegexpEscaper",
                "newPage": false,
                "searchKey": "template.jsRegexpEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func jsRegexpEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc jsRegexpEscaper(args ...interface{}) string\n```\n\njsRegexpEscaper behaves like jsStrEscaper but escapes regular expression specials so the result is treated literally when included in a regular expression literal. /foo{{.X}}bar/ matches the string \"foo\" followed by the literal text of {{.X}} followed by the string \"bar\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#replace",
              "documentation": {
                "identifier": "replace",
                "newPage": false,
                "searchKey": "template.replace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func replace(s string, replacementTable []string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc replace(s string, replacementTable []string) string\n```\n\nreplace replaces each rune r of s with replacementTable[r], provided that r < len(replacementTable). If replacementTable[r] is the empty string then no replacement is made. It also replaces runes U+2028 and U+2029 with the raw strings `\\u2028` and `\\u2029`. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#isJSIdentPart",
              "documentation": {
                "identifier": "isJSIdentPart",
                "newPage": false,
                "searchKey": "template.isJSIdentPart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isJSIdentPart(r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isJSIdentPart(r rune) bool\n```\n\nisJSIdentPart reports whether the given rune is a JS identifier part. It does not handle all the non-Latin letters, joiners, and combining marks, but it does handle every codepoint that can occur in a numeric literal or a keyword. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#isJSType",
              "documentation": {
                "identifier": "isJSType",
                "newPage": false,
                "searchKey": "template.isJSType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isJSType(mimeType string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isJSType(mimeType string) bool\n```\n\nisJSType reports whether the given MIME type should be considered JavaScript. \n\nIt is used to determine whether a script tag with a type attribute is a javascript container. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#IsTrue",
              "documentation": {
                "identifier": "IsTrue",
                "newPage": false,
                "searchKey": "template.IsTrue",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsTrue(val interface{}) (truth, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsTrue(val interface{}) (truth, ok bool)\n```\n\nIsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#readFileOS",
              "documentation": {
                "identifier": "readFileOS",
                "newPage": false,
                "searchKey": "template.readFileOS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readFileOS(file string) (name string, b []byte, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readFileOS(file string) (name string, b []byte, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#readFileFS",
              "documentation": {
                "identifier": "readFileFS",
                "newPage": false,
                "searchKey": "template.readFileFS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readFileFS(fsys fs.FS) func(string) (string, []byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readFileFS(fsys fs.FS) func(string) (string, []byte, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#indexTagEnd",
              "documentation": {
                "identifier": "indexTagEnd",
                "newPage": false,
                "searchKey": "template.indexTagEnd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func indexTagEnd(s []byte, tag []byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc indexTagEnd(s []byte, tag []byte) int\n```\n\nindexTagEnd finds the index of a special tag end in a case insensitive way, or returns -1 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#asciiAlpha",
              "documentation": {
                "identifier": "asciiAlpha",
                "newPage": false,
                "searchKey": "template.asciiAlpha",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func asciiAlpha(c byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc asciiAlpha(c byte) bool\n```\n\nasciiAlpha reports whether c is an ASCII letter. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#asciiAlphaNum",
              "documentation": {
                "identifier": "asciiAlphaNum",
                "newPage": false,
                "searchKey": "template.asciiAlphaNum",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func asciiAlphaNum(c byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc asciiAlphaNum(c byte) bool\n```\n\nasciiAlphaNum reports whether c is an ASCII letter or digit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#eatWhiteSpace",
              "documentation": {
                "identifier": "eatWhiteSpace",
                "newPage": false,
                "searchKey": "template.eatWhiteSpace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func eatWhiteSpace(s []byte, i int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc eatWhiteSpace(s []byte, i int) int\n```\n\neatWhiteSpace returns the largest j such that s[i:j] is white space. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#urlFilter",
              "documentation": {
                "identifier": "urlFilter",
                "newPage": false,
                "searchKey": "template.urlFilter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func urlFilter(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc urlFilter(args ...interface{}) string\n```\n\nurlFilter returns its input unless it contains an unsafe scheme in which case it defangs the entire URL. \n\nSchemes that cause unintended side effects that are irreversible without user interaction are considered unsafe. For example, clicking on a \"javascript:\" link can immediately trigger JavaScript code execution. \n\nThis filter conservatively assumes that all schemes other than the following are unsafe: \n\n```\n* http:   Navigates to a new website, and may open a new window or tab.\n          These side effects can be reversed by navigating back to the\n          previous website, or closing the window or tab. No irreversible\n          changes will take place without further user interaction with\n          the new website.\n* https:  Same as http.\n* mailto: Opens an email program and starts a new draft. This side effect\n          is not irreversible until the user explicitly clicks send; it\n          can be undone by closing the email program.\n\n```\nTo allow URLs containing other schemes to bypass this filter, developers must explicitly indicate that such a URL is expected and safe by encapsulating it in a template.URL value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#isSafeURL",
              "documentation": {
                "identifier": "isSafeURL",
                "newPage": false,
                "searchKey": "template.isSafeURL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isSafeURL(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isSafeURL(s string) bool\n```\n\nisSafeURL is true if s is a relative URL or if URL has a protocol in (http, https, mailto). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#urlEscaper",
              "documentation": {
                "identifier": "urlEscaper",
                "newPage": false,
                "searchKey": "template.urlEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func urlEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc urlEscaper(args ...interface{}) string\n```\n\nurlEscaper produces an output that can be embedded in a URL query. The output can be embedded in an HTML attribute without further escaping. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#urlNormalizer",
              "documentation": {
                "identifier": "urlNormalizer",
                "newPage": false,
                "searchKey": "template.urlNormalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func urlNormalizer(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc urlNormalizer(args ...interface{}) string\n```\n\nurlNormalizer normalizes URL content so it can be embedded in a quote-delimited string or parenthesis delimited url(...). The normalizer does not encode all HTML specials. Specifically, it does not encode '&' so correct embedding in an HTML attribute requires escaping of '&' to '&amp;'. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#urlProcessor",
              "documentation": {
                "identifier": "urlProcessor",
                "newPage": false,
                "searchKey": "template.urlProcessor",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func urlProcessor(norm bool, args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc urlProcessor(norm bool, args ...interface{}) string\n```\n\nurlProcessor normalizes (when norm is true) or escapes its input to produce a valid hierarchical or opaque URL part. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#processURLOnto",
              "documentation": {
                "identifier": "processURLOnto",
                "newPage": false,
                "searchKey": "template.processURLOnto",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func processURLOnto(s string, norm bool, b *bytes.Buffer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc processURLOnto(s string, norm bool, b *bytes.Buffer) bool\n```\n\nprocessURLOnto appends a normalized URL corresponding to its input to b and reports whether the appended content differs from s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#srcsetFilterAndEscaper",
              "documentation": {
                "identifier": "srcsetFilterAndEscaper",
                "newPage": false,
                "searchKey": "template.srcsetFilterAndEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func srcsetFilterAndEscaper(args ...interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc srcsetFilterAndEscaper(args ...interface{}) string\n```\n\nFilters and normalizes srcset values which are comma separated URLs followed by metadata. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#isHTMLSpace",
              "documentation": {
                "identifier": "isHTMLSpace",
                "newPage": false,
                "searchKey": "template.isHTMLSpace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isHTMLSpace(c byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isHTMLSpace(c byte) bool\n```\n\nisHTMLSpace is true iff c is a whitespace character per [https://infra.spec.whatwg.org/#ascii-whitespace](https://infra.spec.whatwg.org/#ascii-whitespace) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#isHTMLSpaceOrASCIIAlnum",
              "documentation": {
                "identifier": "isHTMLSpaceOrASCIIAlnum",
                "newPage": false,
                "searchKey": "template.isHTMLSpaceOrASCIIAlnum",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isHTMLSpaceOrASCIIAlnum(c byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isHTMLSpaceOrASCIIAlnum(c byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#filterSrcsetElement",
              "documentation": {
                "identifier": "filterSrcsetElement",
                "newPage": false,
                "searchKey": "template.filterSrcsetElement",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func filterSrcsetElement(s string, left int, right int, b *bytes.Buffer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc filterSrcsetElement(s string, left int, right int, b *bytes.Buffer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestAddParseTreeHTML",
              "documentation": {
                "identifier": "TestAddParseTreeHTML",
                "newPage": false,
                "searchKey": "template.TestAddParseTreeHTML",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAddParseTreeHTML(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAddParseTreeHTML(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestClone",
              "documentation": {
                "identifier": "TestClone",
                "newPage": false,
                "searchKey": "template.TestClone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestClone(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestClone(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestTemplates",
              "documentation": {
                "identifier": "TestTemplates",
                "newPage": false,
                "searchKey": "template.TestTemplates",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTemplates(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTemplates(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestCloneCrash",
              "documentation": {
                "identifier": "TestCloneCrash",
                "newPage": false,
                "searchKey": "template.TestCloneCrash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloneCrash(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloneCrash(t *testing.T)\n```\n\nThis used to crash; [https://golang.org/issue/3281](https://golang.org/issue/3281) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestCloneThenParse",
              "documentation": {
                "identifier": "TestCloneThenParse",
                "newPage": false,
                "searchKey": "template.TestCloneThenParse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloneThenParse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloneThenParse(t *testing.T)\n```\n\nEnsure that this guarantee from the docs is upheld: \"Further calls to Parse in the copy will add templates to the copy but not to the original.\" \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestFuncMapWorksAfterClone",
              "documentation": {
                "identifier": "TestFuncMapWorksAfterClone",
                "newPage": false,
                "searchKey": "template.TestFuncMapWorksAfterClone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFuncMapWorksAfterClone(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFuncMapWorksAfterClone(t *testing.T)\n```\n\n[https://golang.org/issue/5980](https://golang.org/issue/5980) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestTemplateCloneExecuteRace",
              "documentation": {
                "identifier": "TestTemplateCloneExecuteRace",
                "newPage": false,
                "searchKey": "template.TestTemplateCloneExecuteRace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTemplateCloneExecuteRace(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTemplateCloneExecuteRace(t *testing.T)\n```\n\n[https://golang.org/issue/16101](https://golang.org/issue/16101) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestTemplateCloneLookup",
              "documentation": {
                "identifier": "TestTemplateCloneLookup",
                "newPage": false,
                "searchKey": "template.TestTemplateCloneLookup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTemplateCloneLookup(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTemplateCloneLookup(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestCloneGrowth",
              "documentation": {
                "identifier": "TestCloneGrowth",
                "newPage": false,
                "searchKey": "template.TestCloneGrowth",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloneGrowth(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloneGrowth(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestCloneRedefinedName",
              "documentation": {
                "identifier": "TestCloneRedefinedName",
                "newPage": false,
                "searchKey": "template.TestCloneRedefinedName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCloneRedefinedName(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCloneRedefinedName(t *testing.T)\n```\n\n[https://golang.org/issue/17735](https://golang.org/issue/17735) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestClonePipe",
              "documentation": {
                "identifier": "TestClonePipe",
                "newPage": false,
                "searchKey": "template.TestClonePipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestClonePipe(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestClonePipe(t *testing.T)\n```\n\nIssue 24791. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestTypedContent",
              "documentation": {
                "identifier": "TestTypedContent",
                "newPage": false,
                "searchKey": "template.TestTypedContent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTypedContent(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTypedContent(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestStringer",
              "documentation": {
                "identifier": "TestStringer",
                "newPage": false,
                "searchKey": "template.TestStringer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestStringer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestStringer(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEscapingNilNonemptyInterfaces",
              "documentation": {
                "identifier": "TestEscapingNilNonemptyInterfaces",
                "newPage": false,
                "searchKey": "template.TestEscapingNilNonemptyInterfaces",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEscapingNilNonemptyInterfaces(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEscapingNilNonemptyInterfaces(t *testing.T)\n```\n\n[https://golang.org/issue/5982](https://golang.org/issue/5982) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEndsWithCSSKeyword",
              "documentation": {
                "identifier": "TestEndsWithCSSKeyword",
                "newPage": false,
                "searchKey": "template.TestEndsWithCSSKeyword",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEndsWithCSSKeyword(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEndsWithCSSKeyword(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestIsCSSNmchar",
              "documentation": {
                "identifier": "TestIsCSSNmchar",
                "newPage": false,
                "searchKey": "template.TestIsCSSNmchar",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIsCSSNmchar(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIsCSSNmchar(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestDecodeCSS",
              "documentation": {
                "identifier": "TestDecodeCSS",
                "newPage": false,
                "searchKey": "template.TestDecodeCSS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDecodeCSS(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDecodeCSS(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestHexDecode",
              "documentation": {
                "identifier": "TestHexDecode",
                "newPage": false,
                "searchKey": "template.TestHexDecode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHexDecode(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHexDecode(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestSkipCSSSpace",
              "documentation": {
                "identifier": "TestSkipCSSSpace",
                "newPage": false,
                "searchKey": "template.TestSkipCSSSpace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSkipCSSSpace(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSkipCSSSpace(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestCSSEscaper",
              "documentation": {
                "identifier": "TestCSSEscaper",
                "newPage": false,
                "searchKey": "template.TestCSSEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCSSEscaper(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCSSEscaper(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestCSSValueFilter",
              "documentation": {
                "identifier": "TestCSSValueFilter",
                "newPage": false,
                "searchKey": "template.TestCSSValueFilter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCSSValueFilter(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCSSValueFilter(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkCSSEscaper",
              "documentation": {
                "identifier": "BenchmarkCSSEscaper",
                "newPage": false,
                "searchKey": "template.BenchmarkCSSEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkCSSEscaper(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkCSSEscaper(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkCSSEscaperNoSpecials",
              "documentation": {
                "identifier": "BenchmarkCSSEscaperNoSpecials",
                "newPage": false,
                "searchKey": "template.BenchmarkCSSEscaperNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkCSSEscaperNoSpecials(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkCSSEscaperNoSpecials(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkDecodeCSS",
              "documentation": {
                "identifier": "BenchmarkDecodeCSS",
                "newPage": false,
                "searchKey": "template.BenchmarkDecodeCSS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkDecodeCSS(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkDecodeCSS(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkDecodeCSSNoSpecials",
              "documentation": {
                "identifier": "BenchmarkDecodeCSSNoSpecials",
                "newPage": false,
                "searchKey": "template.BenchmarkDecodeCSSNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkDecodeCSSNoSpecials(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkDecodeCSSNoSpecials(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkCSSValueFilter",
              "documentation": {
                "identifier": "BenchmarkCSSValueFilter",
                "newPage": false,
                "searchKey": "template.BenchmarkCSSValueFilter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkCSSValueFilter(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkCSSValueFilter(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkCSSValueFilterOk",
              "documentation": {
                "identifier": "BenchmarkCSSValueFilterOk",
                "newPage": false,
                "searchKey": "template.BenchmarkCSSValueFilterOk",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkCSSValueFilterOk(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkCSSValueFilterOk(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEscape",
              "documentation": {
                "identifier": "TestEscape",
                "newPage": false,
                "searchKey": "template.TestEscape",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEscape(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEscape(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEscapeMap",
              "documentation": {
                "identifier": "TestEscapeMap",
                "newPage": false,
                "searchKey": "template.TestEscapeMap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEscapeMap(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEscapeMap(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEscapeSet",
              "documentation": {
                "identifier": "TestEscapeSet",
                "newPage": false,
                "searchKey": "template.TestEscapeSet",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEscapeSet(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEscapeSet(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestErrors",
              "documentation": {
                "identifier": "TestErrors",
                "newPage": false,
                "searchKey": "template.TestErrors",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestErrors(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestErrors(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEscapeText",
              "documentation": {
                "identifier": "TestEscapeText",
                "newPage": false,
                "searchKey": "template.TestEscapeText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEscapeText(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEscapeText(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEnsurePipelineContains",
              "documentation": {
                "identifier": "TestEnsurePipelineContains",
                "newPage": false,
                "searchKey": "template.TestEnsurePipelineContains",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEnsurePipelineContains(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEnsurePipelineContains(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEscapeMalformedPipelines",
              "documentation": {
                "identifier": "TestEscapeMalformedPipelines",
                "newPage": false,
                "searchKey": "template.TestEscapeMalformedPipelines",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEscapeMalformedPipelines(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEscapeMalformedPipelines(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEscapeErrorsNotIgnorable",
              "documentation": {
                "identifier": "TestEscapeErrorsNotIgnorable",
                "newPage": false,
                "searchKey": "template.TestEscapeErrorsNotIgnorable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEscapeErrorsNotIgnorable(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEscapeErrorsNotIgnorable(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEscapeSetErrorsNotIgnorable",
              "documentation": {
                "identifier": "TestEscapeSetErrorsNotIgnorable",
                "newPage": false,
                "searchKey": "template.TestEscapeSetErrorsNotIgnorable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEscapeSetErrorsNotIgnorable(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEscapeSetErrorsNotIgnorable(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestRedundantFuncs",
              "documentation": {
                "identifier": "TestRedundantFuncs",
                "newPage": false,
                "searchKey": "template.TestRedundantFuncs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRedundantFuncs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRedundantFuncs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestIndirectPrint",
              "documentation": {
                "identifier": "TestIndirectPrint",
                "newPage": false,
                "searchKey": "template.TestIndirectPrint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIndirectPrint(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIndirectPrint(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEmptyTemplateHTML",
              "documentation": {
                "identifier": "TestEmptyTemplateHTML",
                "newPage": false,
                "searchKey": "template.TestEmptyTemplateHTML",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEmptyTemplateHTML(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEmptyTemplateHTML(t *testing.T)\n```\n\nThis is a test for issue 3272. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestPipeToMethodIsEscaped",
              "documentation": {
                "identifier": "TestPipeToMethodIsEscaped",
                "newPage": false,
                "searchKey": "template.TestPipeToMethodIsEscaped",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestPipeToMethodIsEscaped(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestPipeToMethodIsEscaped(t *testing.T)\n```\n\nThis is a test for issue 7379: type assertion error caused panic, and then the code to handle the panic breaks escaping. It's hard to see the second problem once the first is fixed, but its fix is trivial so we let that go. See the discussion for issue 7379. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestErrorOnUndefined",
              "documentation": {
                "identifier": "TestErrorOnUndefined",
                "newPage": false,
                "searchKey": "template.TestErrorOnUndefined",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestErrorOnUndefined(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestErrorOnUndefined(t *testing.T)\n```\n\nUnlike text/template, html/template crashed if given an incomplete template, that is, a template that had been named but not given any content. This is issue #10204. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestIdempotentExecute",
              "documentation": {
                "identifier": "TestIdempotentExecute",
                "newPage": false,
                "searchKey": "template.TestIdempotentExecute",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIdempotentExecute(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIdempotentExecute(t *testing.T)\n```\n\nThis covers issue #20842. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkEscapedExecute",
              "documentation": {
                "identifier": "BenchmarkEscapedExecute",
                "newPage": false,
                "searchKey": "template.BenchmarkEscapedExecute",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkEscapedExecute(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkEscapedExecute(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestOrphanedTemplate",
              "documentation": {
                "identifier": "TestOrphanedTemplate",
                "newPage": false,
                "searchKey": "template.TestOrphanedTemplate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestOrphanedTemplate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestOrphanedTemplate(t *testing.T)\n```\n\nCovers issue 22780. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestAliasedParseTreeDoesNotOverescape",
              "documentation": {
                "identifier": "TestAliasedParseTreeDoesNotOverescape",
                "newPage": false,
                "searchKey": "template.TestAliasedParseTreeDoesNotOverescape",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAliasedParseTreeDoesNotOverescape(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAliasedParseTreeDoesNotOverescape(t *testing.T)\n```\n\nCovers issue 21844. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#newInt",
              "documentation": {
                "identifier": "newInt",
                "newPage": false,
                "searchKey": "template.newInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newInt(n int) *int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newInt(n int) *int\n```\n\nHelpers for creation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#newString",
              "documentation": {
                "identifier": "newString",
                "newPage": false,
                "searchKey": "template.newString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newString(s string) *string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newString(s string) *string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#newIntSlice",
              "documentation": {
                "identifier": "newIntSlice",
                "newPage": false,
                "searchKey": "template.newIntSlice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newIntSlice(n ...int) *[]int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newIntSlice(n ...int) *[]int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#typeOf",
              "documentation": {
                "identifier": "typeOf",
                "newPage": false,
                "searchKey": "template.typeOf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typeOf(arg interface{}) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typeOf(arg interface{}) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#zeroArgs",
              "documentation": {
                "identifier": "zeroArgs",
                "newPage": false,
                "searchKey": "template.zeroArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func zeroArgs() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc zeroArgs() string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#oneArg",
              "documentation": {
                "identifier": "oneArg",
                "newPage": false,
                "searchKey": "template.oneArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func oneArg(a string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc oneArg(a string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#twoArgs",
              "documentation": {
                "identifier": "twoArgs",
                "newPage": false,
                "searchKey": "template.twoArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func twoArgs(a, b string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc twoArgs(a, b string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#dddArg",
              "documentation": {
                "identifier": "dddArg",
                "newPage": false,
                "searchKey": "template.dddArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dddArg(a int, b ...string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dddArg(a int, b ...string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#count",
              "documentation": {
                "identifier": "count",
                "newPage": false,
                "searchKey": "template.count",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func count(n int) chan string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc count(n int) chan string\n```\n\ncount returns a channel that will deliver n sequential 1-letter strings starting at \"a\" \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#vfunc",
              "documentation": {
                "identifier": "vfunc",
                "newPage": false,
                "searchKey": "template.vfunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func vfunc(V, *V) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc vfunc(V, *V) string\n```\n\nvfunc takes a *V and a V \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#valueString",
              "documentation": {
                "identifier": "valueString",
                "newPage": false,
                "searchKey": "template.valueString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func valueString(v string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc valueString(v string) string\n```\n\nvalueString takes a string, not a pointer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#returnInt",
              "documentation": {
                "identifier": "returnInt",
                "newPage": false,
                "searchKey": "template.returnInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func returnInt() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc returnInt() int\n```\n\nreturnInt returns an int \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#add",
              "documentation": {
                "identifier": "add",
                "newPage": false,
                "searchKey": "template.add",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func add(args ...int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc add(args ...int) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#echo",
              "documentation": {
                "identifier": "echo",
                "newPage": false,
                "searchKey": "template.echo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func echo(arg interface{}) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc echo(arg interface{}) interface{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#makemap",
              "documentation": {
                "identifier": "makemap",
                "newPage": false,
                "searchKey": "template.makemap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makemap(arg ...string) map[string]string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makemap(arg ...string) map[string]string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#stringer",
              "documentation": {
                "identifier": "stringer",
                "newPage": false,
                "searchKey": "template.stringer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringer(s fmt.Stringer) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringer(s fmt.Stringer) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#mapOfThree",
              "documentation": {
                "identifier": "mapOfThree",
                "newPage": false,
                "searchKey": "template.mapOfThree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapOfThree() interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapOfThree() interface{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#testExecute",
              "documentation": {
                "identifier": "testExecute",
                "newPage": false,
                "searchKey": "template.testExecute",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testExecute(execTests []execTest, template *Template, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testExecute(execTests []execTest, template *Template, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestExecute",
              "documentation": {
                "identifier": "TestExecute",
                "newPage": false,
                "searchKey": "template.TestExecute",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecute(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecute(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestDelims",
              "documentation": {
                "identifier": "TestDelims",
                "newPage": false,
                "searchKey": "template.TestDelims",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDelims(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDelims(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestExecuteError",
              "documentation": {
                "identifier": "TestExecuteError",
                "newPage": false,
                "searchKey": "template.TestExecuteError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecuteError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecuteError(t *testing.T)\n```\n\nCheck that an error from a method flows back to the top. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestExecError",
              "documentation": {
                "identifier": "TestExecError",
                "newPage": false,
                "searchKey": "template.TestExecError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecError(t *testing.T)\n```\n\nCheck that an error from a nested template contains all the relevant information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestJSEscaping",
              "documentation": {
                "identifier": "TestJSEscaping",
                "newPage": false,
                "searchKey": "template.TestJSEscaping",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestJSEscaping(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestJSEscaping(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestTree",
              "documentation": {
                "identifier": "TestTree",
                "newPage": false,
                "searchKey": "template.TestTree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTree(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTree(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestExecuteOnNewTemplate",
              "documentation": {
                "identifier": "TestExecuteOnNewTemplate",
                "newPage": false,
                "searchKey": "template.TestExecuteOnNewTemplate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecuteOnNewTemplate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecuteOnNewTemplate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestMessageForExecuteEmpty",
              "documentation": {
                "identifier": "TestMessageForExecuteEmpty",
                "newPage": false,
                "searchKey": "template.TestMessageForExecuteEmpty",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMessageForExecuteEmpty(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMessageForExecuteEmpty(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestFinalForPrintf",
              "documentation": {
                "identifier": "TestFinalForPrintf",
                "newPage": false,
                "searchKey": "template.TestFinalForPrintf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFinalForPrintf(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFinalForPrintf(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestComparison",
              "documentation": {
                "identifier": "TestComparison",
                "newPage": false,
                "searchKey": "template.TestComparison",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestComparison(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestComparison(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestMissingMapKey",
              "documentation": {
                "identifier": "TestMissingMapKey",
                "newPage": false,
                "searchKey": "template.TestMissingMapKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMissingMapKey(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMissingMapKey(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestUnterminatedStringError",
              "documentation": {
                "identifier": "TestUnterminatedStringError",
                "newPage": false,
                "searchKey": "template.TestUnterminatedStringError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUnterminatedStringError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUnterminatedStringError(t *testing.T)\n```\n\nTest that the error message for multiline unterminated string refers to the line number of the opening quote. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestExecuteGivesExecError",
              "documentation": {
                "identifier": "TestExecuteGivesExecError",
                "newPage": false,
                "searchKey": "template.TestExecuteGivesExecError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecuteGivesExecError(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecuteGivesExecError(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#funcNameTestFunc",
              "documentation": {
                "identifier": "funcNameTestFunc",
                "newPage": false,
                "searchKey": "template.funcNameTestFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcNameTestFunc() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcNameTestFunc() int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestGoodFuncNames",
              "documentation": {
                "identifier": "TestGoodFuncNames",
                "newPage": false,
                "searchKey": "template.TestGoodFuncNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGoodFuncNames(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGoodFuncNames(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestBadFuncNames",
              "documentation": {
                "identifier": "TestBadFuncNames",
                "newPage": false,
                "searchKey": "template.TestBadFuncNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBadFuncNames(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBadFuncNames(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#testBadFuncName",
              "documentation": {
                "identifier": "testBadFuncName",
                "newPage": false,
                "searchKey": "template.testBadFuncName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testBadFuncName(name string, t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testBadFuncName(name string, t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestBlock",
              "documentation": {
                "identifier": "TestBlock",
                "newPage": false,
                "searchKey": "template.TestBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBlock(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBlock(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEvalFieldErrors",
              "documentation": {
                "identifier": "TestEvalFieldErrors",
                "newPage": false,
                "searchKey": "template.TestEvalFieldErrors",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEvalFieldErrors(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEvalFieldErrors(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestMaxExecDepth",
              "documentation": {
                "identifier": "TestMaxExecDepth",
                "newPage": false,
                "searchKey": "template.TestMaxExecDepth",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMaxExecDepth(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMaxExecDepth(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestAddrOfIndex",
              "documentation": {
                "identifier": "TestAddrOfIndex",
                "newPage": false,
                "searchKey": "template.TestAddrOfIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAddrOfIndex(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAddrOfIndex(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestInterfaceValues",
              "documentation": {
                "identifier": "TestInterfaceValues",
                "newPage": false,
                "searchKey": "template.TestInterfaceValues",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestInterfaceValues(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestInterfaceValues(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestExecutePanicDuringCall",
              "documentation": {
                "identifier": "TestExecutePanicDuringCall",
                "newPage": false,
                "searchKey": "template.TestExecutePanicDuringCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExecutePanicDuringCall(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExecutePanicDuringCall(t *testing.T)\n```\n\nCheck that panics during calls are recovered and returned as errors. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestIssue31810",
              "documentation": {
                "identifier": "TestIssue31810",
                "newPage": false,
                "searchKey": "template.TestIssue31810",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue31810(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue31810(t *testing.T)\n```\n\nIssue 31810. Check that a parenthesized first argument behaves properly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEscapeRace",
              "documentation": {
                "identifier": "TestEscapeRace",
                "newPage": false,
                "searchKey": "template.TestEscapeRace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEscapeRace(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEscapeRace(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestRecursiveExecute",
              "documentation": {
                "identifier": "TestRecursiveExecute",
                "newPage": false,
                "searchKey": "template.TestRecursiveExecute",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRecursiveExecute(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRecursiveExecute(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestRecursiveExecuteViaMethod",
              "documentation": {
                "identifier": "TestRecursiveExecuteViaMethod",
                "newPage": false,
                "searchKey": "template.TestRecursiveExecuteViaMethod",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRecursiveExecuteViaMethod(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRecursiveExecuteViaMethod(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestTemplateFuncsAfterClone",
              "documentation": {
                "identifier": "TestTemplateFuncsAfterClone",
                "newPage": false,
                "searchKey": "template.TestTemplateFuncsAfterClone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTemplateFuncsAfterClone(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTemplateFuncsAfterClone(t *testing.T)\n```\n\nIssue 43295. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestHTMLNospaceEscaper",
              "documentation": {
                "identifier": "TestHTMLNospaceEscaper",
                "newPage": false,
                "searchKey": "template.TestHTMLNospaceEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHTMLNospaceEscaper(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHTMLNospaceEscaper(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestStripTags",
              "documentation": {
                "identifier": "TestStripTags",
                "newPage": false,
                "searchKey": "template.TestStripTags",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestStripTags(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestStripTags(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkHTMLNospaceEscaper",
              "documentation": {
                "identifier": "BenchmarkHTMLNospaceEscaper",
                "newPage": false,
                "searchKey": "template.BenchmarkHTMLNospaceEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkHTMLNospaceEscaper(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkHTMLNospaceEscaper(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkHTMLNospaceEscaperNoSpecials",
              "documentation": {
                "identifier": "BenchmarkHTMLNospaceEscaperNoSpecials",
                "newPage": false,
                "searchKey": "template.BenchmarkHTMLNospaceEscaperNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkHTMLNospaceEscaperNoSpecials(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkHTMLNospaceEscaperNoSpecials(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkStripTags",
              "documentation": {
                "identifier": "BenchmarkStripTags",
                "newPage": false,
                "searchKey": "template.BenchmarkStripTags",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkStripTags(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkStripTags(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkStripTagsNoSpecials",
              "documentation": {
                "identifier": "BenchmarkStripTagsNoSpecials",
                "newPage": false,
                "searchKey": "template.BenchmarkStripTagsNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkStripTagsNoSpecials(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkStripTagsNoSpecials(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestNextJsCtx",
              "documentation": {
                "identifier": "TestNextJsCtx",
                "newPage": false,
                "searchKey": "template.TestNextJsCtx",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNextJsCtx(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNextJsCtx(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestJSValEscaper",
              "documentation": {
                "identifier": "TestJSValEscaper",
                "newPage": false,
                "searchKey": "template.TestJSValEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestJSValEscaper(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestJSValEscaper(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestJSStrEscaper",
              "documentation": {
                "identifier": "TestJSStrEscaper",
                "newPage": false,
                "searchKey": "template.TestJSStrEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestJSStrEscaper(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestJSStrEscaper(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestJSRegexpEscaper",
              "documentation": {
                "identifier": "TestJSRegexpEscaper",
                "newPage": false,
                "searchKey": "template.TestJSRegexpEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestJSRegexpEscaper(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestJSRegexpEscaper(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEscapersOnLower7AndSelectHighCodepoints",
              "documentation": {
                "identifier": "TestEscapersOnLower7AndSelectHighCodepoints",
                "newPage": false,
                "searchKey": "template.TestEscapersOnLower7AndSelectHighCodepoints",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEscapersOnLower7AndSelectHighCodepoints(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEscapersOnLower7AndSelectHighCodepoints(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestIsJsMimeType",
              "documentation": {
                "identifier": "TestIsJsMimeType",
                "newPage": false,
                "searchKey": "template.TestIsJsMimeType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIsJsMimeType(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIsJsMimeType(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkJSValEscaperWithNum",
              "documentation": {
                "identifier": "BenchmarkJSValEscaperWithNum",
                "newPage": false,
                "searchKey": "template.BenchmarkJSValEscaperWithNum",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkJSValEscaperWithNum(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkJSValEscaperWithNum(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkJSValEscaperWithStr",
              "documentation": {
                "identifier": "BenchmarkJSValEscaperWithStr",
                "newPage": false,
                "searchKey": "template.BenchmarkJSValEscaperWithStr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkJSValEscaperWithStr(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkJSValEscaperWithStr(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkJSValEscaperWithStrNoSpecials",
              "documentation": {
                "identifier": "BenchmarkJSValEscaperWithStrNoSpecials",
                "newPage": false,
                "searchKey": "template.BenchmarkJSValEscaperWithStrNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkJSValEscaperWithStrNoSpecials(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkJSValEscaperWithStrNoSpecials(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkJSValEscaperWithObj",
              "documentation": {
                "identifier": "BenchmarkJSValEscaperWithObj",
                "newPage": false,
                "searchKey": "template.BenchmarkJSValEscaperWithObj",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkJSValEscaperWithObj(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkJSValEscaperWithObj(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkJSValEscaperWithObjNoSpecials",
              "documentation": {
                "identifier": "BenchmarkJSValEscaperWithObjNoSpecials",
                "newPage": false,
                "searchKey": "template.BenchmarkJSValEscaperWithObjNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkJSValEscaperWithObjNoSpecials(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkJSValEscaperWithObjNoSpecials(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkJSStrEscaperNoSpecials",
              "documentation": {
                "identifier": "BenchmarkJSStrEscaperNoSpecials",
                "newPage": false,
                "searchKey": "template.BenchmarkJSStrEscaperNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkJSStrEscaperNoSpecials(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkJSStrEscaperNoSpecials(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkJSStrEscaper",
              "documentation": {
                "identifier": "BenchmarkJSStrEscaper",
                "newPage": false,
                "searchKey": "template.BenchmarkJSStrEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkJSStrEscaper(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkJSStrEscaper(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkJSRegexpEscaperNoSpecials",
              "documentation": {
                "identifier": "BenchmarkJSRegexpEscaperNoSpecials",
                "newPage": false,
                "searchKey": "template.BenchmarkJSRegexpEscaperNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkJSRegexpEscaperNoSpecials(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkJSRegexpEscaperNoSpecials(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkJSRegexpEscaper",
              "documentation": {
                "identifier": "BenchmarkJSRegexpEscaper",
                "newPage": false,
                "searchKey": "template.BenchmarkJSRegexpEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkJSRegexpEscaper(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkJSRegexpEscaper(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestMultiExecute",
              "documentation": {
                "identifier": "TestMultiExecute",
                "newPage": false,
                "searchKey": "template.TestMultiExecute",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMultiExecute(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMultiExecute(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestParseFiles",
              "documentation": {
                "identifier": "TestParseFiles",
                "newPage": false,
                "searchKey": "template.TestParseFiles",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseFiles(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseFiles(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestParseGlob",
              "documentation": {
                "identifier": "TestParseGlob",
                "newPage": false,
                "searchKey": "template.TestParseGlob",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseGlob(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseGlob(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestParseFS",
              "documentation": {
                "identifier": "TestParseFS",
                "newPage": false,
                "searchKey": "template.TestParseFS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseFS(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseFS(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestParseFilesWithData",
              "documentation": {
                "identifier": "TestParseFilesWithData",
                "newPage": false,
                "searchKey": "template.TestParseFilesWithData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseFilesWithData(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseFilesWithData(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestParseGlobWithData",
              "documentation": {
                "identifier": "TestParseGlobWithData",
                "newPage": false,
                "searchKey": "template.TestParseGlobWithData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseGlobWithData(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseGlobWithData(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestParseZipFS",
              "documentation": {
                "identifier": "TestParseZipFS",
                "newPage": false,
                "searchKey": "template.TestParseZipFS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseZipFS(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseZipFS(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestAddParseTreeToUnparsedTemplate",
              "documentation": {
                "identifier": "TestAddParseTreeToUnparsedTemplate",
                "newPage": false,
                "searchKey": "template.TestAddParseTreeToUnparsedTemplate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAddParseTreeToUnparsedTemplate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAddParseTreeToUnparsedTemplate(t *testing.T)\n```\n\nIssue 7032 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestRedefinition",
              "documentation": {
                "identifier": "TestRedefinition",
                "newPage": false,
                "searchKey": "template.TestRedefinition",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRedefinition(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRedefinition(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEmptyTemplateCloneCrash",
              "documentation": {
                "identifier": "TestEmptyTemplateCloneCrash",
                "newPage": false,
                "searchKey": "template.TestEmptyTemplateCloneCrash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEmptyTemplateCloneCrash(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEmptyTemplateCloneCrash(t *testing.T)\n```\n\nIssue 10879 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestTemplateLookUp",
              "documentation": {
                "identifier": "TestTemplateLookUp",
                "newPage": false,
                "searchKey": "template.TestTemplateLookUp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTemplateLookUp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTemplateLookUp(t *testing.T)\n```\n\nIssue 10910, 10926 \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestParse",
              "documentation": {
                "identifier": "TestParse",
                "newPage": false,
                "searchKey": "template.TestParse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParse(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestEmptyTemplate",
              "documentation": {
                "identifier": "TestEmptyTemplate",
                "newPage": false,
                "searchKey": "template.TestEmptyTemplate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestEmptyTemplate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestEmptyTemplate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestIssue19294",
              "documentation": {
                "identifier": "TestIssue19294",
                "newPage": false,
                "searchKey": "template.TestIssue19294",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue19294(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue19294(t *testing.T)\n```\n\nIssue 19249 was a regression in 1.8 caused by the handling of empty templates added in that release, which got different answers depending on the order templates appeared in the internal map. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestFindEndTag",
              "documentation": {
                "identifier": "TestFindEndTag",
                "newPage": false,
                "searchKey": "template.TestFindEndTag",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFindEndTag(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFindEndTag(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkTemplateSpecialTags",
              "documentation": {
                "identifier": "BenchmarkTemplateSpecialTags",
                "newPage": false,
                "searchKey": "template.BenchmarkTemplateSpecialTags",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkTemplateSpecialTags(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkTemplateSpecialTags(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestURLNormalizer",
              "documentation": {
                "identifier": "TestURLNormalizer",
                "newPage": false,
                "searchKey": "template.TestURLNormalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestURLNormalizer(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestURLNormalizer(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestURLFilters",
              "documentation": {
                "identifier": "TestURLFilters",
                "newPage": false,
                "searchKey": "template.TestURLFilters",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestURLFilters(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestURLFilters(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#TestSrcsetFilter",
              "documentation": {
                "identifier": "TestSrcsetFilter",
                "newPage": false,
                "searchKey": "template.TestSrcsetFilter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSrcsetFilter(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSrcsetFilter(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkURLEscaper",
              "documentation": {
                "identifier": "BenchmarkURLEscaper",
                "newPage": false,
                "searchKey": "template.BenchmarkURLEscaper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkURLEscaper(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkURLEscaper(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkURLEscaperNoSpecials",
              "documentation": {
                "identifier": "BenchmarkURLEscaperNoSpecials",
                "newPage": false,
                "searchKey": "template.BenchmarkURLEscaperNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkURLEscaperNoSpecials(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkURLEscaperNoSpecials(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkURLNormalizer",
              "documentation": {
                "identifier": "BenchmarkURLNormalizer",
                "newPage": false,
                "searchKey": "template.BenchmarkURLNormalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkURLNormalizer(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkURLNormalizer(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkURLNormalizerNoSpecials",
              "documentation": {
                "identifier": "BenchmarkURLNormalizerNoSpecials",
                "newPage": false,
                "searchKey": "template.BenchmarkURLNormalizerNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkURLNormalizerNoSpecials(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkURLNormalizerNoSpecials(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkSrcsetFilter",
              "documentation": {
                "identifier": "BenchmarkSrcsetFilter",
                "newPage": false,
                "searchKey": "template.BenchmarkSrcsetFilter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkSrcsetFilter(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkSrcsetFilter(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/html/template#BenchmarkSrcsetFilterNoSpecials",
              "documentation": {
                "identifier": "BenchmarkSrcsetFilterNoSpecials",
                "newPage": false,
                "searchKey": "template.BenchmarkSrcsetFilterNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkSrcsetFilterNoSpecials(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkSrcsetFilterNoSpecials(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
