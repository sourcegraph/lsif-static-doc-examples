{
  "pathID": "/std/regexp/syntax",
  "documentation": {
    "identifier": "syntax",
    "newPage": true,
    "searchKey": "std/regexp/syntax",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package syntax"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package syntax parses regular expressions into parse trees and compiles parse trees into programs. Most clients of regular expressions will use the facilities of package regexp (such as Compile and Match) instead of this package. \n\n### hdr-SyntaxSyntax\nThe regular expression syntax understood by this package when parsing with the Perl flag is as follows. Parts of the syntax can be disabled by passing alternate flags to Parse. \n\nSingle characters: \n\n```\n.              any character, possibly including newline (flag s=true)\n[xyz]          character class\n[^xyz]         negated character class\n\\d             Perl character class\n\\D             negated Perl character class\n[[:alpha:]]    ASCII character class\n[[:^alpha:]]   negated ASCII character class\n\\pN            Unicode character class (one-letter name)\n\\p{Greek}      Unicode character class\n\\PN            negated Unicode character class (one-letter name)\n\\P{Greek}      negated Unicode character class\n\n```\nComposites: \n\n```\nxy             x followed by y\nx|y            x or y (prefer x)\n\n```\nRepetitions: \n\n```\nx*             zero or more x, prefer more\nx+             one or more x, prefer more\nx?             zero or one x, prefer one\nx{n,m}         n or n+1 or ... or m x, prefer more\nx{n,}          n or more x, prefer more\nx{n}           exactly n x\nx*?            zero or more x, prefer fewer\nx+?            one or more x, prefer fewer\nx??            zero or one x, prefer zero\nx{n,m}?        n or n+1 or ... or m x, prefer fewer\nx{n,}?         n or more x, prefer fewer\nx{n}?          exactly n x\n\n```\nImplementation restriction: The counting forms x{n,m}, x{n,}, and x{n} reject forms that create a minimum or maximum repetition count above 1000. Unlimited repetitions are not subject to this restriction. \n\nGrouping: \n\n```\n(re)           numbered capturing group (submatch)\n(?P<name>re)   named & numbered capturing group (submatch)\n(?:re)         non-capturing group\n(?flags)       set flags within current group; non-capturing\n(?flags:re)    set flags during re; non-capturing\n\nFlag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:\n\ni              case-insensitive (default false)\nm              multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false)\ns              let . match \\n (default false)\nU              ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)\n\n```\nEmpty strings: \n\n```\n^              at beginning of text or line (flag m=true)\n$              at end of text (like \\z not \\Z) or line (flag m=true)\n\\A             at beginning of text\n\\b             at ASCII word boundary (\\w on one side and \\W, \\A, or \\z on the other)\n\\B             not at ASCII word boundary\n\\z             at end of text\n\n```\nEscape sequences: \n\n```\n\\a             bell (== \\007)\n\\f             form feed (== \\014)\n\\t             horizontal tab (== \\011)\n\\n             newline (== \\012)\n\\r             carriage return (== \\015)\n\\v             vertical tab character (== \\013)\n\\*             literal *, for any punctuation character *\n\\123           octal character code (up to three digits)\n\\x7F           hex character code (exactly two digits)\n\\x{10FFFF}     hex character code\n\\Q...\\E        literal text ... even if ... has punctuation\n\n```\nCharacter class elements: \n\n```\nx              single character\nA-Z            character range (inclusive)\n\\d             Perl character class\n[:foo:]        ASCII character class foo\n\\p{Foo}        Unicode character class Foo\n\\pF            Unicode character class F (one-letter name)\n\n```\nNamed character classes as character class elements: \n\n```\n[\\d]           digits (== \\d)\n[^\\d]          not digits (== \\D)\n[\\D]           not digits (== \\D)\n[^\\D]          not not digits (== \\d)\n[[:name:]]     named ASCII class inside character class (== [:name:])\n[^[:name:]]    named ASCII class inside negated character class (== [:^name:])\n[\\p{Name}]     named Unicode property inside character class (== \\p{Name})\n[^\\p{Name}]    named Unicode property inside negated character class (== \\P{Name})\n\n```\nPerl character classes (all ASCII-only): \n\n```\n\\d             digits (== [0-9])\n\\D             not digits (== [^0-9])\n\\s             whitespace (== [\\t\\n\\f\\r ])\n\\S             not whitespace (== [^\\t\\n\\f\\r ])\n\\w             word characters (== [0-9A-Za-z_])\n\\W             not word characters (== [^0-9A-Za-z_])\n\n```\nASCII character classes: \n\n```\n[[:alnum:]]    alphanumeric (== [0-9A-Za-z])\n[[:alpha:]]    alphabetic (== [A-Za-z])\n[[:ascii:]]    ASCII (== [\\x00-\\x7F])\n[[:blank:]]    blank (== [\\t ])\n[[:cntrl:]]    control (== [\\x00-\\x1F\\x7F])\n[[:digit:]]    digits (== [0-9])\n[[:graph:]]    graphical (== [!-~] == [A-Za-z0-9!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])\n[[:lower:]]    lower case (== [a-z])\n[[:print:]]    printable (== [ -~] == [ [:graph:]])\n[[:punct:]]    punctuation (== [!-/:-@[-`{-~])\n[[:space:]]    whitespace (== [\\t\\n\\v\\f\\r ])\n[[:upper:]]    upper case (== [A-Z])\n[[:word:]]     word characters (== [0-9A-Za-z_])\n[[:xdigit:]]   hex digit (== [0-9A-Fa-f])\n\n```\nUnicode character classes are those in unicode.Categories and unicode.Scripts. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/std/regexp/syntax#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/regexp/syntax#_Op_name_0",
              "documentation": {
                "identifier": "_Op_name_0",
                "newPage": false,
                "searchKey": "syntax._Op_name_0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Op_name_0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Op_name_0 = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#_Op_name_1",
              "documentation": {
                "identifier": "_Op_name_1",
                "newPage": false,
                "searchKey": "syntax._Op_name_1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Op_name_1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Op_name_1 = \"opPseudo\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrInternalError",
              "documentation": {
                "identifier": "ErrInternalError",
                "newPage": false,
                "searchKey": "syntax.ErrInternalError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrInternalError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrInternalError ErrorCode = \"regexp/syntax: internal error\"\n```\n\nUnexpected error \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrInvalidCharClass",
              "documentation": {
                "identifier": "ErrInvalidCharClass",
                "newPage": false,
                "searchKey": "syntax.ErrInvalidCharClass",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrInvalidCharClass"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrInvalidCharClass ErrorCode = \"invalid character class\"\n```\n\nParse errors \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrInvalidCharRange",
              "documentation": {
                "identifier": "ErrInvalidCharRange",
                "newPage": false,
                "searchKey": "syntax.ErrInvalidCharRange",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrInvalidCharRange"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrInvalidCharRange ErrorCode = \"invalid character class range\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrInvalidEscape",
              "documentation": {
                "identifier": "ErrInvalidEscape",
                "newPage": false,
                "searchKey": "syntax.ErrInvalidEscape",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrInvalidEscape"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrInvalidEscape ErrorCode = \"invalid escape sequence\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrInvalidNamedCapture",
              "documentation": {
                "identifier": "ErrInvalidNamedCapture",
                "newPage": false,
                "searchKey": "syntax.ErrInvalidNamedCapture",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrInvalidNamedCapture"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrInvalidNamedCapture ErrorCode = \"invalid named capture\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrInvalidPerlOp",
              "documentation": {
                "identifier": "ErrInvalidPerlOp",
                "newPage": false,
                "searchKey": "syntax.ErrInvalidPerlOp",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrInvalidPerlOp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrInvalidPerlOp ErrorCode = \"invalid or unsupported Perl syntax\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrInvalidRepeatOp",
              "documentation": {
                "identifier": "ErrInvalidRepeatOp",
                "newPage": false,
                "searchKey": "syntax.ErrInvalidRepeatOp",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrInvalidRepeatOp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrInvalidRepeatOp ErrorCode = \"invalid nested repetition operator\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrInvalidRepeatSize",
              "documentation": {
                "identifier": "ErrInvalidRepeatSize",
                "newPage": false,
                "searchKey": "syntax.ErrInvalidRepeatSize",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrInvalidRepeatSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrInvalidRepeatSize ErrorCode = \"invalid repeat count\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrInvalidUTF8",
              "documentation": {
                "identifier": "ErrInvalidUTF8",
                "newPage": false,
                "searchKey": "syntax.ErrInvalidUTF8",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrInvalidUTF8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrInvalidUTF8 ErrorCode = \"invalid UTF-8\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrMissingBracket",
              "documentation": {
                "identifier": "ErrMissingBracket",
                "newPage": false,
                "searchKey": "syntax.ErrMissingBracket",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrMissingBracket"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrMissingBracket ErrorCode = \"missing closing ]\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrMissingParen",
              "documentation": {
                "identifier": "ErrMissingParen",
                "newPage": false,
                "searchKey": "syntax.ErrMissingParen",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrMissingParen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrMissingParen ErrorCode = \"missing closing )\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrMissingRepeatArgument",
              "documentation": {
                "identifier": "ErrMissingRepeatArgument",
                "newPage": false,
                "searchKey": "syntax.ErrMissingRepeatArgument",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrMissingRepeatArgument"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrMissingRepeatArgument ErrorCode = \"missing argument to repetition operator\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrTrailingBackslash",
              "documentation": {
                "identifier": "ErrTrailingBackslash",
                "newPage": false,
                "searchKey": "syntax.ErrTrailingBackslash",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrTrailingBackslash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrTrailingBackslash ErrorCode = \"trailing backslash at end of expression\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrUnexpectedParen",
              "documentation": {
                "identifier": "ErrUnexpectedParen",
                "newPage": false,
                "searchKey": "syntax.ErrUnexpectedParen",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ErrUnexpectedParen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ErrUnexpectedParen ErrorCode = \"unexpected )\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#FoldCase",
              "documentation": {
                "identifier": "FoldCase",
                "newPage": false,
                "searchKey": "syntax.FoldCase",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const FoldCase"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst FoldCase Flags = 1 << iota // case-insensitive match\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#Literal",
              "documentation": {
                "identifier": "Literal",
                "newPage": false,
                "searchKey": "syntax.Literal",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Literal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Literal // treat pattern as literal string\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ClassNL",
              "documentation": {
                "identifier": "ClassNL",
                "newPage": false,
                "searchKey": "syntax.ClassNL",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ClassNL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ClassNL // allow character classes like [^a-z] and [[:space:]] to match newline\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#DotNL",
              "documentation": {
                "identifier": "DotNL",
                "newPage": false,
                "searchKey": "syntax.DotNL",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const DotNL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst DotNL // allow . to match newline\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OneLine",
              "documentation": {
                "identifier": "OneLine",
                "newPage": false,
                "searchKey": "syntax.OneLine",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OneLine"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OneLine // treat ^ and $ as only matching at beginning and end of text\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#NonGreedy",
              "documentation": {
                "identifier": "NonGreedy",
                "newPage": false,
                "searchKey": "syntax.NonGreedy",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const NonGreedy"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst NonGreedy // make repetition operators default to non-greedy\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#PerlX",
              "documentation": {
                "identifier": "PerlX",
                "newPage": false,
                "searchKey": "syntax.PerlX",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const PerlX"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PerlX // allow Perl extensions\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#UnicodeGroups",
              "documentation": {
                "identifier": "UnicodeGroups",
                "newPage": false,
                "searchKey": "syntax.UnicodeGroups",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const UnicodeGroups"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst UnicodeGroups // allow \\p{Han}, \\P{Han} for Unicode group and negation\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#WasDollar",
              "documentation": {
                "identifier": "WasDollar",
                "newPage": false,
                "searchKey": "syntax.WasDollar",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const WasDollar"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst WasDollar // regexp OpEndText was $, not \\z\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#Simple",
              "documentation": {
                "identifier": "Simple",
                "newPage": false,
                "searchKey": "syntax.Simple",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Simple"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Simple // regexp contains no counted repetition\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#MatchNL",
              "documentation": {
                "identifier": "MatchNL",
                "newPage": false,
                "searchKey": "syntax.MatchNL",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MatchNL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MatchNL = ClassNL | DotNL\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#Perl",
              "documentation": {
                "identifier": "Perl",
                "newPage": false,
                "searchKey": "syntax.Perl",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Perl"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Perl = ClassNL | OneLine | PerlX | UnicodeGroups // as close to Perl as possible\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#POSIX",
              "documentation": {
                "identifier": "POSIX",
                "newPage": false,
                "searchKey": "syntax.POSIX",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const POSIX"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst POSIX Flags = 0 // POSIX syntax\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#opLeftParen",
              "documentation": {
                "identifier": "opLeftParen",
                "newPage": false,
                "searchKey": "syntax.opLeftParen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opLeftParen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opLeftParen = opPseudo + iota\n```\n\nPseudo-ops for parsing stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#opVerticalBar",
              "documentation": {
                "identifier": "opVerticalBar",
                "newPage": false,
                "searchKey": "syntax.opVerticalBar",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opVerticalBar"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opVerticalBar\n```\n\nPseudo-ops for parsing stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#minFold",
              "documentation": {
                "identifier": "minFold",
                "newPage": false,
                "searchKey": "syntax.minFold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const minFold"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst minFold = 0x0041\n```\n\nminimum and maximum runes involved in folding. checked during test. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#maxFold",
              "documentation": {
                "identifier": "maxFold",
                "newPage": false,
                "searchKey": "syntax.maxFold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxFold"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxFold = 0x1e943\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstAlt",
              "documentation": {
                "identifier": "InstAlt",
                "newPage": false,
                "searchKey": "syntax.InstAlt",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const InstAlt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst InstAlt InstOp = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstAltMatch",
              "documentation": {
                "identifier": "InstAltMatch",
                "newPage": false,
                "searchKey": "syntax.InstAltMatch",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const InstAltMatch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst InstAltMatch\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstCapture",
              "documentation": {
                "identifier": "InstCapture",
                "newPage": false,
                "searchKey": "syntax.InstCapture",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const InstCapture"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst InstCapture\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstEmptyWidth",
              "documentation": {
                "identifier": "InstEmptyWidth",
                "newPage": false,
                "searchKey": "syntax.InstEmptyWidth",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const InstEmptyWidth"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst InstEmptyWidth\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstMatch",
              "documentation": {
                "identifier": "InstMatch",
                "newPage": false,
                "searchKey": "syntax.InstMatch",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const InstMatch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst InstMatch\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstFail",
              "documentation": {
                "identifier": "InstFail",
                "newPage": false,
                "searchKey": "syntax.InstFail",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const InstFail"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst InstFail\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstNop",
              "documentation": {
                "identifier": "InstNop",
                "newPage": false,
                "searchKey": "syntax.InstNop",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const InstNop"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst InstNop\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstRune",
              "documentation": {
                "identifier": "InstRune",
                "newPage": false,
                "searchKey": "syntax.InstRune",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const InstRune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst InstRune\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstRune1",
              "documentation": {
                "identifier": "InstRune1",
                "newPage": false,
                "searchKey": "syntax.InstRune1",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const InstRune1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst InstRune1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstRuneAny",
              "documentation": {
                "identifier": "InstRuneAny",
                "newPage": false,
                "searchKey": "syntax.InstRuneAny",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const InstRuneAny"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst InstRuneAny\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstRuneAnyNotNL",
              "documentation": {
                "identifier": "InstRuneAnyNotNL",
                "newPage": false,
                "searchKey": "syntax.InstRuneAnyNotNL",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const InstRuneAnyNotNL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst InstRuneAnyNotNL\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#EmptyBeginLine",
              "documentation": {
                "identifier": "EmptyBeginLine",
                "newPage": false,
                "searchKey": "syntax.EmptyBeginLine",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const EmptyBeginLine"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst EmptyBeginLine EmptyOp = 1 << iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#EmptyEndLine",
              "documentation": {
                "identifier": "EmptyEndLine",
                "newPage": false,
                "searchKey": "syntax.EmptyEndLine",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const EmptyEndLine"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst EmptyEndLine\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#EmptyBeginText",
              "documentation": {
                "identifier": "EmptyBeginText",
                "newPage": false,
                "searchKey": "syntax.EmptyBeginText",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const EmptyBeginText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst EmptyBeginText\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#EmptyEndText",
              "documentation": {
                "identifier": "EmptyEndText",
                "newPage": false,
                "searchKey": "syntax.EmptyEndText",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const EmptyEndText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst EmptyEndText\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#EmptyWordBoundary",
              "documentation": {
                "identifier": "EmptyWordBoundary",
                "newPage": false,
                "searchKey": "syntax.EmptyWordBoundary",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const EmptyWordBoundary"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst EmptyWordBoundary\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#EmptyNoWordBoundary",
              "documentation": {
                "identifier": "EmptyNoWordBoundary",
                "newPage": false,
                "searchKey": "syntax.EmptyNoWordBoundary",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const EmptyNoWordBoundary"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst EmptyNoWordBoundary\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#noMatch",
              "documentation": {
                "identifier": "noMatch",
                "newPage": false,
                "searchKey": "syntax.noMatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const noMatch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst noMatch = -1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpNoMatch",
              "documentation": {
                "identifier": "OpNoMatch",
                "newPage": false,
                "searchKey": "syntax.OpNoMatch",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpNoMatch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpNoMatch Op = 1 + iota // matches no strings\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpEmptyMatch",
              "documentation": {
                "identifier": "OpEmptyMatch",
                "newPage": false,
                "searchKey": "syntax.OpEmptyMatch",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpEmptyMatch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpEmptyMatch // matches empty string\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpLiteral",
              "documentation": {
                "identifier": "OpLiteral",
                "newPage": false,
                "searchKey": "syntax.OpLiteral",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpLiteral"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpLiteral // matches Runes sequence\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpCharClass",
              "documentation": {
                "identifier": "OpCharClass",
                "newPage": false,
                "searchKey": "syntax.OpCharClass",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpCharClass"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpCharClass // matches Runes interpreted as range pair list\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpAnyCharNotNL",
              "documentation": {
                "identifier": "OpAnyCharNotNL",
                "newPage": false,
                "searchKey": "syntax.OpAnyCharNotNL",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpAnyCharNotNL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpAnyCharNotNL // matches any character except newline\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpAnyChar",
              "documentation": {
                "identifier": "OpAnyChar",
                "newPage": false,
                "searchKey": "syntax.OpAnyChar",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpAnyChar"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpAnyChar // matches any character\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpBeginLine",
              "documentation": {
                "identifier": "OpBeginLine",
                "newPage": false,
                "searchKey": "syntax.OpBeginLine",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpBeginLine"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpBeginLine // matches empty string at beginning of line\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpEndLine",
              "documentation": {
                "identifier": "OpEndLine",
                "newPage": false,
                "searchKey": "syntax.OpEndLine",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpEndLine"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpEndLine // matches empty string at end of line\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpBeginText",
              "documentation": {
                "identifier": "OpBeginText",
                "newPage": false,
                "searchKey": "syntax.OpBeginText",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpBeginText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpBeginText // matches empty string at beginning of text\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpEndText",
              "documentation": {
                "identifier": "OpEndText",
                "newPage": false,
                "searchKey": "syntax.OpEndText",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpEndText"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpEndText // matches empty string at end of text\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpWordBoundary",
              "documentation": {
                "identifier": "OpWordBoundary",
                "newPage": false,
                "searchKey": "syntax.OpWordBoundary",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpWordBoundary"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpWordBoundary // matches word boundary `\\b`\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpNoWordBoundary",
              "documentation": {
                "identifier": "OpNoWordBoundary",
                "newPage": false,
                "searchKey": "syntax.OpNoWordBoundary",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpNoWordBoundary"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpNoWordBoundary // matches word non-boundary `\\B`\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpCapture",
              "documentation": {
                "identifier": "OpCapture",
                "newPage": false,
                "searchKey": "syntax.OpCapture",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpCapture"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpCapture // capturing subexpression with index Cap, optional name Name\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpStar",
              "documentation": {
                "identifier": "OpStar",
                "newPage": false,
                "searchKey": "syntax.OpStar",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpStar"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpStar // matches Sub[0] zero or more times\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpPlus",
              "documentation": {
                "identifier": "OpPlus",
                "newPage": false,
                "searchKey": "syntax.OpPlus",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpPlus"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpPlus // matches Sub[0] one or more times\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpQuest",
              "documentation": {
                "identifier": "OpQuest",
                "newPage": false,
                "searchKey": "syntax.OpQuest",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpQuest"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpQuest // matches Sub[0] zero or one times\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpRepeat",
              "documentation": {
                "identifier": "OpRepeat",
                "newPage": false,
                "searchKey": "syntax.OpRepeat",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpRepeat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpRepeat // matches Sub[0] at least Min times, at most Max (Max == -1 is no limit)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpConcat",
              "documentation": {
                "identifier": "OpConcat",
                "newPage": false,
                "searchKey": "syntax.OpConcat",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpConcat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpConcat // matches concatenation of Subs\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#OpAlternate",
              "documentation": {
                "identifier": "OpAlternate",
                "newPage": false,
                "searchKey": "syntax.OpAlternate",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const OpAlternate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst OpAlternate // matches alternation of Subs\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#opPseudo",
              "documentation": {
                "identifier": "opPseudo",
                "newPage": false,
                "searchKey": "syntax.opPseudo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const opPseudo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst opPseudo Op = 128 // where pseudo-ops start\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#meta",
              "documentation": {
                "identifier": "meta",
                "newPage": false,
                "searchKey": "syntax.meta",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const meta"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst meta = `\\.+*?()|[]{}^$`\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#testFlags",
              "documentation": {
                "identifier": "testFlags",
                "newPage": false,
                "searchKey": "syntax.testFlags",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const testFlags"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst testFlags = MatchNL | PerlX | UnicodeGroups\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/regexp/syntax#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/regexp/syntax#anyRuneNotNL",
              "documentation": {
                "identifier": "anyRuneNotNL",
                "newPage": false,
                "searchKey": "syntax.anyRuneNotNL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var anyRuneNotNL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar anyRuneNotNL = []rune{0, '\\n' - 1, '\\n' + 1, unicode.MaxRune}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#anyRune",
              "documentation": {
                "identifier": "anyRune",
                "newPage": false,
                "searchKey": "syntax.anyRune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var anyRune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar anyRune = []rune{0, unicode.MaxRune}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#_Op_index_0",
              "documentation": {
                "identifier": "_Op_index_0",
                "newPage": false,
                "searchKey": "syntax._Op_index_0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _Op_index_0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _Op_index_0 = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#anyTable",
              "documentation": {
                "identifier": "anyTable",
                "newPage": false,
                "searchKey": "syntax.anyTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var anyTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar anyTable = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code1",
              "documentation": {
                "identifier": "code1",
                "newPage": false,
                "searchKey": "syntax.code1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code1 = []rune{\n\t0x30, 0x39,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code2",
              "documentation": {
                "identifier": "code2",
                "newPage": false,
                "searchKey": "syntax.code2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code2 = []rune{\n\t0x9, 0xa,\n\t0xc, 0xd,\n\t0x20, 0x20,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code3",
              "documentation": {
                "identifier": "code3",
                "newPage": false,
                "searchKey": "syntax.code3",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code3"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code3 = []rune{\n\t0x30, 0x39,\n\t0x41, 0x5a,\n\t0x5f, 0x5f,\n\t0x61, 0x7a,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#perlGroup",
              "documentation": {
                "identifier": "perlGroup",
                "newPage": false,
                "searchKey": "syntax.perlGroup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var perlGroup"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar perlGroup = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code4",
              "documentation": {
                "identifier": "code4",
                "newPage": false,
                "searchKey": "syntax.code4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code4 = []rune{\n\t0x30, 0x39,\n\t0x41, 0x5a,\n\t0x61, 0x7a,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code5",
              "documentation": {
                "identifier": "code5",
                "newPage": false,
                "searchKey": "syntax.code5",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code5 = []rune{\n\t0x41, 0x5a,\n\t0x61, 0x7a,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code6",
              "documentation": {
                "identifier": "code6",
                "newPage": false,
                "searchKey": "syntax.code6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code6"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code6 = []rune{\n\t0x0, 0x7f,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code7",
              "documentation": {
                "identifier": "code7",
                "newPage": false,
                "searchKey": "syntax.code7",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code7"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code7 = []rune{\n\t0x9, 0x9,\n\t0x20, 0x20,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code8",
              "documentation": {
                "identifier": "code8",
                "newPage": false,
                "searchKey": "syntax.code8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code8 = []rune{\n\t0x0, 0x1f,\n\t0x7f, 0x7f,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code9",
              "documentation": {
                "identifier": "code9",
                "newPage": false,
                "searchKey": "syntax.code9",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code9"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code9 = []rune{\n\t0x30, 0x39,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code10",
              "documentation": {
                "identifier": "code10",
                "newPage": false,
                "searchKey": "syntax.code10",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code10"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code10 = []rune{\n\t0x21, 0x7e,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code11",
              "documentation": {
                "identifier": "code11",
                "newPage": false,
                "searchKey": "syntax.code11",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code11"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code11 = []rune{\n\t0x61, 0x7a,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code12",
              "documentation": {
                "identifier": "code12",
                "newPage": false,
                "searchKey": "syntax.code12",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code12"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code12 = []rune{\n\t0x20, 0x7e,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code13",
              "documentation": {
                "identifier": "code13",
                "newPage": false,
                "searchKey": "syntax.code13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code13"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code13 = []rune{\n\t0x21, 0x2f,\n\t0x3a, 0x40,\n\t0x5b, 0x60,\n\t0x7b, 0x7e,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code14",
              "documentation": {
                "identifier": "code14",
                "newPage": false,
                "searchKey": "syntax.code14",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code14"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code14 = []rune{\n\t0x9, 0xd,\n\t0x20, 0x20,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code15",
              "documentation": {
                "identifier": "code15",
                "newPage": false,
                "searchKey": "syntax.code15",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code15"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code15 = []rune{\n\t0x41, 0x5a,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code16",
              "documentation": {
                "identifier": "code16",
                "newPage": false,
                "searchKey": "syntax.code16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code16 = []rune{\n\t0x30, 0x39,\n\t0x41, 0x5a,\n\t0x5f, 0x5f,\n\t0x61, 0x7a,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#code17",
              "documentation": {
                "identifier": "code17",
                "newPage": false,
                "searchKey": "syntax.code17",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var code17"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar code17 = []rune{\n\t0x30, 0x39,\n\t0x41, 0x46,\n\t0x61, 0x66,\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#posixGroup",
              "documentation": {
                "identifier": "posixGroup",
                "newPage": false,
                "searchKey": "syntax.posixGroup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var posixGroup"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar posixGroup = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#instOpNames",
              "documentation": {
                "identifier": "instOpNames",
                "newPage": false,
                "searchKey": "syntax.instOpNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var instOpNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar instOpNames = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#parseTests",
              "documentation": {
                "identifier": "parseTests",
                "newPage": false,
                "searchKey": "syntax.parseTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var parseTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar parseTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#foldcaseTests",
              "documentation": {
                "identifier": "foldcaseTests",
                "newPage": false,
                "searchKey": "syntax.foldcaseTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var foldcaseTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar foldcaseTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#literalTests",
              "documentation": {
                "identifier": "literalTests",
                "newPage": false,
                "searchKey": "syntax.literalTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var literalTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar literalTests = []parseTest{\n\t{\"(|)^$.[*+?]{5,10},\\\\\", \"str{(|)^$.[*+?]{5,10},\\\\}\"},\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#matchnlTests",
              "documentation": {
                "identifier": "matchnlTests",
                "newPage": false,
                "searchKey": "syntax.matchnlTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var matchnlTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar matchnlTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#nomatchnlTests",
              "documentation": {
                "identifier": "nomatchnlTests",
                "newPage": false,
                "searchKey": "syntax.nomatchnlTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var nomatchnlTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar nomatchnlTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#opNames",
              "documentation": {
                "identifier": "opNames",
                "newPage": false,
                "searchKey": "syntax.opNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var opNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar opNames = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#invalidRegexps",
              "documentation": {
                "identifier": "invalidRegexps",
                "newPage": false,
                "searchKey": "syntax.invalidRegexps",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var invalidRegexps"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar invalidRegexps = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#onlyPerl",
              "documentation": {
                "identifier": "onlyPerl",
                "newPage": false,
                "searchKey": "syntax.onlyPerl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var onlyPerl"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar onlyPerl = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#onlyPOSIX",
              "documentation": {
                "identifier": "onlyPOSIX",
                "newPage": false,
                "searchKey": "syntax.onlyPOSIX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var onlyPOSIX"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar onlyPOSIX = []string{\n\t\"a++\",\n\t\"a**\",\n\t\"a?*\",\n\t\"a+*\",\n\t\"a{1}*\",\n\t\".{1}{2}.{3}\",\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#compileTests",
              "documentation": {
                "identifier": "compileTests",
                "newPage": false,
                "searchKey": "syntax.compileTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var compileTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar compileTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#simplifyTests",
              "documentation": {
                "identifier": "simplifyTests",
                "newPage": false,
                "searchKey": "syntax.simplifyTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var simplifyTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar simplifyTests = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/regexp/syntax#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/regexp/syntax#patchList",
              "documentation": {
                "identifier": "patchList",
                "newPage": false,
                "searchKey": "syntax.patchList",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type patchList struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype patchList struct {\n\thead, tail uint32\n}\n```\n\nA patchList is a list of instruction pointers that need to be filled in (patched). Because the pointers haven't been filled in yet, we can reuse their storage to hold the list. It's kind of sleazy, but works well in practice. See [https://swtch.com/~rsc/regexp/regexp1.html](https://swtch.com/~rsc/regexp/regexp1.html) for inspiration. \n\nThese aren't really pointers: they're integers, so we can reinterpret them this way without using package unsafe. A value l.head denotes p.inst[l.head>>1].Out (l.head&1==0) or .Arg (l.head&1==1). head == 0 denotes the empty list, okay because we start every program with a fail instruction, so we'll never want to point at its output link. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#makePatchList",
                    "documentation": {
                      "identifier": "makePatchList",
                      "newPage": false,
                      "searchKey": "syntax.makePatchList",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makePatchList(n uint32) patchList"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makePatchList(n uint32) patchList\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#patchList.patch",
                    "documentation": {
                      "identifier": "patchList.patch",
                      "newPage": false,
                      "searchKey": "syntax.patchList.patch",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l patchList) patch(p *Prog, val uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l patchList) patch(p *Prog, val uint32)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#patchList.append",
                    "documentation": {
                      "identifier": "patchList.append",
                      "newPage": false,
                      "searchKey": "syntax.patchList.append",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l1 patchList) append(p *Prog, l2 patchList) patchList"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l1 patchList) append(p *Prog, l2 patchList) patchList\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#frag",
              "documentation": {
                "identifier": "frag",
                "newPage": false,
                "searchKey": "syntax.frag",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type frag struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype frag struct {\n\ti        uint32    // index of first instruction\n\tout      patchList // where to record end instruction\n\tnullable bool      // whether fragment can match empty string\n}\n```\n\nA frag represents a compiled program fragment. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#compiler",
              "documentation": {
                "identifier": "compiler",
                "newPage": false,
                "searchKey": "syntax.compiler",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type compiler struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype compiler struct {\n\tp *Prog\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.init",
                    "documentation": {
                      "identifier": "compiler.init",
                      "newPage": false,
                      "searchKey": "syntax.compiler.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) init()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) init()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.compile",
                    "documentation": {
                      "identifier": "compiler.compile",
                      "newPage": false,
                      "searchKey": "syntax.compiler.compile",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) compile(re *Regexp) frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) compile(re *Regexp) frag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.inst",
                    "documentation": {
                      "identifier": "compiler.inst",
                      "newPage": false,
                      "searchKey": "syntax.compiler.inst",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) inst(op InstOp) frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) inst(op InstOp) frag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.nop",
                    "documentation": {
                      "identifier": "compiler.nop",
                      "newPage": false,
                      "searchKey": "syntax.compiler.nop",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) nop() frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) nop() frag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.fail",
                    "documentation": {
                      "identifier": "compiler.fail",
                      "newPage": false,
                      "searchKey": "syntax.compiler.fail",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) fail() frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) fail() frag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.cap",
                    "documentation": {
                      "identifier": "compiler.cap",
                      "newPage": false,
                      "searchKey": "syntax.compiler.cap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) cap(arg uint32) frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) cap(arg uint32) frag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.cat",
                    "documentation": {
                      "identifier": "compiler.cat",
                      "newPage": false,
                      "searchKey": "syntax.compiler.cat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) cat(f1, f2 frag) frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) cat(f1, f2 frag) frag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.alt",
                    "documentation": {
                      "identifier": "compiler.alt",
                      "newPage": false,
                      "searchKey": "syntax.compiler.alt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) alt(f1, f2 frag) frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) alt(f1, f2 frag) frag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.quest",
                    "documentation": {
                      "identifier": "compiler.quest",
                      "newPage": false,
                      "searchKey": "syntax.compiler.quest",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) quest(f1 frag, nongreedy bool) frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) quest(f1 frag, nongreedy bool) frag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.loop",
                    "documentation": {
                      "identifier": "compiler.loop",
                      "newPage": false,
                      "searchKey": "syntax.compiler.loop",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) loop(f1 frag, nongreedy bool) frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) loop(f1 frag, nongreedy bool) frag\n```\n\nloop returns the fragment for the main loop of a plus or star. For plus, it can be used after changing the entry to f1.i. For star, it can be used directly when f1 can't match an empty string. (When f1 can match an empty string, f1* must be implemented as (f1+)? to get the priority match order correct.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.star",
                    "documentation": {
                      "identifier": "compiler.star",
                      "newPage": false,
                      "searchKey": "syntax.compiler.star",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) star(f1 frag, nongreedy bool) frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) star(f1 frag, nongreedy bool) frag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.plus",
                    "documentation": {
                      "identifier": "compiler.plus",
                      "newPage": false,
                      "searchKey": "syntax.compiler.plus",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) plus(f1 frag, nongreedy bool) frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) plus(f1 frag, nongreedy bool) frag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.empty",
                    "documentation": {
                      "identifier": "compiler.empty",
                      "newPage": false,
                      "searchKey": "syntax.compiler.empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) empty(op EmptyOp) frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) empty(op EmptyOp) frag\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#compiler.rune",
                    "documentation": {
                      "identifier": "compiler.rune",
                      "newPage": false,
                      "searchKey": "syntax.compiler.rune",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *compiler) rune(r []rune, flags Flags) frag"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *compiler) rune(r []rune, flags Flags) frag\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#Error",
              "documentation": {
                "identifier": "Error",
                "newPage": false,
                "searchKey": "syntax.Error",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Error struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Error struct {\n\tCode ErrorCode\n\tExpr string\n}\n```\n\nAn Error describes a failure to parse a regular expression and gives the offending expression. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Error.Error",
                    "documentation": {
                      "identifier": "Error.Error",
                      "newPage": false,
                      "searchKey": "syntax.Error.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *Error) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *Error) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ErrorCode",
              "documentation": {
                "identifier": "ErrorCode",
                "newPage": false,
                "searchKey": "syntax.ErrorCode",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ErrorCode string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ErrorCode string\n```\n\nAn ErrorCode describes a failure to parse a regular expression. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#ErrorCode.String",
                    "documentation": {
                      "identifier": "ErrorCode.String",
                      "newPage": false,
                      "searchKey": "syntax.ErrorCode.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e ErrorCode) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e ErrorCode) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#Flags",
              "documentation": {
                "identifier": "Flags",
                "newPage": false,
                "searchKey": "syntax.Flags",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Flags uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Flags uint16\n```\n\nFlags control the behavior of the parser and record information about regexp context. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#parser",
              "documentation": {
                "identifier": "parser",
                "newPage": false,
                "searchKey": "syntax.parser",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type parser struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype parser struct {\n\tflags       Flags     // parse mode flags\n\tstack       []*Regexp // stack of parsed expressions\n\tfree        *Regexp\n\tnumCap      int // number of capturing groups seen\n\twholeRegexp string\n\ttmpClass    []rune // temporary char class work space\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.newRegexp",
                    "documentation": {
                      "identifier": "parser.newRegexp",
                      "newPage": false,
                      "searchKey": "syntax.parser.newRegexp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) newRegexp(op Op) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) newRegexp(op Op) *Regexp\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.reuse",
                    "documentation": {
                      "identifier": "parser.reuse",
                      "newPage": false,
                      "searchKey": "syntax.parser.reuse",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) reuse(re *Regexp)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) reuse(re *Regexp)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.push",
                    "documentation": {
                      "identifier": "parser.push",
                      "newPage": false,
                      "searchKey": "syntax.parser.push",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) push(re *Regexp) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) push(re *Regexp) *Regexp\n```\n\npush pushes the regexp re onto the parse stack and returns the regexp. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.maybeConcat",
                    "documentation": {
                      "identifier": "parser.maybeConcat",
                      "newPage": false,
                      "searchKey": "syntax.parser.maybeConcat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) maybeConcat(r rune, flags Flags) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) maybeConcat(r rune, flags Flags) bool\n```\n\nmaybeConcat implements incremental concatenation of literal runes into string nodes. The parser calls this before each push, so only the top fragment of the stack might need processing. Since this is called before a push, the topmost literal is no longer subject to operators like * (Otherwise ab* would turn into (ab)*.) If r >= 0 and there's a node left over, maybeConcat uses it to push r with the given flags. maybeConcat reports whether r was pushed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.literal",
                    "documentation": {
                      "identifier": "parser.literal",
                      "newPage": false,
                      "searchKey": "syntax.parser.literal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) literal(r rune)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) literal(r rune)\n```\n\nliteral pushes a literal regexp for the rune r on the stack. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.op",
                    "documentation": {
                      "identifier": "parser.op",
                      "newPage": false,
                      "searchKey": "syntax.parser.op",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) op(op Op) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) op(op Op) *Regexp\n```\n\nop pushes a regexp with the given op onto the stack and returns that regexp. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.repeat",
                    "documentation": {
                      "identifier": "parser.repeat",
                      "newPage": false,
                      "searchKey": "syntax.parser.repeat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) repeat(op Op, min, max int, before, after, lastRepeat string) (string, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) repeat(op Op, min, max int, before, after, lastRepeat string) (string, error)\n```\n\nrepeat replaces the top stack element with itself repeated according to op, min, max. before is the regexp suffix starting at the repetition operator. after is the regexp suffix following after the repetition operator. repeat returns an updated 'after' and an error, if any. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.concat",
                    "documentation": {
                      "identifier": "parser.concat",
                      "newPage": false,
                      "searchKey": "syntax.parser.concat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) concat() *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) concat() *Regexp\n```\n\nconcat replaces the top of the stack (above the topmost '|' or '(') with its concatenation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.alternate",
                    "documentation": {
                      "identifier": "parser.alternate",
                      "newPage": false,
                      "searchKey": "syntax.parser.alternate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) alternate() *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) alternate() *Regexp\n```\n\nalternate replaces the top of the stack (above the topmost '(') with its alternation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.collapse",
                    "documentation": {
                      "identifier": "parser.collapse",
                      "newPage": false,
                      "searchKey": "syntax.parser.collapse",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) collapse(subs []*Regexp, op Op) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) collapse(subs []*Regexp, op Op) *Regexp\n```\n\ncollapse returns the result of applying op to sub. If sub contains op nodes, they all get hoisted up so that there is never a concat of a concat or an alternate of an alternate. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.factor",
                    "documentation": {
                      "identifier": "parser.factor",
                      "newPage": false,
                      "searchKey": "syntax.parser.factor",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) factor(sub []*Regexp) []*Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) factor(sub []*Regexp) []*Regexp\n```\n\nfactor factors common prefixes from the alternation list sub. It returns a replacement list that reuses the same storage and frees (passes to p.reuse) any removed *Regexps. \n\nFor example, \n\n```\nABC|ABD|AEF|BCX|BCY\n\n```\nsimplifies by literal prefix extraction to \n\n```\nA(B(C|D)|EF)|BC(X|Y)\n\n```\nwhich simplifies by character class introduction to \n\n```\nA(B[CD]|EF)|BC[XY]\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.leadingString",
                    "documentation": {
                      "identifier": "parser.leadingString",
                      "newPage": false,
                      "searchKey": "syntax.parser.leadingString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) leadingString(re *Regexp) ([]rune, Flags)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) leadingString(re *Regexp) ([]rune, Flags)\n```\n\nleadingString returns the leading literal string that re begins with. The string refers to storage in re or its children. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.removeLeadingString",
                    "documentation": {
                      "identifier": "parser.removeLeadingString",
                      "newPage": false,
                      "searchKey": "syntax.parser.removeLeadingString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) removeLeadingString(re *Regexp, n int) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) removeLeadingString(re *Regexp, n int) *Regexp\n```\n\nremoveLeadingString removes the first n leading runes from the beginning of re. It returns the replacement for re. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.leadingRegexp",
                    "documentation": {
                      "identifier": "parser.leadingRegexp",
                      "newPage": false,
                      "searchKey": "syntax.parser.leadingRegexp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) leadingRegexp(re *Regexp) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) leadingRegexp(re *Regexp) *Regexp\n```\n\nleadingRegexp returns the leading regexp that re begins with. The regexp refers to storage in re or its children. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.removeLeadingRegexp",
                    "documentation": {
                      "identifier": "parser.removeLeadingRegexp",
                      "newPage": false,
                      "searchKey": "syntax.parser.removeLeadingRegexp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) removeLeadingRegexp(re *Regexp, reuse bool) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) removeLeadingRegexp(re *Regexp, reuse bool) *Regexp\n```\n\nremoveLeadingRegexp removes the leading regexp in re. It returns the replacement for re. If reuse is true, it passes the removed regexp (if no longer needed) to p.reuse. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.parseRepeat",
                    "documentation": {
                      "identifier": "parser.parseRepeat",
                      "newPage": false,
                      "searchKey": "syntax.parser.parseRepeat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseRepeat(s string) (min, max int, rest string, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseRepeat(s string) (min, max int, rest string, ok bool)\n```\n\nparseRepeat parses {min} (max=min) or {min,} (max=-1) or {min,max}. If s is not of that form, it returns ok == false. If s has the right form but the values are too big, it returns min == -1, ok == true. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.parsePerlFlags",
                    "documentation": {
                      "identifier": "parser.parsePerlFlags",
                      "newPage": false,
                      "searchKey": "syntax.parser.parsePerlFlags",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parsePerlFlags(s string) (rest string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parsePerlFlags(s string) (rest string, err error)\n```\n\nparsePerlFlags parses a Perl flag setting or non-capturing group or both, like (?i) or (?: or (?i:.  It removes the prefix from s and updates the parse state. The caller must have ensured that s begins with \"(?\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.parseInt",
                    "documentation": {
                      "identifier": "parser.parseInt",
                      "newPage": false,
                      "searchKey": "syntax.parser.parseInt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseInt(s string) (n int, rest string, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseInt(s string) (n int, rest string, ok bool)\n```\n\nparseInt parses a decimal integer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.parseVerticalBar",
                    "documentation": {
                      "identifier": "parser.parseVerticalBar",
                      "newPage": false,
                      "searchKey": "syntax.parser.parseVerticalBar",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseVerticalBar() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseVerticalBar() error\n```\n\nparseVerticalBar handles a | in the input. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.swapVerticalBar",
                    "documentation": {
                      "identifier": "parser.swapVerticalBar",
                      "newPage": false,
                      "searchKey": "syntax.parser.swapVerticalBar",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) swapVerticalBar() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) swapVerticalBar() bool\n```\n\nIf the top of the stack is an element followed by an opVerticalBar swapVerticalBar swaps the two and returns true. Otherwise it returns false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.parseRightParen",
                    "documentation": {
                      "identifier": "parser.parseRightParen",
                      "newPage": false,
                      "searchKey": "syntax.parser.parseRightParen",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseRightParen() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseRightParen() error\n```\n\nparseRightParen handles a ) in the input. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.parseEscape",
                    "documentation": {
                      "identifier": "parser.parseEscape",
                      "newPage": false,
                      "searchKey": "syntax.parser.parseEscape",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseEscape(s string) (r rune, rest string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseEscape(s string) (r rune, rest string, err error)\n```\n\nparseEscape parses an escape sequence at the beginning of s and returns the rune. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.parseClassChar",
                    "documentation": {
                      "identifier": "parser.parseClassChar",
                      "newPage": false,
                      "searchKey": "syntax.parser.parseClassChar",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseClassChar(s, wholeClass string) (r rune, rest string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseClassChar(s, wholeClass string) (r rune, rest string, err error)\n```\n\nparseClassChar parses a character class character at the beginning of s and returns it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.parsePerlClassEscape",
                    "documentation": {
                      "identifier": "parser.parsePerlClassEscape",
                      "newPage": false,
                      "searchKey": "syntax.parser.parsePerlClassEscape",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parsePerlClassEscape(s string, r []rune) (out []rune, rest string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parsePerlClassEscape(s string, r []rune) (out []rune, rest string)\n```\n\nparsePerlClassEscape parses a leading Perl character class escape like \\d from the beginning of s. If one is present, it appends the characters to r and returns the new slice r and the remainder of the string. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.parseNamedClass",
                    "documentation": {
                      "identifier": "parser.parseNamedClass",
                      "newPage": false,
                      "searchKey": "syntax.parser.parseNamedClass",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseNamedClass(s string, r []rune) (out []rune, rest string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseNamedClass(s string, r []rune) (out []rune, rest string, err error)\n```\n\nparseNamedClass parses a leading POSIX named character class like [:alnum:] from the beginning of s. If one is present, it appends the characters to r and returns the new slice r and the remainder of the string. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.appendGroup",
                    "documentation": {
                      "identifier": "parser.appendGroup",
                      "newPage": false,
                      "searchKey": "syntax.parser.appendGroup",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) appendGroup(r []rune, g charGroup) []rune"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) appendGroup(r []rune, g charGroup) []rune\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.parseUnicodeClass",
                    "documentation": {
                      "identifier": "parser.parseUnicodeClass",
                      "newPage": false,
                      "searchKey": "syntax.parser.parseUnicodeClass",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseUnicodeClass(s string, r []rune) (out []rune, rest string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseUnicodeClass(s string, r []rune) (out []rune, rest string, err error)\n```\n\nparseUnicodeClass parses a leading Unicode character class like \\p{Han} from the beginning of s. If one is present, it appends the characters to r and returns the new slice r and the remainder of the string. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#parser.parseClass",
                    "documentation": {
                      "identifier": "parser.parseClass",
                      "newPage": false,
                      "searchKey": "syntax.parser.parseClass",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *parser) parseClass(s string) (rest string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *parser) parseClass(s string) (rest string, err error)\n```\n\nparseClass parses a character class at the beginning of s and pushes it onto the parse stack. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#charGroup",
              "documentation": {
                "identifier": "charGroup",
                "newPage": false,
                "searchKey": "syntax.charGroup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type charGroup struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype charGroup struct {\n\tsign  int\n\tclass []rune\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#ranges",
              "documentation": {
                "identifier": "ranges",
                "newPage": false,
                "searchKey": "syntax.ranges",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ranges struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ranges struct {\n\tp *[]rune\n}\n```\n\nranges implements sort.Interface on a []rune. The choice of receiver type definition is strange but avoids an allocation since we already have a *[]rune. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#ranges.Less",
                    "documentation": {
                      "identifier": "ranges.Less",
                      "newPage": false,
                      "searchKey": "syntax.ranges.Less",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ra ranges) Less(i, j int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ra ranges) Less(i, j int) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#ranges.Len",
                    "documentation": {
                      "identifier": "ranges.Len",
                      "newPage": false,
                      "searchKey": "syntax.ranges.Len",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ra ranges) Len() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ra ranges) Len() int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#ranges.Swap",
                    "documentation": {
                      "identifier": "ranges.Swap",
                      "newPage": false,
                      "searchKey": "syntax.ranges.Swap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ra ranges) Swap(i, j int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ra ranges) Swap(i, j int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#Prog",
              "documentation": {
                "identifier": "Prog",
                "newPage": false,
                "searchKey": "syntax.Prog",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Prog struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Prog struct {\n\tInst   []Inst\n\tStart  int // index of start instruction\n\tNumCap int // number of InstCapture insts in re\n}\n```\n\nA Prog is a compiled regular expression program. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Compile",
                    "documentation": {
                      "identifier": "Compile",
                      "newPage": false,
                      "searchKey": "syntax.Compile",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Compile(re *Regexp) (*Prog, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Compile(re *Regexp) (*Prog, error)\n```\n\nCompile compiles the regexp into a program to be executed. The regexp should have been simplified already (returned from re.Simplify). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Prog.String",
                    "documentation": {
                      "identifier": "Prog.String",
                      "newPage": false,
                      "searchKey": "syntax.Prog.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Prog) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Prog) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Prog.skipNop",
                    "documentation": {
                      "identifier": "Prog.skipNop",
                      "newPage": false,
                      "searchKey": "syntax.Prog.skipNop",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Prog) skipNop(pc uint32) *Inst"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Prog) skipNop(pc uint32) *Inst\n```\n\nskipNop follows any no-op or capturing instructions. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Prog.Prefix",
                    "documentation": {
                      "identifier": "Prog.Prefix",
                      "newPage": false,
                      "searchKey": "syntax.Prog.Prefix",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Prog) Prefix() (prefix string, complete bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Prog) Prefix() (prefix string, complete bool)\n```\n\nPrefix returns a literal string that all matches for the regexp must start with. Complete is true if the prefix is the entire match. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Prog.StartCond",
                    "documentation": {
                      "identifier": "Prog.StartCond",
                      "newPage": false,
                      "searchKey": "syntax.Prog.StartCond",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Prog) StartCond() EmptyOp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Prog) StartCond() EmptyOp\n```\n\nStartCond returns the leading empty-width conditions that must be true in any match. It returns ^EmptyOp(0) if no matches are possible. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#InstOp",
              "documentation": {
                "identifier": "InstOp",
                "newPage": false,
                "searchKey": "syntax.InstOp",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type InstOp uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype InstOp uint8\n```\n\nAn InstOp is an instruction opcode. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#InstOp.String",
                    "documentation": {
                      "identifier": "InstOp.String",
                      "newPage": false,
                      "searchKey": "syntax.InstOp.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i InstOp) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i InstOp) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#EmptyOp",
              "documentation": {
                "identifier": "EmptyOp",
                "newPage": false,
                "searchKey": "syntax.EmptyOp",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type EmptyOp uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype EmptyOp uint8\n```\n\nAn EmptyOp specifies a kind or mixture of zero-width assertions. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#EmptyOpContext",
                    "documentation": {
                      "identifier": "EmptyOpContext",
                      "newPage": false,
                      "searchKey": "syntax.EmptyOpContext",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func EmptyOpContext(r1, r2 rune) EmptyOp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc EmptyOpContext(r1, r2 rune) EmptyOp\n```\n\nEmptyOpContext returns the zero-width assertions satisfied at the position between the runes r1 and r2. Passing r1 == -1 indicates that the position is at the beginning of the text. Passing r2 == -1 indicates that the position is at the end of the text. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#Inst",
              "documentation": {
                "identifier": "Inst",
                "newPage": false,
                "searchKey": "syntax.Inst",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Inst struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Inst struct {\n\tOp   InstOp\n\tOut  uint32 // all but InstMatch, InstFail\n\tArg  uint32 // InstAlt, InstAltMatch, InstCapture, InstEmptyWidth\n\tRune []rune\n}\n```\n\nAn Inst is a single instruction in a regular expression program. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Inst.op",
                    "documentation": {
                      "identifier": "Inst.op",
                      "newPage": false,
                      "searchKey": "syntax.Inst.op",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *Inst) op() InstOp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *Inst) op() InstOp\n```\n\nop returns i.Op but merges all the Rune special cases into InstRune \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Inst.MatchRune",
                    "documentation": {
                      "identifier": "Inst.MatchRune",
                      "newPage": false,
                      "searchKey": "syntax.Inst.MatchRune",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *Inst) MatchRune(r rune) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *Inst) MatchRune(r rune) bool\n```\n\nMatchRune reports whether the instruction matches (and consumes) r. It should only be called when i.Op == InstRune. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Inst.MatchRunePos",
                    "documentation": {
                      "identifier": "Inst.MatchRunePos",
                      "newPage": false,
                      "searchKey": "syntax.Inst.MatchRunePos",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *Inst) MatchRunePos(r rune) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *Inst) MatchRunePos(r rune) int\n```\n\nMatchRunePos checks whether the instruction matches (and consumes) r. If so, MatchRunePos returns the index of the matching rune pair (or, when len(i.Rune) == 1, rune singleton). If not, MatchRunePos returns -1. MatchRunePos should only be called when i.Op == InstRune. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Inst.MatchEmptyWidth",
                    "documentation": {
                      "identifier": "Inst.MatchEmptyWidth",
                      "newPage": false,
                      "searchKey": "syntax.Inst.MatchEmptyWidth",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *Inst) MatchEmptyWidth(before rune, after rune) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *Inst) MatchEmptyWidth(before rune, after rune) bool\n```\n\nMatchEmptyWidth reports whether the instruction matches an empty string between the runes before and after. It should only be called when i.Op == InstEmptyWidth. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Inst.String",
                    "documentation": {
                      "identifier": "Inst.String",
                      "newPage": false,
                      "searchKey": "syntax.Inst.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *Inst) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *Inst) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#Regexp",
              "documentation": {
                "identifier": "Regexp",
                "newPage": false,
                "searchKey": "syntax.Regexp",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Regexp struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Regexp struct {\n\tOp       Op // operator\n\tFlags    Flags\n\tSub      []*Regexp  // subexpressions, if any\n\tSub0     [1]*Regexp // storage for short Sub\n\tRune     []rune     // matched runes, for OpLiteral, OpCharClass\n\tRune0    [2]rune    // storage for short Rune\n\tMin, Max int        // min, max for OpRepeat\n\tCap      int        // capturing index, for OpCapture\n\tName     string     // capturing name, for OpCapture\n}\n```\n\nA Regexp is a node in a regular expression syntax tree. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#literalRegexp",
                    "documentation": {
                      "identifier": "literalRegexp",
                      "newPage": false,
                      "searchKey": "syntax.literalRegexp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func literalRegexp(s string, flags Flags) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc literalRegexp(s string, flags Flags) *Regexp\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Parse",
                    "documentation": {
                      "identifier": "Parse",
                      "newPage": false,
                      "searchKey": "syntax.Parse",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Parse(s string, flags Flags) (*Regexp, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Parse(s string, flags Flags) (*Regexp, error)\n```\n\nParse parses a regular expression string s, controlled by the specified Flags, and returns a regular expression parse tree. The syntax is described in the top-level comment. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#simplify1",
                    "documentation": {
                      "identifier": "simplify1",
                      "newPage": false,
                      "searchKey": "syntax.simplify1",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func simplify1(op Op, flags Flags, sub, re *Regexp) *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc simplify1(op Op, flags Flags, sub, re *Regexp) *Regexp\n```\n\nsimplify1 implements Simplify for the unary OpStar, OpPlus, and OpQuest operators. It returns the simple regexp equivalent to \n\n```\nRegexp{Op: op, Flags: flags, Sub: {sub}}\n\n```\nunder the assumption that sub is already simple, and without first allocating that structure. If the regexp to be returned turns out to be equivalent to re, simplify1 returns re instead. \n\nsimplify1 is factored out of Simplify because the implementation for other operators generates these unary expressions. Letting them call simplify1 makes sure the expressions they generate are simple. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Regexp.Equal",
                    "documentation": {
                      "identifier": "Regexp.Equal",
                      "newPage": false,
                      "searchKey": "syntax.Regexp.Equal",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Regexp) Equal(y *Regexp) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Regexp) Equal(y *Regexp) bool\n```\n\nEqual reports whether x and y have identical structure. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Regexp.String",
                    "documentation": {
                      "identifier": "Regexp.String",
                      "newPage": false,
                      "searchKey": "syntax.Regexp.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Regexp.MaxCap",
                    "documentation": {
                      "identifier": "Regexp.MaxCap",
                      "newPage": false,
                      "searchKey": "syntax.Regexp.MaxCap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) MaxCap() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) MaxCap() int\n```\n\nMaxCap walks the regexp to find the maximum capture index. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Regexp.CapNames",
                    "documentation": {
                      "identifier": "Regexp.CapNames",
                      "newPage": false,
                      "searchKey": "syntax.Regexp.CapNames",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) CapNames() []string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) CapNames() []string\n```\n\nCapNames walks the regexp to find the names of capturing groups. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Regexp.capNames",
                    "documentation": {
                      "identifier": "Regexp.capNames",
                      "newPage": false,
                      "searchKey": "syntax.Regexp.capNames",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) capNames(names []string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) capNames(names []string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Regexp.Simplify",
                    "documentation": {
                      "identifier": "Regexp.Simplify",
                      "newPage": false,
                      "searchKey": "syntax.Regexp.Simplify",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (re *Regexp) Simplify() *Regexp"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (re *Regexp) Simplify() *Regexp\n```\n\nSimplify returns a regexp equivalent to re but without counted repetitions and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/. The resulting regexp will execute correctly but its string representation will not produce the same parse tree, because capturing parentheses may have been duplicated or removed. For example, the simplified form for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1. The returned regexp may share structure with or be the original. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#Op",
              "documentation": {
                "identifier": "Op",
                "newPage": false,
                "searchKey": "syntax.Op",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Op uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Op uint8\n```\n\nAn Op is a single regular expression operator. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/regexp/syntax#Op.String",
                    "documentation": {
                      "identifier": "Op.String",
                      "newPage": false,
                      "searchKey": "syntax.Op.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i Op) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i Op) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#parseTest",
              "documentation": {
                "identifier": "parseTest",
                "newPage": false,
                "searchKey": "syntax.parseTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type parseTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype parseTest struct {\n\tRegexp string\n\tDump   string\n}\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/regexp/syntax#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/regexp/syntax#minFoldRune",
              "documentation": {
                "identifier": "minFoldRune",
                "newPage": false,
                "searchKey": "syntax.minFoldRune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func minFoldRune(r rune) rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc minFoldRune(r rune) rune\n```\n\nminFoldRune returns the minimum rune fold-equivalent to r. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#repeatIsValid",
              "documentation": {
                "identifier": "repeatIsValid",
                "newPage": false,
                "searchKey": "syntax.repeatIsValid",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func repeatIsValid(re *Regexp, n int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc repeatIsValid(re *Regexp, n int) bool\n```\n\nrepeatIsValid reports whether the repetition re is valid. Valid means that the combination of the top-level repetition and any inner repetitions does not exceed n copies of the innermost thing. This function rewalks the regexp tree and is called for every repetition, so we have to worry about inducing quadratic behavior in the parser. We avoid this by only calling repeatIsValid when min or max >= 2. In that case the depth of any >= 2 nesting can only get to 9 without triggering a parse error, so each subtree can only be rewalked 9 times. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#cleanAlt",
              "documentation": {
                "identifier": "cleanAlt",
                "newPage": false,
                "searchKey": "syntax.cleanAlt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cleanAlt(re *Regexp)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cleanAlt(re *Regexp)\n```\n\ncleanAlt cleans re for eventual inclusion in an alternation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#isValidCaptureName",
              "documentation": {
                "identifier": "isValidCaptureName",
                "newPage": false,
                "searchKey": "syntax.isValidCaptureName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isValidCaptureName(name string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isValidCaptureName(name string) bool\n```\n\nisValidCaptureName reports whether name is a valid capture name: [A-Za-z0-9_]+. PCRE limits names to 32 bytes. Python rejects names starting with digits. We don't enforce either of those. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#isCharClass",
              "documentation": {
                "identifier": "isCharClass",
                "newPage": false,
                "searchKey": "syntax.isCharClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isCharClass(re *Regexp) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isCharClass(re *Regexp) bool\n```\n\ncan this be represented as a character class? single-rune literal string, char class, ., and .|\\n. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#matchRune",
              "documentation": {
                "identifier": "matchRune",
                "newPage": false,
                "searchKey": "syntax.matchRune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func matchRune(re *Regexp, r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc matchRune(re *Regexp, r rune) bool\n```\n\ndoes re match r? \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#mergeCharClass",
              "documentation": {
                "identifier": "mergeCharClass",
                "newPage": false,
                "searchKey": "syntax.mergeCharClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mergeCharClass(dst, src *Regexp)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mergeCharClass(dst, src *Regexp)\n```\n\nmergeCharClass makes dst = dst|src. The caller must ensure that dst.Op >= src.Op, to reduce the amount of copying. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#unicodeTable",
              "documentation": {
                "identifier": "unicodeTable",
                "newPage": false,
                "searchKey": "syntax.unicodeTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unicodeTable(name string) (*unicode.RangeTable, *unicode.RangeTable)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unicodeTable(name string) (*unicode.RangeTable, *unicode.RangeTable)\n```\n\nunicodeTable returns the unicode.RangeTable identified by name and the table of additional fold-equivalent code points. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#cleanClass",
              "documentation": {
                "identifier": "cleanClass",
                "newPage": false,
                "searchKey": "syntax.cleanClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cleanClass(rp *[]rune) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cleanClass(rp *[]rune) []rune\n```\n\ncleanClass sorts the ranges (pairs of elements of r), merges them, and eliminates duplicates. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#appendLiteral",
              "documentation": {
                "identifier": "appendLiteral",
                "newPage": false,
                "searchKey": "syntax.appendLiteral",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendLiteral(r []rune, x rune, flags Flags) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendLiteral(r []rune, x rune, flags Flags) []rune\n```\n\nappendLiteral returns the result of appending the literal x to the class r. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#appendRange",
              "documentation": {
                "identifier": "appendRange",
                "newPage": false,
                "searchKey": "syntax.appendRange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendRange(r []rune, lo, hi rune) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendRange(r []rune, lo, hi rune) []rune\n```\n\nappendRange returns the result of appending the range lo-hi to the class r. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#appendFoldedRange",
              "documentation": {
                "identifier": "appendFoldedRange",
                "newPage": false,
                "searchKey": "syntax.appendFoldedRange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendFoldedRange(r []rune, lo, hi rune) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendFoldedRange(r []rune, lo, hi rune) []rune\n```\n\nappendFoldedRange returns the result of appending the range lo-hi and its case folding-equivalent runes to the class r. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#appendClass",
              "documentation": {
                "identifier": "appendClass",
                "newPage": false,
                "searchKey": "syntax.appendClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendClass(r []rune, x []rune) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendClass(r []rune, x []rune) []rune\n```\n\nappendClass returns the result of appending the class x to the class r. It assume x is clean. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#appendFoldedClass",
              "documentation": {
                "identifier": "appendFoldedClass",
                "newPage": false,
                "searchKey": "syntax.appendFoldedClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendFoldedClass(r []rune, x []rune) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendFoldedClass(r []rune, x []rune) []rune\n```\n\nappendFolded returns the result of appending the case folding of the class x to the class r. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#appendNegatedClass",
              "documentation": {
                "identifier": "appendNegatedClass",
                "newPage": false,
                "searchKey": "syntax.appendNegatedClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendNegatedClass(r []rune, x []rune) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendNegatedClass(r []rune, x []rune) []rune\n```\n\nappendNegatedClass returns the result of appending the negation of the class x to the class r. It assumes x is clean. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#appendTable",
              "documentation": {
                "identifier": "appendTable",
                "newPage": false,
                "searchKey": "syntax.appendTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendTable(r []rune, x *unicode.RangeTable) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendTable(r []rune, x *unicode.RangeTable) []rune\n```\n\nappendTable returns the result of appending x to the class r. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#appendNegatedTable",
              "documentation": {
                "identifier": "appendNegatedTable",
                "newPage": false,
                "searchKey": "syntax.appendNegatedTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendNegatedTable(r []rune, x *unicode.RangeTable) []rune\n```\n\nappendNegatedTable returns the result of appending the negation of x to the class r. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#negateClass",
              "documentation": {
                "identifier": "negateClass",
                "newPage": false,
                "searchKey": "syntax.negateClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func negateClass(r []rune) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc negateClass(r []rune) []rune\n```\n\nnegateClass overwrites r and returns r's negation. It assumes the class r is already clean. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#checkUTF8",
              "documentation": {
                "identifier": "checkUTF8",
                "newPage": false,
                "searchKey": "syntax.checkUTF8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkUTF8(s string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkUTF8(s string) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#nextRune",
              "documentation": {
                "identifier": "nextRune",
                "newPage": false,
                "searchKey": "syntax.nextRune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nextRune(s string) (c rune, t string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nextRune(s string) (c rune, t string, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#isalnum",
              "documentation": {
                "identifier": "isalnum",
                "newPage": false,
                "searchKey": "syntax.isalnum",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isalnum(c rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isalnum(c rune) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#unhex",
              "documentation": {
                "identifier": "unhex",
                "newPage": false,
                "searchKey": "syntax.unhex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unhex(c rune) rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unhex(c rune) rune\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#IsWordChar",
              "documentation": {
                "identifier": "IsWordChar",
                "newPage": false,
                "searchKey": "syntax.IsWordChar",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsWordChar(r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsWordChar(r rune) bool\n```\n\nIsWordChar reports whether r is consider a `word character' during the evaluation of the \\b and \\B zero-width assertions. These assertions are ASCII-only: the word characters are [A-Za-z0-9_]. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#bw",
              "documentation": {
                "identifier": "bw",
                "newPage": false,
                "searchKey": "syntax.bw",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bw(b *strings.Builder, args ...string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bw(b *strings.Builder, args ...string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#dumpProg",
              "documentation": {
                "identifier": "dumpProg",
                "newPage": false,
                "searchKey": "syntax.dumpProg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpProg(b *strings.Builder, p *Prog)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpProg(b *strings.Builder, p *Prog)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#u32",
              "documentation": {
                "identifier": "u32",
                "newPage": false,
                "searchKey": "syntax.u32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func u32(i uint32) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc u32(i uint32) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#dumpInst",
              "documentation": {
                "identifier": "dumpInst",
                "newPage": false,
                "searchKey": "syntax.dumpInst",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpInst(b *strings.Builder, i *Inst)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpInst(b *strings.Builder, i *Inst)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#writeRegexp",
              "documentation": {
                "identifier": "writeRegexp",
                "newPage": false,
                "searchKey": "syntax.writeRegexp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeRegexp(b *strings.Builder, re *Regexp)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeRegexp(b *strings.Builder, re *Regexp)\n```\n\nwriteRegexp writes the Perl syntax for the regular expression re to b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#escape",
              "documentation": {
                "identifier": "escape",
                "newPage": false,
                "searchKey": "syntax.escape",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func escape(b *strings.Builder, r rune, force bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc escape(b *strings.Builder, r rune, force bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#TestParseSimple",
              "documentation": {
                "identifier": "TestParseSimple",
                "newPage": false,
                "searchKey": "syntax.TestParseSimple",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseSimple(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseSimple(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#TestParseFoldCase",
              "documentation": {
                "identifier": "TestParseFoldCase",
                "newPage": false,
                "searchKey": "syntax.TestParseFoldCase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseFoldCase(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseFoldCase(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#TestParseLiteral",
              "documentation": {
                "identifier": "TestParseLiteral",
                "newPage": false,
                "searchKey": "syntax.TestParseLiteral",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseLiteral(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseLiteral(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#TestParseMatchNL",
              "documentation": {
                "identifier": "TestParseMatchNL",
                "newPage": false,
                "searchKey": "syntax.TestParseMatchNL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseMatchNL(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseMatchNL(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#TestParseNoMatchNL",
              "documentation": {
                "identifier": "TestParseNoMatchNL",
                "newPage": false,
                "searchKey": "syntax.TestParseNoMatchNL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseNoMatchNL(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseNoMatchNL(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#testParseDump",
              "documentation": {
                "identifier": "testParseDump",
                "newPage": false,
                "searchKey": "syntax.testParseDump",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testParseDump(t *testing.T, tests []parseTest, flags Flags)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testParseDump(t *testing.T, tests []parseTest, flags Flags)\n```\n\nTest Parse -> Dump. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#dump",
              "documentation": {
                "identifier": "dump",
                "newPage": false,
                "searchKey": "syntax.dump",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dump(re *Regexp) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dump(re *Regexp) string\n```\n\ndump prints a string representation of the regexp showing the structure explicitly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#dumpRegexp",
              "documentation": {
                "identifier": "dumpRegexp",
                "newPage": false,
                "searchKey": "syntax.dumpRegexp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpRegexp(b *strings.Builder, re *Regexp)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpRegexp(b *strings.Builder, re *Regexp)\n```\n\ndumpRegexp writes an encoding of the syntax tree for the regexp re to b. It is used during testing to distinguish between parses that might print the same using re's String method. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#mkCharClass",
              "documentation": {
                "identifier": "mkCharClass",
                "newPage": false,
                "searchKey": "syntax.mkCharClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mkCharClass(f func(rune) bool) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mkCharClass(f func(rune) bool) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#isUpperFold",
              "documentation": {
                "identifier": "isUpperFold",
                "newPage": false,
                "searchKey": "syntax.isUpperFold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isUpperFold(r rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isUpperFold(r rune) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#TestFoldConstants",
              "documentation": {
                "identifier": "TestFoldConstants",
                "newPage": false,
                "searchKey": "syntax.TestFoldConstants",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFoldConstants(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFoldConstants(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#TestAppendRangeCollapse",
              "documentation": {
                "identifier": "TestAppendRangeCollapse",
                "newPage": false,
                "searchKey": "syntax.TestAppendRangeCollapse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAppendRangeCollapse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAppendRangeCollapse(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#TestParseInvalidRegexps",
              "documentation": {
                "identifier": "TestParseInvalidRegexps",
                "newPage": false,
                "searchKey": "syntax.TestParseInvalidRegexps",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestParseInvalidRegexps(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestParseInvalidRegexps(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#TestToStringEquivalentParse",
              "documentation": {
                "identifier": "TestToStringEquivalentParse",
                "newPage": false,
                "searchKey": "syntax.TestToStringEquivalentParse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestToStringEquivalentParse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestToStringEquivalentParse(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#TestCompile",
              "documentation": {
                "identifier": "TestCompile",
                "newPage": false,
                "searchKey": "syntax.TestCompile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCompile(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCompile(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#BenchmarkEmptyOpContext",
              "documentation": {
                "identifier": "BenchmarkEmptyOpContext",
                "newPage": false,
                "searchKey": "syntax.BenchmarkEmptyOpContext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkEmptyOpContext(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkEmptyOpContext(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/regexp/syntax#TestSimplify",
              "documentation": {
                "identifier": "TestSimplify",
                "newPage": false,
                "searchKey": "syntax.TestSimplify",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSimplify(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSimplify(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
