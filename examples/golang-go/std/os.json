{
  "pathID": "/std/os",
  "documentation": {
    "identifier": "os",
    "newPage": true,
    "searchKey": "std/os",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package os"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package os provides a platform-independent interface to operating system functionality. The design is Unix-like, although the error handling is Go-like; failing calls return values of type error rather than error numbers. Often, more information is available within the error. For example, if a call that takes a file name fails, such as Open or Stat, the error will include the failing file name when printed and will be of type *PathError, which may be unpacked for more information. \n\nThe os interface is intended to be uniform across all operating systems. Features not generally available appear in the system-specific package syscall. \n\nHere is a simple example, opening a file and reading some of it. \n\n```\nfile, err := os.Open(\"file.go\") // For read access.\nif err != nil {\n\tlog.Fatal(err)\n}\n\n```\nIf the open fails, the error string will be self-explanatory, like \n\n```\nopen file.go: no such file or directory\n\n```\nThe file's data can then be read into a slice of bytes. Read and Write take their byte counts from the length of the argument slice. \n\n```\ndata := make([]byte, 100)\ncount, err := file.Read(data)\nif err != nil {\n\tlog.Fatal(err)\n}\nfmt.Printf(\"read %d bytes: %q\\n\", count, data[:count])\n\n```\nNote: The maximum number of concurrent operations on a File may be limited by the OS or the system. The number should be high, but exceeding it may degrade performance or cause other issues. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/std/os#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/os#readdirName",
              "documentation": {
                "identifier": "readdirName",
                "newPage": false,
                "searchKey": "os.readdirName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const readdirName"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst readdirName readdirMode = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#readdirDirEntry",
              "documentation": {
                "identifier": "readdirDirEntry",
                "newPage": false,
                "searchKey": "os.readdirDirEntry",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const readdirDirEntry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst readdirDirEntry\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#readdirFileInfo",
              "documentation": {
                "identifier": "readdirFileInfo",
                "newPage": false,
                "searchKey": "os.readdirFileInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const readdirFileInfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst readdirFileInfo\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#isBigEndian",
              "documentation": {
                "identifier": "isBigEndian",
                "newPage": false,
                "searchKey": "os.isBigEndian",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const isBigEndian"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst isBigEndian = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#O_RDONLY",
              "documentation": {
                "identifier": "O_RDONLY",
                "newPage": false,
                "searchKey": "os.O_RDONLY",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const O_RDONLY"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst O_RDONLY int = syscall.O_RDONLY // open the file read-only.\n\n```\n\nFlags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. \n\nExactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#O_WRONLY",
              "documentation": {
                "identifier": "O_WRONLY",
                "newPage": false,
                "searchKey": "os.O_WRONLY",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const O_WRONLY"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst O_WRONLY int = syscall.O_WRONLY // open the file write-only.\n\n```\n\nFlags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#O_RDWR",
              "documentation": {
                "identifier": "O_RDWR",
                "newPage": false,
                "searchKey": "os.O_RDWR",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const O_RDWR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst O_RDWR int = syscall.O_RDWR // open the file read-write.\n\n```\n\nFlags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#O_APPEND",
              "documentation": {
                "identifier": "O_APPEND",
                "newPage": false,
                "searchKey": "os.O_APPEND",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const O_APPEND"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst O_APPEND int = syscall.O_APPEND // append data to the file when writing.\n\n```\n\nFlags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. \n\nThe remaining values may be or'ed in to control behavior. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#O_CREATE",
              "documentation": {
                "identifier": "O_CREATE",
                "newPage": false,
                "searchKey": "os.O_CREATE",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const O_CREATE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst O_CREATE int = syscall.O_CREAT // create a new file if none exists.\n\n```\n\nFlags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#O_EXCL",
              "documentation": {
                "identifier": "O_EXCL",
                "newPage": false,
                "searchKey": "os.O_EXCL",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const O_EXCL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst O_EXCL int = syscall.O_EXCL // used with O_CREATE, file must not exist.\n\n```\n\nFlags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#O_SYNC",
              "documentation": {
                "identifier": "O_SYNC",
                "newPage": false,
                "searchKey": "os.O_SYNC",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const O_SYNC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst O_SYNC int = syscall.O_SYNC // open for synchronous I/O.\n\n```\n\nFlags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#O_TRUNC",
              "documentation": {
                "identifier": "O_TRUNC",
                "newPage": false,
                "searchKey": "os.O_TRUNC",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const O_TRUNC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst O_TRUNC int = syscall.O_TRUNC // truncate regular writable file when opened.\n\n```\n\nFlags to OpenFile wrapping those of the underlying system. Not all flags may be implemented on a given system. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#SEEK_SET",
              "documentation": {
                "identifier": "SEEK_SET",
                "newPage": false,
                "searchKey": "os.SEEK_SET",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SEEK_SET"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SEEK_SET int = 0 // seek relative to the origin of the file\n\n```\n\nSeek whence values. \n\nDeprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#SEEK_CUR",
              "documentation": {
                "identifier": "SEEK_CUR",
                "newPage": false,
                "searchKey": "os.SEEK_CUR",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SEEK_CUR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SEEK_CUR int = 1 // seek relative to the current offset\n\n```\n\nSeek whence values. \n\nDeprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#SEEK_END",
              "documentation": {
                "identifier": "SEEK_END",
                "newPage": false,
                "searchKey": "os.SEEK_END",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const SEEK_END"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst SEEK_END int = 2 // seek relative to the end\n\n```\n\nSeek whence values. \n\nDeprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#kindNewFile",
              "documentation": {
                "identifier": "kindNewFile",
                "newPage": false,
                "searchKey": "os.kindNewFile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindNewFile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindNewFile newFileKind = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#kindOpenFile",
              "documentation": {
                "identifier": "kindOpenFile",
                "newPage": false,
                "searchKey": "os.kindOpenFile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindOpenFile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindOpenFile\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#kindPipe",
              "documentation": {
                "identifier": "kindPipe",
                "newPage": false,
                "searchKey": "os.kindPipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindPipe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindPipe\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#kindNonBlock",
              "documentation": {
                "identifier": "kindNonBlock",
                "newPage": false,
                "searchKey": "os.kindNonBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindNonBlock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindNonBlock\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#DevNull",
              "documentation": {
                "identifier": "DevNull",
                "newPage": false,
                "searchKey": "os.DevNull",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const DevNull"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst DevNull = \"/dev/null\"\n```\n\nDevNull is the name of the operating system's `null device.' On Unix-like systems, it is \"/dev/null\"; on Windows, \"NUL\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#PathSeparator",
              "documentation": {
                "identifier": "PathSeparator",
                "newPage": false,
                "searchKey": "os.PathSeparator",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const PathSeparator"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PathSeparator = '/' // OS-specific path separator\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#PathListSeparator",
              "documentation": {
                "identifier": "PathListSeparator",
                "newPage": false,
                "searchKey": "os.PathListSeparator",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const PathListSeparator"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PathListSeparator = ':' // OS-specific path list separator\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#supportsCreateWithStickyBit",
              "documentation": {
                "identifier": "supportsCreateWithStickyBit",
                "newPage": false,
                "searchKey": "os.supportsCreateWithStickyBit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const supportsCreateWithStickyBit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst supportsCreateWithStickyBit = false\n```\n\nAccording to sticky(8), neither open(2) nor mkdir(2) will create a file with the sticky bit set. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#hex",
              "documentation": {
                "identifier": "hex",
                "newPage": false,
                "searchKey": "os.hex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hex = \"0123456789abcdef\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#supportsCloseOnExec",
              "documentation": {
                "identifier": "supportsCloseOnExec",
                "newPage": false,
                "searchKey": "os.supportsCloseOnExec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const supportsCloseOnExec"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst supportsCloseOnExec = true\n```\n\nsupportsCloseOnExec reports whether the platform supports the O_CLOEXEC flag. On Darwin, the O_CLOEXEC flag was introduced in OS X 10.7 (Darwin 11.0.0). See [https://support.apple.com/kb/HT1633](https://support.apple.com/kb/HT1633). On FreeBSD, the O_CLOEXEC flag was introduced in version 8.3. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeDir",
              "documentation": {
                "identifier": "ModeDir",
                "newPage": false,
                "searchKey": "os.ModeDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeDir"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeDir = fs.ModeDir // d: is a directory\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\nThe single letters are the abbreviations used by the String method's formatting. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeAppend",
              "documentation": {
                "identifier": "ModeAppend",
                "newPage": false,
                "searchKey": "os.ModeAppend",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeAppend"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeAppend = fs.ModeAppend // a: append-only\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeExclusive",
              "documentation": {
                "identifier": "ModeExclusive",
                "newPage": false,
                "searchKey": "os.ModeExclusive",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeExclusive"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeExclusive = fs.ModeExclusive // l: exclusive use\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeTemporary",
              "documentation": {
                "identifier": "ModeTemporary",
                "newPage": false,
                "searchKey": "os.ModeTemporary",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeTemporary"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeTemporary = fs.ModeTemporary // T: temporary file; Plan 9 only\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeSymlink",
              "documentation": {
                "identifier": "ModeSymlink",
                "newPage": false,
                "searchKey": "os.ModeSymlink",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeSymlink"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeSymlink = fs.ModeSymlink // L: symbolic link\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeDevice",
              "documentation": {
                "identifier": "ModeDevice",
                "newPage": false,
                "searchKey": "os.ModeDevice",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeDevice"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeDevice = fs.ModeDevice // D: device file\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeNamedPipe",
              "documentation": {
                "identifier": "ModeNamedPipe",
                "newPage": false,
                "searchKey": "os.ModeNamedPipe",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeNamedPipe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeNamedPipe = fs.ModeNamedPipe // p: named pipe (FIFO)\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeSocket",
              "documentation": {
                "identifier": "ModeSocket",
                "newPage": false,
                "searchKey": "os.ModeSocket",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeSocket"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeSocket = fs.ModeSocket // S: Unix domain socket\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeSetuid",
              "documentation": {
                "identifier": "ModeSetuid",
                "newPage": false,
                "searchKey": "os.ModeSetuid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeSetuid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeSetuid = fs.ModeSetuid // u: setuid\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeSetgid",
              "documentation": {
                "identifier": "ModeSetgid",
                "newPage": false,
                "searchKey": "os.ModeSetgid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeSetgid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeSetgid = fs.ModeSetgid // g: setgid\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeCharDevice",
              "documentation": {
                "identifier": "ModeCharDevice",
                "newPage": false,
                "searchKey": "os.ModeCharDevice",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeCharDevice"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeCharDevice = fs.ModeCharDevice // c: Unix character device, when ModeDevice is set\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeSticky",
              "documentation": {
                "identifier": "ModeSticky",
                "newPage": false,
                "searchKey": "os.ModeSticky",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeSticky"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeSticky = fs.ModeSticky // t: sticky\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeIrregular",
              "documentation": {
                "identifier": "ModeIrregular",
                "newPage": false,
                "searchKey": "os.ModeIrregular",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeIrregular"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeIrregular // ?: non-regular file; nothing else is known about this file\n = ...\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModeType",
              "documentation": {
                "identifier": "ModeType",
                "newPage": false,
                "searchKey": "os.ModeType",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModeType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModeType = fs.ModeType\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\nMask for the type bits. For regular files, none will be set. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ModePerm",
              "documentation": {
                "identifier": "ModePerm",
                "newPage": false,
                "searchKey": "os.ModePerm",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ModePerm"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ModePerm = fs.ModePerm // Unix permission bits, 0o777\n\n```\n\nThe defined file mode bits are the most significant bits of the FileMode. The nine least-significant bits are the standard Unix rwxrwxrwx permissions. The values of these bits should be considered part of the public API and may be used in wire protocols or disk representations: they must not be changed, although new bits might be added. \n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/os#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/os#testingForceReadDirLstat",
              "documentation": {
                "identifier": "testingForceReadDirLstat",
                "newPage": false,
                "searchKey": "os.testingForceReadDirLstat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testingForceReadDirLstat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testingForceReadDirLstat bool\n```\n\ntestingForceReadDirLstat forces ReadDir to call Lstat, for testing that code path. This can be difficult to provoke on some Unix systems otherwise. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ErrInvalid",
              "documentation": {
                "identifier": "ErrInvalid",
                "newPage": false,
                "searchKey": "os.ErrInvalid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrInvalid"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrInvalid = fs.ErrInvalid // \"invalid argument\"\n\n```\n\nPortable analogs of some common system call errors. \n\nErrors returned from this package may be tested against these errors with errors.Is. \n\nErrInvalid indicates an invalid argument. Methods on File will return this error when the receiver is nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ErrPermission",
              "documentation": {
                "identifier": "ErrPermission",
                "newPage": false,
                "searchKey": "os.ErrPermission",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrPermission"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrPermission = fs.ErrPermission // \"permission denied\"\n\n```\n\nPortable analogs of some common system call errors. \n\nErrors returned from this package may be tested against these errors with errors.Is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ErrExist",
              "documentation": {
                "identifier": "ErrExist",
                "newPage": false,
                "searchKey": "os.ErrExist",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrExist"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrExist = fs.ErrExist // \"file already exists\"\n\n```\n\nPortable analogs of some common system call errors. \n\nErrors returned from this package may be tested against these errors with errors.Is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ErrNotExist",
              "documentation": {
                "identifier": "ErrNotExist",
                "newPage": false,
                "searchKey": "os.ErrNotExist",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrNotExist"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrNotExist = fs.ErrNotExist // \"file does not exist\"\n\n```\n\nPortable analogs of some common system call errors. \n\nErrors returned from this package may be tested against these errors with errors.Is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ErrClosed",
              "documentation": {
                "identifier": "ErrClosed",
                "newPage": false,
                "searchKey": "os.ErrClosed",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrClosed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrClosed = fs.ErrClosed // \"file already closed\"\n\n```\n\nPortable analogs of some common system call errors. \n\nErrors returned from this package may be tested against these errors with errors.Is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ErrNoDeadline",
              "documentation": {
                "identifier": "ErrNoDeadline",
                "newPage": false,
                "searchKey": "os.ErrNoDeadline",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrNoDeadline"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrNoDeadline = errNoDeadline() // \"file type does not support deadline\"\n\n```\n\nPortable analogs of some common system call errors. \n\nErrors returned from this package may be tested against these errors with errors.Is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ErrDeadlineExceeded",
              "documentation": {
                "identifier": "ErrDeadlineExceeded",
                "newPage": false,
                "searchKey": "os.ErrDeadlineExceeded",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrDeadlineExceeded"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrDeadlineExceeded = errDeadlineExceeded() // \"i/o timeout\"\n\n```\n\nPortable analogs of some common system call errors. \n\nErrors returned from this package may be tested against these errors with errors.Is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ErrProcessDone",
              "documentation": {
                "identifier": "ErrProcessDone",
                "newPage": false,
                "searchKey": "os.ErrProcessDone",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrProcessDone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrProcessDone = errors.New(\"os: process already finished\")\n```\n\nErrProcessDone indicates a Process has finished. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Interrupt",
              "documentation": {
                "identifier": "Interrupt",
                "newPage": false,
                "searchKey": "os.Interrupt",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Interrupt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Interrupt Signal = syscall.SIGINT\n```\n\nThe only signal values guaranteed to be present in the os package on all systems are os.Interrupt (send the process an interrupt) and os.Kill (force the process to exit). On Windows, sending os.Interrupt to a process with os.Process.Signal is not implemented; it will return an error instead of sending a signal. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Kill",
              "documentation": {
                "identifier": "Kill",
                "newPage": false,
                "searchKey": "os.Kill",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Kill"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Kill Signal = syscall.SIGKILL\n```\n\nThe only signal values guaranteed to be present in the os package on all systems are os.Interrupt (send the process an interrupt) and os.Kill (force the process to exit). On Windows, sending os.Interrupt to a process with os.Process.Signal is not implemented; it will return an error instead of sending a signal. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#executablePath",
              "documentation": {
                "identifier": "executablePath",
                "newPage": false,
                "searchKey": "os.executablePath",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var executablePath"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar executablePath string // set by ../runtime/os_darwin.go\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#initCwd",
              "documentation": {
                "identifier": "initCwd",
                "newPage": false,
                "searchKey": "os.initCwd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var initCwd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar initCwd, initCwdErr = Getwd()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#initCwdErr",
              "documentation": {
                "identifier": "initCwdErr",
                "newPage": false,
                "searchKey": "os.initCwdErr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var initCwdErr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar initCwd, initCwdErr = Getwd()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Stdin",
              "documentation": {
                "identifier": "Stdin",
                "newPage": false,
                "searchKey": "os.Stdin",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Stdin"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Stdin = NewFile(uintptr(syscall.Stdin), \"/dev/stdin\")\n```\n\nStdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors. \n\nNote that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Stdout",
              "documentation": {
                "identifier": "Stdout",
                "newPage": false,
                "searchKey": "os.Stdout",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Stdout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Stdout = NewFile(uintptr(syscall.Stdout), \"/dev/stdout\")\n```\n\nStdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors. \n\nNote that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Stderr",
              "documentation": {
                "identifier": "Stderr",
                "newPage": false,
                "searchKey": "os.Stderr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Stderr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Stderr = NewFile(uintptr(syscall.Stderr), \"/dev/stderr\")\n```\n\nStdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors. \n\nNote that the Go runtime writes to standard error for panics and crashes; closing Stderr may cause those messages to go elsewhere, perhaps to a file opened later. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#errWriteAtInAppendMode",
              "documentation": {
                "identifier": "errWriteAtInAppendMode",
                "newPage": false,
                "searchKey": "os.errWriteAtInAppendMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errWriteAtInAppendMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errWriteAtInAppendMode = errors.New(\"os: invalid use of WriteAt on file opened with O_APPEND\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#lstat",
              "documentation": {
                "identifier": "lstat",
                "newPage": false,
                "searchKey": "os.lstat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lstat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lstat = Lstat\n```\n\nlstat is overridden in tests. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#getwdCache",
              "documentation": {
                "identifier": "getwdCache",
                "newPage": false,
                "searchKey": "os.getwdCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var getwdCache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar getwdCache struct {\n\tsync.Mutex\n\tdir string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Args",
              "documentation": {
                "identifier": "Args",
                "newPage": false,
                "searchKey": "os.Args",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var Args"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Args []string\n```\n\nArgs hold the command-line arguments, starting with the program name. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#errPatternHasSeparator",
              "documentation": {
                "identifier": "errPatternHasSeparator",
                "newPage": false,
                "searchKey": "os.errPatternHasSeparator",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errPatternHasSeparator"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errPatternHasSeparator = errors.New(\"pattern contains path separator\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Atime",
              "documentation": {
                "identifier": "Atime",
                "newPage": false,
                "searchKey": "os.Atime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Atime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Atime = atime\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#LstatP",
              "documentation": {
                "identifier": "LstatP",
                "newPage": false,
                "searchKey": "os.LstatP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var LstatP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar LstatP = &lstat\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ErrWriteAtInAppendMode",
              "documentation": {
                "identifier": "ErrWriteAtInAppendMode",
                "newPage": false,
                "searchKey": "os.ErrWriteAtInAppendMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrWriteAtInAppendMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrWriteAtInAppendMode = errWriteAtInAppendMode\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#TestingForceReadDirLstat",
              "documentation": {
                "identifier": "TestingForceReadDirLstat",
                "newPage": false,
                "searchKey": "os.TestingForceReadDirLstat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var TestingForceReadDirLstat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar TestingForceReadDirLstat = &testingForceReadDirLstat\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ErrPatternHasSeparator",
              "documentation": {
                "identifier": "ErrPatternHasSeparator",
                "newPage": false,
                "searchKey": "os.ErrPatternHasSeparator",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ErrPatternHasSeparator"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ErrPatternHasSeparator = errPatternHasSeparator\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#SplitPath",
              "documentation": {
                "identifier": "SplitPath",
                "newPage": false,
                "searchKey": "os.SplitPath",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var SplitPath"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar SplitPath = splitPath\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/os#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/os#readdirMode",
              "documentation": {
                "identifier": "readdirMode",
                "newPage": false,
                "searchKey": "os.readdirMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type readdirMode int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype readdirMode int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#DirEntry",
              "documentation": {
                "identifier": "DirEntry",
                "newPage": false,
                "searchKey": "os.DirEntry",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type DirEntry fs.DirEntry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype DirEntry = fs.DirEntry\n```\n\nA DirEntry is an entry read from a directory (using the ReadDir function or a File's ReadDir method). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#newUnixDirent",
                    "documentation": {
                      "identifier": "newUnixDirent",
                      "newPage": false,
                      "searchKey": "os.newUnixDirent",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newUnixDirent(parent, name string, typ FileMode) (DirEntry, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newUnixDirent(parent, name string, typ FileMode) (DirEntry, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#dirInfo",
              "documentation": {
                "identifier": "dirInfo",
                "newPage": false,
                "searchKey": "os.dirInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type dirInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dirInfo struct {\n\tdir uintptr // Pointer to DIR structure from dirent.h\n}\n```\n\nAuxiliary information if the File describes a directory \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#dirInfo.close",
                    "documentation": {
                      "identifier": "dirInfo.close",
                      "newPage": false,
                      "searchKey": "os.dirInfo.close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *dirInfo) close()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *dirInfo) close()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#timeout",
              "documentation": {
                "identifier": "timeout",
                "newPage": false,
                "searchKey": "os.timeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type timeout interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype timeout interface {\n\tTimeout() bool\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#PathError",
              "documentation": {
                "identifier": "PathError",
                "newPage": false,
                "searchKey": "os.PathError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type PathError fs.PathError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PathError = fs.PathError\n```\n\nPathError records an error and the operation and file path that caused it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#SyscallError",
              "documentation": {
                "identifier": "SyscallError",
                "newPage": false,
                "searchKey": "os.SyscallError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type SyscallError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype SyscallError struct {\n\tSyscall string\n\tErr     error\n}\n```\n\nSyscallError records an error from a specific system call. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#SyscallError.Error",
                    "documentation": {
                      "identifier": "SyscallError.Error",
                      "newPage": false,
                      "searchKey": "os.SyscallError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *SyscallError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *SyscallError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#SyscallError.Unwrap",
                    "documentation": {
                      "identifier": "SyscallError.Unwrap",
                      "newPage": false,
                      "searchKey": "os.SyscallError.Unwrap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *SyscallError) Unwrap() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *SyscallError) Unwrap() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#SyscallError.Timeout",
                    "documentation": {
                      "identifier": "SyscallError.Timeout",
                      "newPage": false,
                      "searchKey": "os.SyscallError.Timeout",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *SyscallError) Timeout() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *SyscallError) Timeout() bool\n```\n\nTimeout reports whether this error represents a timeout. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#syscallErrorType",
              "documentation": {
                "identifier": "syscallErrorType",
                "newPage": false,
                "searchKey": "os.syscallErrorType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type syscallErrorType syscall.Errno"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype syscallErrorType = syscall.Errno\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#readdir_r",
                    "documentation": {
                      "identifier": "readdir_r",
                      "newPage": false,
                      "searchKey": "os.readdir_r",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func readdir_r(dir uintptr, entry *syscall.Dirent, result **syscall.Dirent) (res syscall.Errno)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc readdir_r(dir uintptr, entry *syscall.Dirent, result **syscall.Dirent) (res syscall.Errno)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#Process",
              "documentation": {
                "identifier": "Process",
                "newPage": false,
                "searchKey": "os.Process",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Process struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Process struct {\n\tPid    int\n\thandle uintptr      // handle is accessed atomically on Windows\n\tisdone uint32       // process has been successfully waited on, non zero if true\n\tsigMu  sync.RWMutex // avoid race between wait and signal\n}\n```\n\nProcess stores the information about a process created by StartProcess. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#newProcess",
                    "documentation": {
                      "identifier": "newProcess",
                      "newPage": false,
                      "searchKey": "os.newProcess",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newProcess(pid int, handle uintptr) *Process"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newProcess(pid int, handle uintptr) *Process\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#FindProcess",
                    "documentation": {
                      "identifier": "FindProcess",
                      "newPage": false,
                      "searchKey": "os.FindProcess",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FindProcess(pid int) (*Process, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FindProcess(pid int) (*Process, error)\n```\n\nFindProcess looks for a running process by its pid. \n\nThe Process it returns can be used to obtain information about the underlying operating system process. \n\nOn Unix systems, FindProcess always succeeds and returns a Process for the given pid, regardless of whether the process exists. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#StartProcess",
                    "documentation": {
                      "identifier": "StartProcess",
                      "newPage": false,
                      "searchKey": "os.StartProcess",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)\n```\n\nStartProcess starts a new process with the program, arguments and attributes specified by name, argv and attr. The argv slice will become os.Args in the new process, so it normally starts with the program name. \n\nIf the calling goroutine has locked the operating system thread with runtime.LockOSThread and modified any inheritable OS-level thread state (for example, Linux or Plan 9 name spaces), the new process will inherit the caller's thread state. \n\nStartProcess is a low-level interface. The os/exec package provides higher-level interfaces. \n\nIf there is an error, it will be of type *PathError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#startProcess",
                    "documentation": {
                      "identifier": "startProcess",
                      "newPage": false,
                      "searchKey": "os.startProcess",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#findProcess",
                    "documentation": {
                      "identifier": "findProcess",
                      "newPage": false,
                      "searchKey": "os.findProcess",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func findProcess(pid int) (p *Process, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc findProcess(pid int) (p *Process, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Process.setDone",
                    "documentation": {
                      "identifier": "Process.setDone",
                      "newPage": false,
                      "searchKey": "os.Process.setDone",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Process) setDone()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Process) setDone()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Process.done",
                    "documentation": {
                      "identifier": "Process.done",
                      "newPage": false,
                      "searchKey": "os.Process.done",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Process) done() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Process) done() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Process.Release",
                    "documentation": {
                      "identifier": "Process.Release",
                      "newPage": false,
                      "searchKey": "os.Process.Release",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Process) Release() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Process) Release() error\n```\n\nRelease releases any resources associated with the Process p, rendering it unusable in the future. Release only needs to be called if Wait is not. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Process.Kill",
                    "documentation": {
                      "identifier": "Process.Kill",
                      "newPage": false,
                      "searchKey": "os.Process.Kill",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Process) Kill() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Process) Kill() error\n```\n\nKill causes the Process to exit immediately. Kill does not wait until the Process has actually exited. This only kills the Process itself, not any other processes it may have started. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Process.Wait",
                    "documentation": {
                      "identifier": "Process.Wait",
                      "newPage": false,
                      "searchKey": "os.Process.Wait",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Process) Wait() (*ProcessState, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Process) Wait() (*ProcessState, error)\n```\n\nWait waits for the Process to exit, and then returns a ProcessState describing its status and an error, if any. Wait releases any resources associated with the Process. On most operating systems, the Process must be a child of the current process or an error will be returned. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Process.Signal",
                    "documentation": {
                      "identifier": "Process.Signal",
                      "newPage": false,
                      "searchKey": "os.Process.Signal",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Process) Signal(sig Signal) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Process) Signal(sig Signal) error\n```\n\nSignal sends a signal to the Process. Sending Interrupt on Windows is not implemented. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Process.kill",
                    "documentation": {
                      "identifier": "Process.kill",
                      "newPage": false,
                      "searchKey": "os.Process.kill",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Process) kill() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Process) kill() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Process.wait",
                    "documentation": {
                      "identifier": "Process.wait",
                      "newPage": false,
                      "searchKey": "os.Process.wait",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Process) wait() (ps *ProcessState, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Process) wait() (ps *ProcessState, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Process.signal",
                    "documentation": {
                      "identifier": "Process.signal",
                      "newPage": false,
                      "searchKey": "os.Process.signal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Process) signal(sig Signal) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Process) signal(sig Signal) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Process.release",
                    "documentation": {
                      "identifier": "Process.release",
                      "newPage": false,
                      "searchKey": "os.Process.release",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Process) release() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Process) release() error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Process.blockUntilWaitable",
                    "documentation": {
                      "identifier": "Process.blockUntilWaitable",
                      "newPage": false,
                      "searchKey": "os.Process.blockUntilWaitable",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *Process) blockUntilWaitable() (bool, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *Process) blockUntilWaitable() (bool, error)\n```\n\nblockUntilWaitable attempts to block until a call to p.Wait will succeed immediately, and reports whether it has done so. It does not actually call p.Wait. This version is used on systems that do not implement waitid, or where we have not implemented it yet. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#ProcAttr",
              "documentation": {
                "identifier": "ProcAttr",
                "newPage": false,
                "searchKey": "os.ProcAttr",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ProcAttr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ProcAttr struct {\n\t// If Dir is non-empty, the child changes into the directory before\n\t// creating the process.\n\tDir string\n\t// If Env is non-nil, it gives the environment variables for the\n\t// new process in the form returned by Environ.\n\t// If it is nil, the result of Environ will be used.\n\tEnv []string\n\t// Files specifies the open files inherited by the new process. The\n\t// first three entries correspond to standard input, standard output, and\n\t// standard error. An implementation may support additional entries,\n\t// depending on the underlying operating system. A nil entry corresponds\n\t// to that file being closed when the process starts.\n\t// On Unix systems, StartProcess will change these File values\n\t// to blocking mode, which means that SetDeadline will stop working\n\t// and calling Close will not interrupt a Read or Write.\n\tFiles []*File\n\n\t// Operating system-specific process creation attributes.\n\t// Note that setting this field means that your program\n\t// may not execute properly or even compile on some\n\t// operating systems.\n\tSys *syscall.SysProcAttr\n}\n```\n\nProcAttr holds the attributes that will be applied to a new process started by StartProcess. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Signal",
              "documentation": {
                "identifier": "Signal",
                "newPage": false,
                "searchKey": "os.Signal",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Signal interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Signal interface {\n\tString() string\n\tSignal() // to distinguish from other Stringers\n}\n```\n\nA Signal represents an operating system signal. The usual underlying implementation is operating system-dependent: on Unix it is syscall.Signal. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ProcessState",
              "documentation": {
                "identifier": "ProcessState",
                "newPage": false,
                "searchKey": "os.ProcessState",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ProcessState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ProcessState struct {\n\tpid    int                // The process's id.\n\tstatus syscall.WaitStatus // System-dependent status info.\n\trusage *syscall.Rusage\n}\n```\n\nProcessState stores information about a process, as reported by Wait. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.UserTime",
                    "documentation": {
                      "identifier": "ProcessState.UserTime",
                      "newPage": false,
                      "searchKey": "os.ProcessState.UserTime",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) UserTime() time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) UserTime() time.Duration\n```\n\nUserTime returns the user CPU time of the exited process and its children. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.SystemTime",
                    "documentation": {
                      "identifier": "ProcessState.SystemTime",
                      "newPage": false,
                      "searchKey": "os.ProcessState.SystemTime",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) SystemTime() time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) SystemTime() time.Duration\n```\n\nSystemTime returns the system CPU time of the exited process and its children. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.Exited",
                    "documentation": {
                      "identifier": "ProcessState.Exited",
                      "newPage": false,
                      "searchKey": "os.ProcessState.Exited",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) Exited() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) Exited() bool\n```\n\nExited reports whether the program has exited. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.Success",
                    "documentation": {
                      "identifier": "ProcessState.Success",
                      "newPage": false,
                      "searchKey": "os.ProcessState.Success",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) Success() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) Success() bool\n```\n\nSuccess reports whether the program exited successfully, such as with exit status 0 on Unix. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.Sys",
                    "documentation": {
                      "identifier": "ProcessState.Sys",
                      "newPage": false,
                      "searchKey": "os.ProcessState.Sys",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) Sys() interface{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) Sys() interface{}\n```\n\nSys returns system-dependent exit information about the process. Convert it to the appropriate underlying type, such as syscall.WaitStatus on Unix, to access its contents. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.SysUsage",
                    "documentation": {
                      "identifier": "ProcessState.SysUsage",
                      "newPage": false,
                      "searchKey": "os.ProcessState.SysUsage",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) SysUsage() interface{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) SysUsage() interface{}\n```\n\nSysUsage returns system-dependent resource usage information about the exited process. Convert it to the appropriate underlying type, such as *syscall.Rusage on Unix, to access its contents. (On Unix, *syscall.Rusage matches struct rusage as defined in the getrusage(2) manual page.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.Pid",
                    "documentation": {
                      "identifier": "ProcessState.Pid",
                      "newPage": false,
                      "searchKey": "os.ProcessState.Pid",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) Pid() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) Pid() int\n```\n\nPid returns the process id of the exited process. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.exited",
                    "documentation": {
                      "identifier": "ProcessState.exited",
                      "newPage": false,
                      "searchKey": "os.ProcessState.exited",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) exited() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) exited() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.success",
                    "documentation": {
                      "identifier": "ProcessState.success",
                      "newPage": false,
                      "searchKey": "os.ProcessState.success",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) success() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) success() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.sys",
                    "documentation": {
                      "identifier": "ProcessState.sys",
                      "newPage": false,
                      "searchKey": "os.ProcessState.sys",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) sys() interface{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) sys() interface{}\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.sysUsage",
                    "documentation": {
                      "identifier": "ProcessState.sysUsage",
                      "newPage": false,
                      "searchKey": "os.ProcessState.sysUsage",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) sysUsage() interface{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) sysUsage() interface{}\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.String",
                    "documentation": {
                      "identifier": "ProcessState.String",
                      "newPage": false,
                      "searchKey": "os.ProcessState.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.ExitCode",
                    "documentation": {
                      "identifier": "ProcessState.ExitCode",
                      "newPage": false,
                      "searchKey": "os.ProcessState.ExitCode",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) ExitCode() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) ExitCode() int\n```\n\nExitCode returns the exit code of the exited process, or -1 if the process hasn't exited or was terminated by a signal. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.userTime",
                    "documentation": {
                      "identifier": "ProcessState.userTime",
                      "newPage": false,
                      "searchKey": "os.ProcessState.userTime",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) userTime() time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) userTime() time.Duration\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#ProcessState.systemTime",
                    "documentation": {
                      "identifier": "ProcessState.systemTime",
                      "newPage": false,
                      "searchKey": "os.ProcessState.systemTime",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProcessState) systemTime() time.Duration"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProcessState) systemTime() time.Duration\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#LinkError",
              "documentation": {
                "identifier": "LinkError",
                "newPage": false,
                "searchKey": "os.LinkError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type LinkError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype LinkError struct {\n\tOp  string\n\tOld string\n\tNew string\n\tErr error\n}\n```\n\nLinkError records an error during a link or symlink or rename system call and the paths that caused it. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#LinkError.Error",
                    "documentation": {
                      "identifier": "LinkError.Error",
                      "newPage": false,
                      "searchKey": "os.LinkError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *LinkError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *LinkError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#LinkError.Unwrap",
                    "documentation": {
                      "identifier": "LinkError.Unwrap",
                      "newPage": false,
                      "searchKey": "os.LinkError.Unwrap",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *LinkError) Unwrap() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *LinkError) Unwrap() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#onlyWriter",
              "documentation": {
                "identifier": "onlyWriter",
                "newPage": false,
                "searchKey": "os.onlyWriter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type onlyWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype onlyWriter struct {\n\tio.Writer\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#dirFS",
              "documentation": {
                "identifier": "dirFS",
                "newPage": false,
                "searchKey": "os.dirFS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type dirFS string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dirFS string\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#dirFS.Open",
                    "documentation": {
                      "identifier": "dirFS.Open",
                      "newPage": false,
                      "searchKey": "os.dirFS.Open",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dir dirFS) Open(name string) (fs.File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dir dirFS) Open(name string) (fs.File, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#dirFS.Stat",
                    "documentation": {
                      "identifier": "dirFS.Stat",
                      "newPage": false,
                      "searchKey": "os.dirFS.Stat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (dir dirFS) Stat(name string) (fs.FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (dir dirFS) Stat(name string) (fs.FileInfo, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#file",
              "documentation": {
                "identifier": "file",
                "newPage": false,
                "searchKey": "os.file",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type file struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype file struct {\n\tpfd         poll.FD\n\tname        string\n\tdirinfo     *dirInfo // nil unless directory being read\n\tnonblock    bool     // whether we set nonblocking mode\n\tstdoutOrErr bool     // whether this is stdout or stderr\n\tappendMode  bool     // whether file is opened for appending\n}\n```\n\nfile is the real representation of *File. The extra level of indirection ensures that no clients of os can overwrite this data, which could cause the finalizer to close the wrong file descriptor. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#file.close",
                    "documentation": {
                      "identifier": "file.close",
                      "newPage": false,
                      "searchKey": "os.file.close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (file *file) close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (file *file) close() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#newFileKind",
              "documentation": {
                "identifier": "newFileKind",
                "newPage": false,
                "searchKey": "os.newFileKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type newFileKind int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype newFileKind int\n```\n\nnewFileKind describes the kind of file to newFile. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#unixDirent",
              "documentation": {
                "identifier": "unixDirent",
                "newPage": false,
                "searchKey": "os.unixDirent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type unixDirent struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype unixDirent struct {\n\tparent string\n\tname   string\n\ttyp    FileMode\n\tinfo   FileInfo\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#unixDirent.Name",
                    "documentation": {
                      "identifier": "unixDirent.Name",
                      "newPage": false,
                      "searchKey": "os.unixDirent.Name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *unixDirent) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *unixDirent) Name() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#unixDirent.IsDir",
                    "documentation": {
                      "identifier": "unixDirent.IsDir",
                      "newPage": false,
                      "searchKey": "os.unixDirent.IsDir",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *unixDirent) IsDir() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *unixDirent) IsDir() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#unixDirent.Type",
                    "documentation": {
                      "identifier": "unixDirent.Type",
                      "newPage": false,
                      "searchKey": "os.unixDirent.Type",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *unixDirent) Type() FileMode"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *unixDirent) Type() FileMode\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#unixDirent.Info",
                    "documentation": {
                      "identifier": "unixDirent.Info",
                      "newPage": false,
                      "searchKey": "os.unixDirent.Info",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *unixDirent) Info() (FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *unixDirent) Info() (FileInfo, error)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#rawConn",
              "documentation": {
                "identifier": "rawConn",
                "newPage": false,
                "searchKey": "os.rawConn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type rawConn struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype rawConn struct {\n\tfile *File\n}\n```\n\nrawConn implements syscall.RawConn. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#newRawConn",
                    "documentation": {
                      "identifier": "newRawConn",
                      "newPage": false,
                      "searchKey": "os.newRawConn",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newRawConn(file *File) (*rawConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newRawConn(file *File) (*rawConn, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#rawConn.Control",
                    "documentation": {
                      "identifier": "rawConn.Control",
                      "newPage": false,
                      "searchKey": "os.rawConn.Control",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *rawConn) Control(f func(uintptr)) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *rawConn) Control(f func(uintptr)) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#rawConn.Read",
                    "documentation": {
                      "identifier": "rawConn.Read",
                      "newPage": false,
                      "searchKey": "os.rawConn.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *rawConn) Read(f func(uintptr) bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *rawConn) Read(f func(uintptr) bool) error\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#rawConn.Write",
                    "documentation": {
                      "identifier": "rawConn.Write",
                      "newPage": false,
                      "searchKey": "os.rawConn.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *rawConn) Write(f func(uintptr) bool) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *rawConn) Write(f func(uintptr) bool) error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#File",
              "documentation": {
                "identifier": "File",
                "newPage": false,
                "searchKey": "os.File",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type File struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype File struct {\n\t*file // os specific\n}\n```\n\nFile represents an open file descriptor. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#Open",
                    "documentation": {
                      "identifier": "Open",
                      "newPage": false,
                      "searchKey": "os.Open",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Open(name string) (*File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Open(name string) (*File, error)\n```\n\nOpen opens the named file for reading. If successful, methods on the returned file can be used for reading; the associated file descriptor has mode O_RDONLY. If there is an error, it will be of type *PathError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Create",
                    "documentation": {
                      "identifier": "Create",
                      "newPage": false,
                      "searchKey": "os.Create",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Create(name string) (*File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Create(name string) (*File, error)\n```\n\nCreate creates or truncates the named file. If the file already exists, it is truncated. If the file does not exist, it is created with mode 0666 (before umask). If successful, methods on the returned File can be used for I/O; the associated file descriptor has mode O_RDWR. If there is an error, it will be of type *PathError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#OpenFile",
                    "documentation": {
                      "identifier": "OpenFile",
                      "newPage": false,
                      "searchKey": "os.OpenFile",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func OpenFile(name string, flag int, perm FileMode) (*File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc OpenFile(name string, flag int, perm FileMode) (*File, error)\n```\n\nOpenFile is the generalized open call; most users will use Open or Create instead. It opens the named file with specified flag (O_RDONLY etc.). If the file does not exist, and the O_CREATE flag is passed, it is created with mode perm (before umask). If successful, methods on the returned File can be used for I/O. If there is an error, it will be of type *PathError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#NewFile",
                    "documentation": {
                      "identifier": "NewFile",
                      "newPage": false,
                      "searchKey": "os.NewFile",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewFile(fd uintptr, name string) *File"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewFile(fd uintptr, name string) *File\n```\n\nNewFile returns a new File with the given file descriptor and name. The returned value will be nil if fd is not a valid file descriptor. On Unix systems, if the file descriptor is in non-blocking mode, NewFile will attempt to return a pollable File (one for which the SetDeadline methods work). \n\nAfter passing it to NewFile, fd may become invalid under the same conditions described in the comments of the Fd method, and the same constraints apply. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#newFile",
                    "documentation": {
                      "identifier": "newFile",
                      "newPage": false,
                      "searchKey": "os.newFile",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newFile(fd uintptr, name string, kind newFileKind) *File"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newFile(fd uintptr, name string, kind newFileKind) *File\n```\n\nnewFile is like NewFile, but if called from OpenFile or Pipe (as passed in the kind parameter) it tries to add the file to the runtime poller. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#openFileNolog",
                    "documentation": {
                      "identifier": "openFileNolog",
                      "newPage": false,
                      "searchKey": "os.openFileNolog",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func openFileNolog(name string, flag int, perm FileMode) (*File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc openFileNolog(name string, flag int, perm FileMode) (*File, error)\n```\n\nopenFileNolog is the Unix implementation of OpenFile. Changes here should be reflected in openFdAt, if relevant. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Pipe",
                    "documentation": {
                      "identifier": "Pipe",
                      "newPage": false,
                      "searchKey": "os.Pipe",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Pipe() (r *File, w *File, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Pipe() (r *File, w *File, err error)\n```\n\nPipe returns a connected pair of Files; reads from r return bytes written to w. It returns the files and an error, if any. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#openFdAt",
                    "documentation": {
                      "identifier": "openFdAt",
                      "newPage": false,
                      "searchKey": "os.openFdAt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func openFdAt(dirfd int, name string) (*File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc openFdAt(dirfd int, name string) (*File, error)\n```\n\nopenFdAt opens path relative to the directory in fd. Other than that this should act like openFileNolog. This acts like openFileNolog rather than OpenFile because we are going to (try to) remove the file. The contents of this file are not relevant for test caching. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#CreateTemp",
                    "documentation": {
                      "identifier": "CreateTemp",
                      "newPage": false,
                      "searchKey": "os.CreateTemp",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func CreateTemp(dir, pattern string) (*File, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc CreateTemp(dir, pattern string) (*File, error)\n```\n\nCreateTemp creates a new temporary file in the directory dir, opens the file for reading and writing, and returns the resulting file. The filename is generated by taking pattern and adding a random string to the end. If pattern includes a \"*\", the random string replaces the last \"*\". If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by TempDir. Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file. The caller can use the file's Name method to find the pathname of the file. It is the caller's responsibility to remove the file when it is no longer needed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Readdir",
                    "documentation": {
                      "identifier": "File.Readdir",
                      "newPage": false,
                      "searchKey": "os.File.Readdir",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Readdir(n int) ([]FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Readdir(n int) ([]FileInfo, error)\n```\n\nReaddir reads the contents of the directory associated with file and returns a slice of up to n FileInfo values, as would be returned by Lstat, in directory order. Subsequent calls on the same file will yield further FileInfos. \n\nIf n > 0, Readdir returns at most n FileInfo structures. In this case, if Readdir returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF. \n\nIf n <= 0, Readdir returns all the FileInfo from the directory in a single slice. In this case, if Readdir succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdir returns the FileInfo read until that point and a non-nil error. \n\nMost clients are better served by the more efficient ReadDir method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Readdirnames",
                    "documentation": {
                      "identifier": "File.Readdirnames",
                      "newPage": false,
                      "searchKey": "os.File.Readdirnames",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Readdirnames(n int) (names []string, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Readdirnames(n int) (names []string, err error)\n```\n\nReaddirnames reads the contents of the directory associated with file and returns a slice of up to n names of files in the directory, in directory order. Subsequent calls on the same file will yield further names. \n\nIf n > 0, Readdirnames returns at most n names. In this case, if Readdirnames returns an empty slice, it will return a non-nil error explaining why. At the end of a directory, the error is io.EOF. \n\nIf n <= 0, Readdirnames returns all the names from the directory in a single slice. In this case, if Readdirnames succeeds (reads all the way to the end of the directory), it returns the slice and a nil error. If it encounters an error before the end of the directory, Readdirnames returns the names read until that point and a non-nil error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.ReadDir",
                    "documentation": {
                      "identifier": "File.ReadDir",
                      "newPage": false,
                      "searchKey": "os.File.ReadDir",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) ReadDir(n int) ([]DirEntry, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) ReadDir(n int) ([]DirEntry, error)\n```\n\nReadDir reads the contents of the directory associated with the file f and returns a slice of DirEntry values in directory order. Subsequent calls on the same file will yield later DirEntry records in the directory. \n\nIf n > 0, ReadDir returns at most n DirEntry records. In this case, if ReadDir returns an empty slice, it will return an error explaining why. At the end of a directory, the error is io.EOF. \n\nIf n <= 0, ReadDir returns all the DirEntry records remaining in the directory. When it succeeds, it returns a nil error (not io.EOF). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.readdir",
                    "documentation": {
                      "identifier": "File.readdir",
                      "newPage": false,
                      "searchKey": "os.File.readdir",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) readdir(n int, mode readdirMode) (names []string, dirents []DirEntry, infos []FileInfo, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) readdir(n int, mode readdirMode) (names []string, dirents []DirEntry, infos []FileInfo, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Name",
                    "documentation": {
                      "identifier": "File.Name",
                      "newPage": false,
                      "searchKey": "os.File.Name",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Name() string\n```\n\nName returns the name of the file as presented to Open. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Read",
                    "documentation": {
                      "identifier": "File.Read",
                      "newPage": false,
                      "searchKey": "os.File.Read",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Read(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Read(b []byte) (n int, err error)\n```\n\nRead reads up to len(b) bytes from the File. It returns the number of bytes read and any error encountered. At end of file, Read returns 0, io.EOF. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.ReadAt",
                    "documentation": {
                      "identifier": "File.ReadAt",
                      "newPage": false,
                      "searchKey": "os.File.ReadAt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) ReadAt(b []byte, off int64) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) ReadAt(b []byte, off int64) (n int, err error)\n```\n\nReadAt reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. ReadAt always returns a non-nil error when n < len(b). At end of file, that error is io.EOF. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.ReadFrom",
                    "documentation": {
                      "identifier": "File.ReadFrom",
                      "newPage": false,
                      "searchKey": "os.File.ReadFrom",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) ReadFrom(r io.Reader) (n int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) ReadFrom(r io.Reader) (n int64, err error)\n```\n\nReadFrom implements io.ReaderFrom. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Write",
                    "documentation": {
                      "identifier": "File.Write",
                      "newPage": false,
                      "searchKey": "os.File.Write",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Write(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Write(b []byte) (n int, err error)\n```\n\nWrite writes len(b) bytes to the File. It returns the number of bytes written and an error, if any. Write returns a non-nil error when n != len(b). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.WriteAt",
                    "documentation": {
                      "identifier": "File.WriteAt",
                      "newPage": false,
                      "searchKey": "os.File.WriteAt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) WriteAt(b []byte, off int64) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) WriteAt(b []byte, off int64) (n int, err error)\n```\n\nWriteAt writes len(b) bytes to the File starting at byte offset off. It returns the number of bytes written and an error, if any. WriteAt returns a non-nil error when n != len(b). \n\nIf file was opened with the O_APPEND flag, WriteAt returns an error. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Seek",
                    "documentation": {
                      "identifier": "File.Seek",
                      "newPage": false,
                      "searchKey": "os.File.Seek",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Seek(offset int64, whence int) (ret int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Seek(offset int64, whence int) (ret int64, err error)\n```\n\nSeek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. The behavior of Seek on a file opened with O_APPEND is not specified. \n\nIf f is a directory, the behavior of Seek varies by operating system; you can seek to the beginning of the directory on Unix-like operating systems, but not on Windows. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.WriteString",
                    "documentation": {
                      "identifier": "File.WriteString",
                      "newPage": false,
                      "searchKey": "os.File.WriteString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) WriteString(s string) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) WriteString(s string) (n int, err error)\n```\n\nWriteString is like Write, but writes the contents of string s rather than a slice of bytes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.wrapErr",
                    "documentation": {
                      "identifier": "File.wrapErr",
                      "newPage": false,
                      "searchKey": "os.File.wrapErr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) wrapErr(op string, err error) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) wrapErr(op string, err error) error\n```\n\nwrapErr wraps an error that occurred during an operation on an open file. It passes io.EOF through unchanged, otherwise converts poll.ErrFileClosing to ErrClosed and wraps the error in a PathError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Chmod",
                    "documentation": {
                      "identifier": "File.Chmod",
                      "newPage": false,
                      "searchKey": "os.File.Chmod",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Chmod(mode FileMode) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Chmod(mode FileMode) error\n```\n\nChmod changes the mode of the file to mode. If there is an error, it will be of type *PathError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.SetDeadline",
                    "documentation": {
                      "identifier": "File.SetDeadline",
                      "newPage": false,
                      "searchKey": "os.File.SetDeadline",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) SetDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) SetDeadline(t time.Time) error\n```\n\nSetDeadline sets the read and write deadlines for a File. It is equivalent to calling both SetReadDeadline and SetWriteDeadline. \n\nOnly some kinds of files support setting a deadline. Calls to SetDeadline for files that do not support deadlines will return ErrNoDeadline. On most systems ordinary files do not support deadlines, but pipes do. \n\nA deadline is an absolute time after which I/O operations fail with an error instead of blocking. The deadline applies to all future and pending I/O, not just the immediately following call to Read or Write. After a deadline has been exceeded, the connection can be refreshed by setting a deadline in the future. \n\nIf the deadline is exceeded a call to Read or Write or to other I/O methods will return an error that wraps ErrDeadlineExceeded. This can be tested using errors.Is(err, os.ErrDeadlineExceeded). That error implements the Timeout method, and calling the Timeout method will return true, but there are other possible errors for which the Timeout will return true even if the deadline has not been exceeded. \n\nAn idle timeout can be implemented by repeatedly extending the deadline after successful Read or Write calls. \n\nA zero value for t means I/O operations will not time out. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.SetReadDeadline",
                    "documentation": {
                      "identifier": "File.SetReadDeadline",
                      "newPage": false,
                      "searchKey": "os.File.SetReadDeadline",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) SetReadDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) SetReadDeadline(t time.Time) error\n```\n\nSetReadDeadline sets the deadline for future Read calls and any currently-blocked Read call. A zero value for t means Read will not time out. Not all files support setting deadlines; see SetDeadline. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.SetWriteDeadline",
                    "documentation": {
                      "identifier": "File.SetWriteDeadline",
                      "newPage": false,
                      "searchKey": "os.File.SetWriteDeadline",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) SetWriteDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) SetWriteDeadline(t time.Time) error\n```\n\nSetWriteDeadline sets the deadline for any future Write calls and any currently-blocked Write call. Even if Write times out, it may return n > 0, indicating that some of the data was successfully written. A zero value for t means Write will not time out. Not all files support setting deadlines; see SetDeadline. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.SyscallConn",
                    "documentation": {
                      "identifier": "File.SyscallConn",
                      "newPage": false,
                      "searchKey": "os.File.SyscallConn",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) SyscallConn() (syscall.RawConn, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) SyscallConn() (syscall.RawConn, error)\n```\n\nSyscallConn returns a raw file. This implements the syscall.Conn interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Close",
                    "documentation": {
                      "identifier": "File.Close",
                      "newPage": false,
                      "searchKey": "os.File.Close",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Close() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Close() error\n```\n\nClose closes the File, rendering it unusable for I/O. On files that support SetDeadline, any pending I/O operations will be canceled and return immediately with an error. Close will return an error if it has already been called. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.read",
                    "documentation": {
                      "identifier": "File.read",
                      "newPage": false,
                      "searchKey": "os.File.read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) read(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) read(b []byte) (n int, err error)\n```\n\nread reads up to len(b) bytes from the File. It returns the number of bytes read and an error, if any. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.pread",
                    "documentation": {
                      "identifier": "File.pread",
                      "newPage": false,
                      "searchKey": "os.File.pread",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) pread(b []byte, off int64) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) pread(b []byte, off int64) (n int, err error)\n```\n\npread reads len(b) bytes from the File starting at byte offset off. It returns the number of bytes read and the error, if any. EOF is signaled by a zero count with err set to nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.write",
                    "documentation": {
                      "identifier": "File.write",
                      "newPage": false,
                      "searchKey": "os.File.write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) write(b []byte) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) write(b []byte) (n int, err error)\n```\n\nwrite writes len(b) bytes to the File. It returns the number of bytes written and an error, if any. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.pwrite",
                    "documentation": {
                      "identifier": "File.pwrite",
                      "newPage": false,
                      "searchKey": "os.File.pwrite",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) pwrite(b []byte, off int64) (n int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) pwrite(b []byte, off int64) (n int, err error)\n```\n\npwrite writes len(b) bytes to the File starting at byte offset off. It returns the number of bytes written and an error, if any. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.chmod",
                    "documentation": {
                      "identifier": "File.chmod",
                      "newPage": false,
                      "searchKey": "os.File.chmod",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) chmod(mode FileMode) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) chmod(mode FileMode) error\n```\n\nSee docs in file.go:(*File).Chmod. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Chown",
                    "documentation": {
                      "identifier": "File.Chown",
                      "newPage": false,
                      "searchKey": "os.File.Chown",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Chown(uid, gid int) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Chown(uid, gid int) error\n```\n\nChown changes the numeric uid and gid of the named file. If there is an error, it will be of type *PathError. \n\nOn Windows, it always returns the syscall.EWINDOWS error, wrapped in *PathError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Truncate",
                    "documentation": {
                      "identifier": "File.Truncate",
                      "newPage": false,
                      "searchKey": "os.File.Truncate",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Truncate(size int64) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Truncate(size int64) error\n```\n\nTruncate changes the size of the file. It does not change the I/O offset. If there is an error, it will be of type *PathError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Sync",
                    "documentation": {
                      "identifier": "File.Sync",
                      "newPage": false,
                      "searchKey": "os.File.Sync",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Sync() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Sync() error\n```\n\nSync commits the current contents of the file to stable storage. Typically, this means flushing the file system's in-memory copy of recently written data to disk. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Chdir",
                    "documentation": {
                      "identifier": "File.Chdir",
                      "newPage": false,
                      "searchKey": "os.File.Chdir",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Chdir() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Chdir() error\n```\n\nChdir changes the current working directory to the file, which must be a directory. If there is an error, it will be of type *PathError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.setDeadline",
                    "documentation": {
                      "identifier": "File.setDeadline",
                      "newPage": false,
                      "searchKey": "os.File.setDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) setDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) setDeadline(t time.Time) error\n```\n\nsetDeadline sets the read and write deadline. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.setReadDeadline",
                    "documentation": {
                      "identifier": "File.setReadDeadline",
                      "newPage": false,
                      "searchKey": "os.File.setReadDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) setReadDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) setReadDeadline(t time.Time) error\n```\n\nsetReadDeadline sets the read deadline. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.setWriteDeadline",
                    "documentation": {
                      "identifier": "File.setWriteDeadline",
                      "newPage": false,
                      "searchKey": "os.File.setWriteDeadline",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) setWriteDeadline(t time.Time) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) setWriteDeadline(t time.Time) error\n```\n\nsetWriteDeadline sets the write deadline. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.checkValid",
                    "documentation": {
                      "identifier": "File.checkValid",
                      "newPage": false,
                      "searchKey": "os.File.checkValid",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) checkValid(op string) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) checkValid(op string) error\n```\n\ncheckValid checks whether f is valid for use. If not, it returns an appropriate error, perhaps incorporating the operation name op. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Fd",
                    "documentation": {
                      "identifier": "File.Fd",
                      "newPage": false,
                      "searchKey": "os.File.Fd",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Fd() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Fd() uintptr\n```\n\nFd returns the integer Unix file descriptor referencing the open file. If f is closed, the file descriptor becomes invalid. If f is garbage collected, a finalizer may close the file descriptor, making it invalid; see runtime.SetFinalizer for more information on when a finalizer might be run. On Unix systems this will cause the SetDeadline methods to stop working. Because file descriptors can be reused, the returned file descriptor may only be closed through the Close method of f, or by its finalizer during garbage collection. Otherwise, during garbage collection the finalizer may close an unrelated file descriptor with the same (reused) number. \n\nAs an alternative, see the f.SyscallConn method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.seek",
                    "documentation": {
                      "identifier": "File.seek",
                      "newPage": false,
                      "searchKey": "os.File.seek",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) seek(offset int64, whence int) (ret int64, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) seek(offset int64, whence int) (ret int64, err error)\n```\n\nseek sets the offset for the next Read or Write on file to offset, interpreted according to whence: 0 means relative to the origin of the file, 1 means relative to the current offset, and 2 means relative to the end. It returns the new offset and an error, if any. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.readFrom",
                    "documentation": {
                      "identifier": "File.readFrom",
                      "newPage": false,
                      "searchKey": "os.File.readFrom",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) readFrom(r io.Reader) (n int64, handled bool, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) readFrom(r io.Reader) (n int64, handled bool, err error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#File.Stat",
                    "documentation": {
                      "identifier": "File.Stat",
                      "newPage": false,
                      "searchKey": "os.File.Stat",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *File) Stat() (FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *File) Stat() (FileInfo, error)\n```\n\nStat returns the FileInfo structure describing file. If there is an error, it will be of type *PathError. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#FileInfo",
              "documentation": {
                "identifier": "FileInfo",
                "newPage": false,
                "searchKey": "os.FileInfo",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type FileInfo fs.FileInfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FileInfo = fs.FileInfo\n```\n\nA FileInfo describes a file and is returned by Stat and Lstat. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#Stat",
                    "documentation": {
                      "identifier": "Stat",
                      "newPage": false,
                      "searchKey": "os.Stat",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Stat(name string) (FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Stat(name string) (FileInfo, error)\n```\n\nStat returns a FileInfo describing the named file. If there is an error, it will be of type *PathError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#Lstat",
                    "documentation": {
                      "identifier": "Lstat",
                      "newPage": false,
                      "searchKey": "os.Lstat",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Lstat(name string) (FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Lstat(name string) (FileInfo, error)\n```\n\nLstat returns a FileInfo describing the named file. If the file is a symbolic link, the returned FileInfo describes the symbolic link. Lstat makes no attempt to follow the link. If there is an error, it will be of type *PathError. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#statNolog",
                    "documentation": {
                      "identifier": "statNolog",
                      "newPage": false,
                      "searchKey": "os.statNolog",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func statNolog(name string) (FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc statNolog(name string) (FileInfo, error)\n```\n\nstatNolog stats a file with no test logging. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#lstatNolog",
                    "documentation": {
                      "identifier": "lstatNolog",
                      "newPage": false,
                      "searchKey": "os.lstatNolog",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func lstatNolog(name string) (FileInfo, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc lstatNolog(name string) (FileInfo, error)\n```\n\nlstatNolog lstats a file with no test logging. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#FileMode",
              "documentation": {
                "identifier": "FileMode",
                "newPage": false,
                "searchKey": "os.FileMode",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type FileMode fs.FileMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype FileMode = fs.FileMode\n```\n\nA FileMode represents a file's mode and permission bits. The bits have the same definition on all systems, so that information about files can be moved from one system to another portably. Not all bits apply to all systems. The only required bit is ModeDir for directories. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#dtToType",
                    "documentation": {
                      "identifier": "dtToType",
                      "newPage": false,
                      "searchKey": "os.dtToType",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func dtToType(typ uint8) FileMode"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc dtToType(typ uint8) FileMode\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/os#fileStat",
              "documentation": {
                "identifier": "fileStat",
                "newPage": false,
                "searchKey": "os.fileStat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type fileStat struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fileStat struct {\n\tname    string\n\tsize    int64\n\tmode    FileMode\n\tmodTime time.Time\n\tsys     syscall.Stat_t\n}\n```\n\nA fileStat is the implementation of FileInfo returned by Stat and Lstat. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/os#fileStat.Name",
                    "documentation": {
                      "identifier": "fileStat.Name",
                      "newPage": false,
                      "searchKey": "os.fileStat.Name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fs *fileStat) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fs *fileStat) Name() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#fileStat.IsDir",
                    "documentation": {
                      "identifier": "fileStat.IsDir",
                      "newPage": false,
                      "searchKey": "os.fileStat.IsDir",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fs *fileStat) IsDir() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fs *fileStat) IsDir() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#fileStat.Size",
                    "documentation": {
                      "identifier": "fileStat.Size",
                      "newPage": false,
                      "searchKey": "os.fileStat.Size",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fs *fileStat) Size() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fs *fileStat) Size() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#fileStat.Mode",
                    "documentation": {
                      "identifier": "fileStat.Mode",
                      "newPage": false,
                      "searchKey": "os.fileStat.Mode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fs *fileStat) Mode() FileMode"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fs *fileStat) Mode() FileMode\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#fileStat.ModTime",
                    "documentation": {
                      "identifier": "fileStat.ModTime",
                      "newPage": false,
                      "searchKey": "os.fileStat.ModTime",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fs *fileStat) ModTime() time.Time"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fs *fileStat) ModTime() time.Time\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/os#fileStat.Sys",
                    "documentation": {
                      "identifier": "fileStat.Sys",
                      "newPage": false,
                      "searchKey": "os.fileStat.Sys",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (fs *fileStat) Sys() interface{}"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (fs *fileStat) Sys() interface{}\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/os#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/os#ReadDir",
              "documentation": {
                "identifier": "ReadDir",
                "newPage": false,
                "searchKey": "os.ReadDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ReadDir(name string) ([]DirEntry, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ReadDir(name string) ([]DirEntry, error)\n```\n\nReadDir reads the named directory, returning all its directory entries sorted by filename. If an error occurs reading the directory, ReadDir returns the entries it was able to read before the error, along with the error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#closedir",
              "documentation": {
                "identifier": "closedir",
                "newPage": false,
                "searchKey": "os.closedir",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func closedir(dir uintptr) (err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc closedir(dir uintptr) (err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Expand",
              "documentation": {
                "identifier": "Expand",
                "newPage": false,
                "searchKey": "os.Expand",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Expand(s string, mapping func(string) string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Expand(s string, mapping func(string) string) string\n```\n\nExpand replaces ${var} or $var in the string based on the mapping function. For example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ExpandEnv",
              "documentation": {
                "identifier": "ExpandEnv",
                "newPage": false,
                "searchKey": "os.ExpandEnv",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ExpandEnv(s string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ExpandEnv(s string) string\n```\n\nExpandEnv replaces ${var} or $var in the string according to the values of the current environment variables. References to undefined variables are replaced by the empty string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#isShellSpecialVar",
              "documentation": {
                "identifier": "isShellSpecialVar",
                "newPage": false,
                "searchKey": "os.isShellSpecialVar",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isShellSpecialVar(c uint8) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isShellSpecialVar(c uint8) bool\n```\n\nisShellSpecialVar reports whether the character identifies a special shell variable such as $*. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#isAlphaNum",
              "documentation": {
                "identifier": "isAlphaNum",
                "newPage": false,
                "searchKey": "os.isAlphaNum",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isAlphaNum(c uint8) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isAlphaNum(c uint8) bool\n```\n\nisAlphaNum reports whether the byte is an ASCII letter, number, or underscore \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#getShellName",
              "documentation": {
                "identifier": "getShellName",
                "newPage": false,
                "searchKey": "os.getShellName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getShellName(s string) (string, int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getShellName(s string) (string, int)\n```\n\ngetShellName returns the name that begins the string and the number of bytes consumed to extract it. If the name is enclosed in {}, it's part of a ${} expansion and two more bytes are needed than the length of the name. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Getenv",
              "documentation": {
                "identifier": "Getenv",
                "newPage": false,
                "searchKey": "os.Getenv",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Getenv(key string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Getenv(key string) string\n```\n\nGetenv retrieves the value of the environment variable named by the key. It returns the value, which will be empty if the variable is not present. To distinguish between an empty value and an unset value, use LookupEnv. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#LookupEnv",
              "documentation": {
                "identifier": "LookupEnv",
                "newPage": false,
                "searchKey": "os.LookupEnv",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LookupEnv(key string) (string, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LookupEnv(key string) (string, bool)\n```\n\nLookupEnv retrieves the value of the environment variable named by the key. If the variable is present in the environment the value (which may be empty) is returned and the boolean is true. Otherwise the returned value will be empty and the boolean will be false. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Setenv",
              "documentation": {
                "identifier": "Setenv",
                "newPage": false,
                "searchKey": "os.Setenv",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Setenv(key, value string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Setenv(key, value string) error\n```\n\nSetenv sets the value of the environment variable named by the key. It returns an error, if any. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Unsetenv",
              "documentation": {
                "identifier": "Unsetenv",
                "newPage": false,
                "searchKey": "os.Unsetenv",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Unsetenv(key string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Unsetenv(key string) error\n```\n\nUnsetenv unsets a single environment variable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Clearenv",
              "documentation": {
                "identifier": "Clearenv",
                "newPage": false,
                "searchKey": "os.Clearenv",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Clearenv()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Clearenv()\n```\n\nClearenv deletes all environment variables. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Environ",
              "documentation": {
                "identifier": "Environ",
                "newPage": false,
                "searchKey": "os.Environ",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Environ() []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Environ() []string\n```\n\nEnviron returns a copy of strings representing the environment, in the form \"key=value\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#errClosed",
              "documentation": {
                "identifier": "errClosed",
                "newPage": false,
                "searchKey": "os.errClosed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func errClosed() error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc errClosed() error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#errNoDeadline",
              "documentation": {
                "identifier": "errNoDeadline",
                "newPage": false,
                "searchKey": "os.errNoDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func errNoDeadline() error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc errNoDeadline() error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#errDeadlineExceeded",
              "documentation": {
                "identifier": "errDeadlineExceeded",
                "newPage": false,
                "searchKey": "os.errDeadlineExceeded",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func errDeadlineExceeded() error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc errDeadlineExceeded() error\n```\n\nerrDeadlineExceeded returns the value for os.ErrDeadlineExceeded. This error comes from the internal/poll package, which is also used by package net. Doing this this way ensures that the net package will return os.ErrDeadlineExceeded for an exceeded deadline, as documented by net.Conn.SetDeadline, without requiring any extra work in the net package and without requiring the internal/poll package to import os (which it can't, because that would be circular). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#NewSyscallError",
              "documentation": {
                "identifier": "NewSyscallError",
                "newPage": false,
                "searchKey": "os.NewSyscallError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func NewSyscallError(syscall string, err error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc NewSyscallError(syscall string, err error) error\n```\n\nNewSyscallError returns, as an error, a new SyscallError with the given system call name and error details. As a convenience, if err is nil, NewSyscallError returns nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#IsExist",
              "documentation": {
                "identifier": "IsExist",
                "newPage": false,
                "searchKey": "os.IsExist",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsExist(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsExist(err error) bool\n```\n\nIsExist returns a boolean indicating whether the error is known to report that a file or directory already exists. It is satisfied by ErrExist as well as some syscall errors. \n\nThis function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, fs.ErrExist). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#IsNotExist",
              "documentation": {
                "identifier": "IsNotExist",
                "newPage": false,
                "searchKey": "os.IsNotExist",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsNotExist(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsNotExist(err error) bool\n```\n\nIsNotExist returns a boolean indicating whether the error is known to report that a file or directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors. \n\nThis function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, fs.ErrNotExist). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#IsPermission",
              "documentation": {
                "identifier": "IsPermission",
                "newPage": false,
                "searchKey": "os.IsPermission",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsPermission(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsPermission(err error) bool\n```\n\nIsPermission returns a boolean indicating whether the error is known to report that permission is denied. It is satisfied by ErrPermission as well as some syscall errors. \n\nThis function predates errors.Is. It only supports errors returned by the os package. New code should use errors.Is(err, fs.ErrPermission). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#IsTimeout",
              "documentation": {
                "identifier": "IsTimeout",
                "newPage": false,
                "searchKey": "os.IsTimeout",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsTimeout(err error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsTimeout(err error) bool\n```\n\nIsTimeout returns a boolean indicating whether the error is known to report that a timeout occurred. \n\nThis function predates errors.Is, and the notion of whether an error indicates a timeout can be ambiguous. For example, the Unix error EWOULDBLOCK sometimes indicates a timeout and sometimes does not. New code should use errors.Is with a value appropriate to the call returning the error, such as os.ErrDeadlineExceeded. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#underlyingErrorIs",
              "documentation": {
                "identifier": "underlyingErrorIs",
                "newPage": false,
                "searchKey": "os.underlyingErrorIs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func underlyingErrorIs(err, target error) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc underlyingErrorIs(err, target error) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#underlyingError",
              "documentation": {
                "identifier": "underlyingError",
                "newPage": false,
                "searchKey": "os.underlyingError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func underlyingError(err error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc underlyingError(err error) error\n```\n\nunderlyingError returns the underlying error for known os error types. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#wrapSyscallError",
              "documentation": {
                "identifier": "wrapSyscallError",
                "newPage": false,
                "searchKey": "os.wrapSyscallError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func wrapSyscallError(name string, err error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc wrapSyscallError(name string, err error) error\n```\n\nwrapSyscallError takes an error and a syscall name. If the error is a syscall.Errno, it wraps it in a os.SyscallError using the syscall name. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Getpid",
              "documentation": {
                "identifier": "Getpid",
                "newPage": false,
                "searchKey": "os.Getpid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Getpid() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Getpid() int\n```\n\nGetpid returns the process id of the caller. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Getppid",
              "documentation": {
                "identifier": "Getppid",
                "newPage": false,
                "searchKey": "os.Getppid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Getppid() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Getppid() int\n```\n\nGetppid returns the process id of the caller's parent. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Executable",
              "documentation": {
                "identifier": "Executable",
                "newPage": false,
                "searchKey": "os.Executable",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Executable() (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Executable() (string, error)\n```\n\nExecutable returns the path name for the executable that started the current process. There is no guarantee that the path is still pointing to the correct executable. If a symlink was used to start the process, depending on the operating system, the result might be the symlink or the path it pointed to. If a stable result is needed, path/filepath.EvalSymlinks might help. \n\nExecutable returns an absolute path unless an error occurred. \n\nThe main use case is finding resources located relative to an executable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#executable",
              "documentation": {
                "identifier": "executable",
                "newPage": false,
                "searchKey": "os.executable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func executable() (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc executable() (string, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#genericReadFrom",
              "documentation": {
                "identifier": "genericReadFrom",
                "newPage": false,
                "searchKey": "os.genericReadFrom",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func genericReadFrom(f *File, r io.Reader) (int64, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc genericReadFrom(f *File, r io.Reader) (int64, error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Mkdir",
              "documentation": {
                "identifier": "Mkdir",
                "newPage": false,
                "searchKey": "os.Mkdir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Mkdir(name string, perm FileMode) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Mkdir(name string, perm FileMode) error\n```\n\nMkdir creates a new directory with the specified name and permission bits (before umask). If there is an error, it will be of type *PathError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#setStickyBit",
              "documentation": {
                "identifier": "setStickyBit",
                "newPage": false,
                "searchKey": "os.setStickyBit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setStickyBit(name string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setStickyBit(name string) error\n```\n\nsetStickyBit adds ModeSticky to the permission bits of path, non atomic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Chdir",
              "documentation": {
                "identifier": "Chdir",
                "newPage": false,
                "searchKey": "os.Chdir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Chdir(dir string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Chdir(dir string) error\n```\n\nChdir changes the current working directory to the named directory. If there is an error, it will be of type *PathError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Rename",
              "documentation": {
                "identifier": "Rename",
                "newPage": false,
                "searchKey": "os.Rename",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Rename(oldpath, newpath string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Rename(oldpath, newpath string) error\n```\n\nRename renames (moves) oldpath to newpath. If newpath already exists and is not a directory, Rename replaces it. OS-specific restrictions may apply when oldpath and newpath are in different directories. If there is an error, it will be of type *LinkError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#fixCount",
              "documentation": {
                "identifier": "fixCount",
                "newPage": false,
                "searchKey": "os.fixCount",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fixCount(n int, err error) (int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fixCount(n int, err error) (int, error)\n```\n\nMany functions in package syscall return a count of -1 instead of 0. Using fixCount(call()) instead of call() corrects the count. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#TempDir",
              "documentation": {
                "identifier": "TempDir",
                "newPage": false,
                "searchKey": "os.TempDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func TempDir() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TempDir() string\n```\n\nTempDir returns the default directory to use for temporary files. \n\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp. On Windows, it uses GetTempPath, returning the first non-empty value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory. On Plan 9, it returns /tmp. \n\nThe directory is neither guaranteed to exist nor have accessible permissions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#UserCacheDir",
              "documentation": {
                "identifier": "UserCacheDir",
                "newPage": false,
                "searchKey": "os.UserCacheDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func UserCacheDir() (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc UserCacheDir() (string, error)\n```\n\nUserCacheDir returns the default root directory to use for user-specific cached data. Users should create their own application-specific subdirectory within this one and use that. \n\nOn Unix systems, it returns $XDG_CACHE_HOME as specified by [https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html) if non-empty, else $HOME/.cache. On Darwin, it returns $HOME/Library/Caches. On Windows, it returns %LocalAppData%. On Plan 9, it returns $home/lib/cache. \n\nIf the location cannot be determined (for example, $HOME is not defined), then it will return an error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#UserConfigDir",
              "documentation": {
                "identifier": "UserConfigDir",
                "newPage": false,
                "searchKey": "os.UserConfigDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func UserConfigDir() (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc UserConfigDir() (string, error)\n```\n\nUserConfigDir returns the default root directory to use for user-specific configuration data. Users should create their own application-specific subdirectory within this one and use that. \n\nOn Unix systems, it returns $XDG_CONFIG_HOME as specified by [https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html) if non-empty, else $HOME/.config. On Darwin, it returns $HOME/Library/Application Support. On Windows, it returns %AppData%. On Plan 9, it returns $home/lib. \n\nIf the location cannot be determined (for example, $HOME is not defined), then it will return an error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#UserHomeDir",
              "documentation": {
                "identifier": "UserHomeDir",
                "newPage": false,
                "searchKey": "os.UserHomeDir",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func UserHomeDir() (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc UserHomeDir() (string, error)\n```\n\nUserHomeDir returns the current user's home directory. \n\nOn Unix, including macOS, it returns the $HOME environment variable. On Windows, it returns %USERPROFILE%. On Plan 9, it returns the $home environment variable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Chmod",
              "documentation": {
                "identifier": "Chmod",
                "newPage": false,
                "searchKey": "os.Chmod",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Chmod(name string, mode FileMode) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Chmod(name string, mode FileMode) error\n```\n\nChmod changes the mode of the named file to mode. If the file is a symbolic link, it changes the mode of the link's target. If there is an error, it will be of type *PathError. \n\nA different subset of the mode bits are used, depending on the operating system. \n\nOn Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and ModeSticky are used. \n\nOn Windows, only the 0200 bit (owner writable) of mode is used; it controls whether the file's read-only attribute is set or cleared. The other bits are currently unused. For compatibility with Go 1.12 and earlier, use a non-zero mode. Use mode 0400 for a read-only file and 0600 for a readable+writable file. \n\nOn Plan 9, the mode's permission bits, ModeAppend, ModeExclusive, and ModeTemporary are used. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#isWindowsNulName",
              "documentation": {
                "identifier": "isWindowsNulName",
                "newPage": false,
                "searchKey": "os.isWindowsNulName",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isWindowsNulName(name string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isWindowsNulName(name string) bool\n```\n\nisWindowsNulName reports whether name is os.DevNull ('NUL') on Windows. True is returned if name is 'NUL' whatever the case. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#DirFS",
              "documentation": {
                "identifier": "DirFS",
                "newPage": false,
                "searchKey": "os.DirFS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func DirFS(dir string) fs.FS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc DirFS(dir string) fs.FS\n```\n\nDirFS returns a file system (an fs.FS) for the tree of files rooted at the directory dir. \n\nNote that DirFS(\"/prefix\") only guarantees that the Open calls it makes to the operating system will begin with \"/prefix\": DirFS(\"/prefix\").Open(\"file\") is the same as os.Open(\"/prefix/file\"). So if /prefix/file is a symbolic link pointing outside the /prefix tree, then using DirFS does not stop the access any more than using os.Open does. DirFS is therefore not a general substitute for a chroot-style security mechanism when the directory tree contains arbitrary content. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#containsAny",
              "documentation": {
                "identifier": "containsAny",
                "newPage": false,
                "searchKey": "os.containsAny",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func containsAny(s, chars string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc containsAny(s, chars string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ReadFile",
              "documentation": {
                "identifier": "ReadFile",
                "newPage": false,
                "searchKey": "os.ReadFile",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ReadFile(name string) ([]byte, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ReadFile(name string) ([]byte, error)\n```\n\nReadFile reads the named file and returns the contents. A successful call returns err == nil, not err == EOF. Because ReadFile reads the whole file, it does not treat an EOF from Read as an error to be reported. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#WriteFile",
              "documentation": {
                "identifier": "WriteFile",
                "newPage": false,
                "searchKey": "os.WriteFile",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func WriteFile(name string, data []byte, perm FileMode) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc WriteFile(name string, data []byte, perm FileMode) error\n```\n\nWriteFile writes data to the named file, creating it if necessary. If the file does not exist, WriteFile creates it with permissions perm (before umask); otherwise WriteFile truncates it before writing, without changing permissions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#sigpipe",
              "documentation": {
                "identifier": "sigpipe",
                "newPage": false,
                "searchKey": "os.sigpipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigpipe()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigpipe()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#syscallMode",
              "documentation": {
                "identifier": "syscallMode",
                "newPage": false,
                "searchKey": "os.syscallMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscallMode(i FileMode) (o uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscallMode(i FileMode) (o uint32)\n```\n\nsyscallMode returns the syscall-specific mode bits from Go's portable mode bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#chmod",
              "documentation": {
                "identifier": "chmod",
                "newPage": false,
                "searchKey": "os.chmod",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chmod(name string, mode FileMode) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chmod(name string, mode FileMode) error\n```\n\nSee docs in file.go:Chmod. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Chown",
              "documentation": {
                "identifier": "Chown",
                "newPage": false,
                "searchKey": "os.Chown",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Chown(name string, uid, gid int) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Chown(name string, uid, gid int) error\n```\n\nChown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link's target. A uid or gid of -1 means to not change that value. If there is an error, it will be of type *PathError. \n\nOn Windows or Plan 9, Chown always returns the syscall.EWINDOWS or EPLAN9 error, wrapped in *PathError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Lchown",
              "documentation": {
                "identifier": "Lchown",
                "newPage": false,
                "searchKey": "os.Lchown",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Lchown(name string, uid, gid int) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Lchown(name string, uid, gid int) error\n```\n\nLchown changes the numeric uid and gid of the named file. If the file is a symbolic link, it changes the uid and gid of the link itself. If there is an error, it will be of type *PathError. \n\nOn Windows, it always returns the syscall.EWINDOWS error, wrapped in *PathError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Chtimes",
              "documentation": {
                "identifier": "Chtimes",
                "newPage": false,
                "searchKey": "os.Chtimes",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Chtimes(name string, atime time.Time, mtime time.Time) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Chtimes(name string, atime time.Time, mtime time.Time) error\n```\n\nChtimes changes the access and modification times of the named file, similar to the Unix utime() or utimes() functions. \n\nThe underlying filesystem may truncate or round the values to a less precise time unit. If there is an error, it will be of type *PathError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#ignoringEINTR",
              "documentation": {
                "identifier": "ignoringEINTR",
                "newPage": false,
                "searchKey": "os.ignoringEINTR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ignoringEINTR(fn func() error) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ignoringEINTR(fn func() error) error\n```\n\nignoringEINTR makes a function call and repeats it if it returns an EINTR error. This appears to be required even though we install all signal handlers with SA_RESTART: see #22838, #38033, #38836, #40846. Also #20400 and #36644 are issues in which a signal handler is installed without setting SA_RESTART. None of these are the common case, but there are enough of them that it seems that we can't avoid an EINTR loop. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#fixLongPath",
              "documentation": {
                "identifier": "fixLongPath",
                "newPage": false,
                "searchKey": "os.fixLongPath",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fixLongPath(path string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fixLongPath(path string) string\n```\n\nfixLongPath is a noop on non-Windows platforms. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#rename",
              "documentation": {
                "identifier": "rename",
                "newPage": false,
                "searchKey": "os.rename",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func rename(oldname, newname string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rename(oldname, newname string) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#epipecheck",
              "documentation": {
                "identifier": "epipecheck",
                "newPage": false,
                "searchKey": "os.epipecheck",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func epipecheck(file *File, e error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc epipecheck(file *File, e error)\n```\n\nepipecheck raises SIGPIPE if we get an EPIPE error on standard output or standard error. See the SIGPIPE docs in os/signal, and issue 11845. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Truncate",
              "documentation": {
                "identifier": "Truncate",
                "newPage": false,
                "searchKey": "os.Truncate",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Truncate(name string, size int64) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Truncate(name string, size int64) error\n```\n\nTruncate changes the size of the named file. If the file is a symbolic link, it changes the size of the link's target. If there is an error, it will be of type *PathError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Remove",
              "documentation": {
                "identifier": "Remove",
                "newPage": false,
                "searchKey": "os.Remove",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Remove(name string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Remove(name string) error\n```\n\nRemove removes the named file or (empty) directory. If there is an error, it will be of type *PathError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#tempDir",
              "documentation": {
                "identifier": "tempDir",
                "newPage": false,
                "searchKey": "os.tempDir",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tempDir() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tempDir() string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Link",
              "documentation": {
                "identifier": "Link",
                "newPage": false,
                "searchKey": "os.Link",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Link(oldname, newname string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Link(oldname, newname string) error\n```\n\nLink creates newname as a hard link to the oldname file. If there is an error, it will be of type *LinkError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Symlink",
              "documentation": {
                "identifier": "Symlink",
                "newPage": false,
                "searchKey": "os.Symlink",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Symlink(oldname, newname string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Symlink(oldname, newname string) error\n```\n\nSymlink creates newname as a symbolic link to oldname. On Windows, a symlink to a non-existent oldname creates a file symlink; if oldname is later created as a directory the symlink will not work. If there is an error, it will be of type *LinkError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Readlink",
              "documentation": {
                "identifier": "Readlink",
                "newPage": false,
                "searchKey": "os.Readlink",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Readlink(name string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Readlink(name string) (string, error)\n```\n\nReadlink returns the destination of the named symbolic link. If there is an error, it will be of type *PathError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Getwd",
              "documentation": {
                "identifier": "Getwd",
                "newPage": false,
                "searchKey": "os.Getwd",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Getwd() (dir string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Getwd() (dir string, err error)\n```\n\nGetwd returns a rooted path name corresponding to the current directory. If the current directory can be reached via multiple paths (due to symbolic links), Getwd may return any one of them. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#MkdirAll",
              "documentation": {
                "identifier": "MkdirAll",
                "newPage": false,
                "searchKey": "os.MkdirAll",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func MkdirAll(path string, perm FileMode) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MkdirAll(path string, perm FileMode) error\n```\n\nMkdirAll creates a directory named path, along with any necessary parents, and returns nil, or else returns an error. The permission bits perm (before umask) are used for all directories that MkdirAll creates. If path is already a directory, MkdirAll does nothing and returns nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#RemoveAll",
              "documentation": {
                "identifier": "RemoveAll",
                "newPage": false,
                "searchKey": "os.RemoveAll",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func RemoveAll(path string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc RemoveAll(path string) error\n```\n\nRemoveAll removes path and any children it contains. It removes everything it can but returns the first error it encounters. If the path does not exist, RemoveAll returns nil (no error). If there is an error, it will be of type *PathError. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#endsWithDot",
              "documentation": {
                "identifier": "endsWithDot",
                "newPage": false,
                "searchKey": "os.endsWithDot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func endsWithDot(path string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc endsWithDot(path string) bool\n```\n\nendsWithDot reports whether the final component of path is \".\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#IsPathSeparator",
              "documentation": {
                "identifier": "IsPathSeparator",
                "newPage": false,
                "searchKey": "os.IsPathSeparator",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func IsPathSeparator(c uint8) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc IsPathSeparator(c uint8) bool\n```\n\nIsPathSeparator reports whether c is a directory separator character. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#basename",
              "documentation": {
                "identifier": "basename",
                "newPage": false,
                "searchKey": "os.basename",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func basename(name string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc basename(name string) string\n```\n\nbasename removes trailing slashes and the leading directory name from path name. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#splitPath",
              "documentation": {
                "identifier": "splitPath",
                "newPage": false,
                "searchKey": "os.splitPath",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func splitPath(path string) (string, string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc splitPath(path string) (string, string)\n```\n\nsplitPath returns the base name and parent directory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#fixRootDirectory",
              "documentation": {
                "identifier": "fixRootDirectory",
                "newPage": false,
                "searchKey": "os.fixRootDirectory",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fixRootDirectory(p string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fixRootDirectory(p string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "os.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#runtime_args",
              "documentation": {
                "identifier": "runtime_args",
                "newPage": false,
                "searchKey": "os.runtime_args",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtime_args() []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtime_args() []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Getuid",
              "documentation": {
                "identifier": "Getuid",
                "newPage": false,
                "searchKey": "os.Getuid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Getuid() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Getuid() int\n```\n\nGetuid returns the numeric user id of the caller. \n\nOn Windows, it returns -1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Geteuid",
              "documentation": {
                "identifier": "Geteuid",
                "newPage": false,
                "searchKey": "os.Geteuid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Geteuid() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Geteuid() int\n```\n\nGeteuid returns the numeric effective user id of the caller. \n\nOn Windows, it returns -1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Getgid",
              "documentation": {
                "identifier": "Getgid",
                "newPage": false,
                "searchKey": "os.Getgid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Getgid() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Getgid() int\n```\n\nGetgid returns the numeric group id of the caller. \n\nOn Windows, it returns -1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Getegid",
              "documentation": {
                "identifier": "Getegid",
                "newPage": false,
                "searchKey": "os.Getegid",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Getegid() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Getegid() int\n```\n\nGetegid returns the numeric effective group id of the caller. \n\nOn Windows, it returns -1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Getgroups",
              "documentation": {
                "identifier": "Getgroups",
                "newPage": false,
                "searchKey": "os.Getgroups",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Getgroups() ([]int, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Getgroups() ([]int, error)\n```\n\nGetgroups returns a list of the numeric ids of groups that the caller belongs to. \n\nOn Windows, it returns syscall.EWINDOWS. See the os/user package for a possible alternative. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Exit",
              "documentation": {
                "identifier": "Exit",
                "newPage": false,
                "searchKey": "os.Exit",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Exit(code int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Exit(code int)\n```\n\nExit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run. \n\nFor portability, the status code should be in the range [0, 125]. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#runtime_beforeExit",
              "documentation": {
                "identifier": "runtime_beforeExit",
                "newPage": false,
                "searchKey": "os.runtime_beforeExit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtime_beforeExit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtime_beforeExit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#removeAll",
              "documentation": {
                "identifier": "removeAll",
                "newPage": false,
                "searchKey": "os.removeAll",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func removeAll(path string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc removeAll(path string) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#removeAllFrom",
              "documentation": {
                "identifier": "removeAllFrom",
                "newPage": false,
                "searchKey": "os.removeAllFrom",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func removeAllFrom(parent *File, base string) error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc removeAllFrom(parent *File, base string) error\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#fillFileStatFromSys",
              "documentation": {
                "identifier": "fillFileStatFromSys",
                "newPage": false,
                "searchKey": "os.fillFileStatFromSys",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fillFileStatFromSys(fs *fileStat, name string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fillFileStatFromSys(fs *fileStat, name string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#timespecToTime",
              "documentation": {
                "identifier": "timespecToTime",
                "newPage": false,
                "searchKey": "os.timespecToTime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func timespecToTime(ts syscall.Timespec) time.Time"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc timespecToTime(ts syscall.Timespec) time.Time\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#atime",
              "documentation": {
                "identifier": "atime",
                "newPage": false,
                "searchKey": "os.atime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func atime(fi FileInfo) time.Time"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc atime(fi FileInfo) time.Time\n```\n\nFor testing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#itox",
              "documentation": {
                "identifier": "itox",
                "newPage": false,
                "searchKey": "os.itox",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func itox(val int) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc itox(val int) string\n```\n\nitox converts val (an int) to a hexdecimal string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#uitox",
              "documentation": {
                "identifier": "uitox",
                "newPage": false,
                "searchKey": "os.uitox",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func uitox(val uint) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc uitox(val uint) string\n```\n\nuitox converts val (a uint) to a hexdecimal string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Hostname",
              "documentation": {
                "identifier": "Hostname",
                "newPage": false,
                "searchKey": "os.Hostname",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Hostname() (name string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Hostname() (name string, err error)\n```\n\nHostname returns the host name reported by the kernel. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#hostname",
              "documentation": {
                "identifier": "hostname",
                "newPage": false,
                "searchKey": "os.hostname",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hostname() (name string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hostname() (name string, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#fastrand",
              "documentation": {
                "identifier": "fastrand",
                "newPage": false,
                "searchKey": "os.fastrand",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fastrand() uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fastrand() uint32\n```\n\nfastrand provided by runtime. We generate random temporary file names so that there's a good chance the file doesn't exist yet - keeps the number of tries in TempFile to a minimum. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#nextRandom",
              "documentation": {
                "identifier": "nextRandom",
                "newPage": false,
                "searchKey": "os.nextRandom",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nextRandom() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nextRandom() string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#prefixAndSuffix",
              "documentation": {
                "identifier": "prefixAndSuffix",
                "newPage": false,
                "searchKey": "os.prefixAndSuffix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func prefixAndSuffix(pattern string) (prefix, suffix string, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc prefixAndSuffix(pattern string) (prefix, suffix string, err error)\n```\n\nprefixAndSuffix splits pattern by the last wildcard \"*\", if applicable, returning prefix as the part before \"*\" and suffix as the part after \"*\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#MkdirTemp",
              "documentation": {
                "identifier": "MkdirTemp",
                "newPage": false,
                "searchKey": "os.MkdirTemp",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func MkdirTemp(dir, pattern string) (string, error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MkdirTemp(dir, pattern string) (string, error)\n```\n\nMkdirTemp creates a new temporary directory in the directory dir and returns the pathname of the new directory. The new directory's name is generated by adding a random string to the end of pattern. If pattern includes a \"*\", the random string replaces the last \"*\" instead. If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir. Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory. It is the caller's responsibility to remove the directory when it is no longer needed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#joinPath",
              "documentation": {
                "identifier": "joinPath",
                "newPage": false,
                "searchKey": "os.joinPath",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func joinPath(dir, name string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc joinPath(dir, name string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#lastIndex",
              "documentation": {
                "identifier": "lastIndex",
                "newPage": false,
                "searchKey": "os.lastIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lastIndex(s string, sep byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lastIndex(s string, sep byte) int\n```\n\nLastIndexByte from the strings package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#Getpagesize",
              "documentation": {
                "identifier": "Getpagesize",
                "newPage": false,
                "searchKey": "os.Getpagesize",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Getpagesize() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Getpagesize() int\n```\n\nGetpagesize returns the underlying system's memory page size. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#SameFile",
              "documentation": {
                "identifier": "SameFile",
                "newPage": false,
                "searchKey": "os.SameFile",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SameFile(fi1, fi2 FileInfo) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SameFile(fi1, fi2 FileInfo) bool\n```\n\nSameFile reports whether fi1 and fi2 describe the same file. For example, on Unix this means that the device and inode fields of the two underlying structures are identical; on other systems the decision may be based on the path names. SameFile only applies to results returned by this package's Stat. It returns false in other cases. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/os#sameFile",
              "documentation": {
                "identifier": "sameFile",
                "newPage": false,
                "searchKey": "os.sameFile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sameFile(fs1, fs2 *fileStat) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sameFile(fs1, fs2 *fileStat) bool\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "pathID": "/std/os/exec"
    },
    {
      "pathID": "/std/os/exec_test"
    },
    {
      "pathID": "/std/os/signal"
    },
    {
      "pathID": "/std/os/signal_test"
    },
    {
      "pathID": "/std/os/user"
    }
  ]
}
