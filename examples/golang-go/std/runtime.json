{
  "pathID": "/std/runtime",
  "documentation": {
    "identifier": "runtime",
    "newPage": true,
    "searchKey": "std/runtime",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package runtime"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package runtime contains operations that interact with Go's runtime system, such as functions to control goroutines. It also includes the low-level type information used by the reflect package; see reflect's documentation for the programmable interface to the run-time type system. \n\n### hdr-Environment_VariablesEnvironment Variables\nThe following environment variables ($name or %name%, depending on the host operating system) control the run-time behavior of Go programs. The meanings and use may change from release to release. \n\nThe GOGC variable sets the initial garbage collection target percentage. A collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. The default is GOGC=100. Setting GOGC=off disables the garbage collector entirely. The runtime/debug package's SetGCPercent function allows changing this percentage at run time. See [https://golang.org/pkg/runtime/debug/#SetGCPercent](https://golang.org/pkg/runtime/debug/#SetGCPercent). \n\nThe GODEBUG variable controls debugging variables within the runtime. It is a comma-separated list of name=val pairs setting these named variables: \n\n```\nallocfreetrace: setting allocfreetrace=1 causes every allocation to be\nprofiled and a stack trace printed on each object's allocation and free.\n\nclobberfree: setting clobberfree=1 causes the garbage collector to\nclobber the memory content of an object with bad content when it frees\nthe object.\n\ncgocheck: setting cgocheck=0 disables all checks for packages\nusing cgo to incorrectly pass Go pointers to non-Go code.\nSetting cgocheck=1 (the default) enables relatively cheap\nchecks that may miss some errors.  Setting cgocheck=2 enables\nexpensive checks that should not miss any errors, but will\ncause your program to run slower.\n\nefence: setting efence=1 causes the allocator to run in a mode\nwhere each object is allocated on a unique page and addresses are\nnever recycled.\n\ngccheckmark: setting gccheckmark=1 enables verification of the\ngarbage collector's concurrent mark phase by performing a\nsecond mark pass while the world is stopped.  If the second\npass finds a reachable object that was not found by concurrent\nmark, the garbage collector will panic.\n\ngcpacertrace: setting gcpacertrace=1 causes the garbage collector to\nprint information about the internal state of the concurrent pacer.\n\ngcshrinkstackoff: setting gcshrinkstackoff=1 disables moving goroutines\nonto smaller stacks. In this mode, a goroutine's stack can only grow.\n\ngcstoptheworld: setting gcstoptheworld=1 disables concurrent garbage collection,\nmaking every garbage collection a stop-the-world event. Setting gcstoptheworld=2\nalso disables concurrent sweeping after the garbage collection finishes.\n\ngctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard\nerror at each collection, summarizing the amount of memory collected and the\nlength of the pause. The format of this line is subject to change.\nCurrently, it is:\n\tgc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #->#-># MB, # MB goal, # P\nwhere the fields are as follows:\n\tgc #        the GC number, incremented at each GC\n\t@#s         time in seconds since program start\n\t#%          percentage of time spent in GC since program start\n\t#+...+#     wall-clock/CPU times for the phases of the GC\n\t#->#-># MB  heap size at GC start, at GC end, and live heap\n\t# MB goal   goal heap size\n\t# P         number of processors used\nThe phases are stop-the-world (STW) sweep termination, concurrent\nmark and scan, and STW mark termination. The CPU times\nfor mark/scan are broken down in to assist time (GC performed in\nline with allocation), background GC time, and idle GC time.\nIf the line ends with \"(forced)\", this GC was forced by a\nruntime.GC() call.\n\ninittrace: setting inittrace=1 causes the runtime to emit a single line to standard\nerror for each package with init work, summarizing the execution time and memory\nallocation. No information is printed for inits executed as part of plugin loading\nand for packages without both user defined and compiler generated init work.\nThe format of this line is subject to change. Currently, it is:\n\tinit # @#ms, # ms clock, # bytes, # allocs\nwhere the fields are as follows:\n\tinit #      the package name\n\t@# ms       time in milliseconds when the init started since program start\n\t# clock     wall-clock time for package initialization work\n\t# bytes     memory allocated on the heap\n\t# allocs    number of heap allocations\n\nmadvdontneed: setting madvdontneed=0 will use MADV_FREE\ninstead of MADV_DONTNEED on Linux when returning memory to the\nkernel. This is more efficient, but means RSS numbers will\ndrop only when the OS is under memory pressure.\n\nmemprofilerate: setting memprofilerate=X will update the value of runtime.MemProfileRate.\nWhen set to 0 memory profiling is disabled.  Refer to the description of\nMemProfileRate for the default value.\n\ninvalidptr: invalidptr=1 (the default) causes the garbage collector and stack\ncopier to crash the program if an invalid pointer value (for example, 1)\nis found in a pointer-typed location. Setting invalidptr=0 disables this check.\nThis should only be used as a temporary workaround to diagnose buggy code.\nThe real fix is to not store integers in pointer-typed locations.\n\nsbrk: setting sbrk=1 replaces the memory allocator and garbage collector\nwith a trivial allocator that obtains memory from the operating system and\nnever reclaims any memory.\n\nscavtrace: setting scavtrace=1 causes the runtime to emit a single line to standard\nerror, roughly once per GC cycle, summarizing the amount of work done by the\nscavenger as well as the total amount of memory returned to the operating system\nand an estimate of physical memory utilization. The format of this line is subject\nto change, but currently it is:\n\tscav # # KiB work, # KiB total, #% util\nwhere the fields are as follows:\n\tscav #       the scavenge cycle number\n\t# KiB work   the amount of memory returned to the OS since the last line\n\t# KiB total  the total amount of memory returned to the OS\n\t#% util      the fraction of all unscavenged memory which is in-use\nIf the line ends with \"(forced)\", then scavenging was forced by a\ndebug.FreeOSMemory() call.\n\nscheddetail: setting schedtrace=X and scheddetail=1 causes the scheduler to emit\ndetailed multiline info every X milliseconds, describing state of the scheduler,\nprocessors, threads and goroutines.\n\nschedtrace: setting schedtrace=X causes the scheduler to emit a single line to standard\nerror every X milliseconds, summarizing the scheduler state.\n\ntracebackancestors: setting tracebackancestors=N extends tracebacks with the stacks at\nwhich goroutines were created, where N limits the number of ancestor goroutines to\nreport. This also extends the information returned by runtime.Stack. Ancestor's goroutine\nIDs will refer to the ID of the goroutine at the time of creation; it's possible for this\nID to be reused for another goroutine. Setting N to 0 will report no ancestry information.\n\nasyncpreemptoff: asyncpreemptoff=1 disables signal-based\nasynchronous goroutine preemption. This makes some loops\nnon-preemptible for long periods, which may delay GC and\ngoroutine scheduling. This is useful for debugging GC issues\nbecause it also disables the conservative stack scanning used\nfor asynchronously preempted goroutines.\n\n```\nThe net, net/http, and crypto/tls packages also refer to debugging variables in GODEBUG. See the documentation for those packages for details. \n\nThe GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes the limit. \n\nThe GORACE variable configures the race detector, for programs built using -race. See [https://golang.org/doc/articles/race_detector.html](https://golang.org/doc/articles/race_detector.html) for details. \n\nThe GOTRACEBACK variable controls the amount of output generated when a Go program fails due to an unrecovered panic or an unexpected runtime condition. By default, a failure prints a stack trace for the current goroutine, eliding functions internal to the run-time system, and then exits with exit code 2. The failure prints stack traces for all goroutines if there is no current goroutine or the failure is internal to the run-time. GOTRACEBACK=none omits the goroutine stack traces entirely. GOTRACEBACK=single (the default) behaves as described above. GOTRACEBACK=all adds stack traces for all user-created goroutines. GOTRACEBACK=system is like `all' but adds stack frames for run-time functions and shows goroutines created internally by the run-time. GOTRACEBACK=crash is like `system' but crashes in an operating system-specific manner instead of exiting. For example, on Unix systems, the crash raises SIGABRT to trigger a core dump. For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for none, all, and system, respectively. The runtime/debug package's SetTraceback function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable. See [https://golang.org/pkg/runtime/debug/#SetTraceback](https://golang.org/pkg/runtime/debug/#SetTraceback). \n\nThe GOARCH, GOOS, GOPATH, and GOROOT environment variables complete the set of Go environment variables. They influence the building of Go programs (see [https://golang.org/cmd/go](https://golang.org/cmd/go) and [https://golang.org/pkg/go/build](https://golang.org/pkg/go/build)). GOARCH, GOOS, and GOROOT are recorded at compile time and made available by constants or functions in this package, but they do not influence the execution of the run-time system. \n\n"
  },
  "children": [
    {
      "pathID": "/std/runtime/internal"
    },
    {
      "node": {
        "pathID": "/std/runtime#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/runtime#c0",
              "documentation": {
                "identifier": "c0",
                "newPage": false,
                "searchKey": "runtime.c0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const c0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c0 = uintptr((8-sys.PtrSize)/4*2860486313 + (sys.PtrSize-4)/4*33054211828000289)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#c1",
              "documentation": {
                "identifier": "c1",
                "newPage": false,
                "searchKey": "runtime.c1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const c1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst c1 = uintptr((8-sys.PtrSize)/4*3267000013 + (sys.PtrSize-4)/4*23344194077549503)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hashRandomBytes",
              "documentation": {
                "identifier": "hashRandomBytes",
                "newPage": false,
                "searchKey": "runtime.hashRandomBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hashRandomBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hashRandomBytes = sys.PtrSize / 4 * 64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoCheckPointerFail",
              "documentation": {
                "identifier": "cgoCheckPointerFail",
                "newPage": false,
                "searchKey": "runtime.cgoCheckPointerFail",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cgoCheckPointerFail"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cgoCheckPointerFail = \"cgo argument has Go pointer to Go pointer\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoResultFail",
              "documentation": {
                "identifier": "cgoResultFail",
                "newPage": false,
                "searchKey": "runtime.cgoResultFail",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cgoResultFail"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cgoResultFail = \"cgo result has Go pointer\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoWriteBarrierFail",
              "documentation": {
                "identifier": "cgoWriteBarrierFail",
                "newPage": false,
                "searchKey": "runtime.cgoWriteBarrierFail",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cgoWriteBarrierFail"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cgoWriteBarrierFail = \"Go pointer stored into non-Go memory\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxAlign",
              "documentation": {
                "identifier": "maxAlign",
                "newPage": false,
                "searchKey": "runtime.maxAlign",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxAlign"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxAlign = 8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hchanSize",
              "documentation": {
                "identifier": "hchanSize",
                "newPage": false,
                "searchKey": "runtime.hchanSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hchanSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hchanSize = unsafe.Sizeof(hchan{}) + uintptr(-int(unsafe.Sizeof(hchan{}))&(maxAlign-1))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugChan",
              "documentation": {
                "identifier": "debugChan",
                "newPage": false,
                "searchKey": "runtime.debugChan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugChan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugChan = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Compiler",
              "documentation": {
                "identifier": "Compiler",
                "newPage": false,
                "searchKey": "runtime.Compiler",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Compiler"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Compiler = \"gc\"\n```\n\nCompiler is the name of the compiler toolchain that built the running binary. Known toolchains are: \n\n```\ngc      Also known as cmd/compile.\ngccgo   The gccgo front end, part of the GCC compiler suite.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#offsetX86HasAVX",
              "documentation": {
                "identifier": "offsetX86HasAVX",
                "newPage": false,
                "searchKey": "runtime.offsetX86HasAVX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const offsetX86HasAVX"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst offsetX86HasAVX = unsafe.Offsetof(cpu.X86.HasAVX)\n```\n\nOffsets into internal/cpu records for use in assembly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#offsetX86HasAVX2",
              "documentation": {
                "identifier": "offsetX86HasAVX2",
                "newPage": false,
                "searchKey": "runtime.offsetX86HasAVX2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const offsetX86HasAVX2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst offsetX86HasAVX2 = unsafe.Offsetof(cpu.X86.HasAVX2)\n```\n\nOffsets into internal/cpu records for use in assembly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#offsetX86HasERMS",
              "documentation": {
                "identifier": "offsetX86HasERMS",
                "newPage": false,
                "searchKey": "runtime.offsetX86HasERMS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const offsetX86HasERMS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst offsetX86HasERMS = unsafe.Offsetof(cpu.X86.HasERMS)\n```\n\nOffsets into internal/cpu records for use in assembly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#offsetX86HasSSE2",
              "documentation": {
                "identifier": "offsetX86HasSSE2",
                "newPage": false,
                "searchKey": "runtime.offsetX86HasSSE2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const offsetX86HasSSE2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst offsetX86HasSSE2 = unsafe.Offsetof(cpu.X86.HasSSE2)\n```\n\nOffsets into internal/cpu records for use in assembly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#offsetARMHasIDIVA",
              "documentation": {
                "identifier": "offsetARMHasIDIVA",
                "newPage": false,
                "searchKey": "runtime.offsetARMHasIDIVA",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const offsetARMHasIDIVA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst offsetARMHasIDIVA = unsafe.Offsetof(cpu.ARM.HasIDIVA)\n```\n\nOffsets into internal/cpu records for use in assembly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#offsetMIPS64XHasMSA",
              "documentation": {
                "identifier": "offsetMIPS64XHasMSA",
                "newPage": false,
                "searchKey": "runtime.offsetMIPS64XHasMSA",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const offsetMIPS64XHasMSA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst offsetMIPS64XHasMSA = unsafe.Offsetof(cpu.MIPS64X.HasMSA)\n```\n\nOffsets into internal/cpu records for use in assembly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxCPUProfStack",
              "documentation": {
                "identifier": "maxCPUProfStack",
                "newPage": false,
                "searchKey": "runtime.maxCPUProfStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxCPUProfStack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxCPUProfStack = 64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCallSystemStack",
              "documentation": {
                "identifier": "debugCallSystemStack",
                "newPage": false,
                "searchKey": "runtime.debugCallSystemStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugCallSystemStack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugCallSystemStack = \"executing on Go runtime stack\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCallUnknownFunc",
              "documentation": {
                "identifier": "debugCallUnknownFunc",
                "newPage": false,
                "searchKey": "runtime.debugCallUnknownFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugCallUnknownFunc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugCallUnknownFunc = \"call from unknown function\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCallRuntime",
              "documentation": {
                "identifier": "debugCallRuntime",
                "newPage": false,
                "searchKey": "runtime.debugCallRuntime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugCallRuntime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugCallRuntime = \"call from within the Go runtime\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCallUnsafePoint",
              "documentation": {
                "identifier": "debugCallUnsafePoint",
                "newPage": false,
                "searchKey": "runtime.debugCallUnsafePoint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugCallUnsafePoint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugCallUnsafePoint = \"call not at safe point\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogBytes",
              "documentation": {
                "identifier": "debugLogBytes",
                "newPage": false,
                "searchKey": "runtime.debugLogBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogBytes = 16 << 10\n```\n\ndebugLogBytes is the size of each per-M ring buffer. This is allocated off-heap to avoid blowing up the M and hence the GC'd heap size. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogStringLimit",
              "documentation": {
                "identifier": "debugLogStringLimit",
                "newPage": false,
                "searchKey": "runtime.debugLogStringLimit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogStringLimit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogStringLimit = debugLogBytes / 8\n```\n\ndebugLogStringLimit is the maximum number of bytes in a string. Above this, the string will be truncated with \"..(n more bytes)..\" \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogUnknown",
              "documentation": {
                "identifier": "debugLogUnknown",
                "newPage": false,
                "searchKey": "runtime.debugLogUnknown",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogUnknown"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogUnknown = 1 + iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogBoolTrue",
              "documentation": {
                "identifier": "debugLogBoolTrue",
                "newPage": false,
                "searchKey": "runtime.debugLogBoolTrue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogBoolTrue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogBoolTrue\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogBoolFalse",
              "documentation": {
                "identifier": "debugLogBoolFalse",
                "newPage": false,
                "searchKey": "runtime.debugLogBoolFalse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogBoolFalse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogBoolFalse\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogInt",
              "documentation": {
                "identifier": "debugLogInt",
                "newPage": false,
                "searchKey": "runtime.debugLogInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogInt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogInt\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogUint",
              "documentation": {
                "identifier": "debugLogUint",
                "newPage": false,
                "searchKey": "runtime.debugLogUint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogUint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogUint\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogHex",
              "documentation": {
                "identifier": "debugLogHex",
                "newPage": false,
                "searchKey": "runtime.debugLogHex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogHex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogHex\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogPtr",
              "documentation": {
                "identifier": "debugLogPtr",
                "newPage": false,
                "searchKey": "runtime.debugLogPtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogPtr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogPtr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogString",
              "documentation": {
                "identifier": "debugLogString",
                "newPage": false,
                "searchKey": "runtime.debugLogString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogString"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogString\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogConstString",
              "documentation": {
                "identifier": "debugLogConstString",
                "newPage": false,
                "searchKey": "runtime.debugLogConstString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogConstString"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogConstString\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogStringOverflow",
              "documentation": {
                "identifier": "debugLogStringOverflow",
                "newPage": false,
                "searchKey": "runtime.debugLogStringOverflow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogStringOverflow"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogStringOverflow\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogPC",
              "documentation": {
                "identifier": "debugLogPC",
                "newPage": false,
                "searchKey": "runtime.debugLogPC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogPC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogPC\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogTraceback",
              "documentation": {
                "identifier": "debugLogTraceback",
                "newPage": false,
                "searchKey": "runtime.debugLogTraceback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogTraceback"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogTraceback\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogHeaderSize",
              "documentation": {
                "identifier": "debugLogHeaderSize",
                "newPage": false,
                "searchKey": "runtime.debugLogHeaderSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogHeaderSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogHeaderSize = 2\n```\n\ndebugLogHeaderSize is the number of bytes in the framing header of every dlog record. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogSyncSize",
              "documentation": {
                "identifier": "debugLogSyncSize",
                "newPage": false,
                "searchKey": "runtime.debugLogSyncSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugLogSyncSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugLogSyncSize = debugLogHeaderSize + 2*8\n```\n\ndebugLogSyncSize is the number of bytes in a sync record. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dlogEnabled",
              "documentation": {
                "identifier": "dlogEnabled",
                "newPage": false,
                "searchKey": "runtime.dlogEnabled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const dlogEnabled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst dlogEnabled = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_EINTR",
              "documentation": {
                "identifier": "_EINTR",
                "newPage": false,
                "searchKey": "runtime._EINTR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _EINTR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _EINTR = 0x4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_EFAULT",
              "documentation": {
                "identifier": "_EFAULT",
                "newPage": false,
                "searchKey": "runtime._EFAULT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _EFAULT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _EFAULT = 0xe\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_EAGAIN",
              "documentation": {
                "identifier": "_EAGAIN",
                "newPage": false,
                "searchKey": "runtime._EAGAIN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _EAGAIN"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _EAGAIN = 0x23\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_ETIMEDOUT",
              "documentation": {
                "identifier": "_ETIMEDOUT",
                "newPage": false,
                "searchKey": "runtime._ETIMEDOUT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _ETIMEDOUT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _ETIMEDOUT = 0x3c\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PROT_NONE",
              "documentation": {
                "identifier": "_PROT_NONE",
                "newPage": false,
                "searchKey": "runtime._PROT_NONE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PROT_NONE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PROT_NONE = 0x0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PROT_READ",
              "documentation": {
                "identifier": "_PROT_READ",
                "newPage": false,
                "searchKey": "runtime._PROT_READ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PROT_READ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PROT_READ = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PROT_WRITE",
              "documentation": {
                "identifier": "_PROT_WRITE",
                "newPage": false,
                "searchKey": "runtime._PROT_WRITE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PROT_WRITE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PROT_WRITE = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PROT_EXEC",
              "documentation": {
                "identifier": "_PROT_EXEC",
                "newPage": false,
                "searchKey": "runtime._PROT_EXEC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PROT_EXEC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PROT_EXEC = 0x4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_MAP_ANON",
              "documentation": {
                "identifier": "_MAP_ANON",
                "newPage": false,
                "searchKey": "runtime._MAP_ANON",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MAP_ANON"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MAP_ANON = 0x1000\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_MAP_PRIVATE",
              "documentation": {
                "identifier": "_MAP_PRIVATE",
                "newPage": false,
                "searchKey": "runtime._MAP_PRIVATE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MAP_PRIVATE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MAP_PRIVATE = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_MAP_FIXED",
              "documentation": {
                "identifier": "_MAP_FIXED",
                "newPage": false,
                "searchKey": "runtime._MAP_FIXED",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MAP_FIXED"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MAP_FIXED = 0x10\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_MADV_DONTNEED",
              "documentation": {
                "identifier": "_MADV_DONTNEED",
                "newPage": false,
                "searchKey": "runtime._MADV_DONTNEED",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MADV_DONTNEED"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MADV_DONTNEED = 0x4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_MADV_FREE",
              "documentation": {
                "identifier": "_MADV_FREE",
                "newPage": false,
                "searchKey": "runtime._MADV_FREE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MADV_FREE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MADV_FREE = 0x5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_MADV_FREE_REUSABLE",
              "documentation": {
                "identifier": "_MADV_FREE_REUSABLE",
                "newPage": false,
                "searchKey": "runtime._MADV_FREE_REUSABLE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MADV_FREE_REUSABLE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MADV_FREE_REUSABLE = 0x7\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_MADV_FREE_REUSE",
              "documentation": {
                "identifier": "_MADV_FREE_REUSE",
                "newPage": false,
                "searchKey": "runtime._MADV_FREE_REUSE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MADV_FREE_REUSE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MADV_FREE_REUSE = 0x8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SA_SIGINFO",
              "documentation": {
                "identifier": "_SA_SIGINFO",
                "newPage": false,
                "searchKey": "runtime._SA_SIGINFO",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SA_SIGINFO"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SA_SIGINFO = 0x40\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SA_RESTART",
              "documentation": {
                "identifier": "_SA_RESTART",
                "newPage": false,
                "searchKey": "runtime._SA_RESTART",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SA_RESTART"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SA_RESTART = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SA_ONSTACK",
              "documentation": {
                "identifier": "_SA_ONSTACK",
                "newPage": false,
                "searchKey": "runtime._SA_ONSTACK",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SA_ONSTACK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SA_ONSTACK = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SA_USERTRAMP",
              "documentation": {
                "identifier": "_SA_USERTRAMP",
                "newPage": false,
                "searchKey": "runtime._SA_USERTRAMP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SA_USERTRAMP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SA_USERTRAMP = 0x100\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SA_64REGSET",
              "documentation": {
                "identifier": "_SA_64REGSET",
                "newPage": false,
                "searchKey": "runtime._SA_64REGSET",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SA_64REGSET"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SA_64REGSET = 0x200\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGHUP",
              "documentation": {
                "identifier": "_SIGHUP",
                "newPage": false,
                "searchKey": "runtime._SIGHUP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGHUP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGHUP = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGINT",
              "documentation": {
                "identifier": "_SIGINT",
                "newPage": false,
                "searchKey": "runtime._SIGINT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGINT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGINT = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGQUIT",
              "documentation": {
                "identifier": "_SIGQUIT",
                "newPage": false,
                "searchKey": "runtime._SIGQUIT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGQUIT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGQUIT = 0x3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGILL",
              "documentation": {
                "identifier": "_SIGILL",
                "newPage": false,
                "searchKey": "runtime._SIGILL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGILL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGILL = 0x4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGTRAP",
              "documentation": {
                "identifier": "_SIGTRAP",
                "newPage": false,
                "searchKey": "runtime._SIGTRAP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGTRAP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGTRAP = 0x5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGABRT",
              "documentation": {
                "identifier": "_SIGABRT",
                "newPage": false,
                "searchKey": "runtime._SIGABRT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGABRT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGABRT = 0x6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGEMT",
              "documentation": {
                "identifier": "_SIGEMT",
                "newPage": false,
                "searchKey": "runtime._SIGEMT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGEMT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGEMT = 0x7\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGFPE",
              "documentation": {
                "identifier": "_SIGFPE",
                "newPage": false,
                "searchKey": "runtime._SIGFPE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGFPE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGFPE = 0x8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGKILL",
              "documentation": {
                "identifier": "_SIGKILL",
                "newPage": false,
                "searchKey": "runtime._SIGKILL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGKILL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGKILL = 0x9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGBUS",
              "documentation": {
                "identifier": "_SIGBUS",
                "newPage": false,
                "searchKey": "runtime._SIGBUS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGBUS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGBUS = 0xa\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGSEGV",
              "documentation": {
                "identifier": "_SIGSEGV",
                "newPage": false,
                "searchKey": "runtime._SIGSEGV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGSEGV"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGSEGV = 0xb\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGSYS",
              "documentation": {
                "identifier": "_SIGSYS",
                "newPage": false,
                "searchKey": "runtime._SIGSYS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGSYS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGSYS = 0xc\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGPIPE",
              "documentation": {
                "identifier": "_SIGPIPE",
                "newPage": false,
                "searchKey": "runtime._SIGPIPE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGPIPE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGPIPE = 0xd\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGALRM",
              "documentation": {
                "identifier": "_SIGALRM",
                "newPage": false,
                "searchKey": "runtime._SIGALRM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGALRM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGALRM = 0xe\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGTERM",
              "documentation": {
                "identifier": "_SIGTERM",
                "newPage": false,
                "searchKey": "runtime._SIGTERM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGTERM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGTERM = 0xf\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGURG",
              "documentation": {
                "identifier": "_SIGURG",
                "newPage": false,
                "searchKey": "runtime._SIGURG",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGURG"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGURG = 0x10\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGSTOP",
              "documentation": {
                "identifier": "_SIGSTOP",
                "newPage": false,
                "searchKey": "runtime._SIGSTOP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGSTOP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGSTOP = 0x11\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGTSTP",
              "documentation": {
                "identifier": "_SIGTSTP",
                "newPage": false,
                "searchKey": "runtime._SIGTSTP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGTSTP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGTSTP = 0x12\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGCONT",
              "documentation": {
                "identifier": "_SIGCONT",
                "newPage": false,
                "searchKey": "runtime._SIGCONT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGCONT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGCONT = 0x13\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGCHLD",
              "documentation": {
                "identifier": "_SIGCHLD",
                "newPage": false,
                "searchKey": "runtime._SIGCHLD",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGCHLD"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGCHLD = 0x14\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGTTIN",
              "documentation": {
                "identifier": "_SIGTTIN",
                "newPage": false,
                "searchKey": "runtime._SIGTTIN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGTTIN"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGTTIN = 0x15\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGTTOU",
              "documentation": {
                "identifier": "_SIGTTOU",
                "newPage": false,
                "searchKey": "runtime._SIGTTOU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGTTOU"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGTTOU = 0x16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGIO",
              "documentation": {
                "identifier": "_SIGIO",
                "newPage": false,
                "searchKey": "runtime._SIGIO",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGIO"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGIO = 0x17\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGXCPU",
              "documentation": {
                "identifier": "_SIGXCPU",
                "newPage": false,
                "searchKey": "runtime._SIGXCPU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGXCPU"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGXCPU = 0x18\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGXFSZ",
              "documentation": {
                "identifier": "_SIGXFSZ",
                "newPage": false,
                "searchKey": "runtime._SIGXFSZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGXFSZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGXFSZ = 0x19\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGVTALRM",
              "documentation": {
                "identifier": "_SIGVTALRM",
                "newPage": false,
                "searchKey": "runtime._SIGVTALRM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGVTALRM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGVTALRM = 0x1a\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGPROF",
              "documentation": {
                "identifier": "_SIGPROF",
                "newPage": false,
                "searchKey": "runtime._SIGPROF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGPROF"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGPROF = 0x1b\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGWINCH",
              "documentation": {
                "identifier": "_SIGWINCH",
                "newPage": false,
                "searchKey": "runtime._SIGWINCH",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGWINCH"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGWINCH = 0x1c\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGINFO",
              "documentation": {
                "identifier": "_SIGINFO",
                "newPage": false,
                "searchKey": "runtime._SIGINFO",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGINFO"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGINFO = 0x1d\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGUSR1",
              "documentation": {
                "identifier": "_SIGUSR1",
                "newPage": false,
                "searchKey": "runtime._SIGUSR1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGUSR1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGUSR1 = 0x1e\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIGUSR2",
              "documentation": {
                "identifier": "_SIGUSR2",
                "newPage": false,
                "searchKey": "runtime._SIGUSR2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIGUSR2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIGUSR2 = 0x1f\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FPE_INTDIV",
              "documentation": {
                "identifier": "_FPE_INTDIV",
                "newPage": false,
                "searchKey": "runtime._FPE_INTDIV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FPE_INTDIV"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FPE_INTDIV = 0x7\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FPE_INTOVF",
              "documentation": {
                "identifier": "_FPE_INTOVF",
                "newPage": false,
                "searchKey": "runtime._FPE_INTOVF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FPE_INTOVF"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FPE_INTOVF = 0x8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FPE_FLTDIV",
              "documentation": {
                "identifier": "_FPE_FLTDIV",
                "newPage": false,
                "searchKey": "runtime._FPE_FLTDIV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FPE_FLTDIV"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FPE_FLTDIV = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FPE_FLTOVF",
              "documentation": {
                "identifier": "_FPE_FLTOVF",
                "newPage": false,
                "searchKey": "runtime._FPE_FLTOVF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FPE_FLTOVF"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FPE_FLTOVF = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FPE_FLTUND",
              "documentation": {
                "identifier": "_FPE_FLTUND",
                "newPage": false,
                "searchKey": "runtime._FPE_FLTUND",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FPE_FLTUND"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FPE_FLTUND = 0x3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FPE_FLTRES",
              "documentation": {
                "identifier": "_FPE_FLTRES",
                "newPage": false,
                "searchKey": "runtime._FPE_FLTRES",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FPE_FLTRES"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FPE_FLTRES = 0x4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FPE_FLTINV",
              "documentation": {
                "identifier": "_FPE_FLTINV",
                "newPage": false,
                "searchKey": "runtime._FPE_FLTINV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FPE_FLTINV"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FPE_FLTINV = 0x5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FPE_FLTSUB",
              "documentation": {
                "identifier": "_FPE_FLTSUB",
                "newPage": false,
                "searchKey": "runtime._FPE_FLTSUB",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FPE_FLTSUB"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FPE_FLTSUB = 0x6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_BUS_ADRALN",
              "documentation": {
                "identifier": "_BUS_ADRALN",
                "newPage": false,
                "searchKey": "runtime._BUS_ADRALN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BUS_ADRALN"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BUS_ADRALN = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_BUS_ADRERR",
              "documentation": {
                "identifier": "_BUS_ADRERR",
                "newPage": false,
                "searchKey": "runtime._BUS_ADRERR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BUS_ADRERR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BUS_ADRERR = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_BUS_OBJERR",
              "documentation": {
                "identifier": "_BUS_OBJERR",
                "newPage": false,
                "searchKey": "runtime._BUS_OBJERR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _BUS_OBJERR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _BUS_OBJERR = 0x3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SEGV_MAPERR",
              "documentation": {
                "identifier": "_SEGV_MAPERR",
                "newPage": false,
                "searchKey": "runtime._SEGV_MAPERR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SEGV_MAPERR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SEGV_MAPERR = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SEGV_ACCERR",
              "documentation": {
                "identifier": "_SEGV_ACCERR",
                "newPage": false,
                "searchKey": "runtime._SEGV_ACCERR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SEGV_ACCERR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SEGV_ACCERR = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_ITIMER_REAL",
              "documentation": {
                "identifier": "_ITIMER_REAL",
                "newPage": false,
                "searchKey": "runtime._ITIMER_REAL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _ITIMER_REAL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _ITIMER_REAL = 0x0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_ITIMER_VIRTUAL",
              "documentation": {
                "identifier": "_ITIMER_VIRTUAL",
                "newPage": false,
                "searchKey": "runtime._ITIMER_VIRTUAL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _ITIMER_VIRTUAL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _ITIMER_VIRTUAL = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_ITIMER_PROF",
              "documentation": {
                "identifier": "_ITIMER_PROF",
                "newPage": false,
                "searchKey": "runtime._ITIMER_PROF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _ITIMER_PROF"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _ITIMER_PROF = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_EV_ADD",
              "documentation": {
                "identifier": "_EV_ADD",
                "newPage": false,
                "searchKey": "runtime._EV_ADD",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _EV_ADD"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _EV_ADD = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_EV_DELETE",
              "documentation": {
                "identifier": "_EV_DELETE",
                "newPage": false,
                "searchKey": "runtime._EV_DELETE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _EV_DELETE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _EV_DELETE = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_EV_CLEAR",
              "documentation": {
                "identifier": "_EV_CLEAR",
                "newPage": false,
                "searchKey": "runtime._EV_CLEAR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _EV_CLEAR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _EV_CLEAR = 0x20\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_EV_RECEIPT",
              "documentation": {
                "identifier": "_EV_RECEIPT",
                "newPage": false,
                "searchKey": "runtime._EV_RECEIPT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _EV_RECEIPT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _EV_RECEIPT = 0x40\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_EV_ERROR",
              "documentation": {
                "identifier": "_EV_ERROR",
                "newPage": false,
                "searchKey": "runtime._EV_ERROR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _EV_ERROR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _EV_ERROR = 0x4000\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_EV_EOF",
              "documentation": {
                "identifier": "_EV_EOF",
                "newPage": false,
                "searchKey": "runtime._EV_EOF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _EV_EOF"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _EV_EOF = 0x8000\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_EVFILT_READ",
              "documentation": {
                "identifier": "_EVFILT_READ",
                "newPage": false,
                "searchKey": "runtime._EVFILT_READ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _EVFILT_READ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _EVFILT_READ = -0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_EVFILT_WRITE",
              "documentation": {
                "identifier": "_EVFILT_WRITE",
                "newPage": false,
                "searchKey": "runtime._EVFILT_WRITE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _EVFILT_WRITE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _EVFILT_WRITE = -0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PTHREAD_CREATE_DETACHED",
              "documentation": {
                "identifier": "_PTHREAD_CREATE_DETACHED",
                "newPage": false,
                "searchKey": "runtime._PTHREAD_CREATE_DETACHED",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PTHREAD_CREATE_DETACHED"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PTHREAD_CREATE_DETACHED = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_F_SETFD",
              "documentation": {
                "identifier": "_F_SETFD",
                "newPage": false,
                "searchKey": "runtime._F_SETFD",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _F_SETFD"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _F_SETFD = 0x2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_F_GETFL",
              "documentation": {
                "identifier": "_F_GETFL",
                "newPage": false,
                "searchKey": "runtime._F_GETFL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _F_GETFL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _F_GETFL = 0x3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_F_SETFL",
              "documentation": {
                "identifier": "_F_SETFL",
                "newPage": false,
                "searchKey": "runtime._F_SETFL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _F_SETFL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _F_SETFL = 0x4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FD_CLOEXEC",
              "documentation": {
                "identifier": "_FD_CLOEXEC",
                "newPage": false,
                "searchKey": "runtime._FD_CLOEXEC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FD_CLOEXEC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FD_CLOEXEC = 0x1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_O_NONBLOCK",
              "documentation": {
                "identifier": "_O_NONBLOCK",
                "newPage": false,
                "searchKey": "runtime._O_NONBLOCK",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _O_NONBLOCK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _O_NONBLOCK = 4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsIndex",
              "documentation": {
                "identifier": "boundsIndex",
                "newPage": false,
                "searchKey": "runtime.boundsIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const boundsIndex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst boundsIndex boundsErrorCode = iota // s[x], 0 <= x < len(s) failed\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsSliceAlen",
              "documentation": {
                "identifier": "boundsSliceAlen",
                "newPage": false,
                "searchKey": "runtime.boundsSliceAlen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const boundsSliceAlen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst boundsSliceAlen // s[?:x], 0 <= x <= len(s) failed\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsSliceAcap",
              "documentation": {
                "identifier": "boundsSliceAcap",
                "newPage": false,
                "searchKey": "runtime.boundsSliceAcap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const boundsSliceAcap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst boundsSliceAcap // s[?:x], 0 <= x <= cap(s) failed\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsSliceB",
              "documentation": {
                "identifier": "boundsSliceB",
                "newPage": false,
                "searchKey": "runtime.boundsSliceB",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const boundsSliceB"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst boundsSliceB // s[x:y], 0 <= x <= y failed (but boundsSliceA didn't happen)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsSlice3Alen",
              "documentation": {
                "identifier": "boundsSlice3Alen",
                "newPage": false,
                "searchKey": "runtime.boundsSlice3Alen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const boundsSlice3Alen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst boundsSlice3Alen // s[?:?:x], 0 <= x <= len(s) failed\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsSlice3Acap",
              "documentation": {
                "identifier": "boundsSlice3Acap",
                "newPage": false,
                "searchKey": "runtime.boundsSlice3Acap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const boundsSlice3Acap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst boundsSlice3Acap // s[?:?:x], 0 <= x <= cap(s) failed\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsSlice3B",
              "documentation": {
                "identifier": "boundsSlice3B",
                "newPage": false,
                "searchKey": "runtime.boundsSlice3B",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const boundsSlice3B"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst boundsSlice3B // s[?:x:y], 0 <= x <= y failed (but boundsSlice3A didn't happen)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsSlice3C",
              "documentation": {
                "identifier": "boundsSlice3C",
                "newPage": false,
                "searchKey": "runtime.boundsSlice3C",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const boundsSlice3C"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst boundsSlice3C // s[x:y:?], 0 <= x <= y failed (but boundsSlice3A/B didn't happen)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsConvert",
              "documentation": {
                "identifier": "boundsConvert",
                "newPage": false,
                "searchKey": "runtime.boundsConvert",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const boundsConvert"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst boundsConvert // (*[x]T)(s), 0 <= x <= len(s) failed\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GOOS",
              "documentation": {
                "identifier": "GOOS",
                "newPage": false,
                "searchKey": "runtime.GOOS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const GOOS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst GOOS string = sys.GOOS\n```\n\nGOOS is the running program's operating system target: one of darwin, freebsd, linux, and so on. To view possible combinations of GOOS and GOARCH, run \"go tool dist list\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GOARCH",
              "documentation": {
                "identifier": "GOARCH",
                "newPage": false,
                "searchKey": "runtime.GOARCH",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const GOARCH"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst GOARCH string = sys.GOARCH\n```\n\nGOARCH is the running program's architecture target: one of 386, amd64, arm, s390x, and so on. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fastlogNumBits",
              "documentation": {
                "identifier": "fastlogNumBits",
                "newPage": false,
                "searchKey": "runtime.fastlogNumBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const fastlogNumBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst fastlogNumBits = 5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#m1",
              "documentation": {
                "identifier": "m1",
                "newPage": false,
                "searchKey": "runtime.m1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const m1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst m1 = 0xa0761d6478bd642f\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#m2",
              "documentation": {
                "identifier": "m2",
                "newPage": false,
                "searchKey": "runtime.m2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const m2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst m2 = 0xe7037ed1a0b428db\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#m3",
              "documentation": {
                "identifier": "m3",
                "newPage": false,
                "searchKey": "runtime.m3",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const m3"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst m3 = 0x8ebc6af09c88c6e3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#m4",
              "documentation": {
                "identifier": "m4",
                "newPage": false,
                "searchKey": "runtime.m4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const m4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst m4 = 0x589965cc75374cc3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#m5",
              "documentation": {
                "identifier": "m5",
                "newPage": false,
                "searchKey": "runtime.m5",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const m5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst m5 = 0x1d8e4e27c47d124f\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fieldKindEol",
              "documentation": {
                "identifier": "fieldKindEol",
                "newPage": false,
                "searchKey": "runtime.fieldKindEol",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const fieldKindEol"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst fieldKindEol = 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fieldKindPtr",
              "documentation": {
                "identifier": "fieldKindPtr",
                "newPage": false,
                "searchKey": "runtime.fieldKindPtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const fieldKindPtr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst fieldKindPtr = 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fieldKindIface",
              "documentation": {
                "identifier": "fieldKindIface",
                "newPage": false,
                "searchKey": "runtime.fieldKindIface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const fieldKindIface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst fieldKindIface = 2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fieldKindEface",
              "documentation": {
                "identifier": "fieldKindEface",
                "newPage": false,
                "searchKey": "runtime.fieldKindEface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const fieldKindEface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst fieldKindEface = 3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagEOF",
              "documentation": {
                "identifier": "tagEOF",
                "newPage": false,
                "searchKey": "runtime.tagEOF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagEOF"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagEOF = 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagObject",
              "documentation": {
                "identifier": "tagObject",
                "newPage": false,
                "searchKey": "runtime.tagObject",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagObject"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagObject = 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagOtherRoot",
              "documentation": {
                "identifier": "tagOtherRoot",
                "newPage": false,
                "searchKey": "runtime.tagOtherRoot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagOtherRoot"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagOtherRoot = 2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagType",
              "documentation": {
                "identifier": "tagType",
                "newPage": false,
                "searchKey": "runtime.tagType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagType = 3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagGoroutine",
              "documentation": {
                "identifier": "tagGoroutine",
                "newPage": false,
                "searchKey": "runtime.tagGoroutine",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagGoroutine"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagGoroutine = 4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagStackFrame",
              "documentation": {
                "identifier": "tagStackFrame",
                "newPage": false,
                "searchKey": "runtime.tagStackFrame",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagStackFrame"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagStackFrame = 5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagParams",
              "documentation": {
                "identifier": "tagParams",
                "newPage": false,
                "searchKey": "runtime.tagParams",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagParams"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagParams = 6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagFinalizer",
              "documentation": {
                "identifier": "tagFinalizer",
                "newPage": false,
                "searchKey": "runtime.tagFinalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagFinalizer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagFinalizer = 7\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagItab",
              "documentation": {
                "identifier": "tagItab",
                "newPage": false,
                "searchKey": "runtime.tagItab",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagItab"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagItab = 8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagOSThread",
              "documentation": {
                "identifier": "tagOSThread",
                "newPage": false,
                "searchKey": "runtime.tagOSThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagOSThread"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagOSThread = 9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagMemStats",
              "documentation": {
                "identifier": "tagMemStats",
                "newPage": false,
                "searchKey": "runtime.tagMemStats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagMemStats"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagMemStats = 10\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagQueuedFinalizer",
              "documentation": {
                "identifier": "tagQueuedFinalizer",
                "newPage": false,
                "searchKey": "runtime.tagQueuedFinalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagQueuedFinalizer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagQueuedFinalizer = 11\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagData",
              "documentation": {
                "identifier": "tagData",
                "newPage": false,
                "searchKey": "runtime.tagData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagData = 12\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagBSS",
              "documentation": {
                "identifier": "tagBSS",
                "newPage": false,
                "searchKey": "runtime.tagBSS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagBSS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagBSS = 13\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagDefer",
              "documentation": {
                "identifier": "tagDefer",
                "newPage": false,
                "searchKey": "runtime.tagDefer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagDefer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagDefer = 14\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagPanic",
              "documentation": {
                "identifier": "tagPanic",
                "newPage": false,
                "searchKey": "runtime.tagPanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagPanic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagPanic = 15\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagMemProf",
              "documentation": {
                "identifier": "tagMemProf",
                "newPage": false,
                "searchKey": "runtime.tagMemProf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagMemProf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagMemProf = 16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tagAllocSample",
              "documentation": {
                "identifier": "tagAllocSample",
                "newPage": false,
                "searchKey": "runtime.tagAllocSample",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tagAllocSample"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tagAllocSample = 17\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bufSize",
              "documentation": {
                "identifier": "bufSize",
                "newPage": false,
                "searchKey": "runtime.bufSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bufSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bufSize = 4096\n```\n\nbuffer of pending write data \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typeCacheBuckets",
              "documentation": {
                "identifier": "typeCacheBuckets",
                "newPage": false,
                "searchKey": "runtime.typeCacheBuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeCacheBuckets"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeCacheBuckets = 256\n```\n\nCache of types that have been serialized already. We use a type's hash field to pick a bucket. Inside a bucket, we keep a list of types that have been serialized so far, most recently used first. Note: when a bucket overflows we may end up serializing a type more than once. That's ok. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typeCacheAssoc",
              "documentation": {
                "identifier": "typeCacheAssoc",
                "newPage": false,
                "searchKey": "runtime.typeCacheAssoc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const typeCacheAssoc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst typeCacheAssoc = 4\n```\n\nCache of types that have been serialized already. We use a type's hash field to pick a bucket. Inside a bucket, we keep a list of types that have been serialized so far, most recently used first. Note: when a bucket overflows we may end up serializing a type more than once. That's ok. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timeHistSubBucketBits",
              "documentation": {
                "identifier": "timeHistSubBucketBits",
                "newPage": false,
                "searchKey": "runtime.timeHistSubBucketBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timeHistSubBucketBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timeHistSubBucketBits = 4\n```\n\nFor the time histogram type, we use an HDR histogram. Values are placed in super-buckets based solely on the most significant set bit. Thus, super-buckets are power-of-2 sized. Values are then placed into sub-buckets based on the value of the next timeHistSubBucketBits most significant bits. Thus, sub-buckets are linear within a super-bucket. \n\nTherefore, the number of sub-buckets (timeHistNumSubBuckets) defines the error. This error may be computed as 1/timeHistNumSubBuckets*100%. For example, for 16 sub-buckets per super-bucket the error is approximately 6%. \n\nThe number of super-buckets (timeHistNumSuperBuckets), on the other hand, defines the range. To reserve room for sub-buckets, bit timeHistSubBucketBits is the first bit considered for super-buckets, so super-bucket indices are adjusted accordingly. \n\nAs an example, consider 45 super-buckets with 16 sub-buckets. \n\n```\n00110\n^----\n│  ^\n│  └---- Lowest 4 bits -> sub-bucket 6\n└------- Bit 4 unset -> super-bucket 0\n\n10110\n^----\n│  ^\n│  └---- Next 4 bits -> sub-bucket 6\n└------- Bit 4 set -> super-bucket 1\n100010\n^----^\n│  ^ └-- Lower bits ignored\n│  └---- Next 4 bits -> sub-bucket 1\n└------- Bit 5 set -> super-bucket 2\n\n```\nFollowing this pattern, bucket 45 will have the bit 48 set. We don't have any buckets for higher values, so the highest sub-bucket will contain values of 2^48-1 nanoseconds or approx. 3 days. This range is more than enough to handle durations produced by the runtime. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timeHistNumSubBuckets",
              "documentation": {
                "identifier": "timeHistNumSubBuckets",
                "newPage": false,
                "searchKey": "runtime.timeHistNumSubBuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timeHistNumSubBuckets"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timeHistNumSubBuckets = 1 << timeHistSubBucketBits\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timeHistNumSuperBuckets",
              "documentation": {
                "identifier": "timeHistNumSuperBuckets",
                "newPage": false,
                "searchKey": "runtime.timeHistNumSuperBuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timeHistNumSuperBuckets"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timeHistNumSuperBuckets = 45\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timeHistTotalBuckets",
              "documentation": {
                "identifier": "timeHistTotalBuckets",
                "newPage": false,
                "searchKey": "runtime.timeHistTotalBuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timeHistTotalBuckets"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timeHistTotalBuckets = timeHistNumSuperBuckets*timeHistNumSubBuckets + 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fInf",
              "documentation": {
                "identifier": "fInf",
                "newPage": false,
                "searchKey": "runtime.fInf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const fInf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst fInf = 0x7FF0000000000000\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fNegInf",
              "documentation": {
                "identifier": "fNegInf",
                "newPage": false,
                "searchKey": "runtime.fNegInf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const fNegInf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst fNegInf = 0xFFF0000000000000\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itabInitSize",
              "documentation": {
                "identifier": "itabInitSize",
                "newPage": false,
                "searchKey": "runtime.itabInitSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const itabInitSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst itabInitSize = 512\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#addrBits",
              "documentation": {
                "identifier": "addrBits",
                "newPage": false,
                "searchKey": "runtime.addrBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const addrBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst addrBits = 48\n```\n\naddrBits is the number of bits needed to represent a virtual address. \n\nSee heapAddrBits for a table of address space sizes on various architectures. 48 bits is enough for all architectures except s390x. \n\nOn AMD64, virtual addresses are 48-bit (or 57-bit) numbers sign extended to 64. We shift the address left 16 to eliminate the sign extended part and make room in the bottom for the count. \n\nOn s390x, virtual addresses are 64-bit. There's not much we can do about this, so we just hope that the kernel doesn't get to really high addresses and panic if it does. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cntBits",
              "documentation": {
                "identifier": "cntBits",
                "newPage": false,
                "searchKey": "runtime.cntBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const cntBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst cntBits = 64 - addrBits + 3\n```\n\nIn addition to the 16 bits taken from the top, we can take 3 from the bottom, because node must be pointer-aligned, giving a total of 19 bits of count. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#aixAddrBits",
              "documentation": {
                "identifier": "aixAddrBits",
                "newPage": false,
                "searchKey": "runtime.aixAddrBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const aixAddrBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst aixAddrBits = 57\n```\n\nOn AIX, 64-bit addresses are split into 36-bit segment number and 28-bit offset in segment.  Segment numbers in the range 0x0A0000000-0x0AFFFFFFF(LSA) are available for mmap. We assume all lfnode addresses are from memory allocated with mmap. We use one bit to distinguish between the two ranges. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#aixCntBits",
              "documentation": {
                "identifier": "aixCntBits",
                "newPage": false,
                "searchKey": "runtime.aixCntBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const aixCntBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst aixCntBits = 64 - aixAddrBits + 3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#locked",
              "documentation": {
                "identifier": "locked",
                "newPage": false,
                "searchKey": "runtime.locked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const locked"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst locked uintptr = 1\n```\n\nThis implementation depends on OS-specific implementations of \n\n```\nfunc semacreate(mp *m)\n\tCreate a semaphore for mp, if it does not already have one.\n\nfunc semasleep(ns int64) int32\n\tIf ns < 0, acquire m's semaphore and return 0.\n\tIf ns >= 0, try to acquire m's semaphore for at most ns nanoseconds.\n\tReturn 0 if the semaphore was acquired, -1 if interrupted or timed out.\n\nfunc semawakeup(mp *m)\n\tWake up mp, which is or will soon be sleeping on its semaphore.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#active_spin",
              "documentation": {
                "identifier": "active_spin",
                "newPage": false,
                "searchKey": "runtime.active_spin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const active_spin"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst active_spin = 4\n```\n\nThis implementation depends on OS-specific implementations of \n\n```\nfunc semacreate(mp *m)\n\tCreate a semaphore for mp, if it does not already have one.\n\nfunc semasleep(ns int64) int32\n\tIf ns < 0, acquire m's semaphore and return 0.\n\tIf ns >= 0, try to acquire m's semaphore for at most ns nanoseconds.\n\tReturn 0 if the semaphore was acquired, -1 if interrupted or timed out.\n\nfunc semawakeup(mp *m)\n\tWake up mp, which is or will soon be sleeping on its semaphore.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#active_spin_cnt",
              "documentation": {
                "identifier": "active_spin_cnt",
                "newPage": false,
                "searchKey": "runtime.active_spin_cnt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const active_spin_cnt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst active_spin_cnt = 30\n```\n\nThis implementation depends on OS-specific implementations of \n\n```\nfunc semacreate(mp *m)\n\tCreate a semaphore for mp, if it does not already have one.\n\nfunc semasleep(ns int64) int32\n\tIf ns < 0, acquire m's semaphore and return 0.\n\tIf ns >= 0, try to acquire m's semaphore for at most ns nanoseconds.\n\tReturn 0 if the semaphore was acquired, -1 if interrupted or timed out.\n\nfunc semawakeup(mp *m)\n\tWake up mp, which is or will soon be sleeping on its semaphore.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#passive_spin",
              "documentation": {
                "identifier": "passive_spin",
                "newPage": false,
                "searchKey": "runtime.passive_spin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const passive_spin"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst passive_spin = 1\n```\n\nThis implementation depends on OS-specific implementations of \n\n```\nfunc semacreate(mp *m)\n\tCreate a semaphore for mp, if it does not already have one.\n\nfunc semasleep(ns int64) int32\n\tIf ns < 0, acquire m's semaphore and return 0.\n\tIf ns >= 0, try to acquire m's semaphore for at most ns nanoseconds.\n\tReturn 0 if the semaphore was acquired, -1 if interrupted or timed out.\n\nfunc semawakeup(mp *m)\n\tWake up mp, which is or will soon be sleeping on its semaphore.\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankDummy",
              "documentation": {
                "identifier": "lockRankDummy",
                "newPage": false,
                "searchKey": "runtime.lockRankDummy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankDummy"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankDummy lockRank = iota\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankSysmon",
              "documentation": {
                "identifier": "lockRankSysmon",
                "newPage": false,
                "searchKey": "runtime.lockRankSysmon",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankSysmon"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankSysmon\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\nLocks held above sched \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankScavenge",
              "documentation": {
                "identifier": "lockRankScavenge",
                "newPage": false,
                "searchKey": "runtime.lockRankScavenge",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankScavenge"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankScavenge\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankForcegc",
              "documentation": {
                "identifier": "lockRankForcegc",
                "newPage": false,
                "searchKey": "runtime.lockRankForcegc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankForcegc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankForcegc\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankSweepWaiters",
              "documentation": {
                "identifier": "lockRankSweepWaiters",
                "newPage": false,
                "searchKey": "runtime.lockRankSweepWaiters",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankSweepWaiters"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankSweepWaiters\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankAssistQueue",
              "documentation": {
                "identifier": "lockRankAssistQueue",
                "newPage": false,
                "searchKey": "runtime.lockRankAssistQueue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankAssistQueue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankAssistQueue\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankCpuprof",
              "documentation": {
                "identifier": "lockRankCpuprof",
                "newPage": false,
                "searchKey": "runtime.lockRankCpuprof",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankCpuprof"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankCpuprof\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankSweep",
              "documentation": {
                "identifier": "lockRankSweep",
                "newPage": false,
                "searchKey": "runtime.lockRankSweep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankSweep"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankSweep\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankPollDesc",
              "documentation": {
                "identifier": "lockRankPollDesc",
                "newPage": false,
                "searchKey": "runtime.lockRankPollDesc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankPollDesc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankPollDesc\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankSched",
              "documentation": {
                "identifier": "lockRankSched",
                "newPage": false,
                "searchKey": "runtime.lockRankSched",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankSched"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankSched\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankDeadlock",
              "documentation": {
                "identifier": "lockRankDeadlock",
                "newPage": false,
                "searchKey": "runtime.lockRankDeadlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankDeadlock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankDeadlock\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankAllg",
              "documentation": {
                "identifier": "lockRankAllg",
                "newPage": false,
                "searchKey": "runtime.lockRankAllg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankAllg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankAllg\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankAllp",
              "documentation": {
                "identifier": "lockRankAllp",
                "newPage": false,
                "searchKey": "runtime.lockRankAllp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankAllp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankAllp\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankTimers",
              "documentation": {
                "identifier": "lockRankTimers",
                "newPage": false,
                "searchKey": "runtime.lockRankTimers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankTimers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankTimers // Multiple timers locked simultaneously in destroy()\n\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankItab",
              "documentation": {
                "identifier": "lockRankItab",
                "newPage": false,
                "searchKey": "runtime.lockRankItab",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankItab"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankItab\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankReflectOffs",
              "documentation": {
                "identifier": "lockRankReflectOffs",
                "newPage": false,
                "searchKey": "runtime.lockRankReflectOffs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankReflectOffs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankReflectOffs\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankHchan",
              "documentation": {
                "identifier": "lockRankHchan",
                "newPage": false,
                "searchKey": "runtime.lockRankHchan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankHchan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankHchan // Multiple hchans acquired in lock order in syncadjustsudogs()\n\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankFin",
              "documentation": {
                "identifier": "lockRankFin",
                "newPage": false,
                "searchKey": "runtime.lockRankFin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankFin"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankFin\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankNotifyList",
              "documentation": {
                "identifier": "lockRankNotifyList",
                "newPage": false,
                "searchKey": "runtime.lockRankNotifyList",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankNotifyList"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankNotifyList\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankTraceBuf",
              "documentation": {
                "identifier": "lockRankTraceBuf",
                "newPage": false,
                "searchKey": "runtime.lockRankTraceBuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankTraceBuf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankTraceBuf\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankTraceStrings",
              "documentation": {
                "identifier": "lockRankTraceStrings",
                "newPage": false,
                "searchKey": "runtime.lockRankTraceStrings",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankTraceStrings"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankTraceStrings\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankMspanSpecial",
              "documentation": {
                "identifier": "lockRankMspanSpecial",
                "newPage": false,
                "searchKey": "runtime.lockRankMspanSpecial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankMspanSpecial"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankMspanSpecial\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankProf",
              "documentation": {
                "identifier": "lockRankProf",
                "newPage": false,
                "searchKey": "runtime.lockRankProf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankProf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankProf\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankGcBitsArenas",
              "documentation": {
                "identifier": "lockRankGcBitsArenas",
                "newPage": false,
                "searchKey": "runtime.lockRankGcBitsArenas",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankGcBitsArenas"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankGcBitsArenas\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankRoot",
              "documentation": {
                "identifier": "lockRankRoot",
                "newPage": false,
                "searchKey": "runtime.lockRankRoot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankRoot"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankRoot\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankTrace",
              "documentation": {
                "identifier": "lockRankTrace",
                "newPage": false,
                "searchKey": "runtime.lockRankTrace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankTrace"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankTrace\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankTraceStackTab",
              "documentation": {
                "identifier": "lockRankTraceStackTab",
                "newPage": false,
                "searchKey": "runtime.lockRankTraceStackTab",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankTraceStackTab"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankTraceStackTab\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankNetpollInit",
              "documentation": {
                "identifier": "lockRankNetpollInit",
                "newPage": false,
                "searchKey": "runtime.lockRankNetpollInit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankNetpollInit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankNetpollInit\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankRwmutexW",
              "documentation": {
                "identifier": "lockRankRwmutexW",
                "newPage": false,
                "searchKey": "runtime.lockRankRwmutexW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankRwmutexW"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankRwmutexW\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankRwmutexR",
              "documentation": {
                "identifier": "lockRankRwmutexR",
                "newPage": false,
                "searchKey": "runtime.lockRankRwmutexR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankRwmutexR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankRwmutexR\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankSpanSetSpine",
              "documentation": {
                "identifier": "lockRankSpanSetSpine",
                "newPage": false,
                "searchKey": "runtime.lockRankSpanSetSpine",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankSpanSetSpine"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankSpanSetSpine\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankGscan",
              "documentation": {
                "identifier": "lockRankGscan",
                "newPage": false,
                "searchKey": "runtime.lockRankGscan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankGscan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankGscan\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankStackpool",
              "documentation": {
                "identifier": "lockRankStackpool",
                "newPage": false,
                "searchKey": "runtime.lockRankStackpool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankStackpool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankStackpool\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankStackLarge",
              "documentation": {
                "identifier": "lockRankStackLarge",
                "newPage": false,
                "searchKey": "runtime.lockRankStackLarge",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankStackLarge"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankStackLarge\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankDefer",
              "documentation": {
                "identifier": "lockRankDefer",
                "newPage": false,
                "searchKey": "runtime.lockRankDefer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankDefer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankDefer\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankSudog",
              "documentation": {
                "identifier": "lockRankSudog",
                "newPage": false,
                "searchKey": "runtime.lockRankSudog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankSudog"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankSudog\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankWbufSpans",
              "documentation": {
                "identifier": "lockRankWbufSpans",
                "newPage": false,
                "searchKey": "runtime.lockRankWbufSpans",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankWbufSpans"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankWbufSpans\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\nMemory-related non-leaf locks \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankMheap",
              "documentation": {
                "identifier": "lockRankMheap",
                "newPage": false,
                "searchKey": "runtime.lockRankMheap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankMheap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankMheap\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankMheapSpecial",
              "documentation": {
                "identifier": "lockRankMheapSpecial",
                "newPage": false,
                "searchKey": "runtime.lockRankMheapSpecial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankMheapSpecial"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankMheapSpecial\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankGlobalAlloc",
              "documentation": {
                "identifier": "lockRankGlobalAlloc",
                "newPage": false,
                "searchKey": "runtime.lockRankGlobalAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankGlobalAlloc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankGlobalAlloc\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\nMemory-related leaf locks \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankGFree",
              "documentation": {
                "identifier": "lockRankGFree",
                "newPage": false,
                "searchKey": "runtime.lockRankGFree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankGFree"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankGFree\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\nOther leaf locks \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankHchanLeaf",
              "documentation": {
                "identifier": "lockRankHchanLeaf",
                "newPage": false,
                "searchKey": "runtime.lockRankHchanLeaf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankHchanLeaf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankHchanLeaf\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\nGenerally, hchan must be acquired before gscan. But in one specific case (in syncadjustsudogs from markroot after the g has been suspended by suspendG), we allow gscan to be acquired, and then an hchan lock. To allow this case, we get this lockRankHchanLeaf rank in syncadjustsudogs(), rather than lockRankHchan. By using this special rank, we don't allow any further locks to be acquired other than more hchan locks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankPanic",
              "documentation": {
                "identifier": "lockRankPanic",
                "newPage": false,
                "searchKey": "runtime.lockRankPanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankPanic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankPanic\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankNewmHandoff",
              "documentation": {
                "identifier": "lockRankNewmHandoff",
                "newPage": false,
                "searchKey": "runtime.lockRankNewmHandoff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankNewmHandoff"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankNewmHandoff\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\nLeaf locks with no dependencies, so these constants are not actually used anywhere. There are other architecture-dependent leaf locks as well. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankDebugPtrmask",
              "documentation": {
                "identifier": "lockRankDebugPtrmask",
                "newPage": false,
                "searchKey": "runtime.lockRankDebugPtrmask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankDebugPtrmask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankDebugPtrmask\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankFaketimeState",
              "documentation": {
                "identifier": "lockRankFaketimeState",
                "newPage": false,
                "searchKey": "runtime.lockRankFaketimeState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankFaketimeState"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankFaketimeState\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankTicks",
              "documentation": {
                "identifier": "lockRankTicks",
                "newPage": false,
                "searchKey": "runtime.lockRankTicks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankTicks"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankTicks\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankRaceFini",
              "documentation": {
                "identifier": "lockRankRaceFini",
                "newPage": false,
                "searchKey": "runtime.lockRankRaceFini",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankRaceFini"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankRaceFini\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankPollCache",
              "documentation": {
                "identifier": "lockRankPollCache",
                "newPage": false,
                "searchKey": "runtime.lockRankPollCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankPollCache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankPollCache\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankDebug",
              "documentation": {
                "identifier": "lockRankDebug",
                "newPage": false,
                "searchKey": "runtime.lockRankDebug",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankDebug"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankDebug\n```\n\nConstants representing the lock rank of the architecture-independent locks in the runtime. Locks with lower rank must be taken before locks with higher rank. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankLeafRank",
              "documentation": {
                "identifier": "lockRankLeafRank",
                "newPage": false,
                "searchKey": "runtime.lockRankLeafRank",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const lockRankLeafRank"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst lockRankLeafRank lockRank = 1000\n```\n\nlockRankLeafRank is the rank of lock that does not have a declared rank, and hence is a leaf lock. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugMalloc",
              "documentation": {
                "identifier": "debugMalloc",
                "newPage": false,
                "searchKey": "runtime.debugMalloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugMalloc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugMalloc = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxTinySize",
              "documentation": {
                "identifier": "maxTinySize",
                "newPage": false,
                "searchKey": "runtime.maxTinySize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxTinySize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxTinySize = _TinySize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tinySizeClass",
              "documentation": {
                "identifier": "tinySizeClass",
                "newPage": false,
                "searchKey": "runtime.tinySizeClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tinySizeClass"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tinySizeClass = _TinySizeClass\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxSmallSize",
              "documentation": {
                "identifier": "maxSmallSize",
                "newPage": false,
                "searchKey": "runtime.maxSmallSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxSmallSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxSmallSize = _MaxSmallSize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pageShift",
              "documentation": {
                "identifier": "pageShift",
                "newPage": false,
                "searchKey": "runtime.pageShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pageShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pageShift = _PageShift\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pageSize",
              "documentation": {
                "identifier": "pageSize",
                "newPage": false,
                "searchKey": "runtime.pageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pageSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pageSize = _PageSize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pageMask",
              "documentation": {
                "identifier": "pageMask",
                "newPage": false,
                "searchKey": "runtime.pageMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pageMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pageMask = _PageMask\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxObjsPerSpan",
              "documentation": {
                "identifier": "maxObjsPerSpan",
                "newPage": false,
                "searchKey": "runtime.maxObjsPerSpan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxObjsPerSpan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxObjsPerSpan = pageSize / 8\n```\n\nBy construction, single page spans of the smallest object class have the most objects per span. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#concurrentSweep",
              "documentation": {
                "identifier": "concurrentSweep",
                "newPage": false,
                "searchKey": "runtime.concurrentSweep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const concurrentSweep"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst concurrentSweep = _ConcurrentSweep\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PageSize",
              "documentation": {
                "identifier": "_PageSize",
                "newPage": false,
                "searchKey": "runtime._PageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PageSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PageSize = 1 << _PageShift\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PageMask",
              "documentation": {
                "identifier": "_PageMask",
                "newPage": false,
                "searchKey": "runtime._PageMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PageMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PageMask = _PageSize - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_64bit",
              "documentation": {
                "identifier": "_64bit",
                "newPage": false,
                "searchKey": "runtime._64bit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _64bit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _64bit = 1 << (^uintptr(0) >> 63) / 2\n```\n\n_64bit = 1 on 64-bit systems, 0 on 32-bit systems \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_TinySize",
              "documentation": {
                "identifier": "_TinySize",
                "newPage": false,
                "searchKey": "runtime._TinySize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _TinySize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _TinySize = 16\n```\n\nTiny allocator parameters, see \"Tiny allocator\" comment in malloc.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_TinySizeClass",
              "documentation": {
                "identifier": "_TinySizeClass",
                "newPage": false,
                "searchKey": "runtime._TinySizeClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _TinySizeClass"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _TinySizeClass = int8(2)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FixAllocChunk",
              "documentation": {
                "identifier": "_FixAllocChunk",
                "newPage": false,
                "searchKey": "runtime._FixAllocChunk",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FixAllocChunk"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FixAllocChunk = 16 << 10 // Chunk size for FixAlloc\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_StackCacheSize",
              "documentation": {
                "identifier": "_StackCacheSize",
                "newPage": false,
                "searchKey": "runtime._StackCacheSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _StackCacheSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _StackCacheSize = 32 * 1024\n```\n\nPer-P, per order stack segment cache size. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_NumStackOrders",
              "documentation": {
                "identifier": "_NumStackOrders",
                "newPage": false,
                "searchKey": "runtime._NumStackOrders",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _NumStackOrders"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _NumStackOrders = 4 - sys.PtrSize/4*sys.GoosWindows - 1*sys.GoosPlan9\n```\n\nNumber of orders that get caching. Order 0 is FixedStack and each successive order is twice as large. We want to cache 2KB, 4KB, 8KB, and 16KB stacks. Larger stacks will be allocated directly. Since FixedStack is different on different systems, we must vary NumStackOrders to keep the same maximum cached size. \n\n```\nOS               | FixedStack | NumStackOrders\n-----------------+------------+---------------\nlinux/darwin/bsd | 2KB        | 4\nwindows/32       | 4KB        | 3\nwindows/64       | 8KB        | 2\nplan9            | 4KB        | 3\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapAddrBits",
              "documentation": {
                "identifier": "heapAddrBits",
                "newPage": false,
                "searchKey": "runtime.heapAddrBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const heapAddrBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst heapAddrBits = ...\n```\n\nheapAddrBits is the number of bits in a heap address. On amd64, addresses are sign-extended beyond heapAddrBits. On other arches, they are zero-extended. \n\nOn most 64-bit platforms, we limit this to 48 bits based on a combination of hardware and OS limitations. \n\namd64 hardware limits addresses to 48 bits, sign-extended to 64 bits. Addresses where the top 16 bits are not either all 0 or all 1 are \"non-canonical\" and invalid. Because of these \"negative\" addresses, we offset addresses by 1<<47 (arenaBaseOffset) on amd64 before computing indexes into the heap arenas index. In 2017, amd64 hardware added support for 57 bit addresses; however, currently only Linux supports this extension and the kernel will never choose an address above 1<<47 unless mmap is called with a hint address above 1<<47 (which we never do). \n\narm64 hardware (as of ARMv8) limits user addresses to 48 bits, in the range [0, 1<<48). \n\nppc64, mips64, and s390x support arbitrary 64 bit addresses in hardware. On Linux, Go leans on stricter OS limits. Based on Linux's processor.h, the user address space is limited as follows on 64-bit architectures: \n\nArchitecture  Name              Maximum Value (exclusive) --------------------------------------------------------------------- amd64         TASK_SIZE_MAX     0x007ffffffff000 (47 bit addresses) arm64         TASK_SIZE_64      0x01000000000000 (48 bit addresses) ppc64{,le}    TASK_SIZE_USER64  0x00400000000000 (46 bit addresses) mips64{,le}   TASK_SIZE64       0x00010000000000 (40 bit addresses) s390x         TASK_SIZE         1<<64 (64 bit addresses) \n\nThese limits may increase over time, but are currently at most 48 bits except on s390x. On all architectures, Linux starts placing mmap'd regions at addresses that are significantly below 48 bits, so even if it's possible to exceed Go's 48 bit limit, it's extremely unlikely in practice. \n\nOn 32-bit platforms, we accept the full 32-bit address space because doing so is cheap. mips32 only has access to the low 2GB of virtual memory, so we further limit it to 31 bits. \n\nOn ios/arm64, although 64-bit pointers are presumably available, pointers are truncated to 33 bits. Furthermore, only the top 4 GiB of the address space are actually available to the application, but we allow the whole 33 bits anyway for simplicity. TODO(mknyszek): Consider limiting it to 32 bits and using arenaBaseOffset to offset into the top 4 GiB. \n\nWebAssembly currently has a limit of 4GB linear memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxAlloc",
              "documentation": {
                "identifier": "maxAlloc",
                "newPage": false,
                "searchKey": "runtime.maxAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxAlloc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxAlloc = (1 << heapAddrBits) - (1-_64bit)*1\n```\n\nmaxAlloc is the maximum size of an allocation. On 64-bit, it's theoretically possible to allocate 1<<heapAddrBits bytes. On 32-bit, however, this is one less than 1<<32 because the number of bytes in the address space doesn't actually fit in a uintptr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapArenaBytes",
              "documentation": {
                "identifier": "heapArenaBytes",
                "newPage": false,
                "searchKey": "runtime.heapArenaBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const heapArenaBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst heapArenaBytes = 1 << logHeapArenaBytes\n```\n\nheapArenaBytes is the size of a heap arena. The heap consists of mappings of size heapArenaBytes, aligned to heapArenaBytes. The initial heap mapping is one arena. \n\nThis is currently 64MB on 64-bit non-Windows and 4MB on 32-bit and on Windows. We use smaller arenas on Windows because all committed memory is charged to the process, even if it's not touched. Hence, for processes with small heaps, the mapped arena space needs to be commensurate. This is particularly important with the race detector, since it significantly amplifies the cost of committed memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#logHeapArenaBytes",
              "documentation": {
                "identifier": "logHeapArenaBytes",
                "newPage": false,
                "searchKey": "runtime.logHeapArenaBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const logHeapArenaBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst logHeapArenaBytes = ...\n```\n\nlogHeapArenaBytes is log_2 of heapArenaBytes. For clarity, prefer using heapArenaBytes where possible (we need the constant to compute some other constants). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapArenaBitmapBytes",
              "documentation": {
                "identifier": "heapArenaBitmapBytes",
                "newPage": false,
                "searchKey": "runtime.heapArenaBitmapBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const heapArenaBitmapBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst heapArenaBitmapBytes = heapArenaBytes / (sys.PtrSize * 8 / 2)\n```\n\nheapArenaBitmapBytes is the size of each heap arena's bitmap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pagesPerArena",
              "documentation": {
                "identifier": "pagesPerArena",
                "newPage": false,
                "searchKey": "runtime.pagesPerArena",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pagesPerArena"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pagesPerArena = heapArenaBytes / pageSize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#arenaL1Bits",
              "documentation": {
                "identifier": "arenaL1Bits",
                "newPage": false,
                "searchKey": "runtime.arenaL1Bits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const arenaL1Bits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst arenaL1Bits = 6 * (_64bit * sys.GoosWindows)\n```\n\narenaL1Bits is the number of bits of the arena number covered by the first level arena map. \n\nThis number should be small, since the first level arena map requires PtrSize*(1<<arenaL1Bits) of space in the binary's BSS. It can be zero, in which case the first level index is effectively unused. There is a performance benefit to this, since the generated code can be more efficient, but comes at the cost of having a large L2 mapping. \n\nWe use the L1 map on 64-bit Windows because the arena size is small, but the address space is still 48 bits, and there's a high cost to having a large L2. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#arenaL2Bits",
              "documentation": {
                "identifier": "arenaL2Bits",
                "newPage": false,
                "searchKey": "runtime.arenaL2Bits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const arenaL2Bits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst arenaL2Bits = heapAddrBits - logHeapArenaBytes - arenaL1Bits\n```\n\narenaL2Bits is the number of bits of the arena number covered by the second level arena index. \n\nThe size of each arena map allocation is proportional to 1<<arenaL2Bits, so it's important that this not be too large. 48 bits leads to 32MB arena index allocations, which is about the practical threshold. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#arenaL1Shift",
              "documentation": {
                "identifier": "arenaL1Shift",
                "newPage": false,
                "searchKey": "runtime.arenaL1Shift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const arenaL1Shift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst arenaL1Shift = arenaL2Bits\n```\n\narenaL1Shift is the number of bits to shift an arena frame number by to compute an index into the first level arena map. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#arenaBits",
              "documentation": {
                "identifier": "arenaBits",
                "newPage": false,
                "searchKey": "runtime.arenaBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const arenaBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst arenaBits = arenaL1Bits + arenaL2Bits\n```\n\narenaBits is the total bits in a combined arena map index. This is split between the index into the L1 arena map and the L2 arena map. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#arenaBaseOffset",
              "documentation": {
                "identifier": "arenaBaseOffset",
                "newPage": false,
                "searchKey": "runtime.arenaBaseOffset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const arenaBaseOffset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst arenaBaseOffset = 0xffff800000000000*sys.GoarchAmd64 + 0x0a00000000000000*sys.GoosAix\n```\n\narenaBaseOffset is the pointer value that corresponds to index 0 in the heap arena map. \n\nOn amd64, the address space is 48 bits, sign extended to 64 bits. This offset lets us handle \"negative\" addresses (or high addresses if viewed as unsigned). \n\nOn aix/ppc64, this offset allows to keep the heapAddrBits to 48. Otherwise, it would be 60 in order to handle mmap addresses (in range 0x0a00000000000000 - 0x0afffffffffffff). But in this case, the memory reserved in (s *pageAlloc).init for chunks is causing important slowdowns. \n\nOn other platforms, the user address space is contiguous and starts at 0, so no offset is necessary. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#arenaBaseOffsetUintptr",
              "documentation": {
                "identifier": "arenaBaseOffsetUintptr",
                "newPage": false,
                "searchKey": "runtime.arenaBaseOffsetUintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const arenaBaseOffsetUintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst arenaBaseOffsetUintptr = uintptr(arenaBaseOffset)\n```\n\nA typed version of this constant that will make it into DWARF (for viewcore). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_MaxGcproc",
              "documentation": {
                "identifier": "_MaxGcproc",
                "newPage": false,
                "searchKey": "runtime._MaxGcproc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MaxGcproc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MaxGcproc = 32\n```\n\nMax number of threads to run garbage collection. 2, 3, and 4 are all plausible maximums depending on the hardware details of the machine. The garbage collector scales well to 32 cpus. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minLegalPointer",
              "documentation": {
                "identifier": "minLegalPointer",
                "newPage": false,
                "searchKey": "runtime.minLegalPointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const minLegalPointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst minLegalPointer uintptr = 4096\n```\n\nminLegalPointer is the smallest possible legal pointer. This is the smallest possible architectural page size, since we assume that the first page is never mapped. \n\nThis should agree with minZeroPage in the compiler. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#persistentChunkSize",
              "documentation": {
                "identifier": "persistentChunkSize",
                "newPage": false,
                "searchKey": "runtime.persistentChunkSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const persistentChunkSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst persistentChunkSize = 256 << 10\n```\n\npersistentChunkSize is the number of bytes we allocate when we grow a persistentAlloc. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bucketCntBits",
              "documentation": {
                "identifier": "bucketCntBits",
                "newPage": false,
                "searchKey": "runtime.bucketCntBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bucketCntBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bucketCntBits = 3\n```\n\nMaximum number of key/elem pairs a bucket can hold. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bucketCnt",
              "documentation": {
                "identifier": "bucketCnt",
                "newPage": false,
                "searchKey": "runtime.bucketCnt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bucketCnt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bucketCnt = 1 << bucketCntBits\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#loadFactorNum",
              "documentation": {
                "identifier": "loadFactorNum",
                "newPage": false,
                "searchKey": "runtime.loadFactorNum",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const loadFactorNum"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst loadFactorNum = 13\n```\n\nMaximum average load of a bucket that triggers growth is 6.5. Represent as loadFactorNum/loadFactorDen, to allow integer math. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#loadFactorDen",
              "documentation": {
                "identifier": "loadFactorDen",
                "newPage": false,
                "searchKey": "runtime.loadFactorDen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const loadFactorDen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst loadFactorDen = 2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxKeySize",
              "documentation": {
                "identifier": "maxKeySize",
                "newPage": false,
                "searchKey": "runtime.maxKeySize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxKeySize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxKeySize = 128\n```\n\nMaximum key or elem size to keep inline (instead of mallocing per element). Must fit in a uint8. Fast versions cannot handle big elems - the cutoff size for fast versions in cmd/compile/internal/gc/walk.go must be at most this elem. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxElemSize",
              "documentation": {
                "identifier": "maxElemSize",
                "newPage": false,
                "searchKey": "runtime.maxElemSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxElemSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxElemSize = 128\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dataOffset",
              "documentation": {
                "identifier": "dataOffset",
                "newPage": false,
                "searchKey": "runtime.dataOffset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const dataOffset"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst dataOffset = unsafe.Offsetof(struct {\n\tb bmap\n\tv int64\n}{}.v)\n```\n\ndata offset should be the size of the bmap struct, but needs to be aligned correctly. For amd64p32 this means 64-bit alignment even though pointers are 32 bit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#emptyRest",
              "documentation": {
                "identifier": "emptyRest",
                "newPage": false,
                "searchKey": "runtime.emptyRest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const emptyRest"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst emptyRest // this cell is empty, and there are no more non-empty cells at higher indexes or overflows.\n = ...\n```\n\nPossible tophash values. We reserve a few possibilities for special marks. Each bucket (including its overflow buckets, if any) will have either all or none of its entries in the evacuated* states (except during the evacuate() method, which only happens during map writes and thus no one else can observe the map during that time). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#emptyOne",
              "documentation": {
                "identifier": "emptyOne",
                "newPage": false,
                "searchKey": "runtime.emptyOne",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const emptyOne"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst emptyOne = 1 // this cell is empty\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#evacuatedX",
              "documentation": {
                "identifier": "evacuatedX",
                "newPage": false,
                "searchKey": "runtime.evacuatedX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const evacuatedX"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst evacuatedX = 2 // key/elem is valid.  Entry has been evacuated to first half of larger table.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#evacuatedY",
              "documentation": {
                "identifier": "evacuatedY",
                "newPage": false,
                "searchKey": "runtime.evacuatedY",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const evacuatedY"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst evacuatedY = 3 // same as above, but evacuated to second half of larger table.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#evacuatedEmpty",
              "documentation": {
                "identifier": "evacuatedEmpty",
                "newPage": false,
                "searchKey": "runtime.evacuatedEmpty",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const evacuatedEmpty"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst evacuatedEmpty = 4 // cell is empty, bucket is evacuated.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minTopHash",
              "documentation": {
                "identifier": "minTopHash",
                "newPage": false,
                "searchKey": "runtime.minTopHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const minTopHash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst minTopHash = 5 // minimum tophash for a normal filled cell.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#iterator",
              "documentation": {
                "identifier": "iterator",
                "newPage": false,
                "searchKey": "runtime.iterator",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const iterator"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst iterator = 1 // there may be an iterator using buckets\n\n```\n\nflags \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#oldIterator",
              "documentation": {
                "identifier": "oldIterator",
                "newPage": false,
                "searchKey": "runtime.oldIterator",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const oldIterator"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst oldIterator = 2 // there may be an iterator using oldbuckets\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hashWriting",
              "documentation": {
                "identifier": "hashWriting",
                "newPage": false,
                "searchKey": "runtime.hashWriting",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hashWriting"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hashWriting = 4 // a goroutine is writing to the map\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sameSizeGrow",
              "documentation": {
                "identifier": "sameSizeGrow",
                "newPage": false,
                "searchKey": "runtime.sameSizeGrow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sameSizeGrow"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sameSizeGrow = 8 // the current map growth is to a new map of the same size\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#noCheck",
              "documentation": {
                "identifier": "noCheck",
                "newPage": false,
                "searchKey": "runtime.noCheck",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const noCheck"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst noCheck = 1<<(8*sys.PtrSize) - 1\n```\n\nsentinel bucket ID for iterator checks \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxZero",
              "documentation": {
                "identifier": "maxZero",
                "newPage": false,
                "searchKey": "runtime.maxZero",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxZero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxZero // must match value in reflect/value.go:maxZero cmd/compile/internal/gc/walk.go:zeroValSize\n = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bitPointer",
              "documentation": {
                "identifier": "bitPointer",
                "newPage": false,
                "searchKey": "runtime.bitPointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bitPointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bitPointer = 1 << 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bitScan",
              "documentation": {
                "identifier": "bitScan",
                "newPage": false,
                "searchKey": "runtime.bitScan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bitScan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bitScan = 1 << 4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapBitsShift",
              "documentation": {
                "identifier": "heapBitsShift",
                "newPage": false,
                "searchKey": "runtime.heapBitsShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const heapBitsShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst heapBitsShift = 1 // shift offset between successive bitPointer or bitScan entries\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#wordsPerBitmapByte",
              "documentation": {
                "identifier": "wordsPerBitmapByte",
                "newPage": false,
                "searchKey": "runtime.wordsPerBitmapByte",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const wordsPerBitmapByte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst wordsPerBitmapByte = 8 / 2 // heap words described by one bitmap byte\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bitScanAll",
              "documentation": {
                "identifier": "bitScanAll",
                "newPage": false,
                "searchKey": "runtime.bitScanAll",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bitScanAll"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bitScanAll = ...\n```\n\nall scan/pointer bits in a byte \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bitPointerAll",
              "documentation": {
                "identifier": "bitPointerAll",
                "newPage": false,
                "searchKey": "runtime.bitPointerAll",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bitPointerAll"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bitPointerAll = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#clobberdeadPtr",
              "documentation": {
                "identifier": "clobberdeadPtr",
                "newPage": false,
                "searchKey": "runtime.clobberdeadPtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const clobberdeadPtr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst clobberdeadPtr = uintptr(0xdeaddead | 0xdeaddead<<((^uintptr(0)>>63)*32))\n```\n\nclobberdeadPtr is a special value that is used by the compiler to clobber dead stack slots, when -clobberdead flag is set. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_ENOMEM",
              "documentation": {
                "identifier": "_ENOMEM",
                "newPage": false,
                "searchKey": "runtime._ENOMEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _ENOMEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _ENOMEM = 12\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapStatsDep",
              "documentation": {
                "identifier": "heapStatsDep",
                "newPage": false,
                "searchKey": "runtime.heapStatsDep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const heapStatsDep"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst heapStatsDep statDep = iota // corresponds to heapStatsAggregate\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysStatsDep",
              "documentation": {
                "identifier": "sysStatsDep",
                "newPage": false,
                "searchKey": "runtime.sysStatsDep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sysStatsDep"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sysStatsDep // corresponds to sysStatsAggregate\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#numStatsDeps",
              "documentation": {
                "identifier": "numStatsDeps",
                "newPage": false,
                "searchKey": "runtime.numStatsDeps",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const numStatsDeps"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst numStatsDeps\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metricKindBad",
              "documentation": {
                "identifier": "metricKindBad",
                "newPage": false,
                "searchKey": "runtime.metricKindBad",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const metricKindBad"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst metricKindBad metricKind = iota\n```\n\nThese values must be kept identical to their corresponding Kind* values in the runtime/metrics package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metricKindUint64",
              "documentation": {
                "identifier": "metricKindUint64",
                "newPage": false,
                "searchKey": "runtime.metricKindUint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const metricKindUint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst metricKindUint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metricKindFloat64",
              "documentation": {
                "identifier": "metricKindFloat64",
                "newPage": false,
                "searchKey": "runtime.metricKindFloat64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const metricKindFloat64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst metricKindFloat64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metricKindFloat64Histogram",
              "documentation": {
                "identifier": "metricKindFloat64Histogram",
                "newPage": false,
                "searchKey": "runtime.metricKindFloat64Histogram",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const metricKindFloat64Histogram"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst metricKindFloat64Histogram\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_DebugGC",
              "documentation": {
                "identifier": "_DebugGC",
                "newPage": false,
                "searchKey": "runtime._DebugGC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _DebugGC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _DebugGC = 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_ConcurrentSweep",
              "documentation": {
                "identifier": "_ConcurrentSweep",
                "newPage": false,
                "searchKey": "runtime._ConcurrentSweep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _ConcurrentSweep"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _ConcurrentSweep = true\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FinBlockSize",
              "documentation": {
                "identifier": "_FinBlockSize",
                "newPage": false,
                "searchKey": "runtime._FinBlockSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FinBlockSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FinBlockSize = 4 * 1024\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugScanConservative",
              "documentation": {
                "identifier": "debugScanConservative",
                "newPage": false,
                "searchKey": "runtime.debugScanConservative",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugScanConservative"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugScanConservative = false\n```\n\ndebugScanConservative enables debug logging for stack frames that are scanned conservatively. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sweepMinHeapDistance",
              "documentation": {
                "identifier": "sweepMinHeapDistance",
                "newPage": false,
                "searchKey": "runtime.sweepMinHeapDistance",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sweepMinHeapDistance"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sweepMinHeapDistance = 1024 * 1024\n```\n\nsweepMinHeapDistance is a lower bound on the heap distance (in bytes) reserved for concurrent sweeping between GC cycles. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_GCoff",
              "documentation": {
                "identifier": "_GCoff",
                "newPage": false,
                "searchKey": "runtime._GCoff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _GCoff"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _GCoff = iota // GC not running; sweeping in background, write barrier disabled\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_GCmark",
              "documentation": {
                "identifier": "_GCmark",
                "newPage": false,
                "searchKey": "runtime._GCmark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _GCmark"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _GCmark // GC marking roots and workbufs: allocate black, write barrier ENABLED\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_GCmarktermination",
              "documentation": {
                "identifier": "_GCmarktermination",
                "newPage": false,
                "searchKey": "runtime._GCmarktermination",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _GCmarktermination"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _GCmarktermination // GC mark termination: allocate black, P's help GC, write barrier ENABLED\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkWorkerNotWorker",
              "documentation": {
                "identifier": "gcMarkWorkerNotWorker",
                "newPage": false,
                "searchKey": "runtime.gcMarkWorkerNotWorker",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcMarkWorkerNotWorker"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcMarkWorkerNotWorker gcMarkWorkerMode = iota\n```\n\ngcMarkWorkerNotWorker indicates that the next scheduled G is not starting work and the mode should be ignored. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkWorkerDedicatedMode",
              "documentation": {
                "identifier": "gcMarkWorkerDedicatedMode",
                "newPage": false,
                "searchKey": "runtime.gcMarkWorkerDedicatedMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcMarkWorkerDedicatedMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcMarkWorkerDedicatedMode\n```\n\ngcMarkWorkerDedicatedMode indicates that the P of a mark worker is dedicated to running that mark worker. The mark worker should run without preemption. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkWorkerFractionalMode",
              "documentation": {
                "identifier": "gcMarkWorkerFractionalMode",
                "newPage": false,
                "searchKey": "runtime.gcMarkWorkerFractionalMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcMarkWorkerFractionalMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcMarkWorkerFractionalMode\n```\n\ngcMarkWorkerFractionalMode indicates that a P is currently running the \"fractional\" mark worker. The fractional worker is necessary when GOMAXPROCS*gcBackgroundUtilization is not an integer and using only dedicated workers would result in utilization too far from the target of gcBackgroundUtilization. The fractional worker should run until it is preempted and will be scheduled to pick up the fractional part of GOMAXPROCS*gcBackgroundUtilization. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkWorkerIdleMode",
              "documentation": {
                "identifier": "gcMarkWorkerIdleMode",
                "newPage": false,
                "searchKey": "runtime.gcMarkWorkerIdleMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcMarkWorkerIdleMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcMarkWorkerIdleMode\n```\n\ngcMarkWorkerIdleMode indicates that a P is running the mark worker because it has nothing else to do. The idle worker should run until it is preempted and account its time against gcController.idleMarkTime. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBackgroundMode",
              "documentation": {
                "identifier": "gcBackgroundMode",
                "newPage": false,
                "searchKey": "runtime.gcBackgroundMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcBackgroundMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcBackgroundMode gcMode = iota // concurrent GC and sweep\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcForceMode",
              "documentation": {
                "identifier": "gcForceMode",
                "newPage": false,
                "searchKey": "runtime.gcForceMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcForceMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcForceMode // stop-the-world GC now, concurrent sweep\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcForceBlockMode",
              "documentation": {
                "identifier": "gcForceBlockMode",
                "newPage": false,
                "searchKey": "runtime.gcForceBlockMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcForceBlockMode"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcForceBlockMode // stop-the-world GC now and STW sweep (forced by user)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcTriggerHeap",
              "documentation": {
                "identifier": "gcTriggerHeap",
                "newPage": false,
                "searchKey": "runtime.gcTriggerHeap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcTriggerHeap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcTriggerHeap gcTriggerKind = iota\n```\n\ngcTriggerHeap indicates that a cycle should be started when the heap size reaches the trigger heap size computed by the controller. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcTriggerTime",
              "documentation": {
                "identifier": "gcTriggerTime",
                "newPage": false,
                "searchKey": "runtime.gcTriggerTime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcTriggerTime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcTriggerTime\n```\n\ngcTriggerTime indicates that a cycle should be started when it's been more than forcegcperiod nanoseconds since the previous GC cycle. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcTriggerCycle",
              "documentation": {
                "identifier": "gcTriggerCycle",
                "newPage": false,
                "searchKey": "runtime.gcTriggerCycle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcTriggerCycle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcTriggerCycle\n```\n\ngcTriggerCycle indicates that a cycle should be started if we have not yet started cycle number gcTrigger.n (relative to work.cycles). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fixedRootFinalizers",
              "documentation": {
                "identifier": "fixedRootFinalizers",
                "newPage": false,
                "searchKey": "runtime.fixedRootFinalizers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const fixedRootFinalizers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst fixedRootFinalizers = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fixedRootFreeGStacks",
              "documentation": {
                "identifier": "fixedRootFreeGStacks",
                "newPage": false,
                "searchKey": "runtime.fixedRootFreeGStacks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const fixedRootFreeGStacks"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst fixedRootFreeGStacks\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fixedRootCount",
              "documentation": {
                "identifier": "fixedRootCount",
                "newPage": false,
                "searchKey": "runtime.fixedRootCount",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const fixedRootCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst fixedRootCount\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#rootBlockBytes",
              "documentation": {
                "identifier": "rootBlockBytes",
                "newPage": false,
                "searchKey": "runtime.rootBlockBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const rootBlockBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst rootBlockBytes = 256 << 10\n```\n\nrootBlockBytes is the number of bytes to scan per data or BSS root. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxObletBytes",
              "documentation": {
                "identifier": "maxObletBytes",
                "newPage": false,
                "searchKey": "runtime.maxObletBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxObletBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxObletBytes = 128 << 10\n```\n\nmaxObletBytes is the maximum bytes of an object to scan at once. Larger objects will be split up into \"oblets\" of at most this size. Since we can scan 1–2 MB/ms, 128 KB bounds scan preemption at ~100 µs. \n\nThis must be > _MaxSmallSize so that the object base is the span base. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#drainCheckThreshold",
              "documentation": {
                "identifier": "drainCheckThreshold",
                "newPage": false,
                "searchKey": "runtime.drainCheckThreshold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const drainCheckThreshold"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst drainCheckThreshold = 100000\n```\n\ndrainCheckThreshold specifies how many units of work to do between self-preemption checks in gcDrain. Assuming a scan rate of 1 MB/ms, this is ~100 µs. Lower values have higher overhead in the scan loop (the scheduler check may perform a syscall, so its overhead is nontrivial). Higher values make the system less responsive to incoming work. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pagesPerSpanRoot",
              "documentation": {
                "identifier": "pagesPerSpanRoot",
                "newPage": false,
                "searchKey": "runtime.pagesPerSpanRoot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pagesPerSpanRoot"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pagesPerSpanRoot = 512\n```\n\npagesPerSpanRoot indicates how many pages to scan from a span root at a time. Used by special root marking. \n\nHigher values improve throughput by increasing locality, but increase the minimum latency of a marking operation. \n\nMust be a multiple of the pageInUse bitmap element size and must also evenly divide pagesPerArena. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcDrainUntilPreempt",
              "documentation": {
                "identifier": "gcDrainUntilPreempt",
                "newPage": false,
                "searchKey": "runtime.gcDrainUntilPreempt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcDrainUntilPreempt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcDrainUntilPreempt gcDrainFlags = 1 << iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcDrainFlushBgCredit",
              "documentation": {
                "identifier": "gcDrainFlushBgCredit",
                "newPage": false,
                "searchKey": "runtime.gcDrainFlushBgCredit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcDrainFlushBgCredit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcDrainFlushBgCredit\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcDrainIdle",
              "documentation": {
                "identifier": "gcDrainIdle",
                "newPage": false,
                "searchKey": "runtime.gcDrainIdle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcDrainIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcDrainIdle\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcDrainFractional",
              "documentation": {
                "identifier": "gcDrainFractional",
                "newPage": false,
                "searchKey": "runtime.gcDrainFractional",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcDrainFractional"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcDrainFractional\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcGoalUtilization",
              "documentation": {
                "identifier": "gcGoalUtilization",
                "newPage": false,
                "searchKey": "runtime.gcGoalUtilization",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcGoalUtilization"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcGoalUtilization = 0.30\n```\n\ngcGoalUtilization is the goal CPU utilization for marking as a fraction of GOMAXPROCS. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBackgroundUtilization",
              "documentation": {
                "identifier": "gcBackgroundUtilization",
                "newPage": false,
                "searchKey": "runtime.gcBackgroundUtilization",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcBackgroundUtilization"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcBackgroundUtilization = 0.25\n```\n\ngcBackgroundUtilization is the fixed CPU utilization for background marking. It must be <= gcGoalUtilization. The difference between gcGoalUtilization and gcBackgroundUtilization will be made up by mark assists. The scheduler will aim to use within 50% of this goal. \n\nSetting this to < gcGoalUtilization avoids saturating the trigger feedback controller when there are no assists, which allows it to better control CPU and heap growth. However, the larger the gap, the more mutator assists are expected to happen, which impact mutator latency. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcCreditSlack",
              "documentation": {
                "identifier": "gcCreditSlack",
                "newPage": false,
                "searchKey": "runtime.gcCreditSlack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcCreditSlack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcCreditSlack = 2000\n```\n\ngcCreditSlack is the amount of scan work credit that can accumulate locally before updating gcController.scanWork and, optionally, gcController.bgScanCredit. Lower values give a more accurate assist ratio and make it more likely that assists will successfully steal background credit. Higher values reduce memory contention. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcAssistTimeSlack",
              "documentation": {
                "identifier": "gcAssistTimeSlack",
                "newPage": false,
                "searchKey": "runtime.gcAssistTimeSlack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcAssistTimeSlack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcAssistTimeSlack = 5000\n```\n\ngcAssistTimeSlack is the nanoseconds of mutator assist time that can accumulate on a P before updating gcController.assistTime. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcOverAssistWork",
              "documentation": {
                "identifier": "gcOverAssistWork",
                "newPage": false,
                "searchKey": "runtime.gcOverAssistWork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcOverAssistWork"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcOverAssistWork = 64 << 10\n```\n\ngcOverAssistWork determines how many extra units of scan work a GC assist does when an assist happens. This amortizes the cost of an assist by pre-paying for this many bytes of future allocations. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#defaultHeapMinimum",
              "documentation": {
                "identifier": "defaultHeapMinimum",
                "newPage": false,
                "searchKey": "runtime.defaultHeapMinimum",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const defaultHeapMinimum"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst defaultHeapMinimum = 4 << 20\n```\n\ndefaultHeapMinimum is the value of heapMinimum for GOGC==100. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#scavengePercent",
              "documentation": {
                "identifier": "scavengePercent",
                "newPage": false,
                "searchKey": "runtime.scavengePercent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const scavengePercent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst scavengePercent = 1 // 1%\n\n```\n\nThe background scavenger is paced according to these parameters. \n\nscavengePercent represents the portion of mutator time we're willing to spend on scavenging in percent. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retainExtraPercent",
              "documentation": {
                "identifier": "retainExtraPercent",
                "newPage": false,
                "searchKey": "runtime.retainExtraPercent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const retainExtraPercent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst retainExtraPercent = 10\n```\n\nretainExtraPercent represents the amount of memory over the heap goal that the scavenger should keep as a buffer space for the allocator. \n\nThe purpose of maintaining this overhead is to have a greater pool of unscavenged memory available for allocation (since using scavenged memory incurs an additional cost), to account for heap fragmentation and the ever-changing layout of the heap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxPagesPerPhysPage",
              "documentation": {
                "identifier": "maxPagesPerPhysPage",
                "newPage": false,
                "searchKey": "runtime.maxPagesPerPhysPage",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxPagesPerPhysPage"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxPagesPerPhysPage = maxPhysPageSize / pageSize\n```\n\nmaxPagesPerPhysPage is the maximum number of supported runtime pages per physical page, based on maxPhysPageSize. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#scavengeCostRatio",
              "documentation": {
                "identifier": "scavengeCostRatio",
                "newPage": false,
                "searchKey": "runtime.scavengeCostRatio",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const scavengeCostRatio"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst scavengeCostRatio = 0.7 * (sys.GoosDarwin + sys.GoosIos)\n```\n\nscavengeCostRatio is the approximate ratio between the costs of using previously scavenged memory and scavenging memory. \n\nFor most systems the cost of scavenging greatly outweighs the costs associated with using scavenged memory, making this constant 0. On other systems (especially ones where \"sysUsed\" is not just a no-op) this cost is non-trivial. \n\nThis ratio is used as part of multiplicative factor to help the scavenger account for the additional costs of using scavenged memory in its pacing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#scavengeReservationShards",
              "documentation": {
                "identifier": "scavengeReservationShards",
                "newPage": false,
                "searchKey": "runtime.scavengeReservationShards",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const scavengeReservationShards"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst scavengeReservationShards = 64\n```\n\nscavengeReservationShards determines the amount of memory the scavenger should reserve for scavenging at a time. Specifically, the amount of memory reserved is (heap size in bytes) / scavengeReservationShards. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackTraceDebug",
              "documentation": {
                "identifier": "stackTraceDebug",
                "newPage": false,
                "searchKey": "runtime.stackTraceDebug",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stackTraceDebug"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stackTraceDebug = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#numSweepClasses",
              "documentation": {
                "identifier": "numSweepClasses",
                "newPage": false,
                "searchKey": "runtime.numSweepClasses",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const numSweepClasses"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst numSweepClasses = numSpanClasses * 2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sweepClassDone",
              "documentation": {
                "identifier": "sweepClassDone",
                "newPage": false,
                "searchKey": "runtime.sweepClassDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sweepClassDone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sweepClassDone sweepClass = sweepClass(^uint32(0))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_WorkbufSize",
              "documentation": {
                "identifier": "_WorkbufSize",
                "newPage": false,
                "searchKey": "runtime._WorkbufSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _WorkbufSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _WorkbufSize = 2048 // in bytes; larger values result in less contention\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#workbufAlloc",
              "documentation": {
                "identifier": "workbufAlloc",
                "newPage": false,
                "searchKey": "runtime.workbufAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const workbufAlloc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst workbufAlloc = 32 << 10\n```\n\nworkbufAlloc is the number of bytes to allocate at a time for new workbufs. This must be a multiple of pageSize and should be a multiple of _WorkbufSize. \n\nLarger values reduce workbuf allocation overhead. Smaller values reduce heap fragmentation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minPhysPageSize",
              "documentation": {
                "identifier": "minPhysPageSize",
                "newPage": false,
                "searchKey": "runtime.minPhysPageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const minPhysPageSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst minPhysPageSize = 4096\n```\n\nminPhysPageSize is a lower-bound on the physical page size. The true physical page size may be larger than this. In contrast, sys.PhysPageSize is an upper-bound on the physical page size. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxPhysPageSize",
              "documentation": {
                "identifier": "maxPhysPageSize",
                "newPage": false,
                "searchKey": "runtime.maxPhysPageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxPhysPageSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxPhysPageSize = 512 << 10\n```\n\nmaxPhysPageSize is the maximum page size the runtime supports. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxPhysHugePageSize",
              "documentation": {
                "identifier": "maxPhysHugePageSize",
                "newPage": false,
                "searchKey": "runtime.maxPhysHugePageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxPhysHugePageSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxPhysHugePageSize = pallocChunkBytes\n```\n\nmaxPhysHugePageSize sets an upper-bound on the maximum huge page size that the runtime supports. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pagesPerReclaimerChunk",
              "documentation": {
                "identifier": "pagesPerReclaimerChunk",
                "newPage": false,
                "searchKey": "runtime.pagesPerReclaimerChunk",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pagesPerReclaimerChunk"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pagesPerReclaimerChunk = 512\n```\n\npagesPerReclaimerChunk indicates how many pages to scan from the pageInUse bitmap at a time. Used by the page reclaimer. \n\nHigher values reduce contention on scanning indexes (such as h.reclaimIndex), but increase the minimum latency of the operation. \n\nThe time required to scan this many pages can vary a lot depending on how many spans are actually freed. Experimentally, it can scan for pages at ~300 GB/ms on a 2.6GHz Core i7, but can only free spans at ~32 MB/ms. Using 512 pages bounds this at roughly 100µs. \n\nMust be a multiple of the pageInUse bitmap element size and must also evenly divide pagesPerArena. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#physPageAlignedStacks",
              "documentation": {
                "identifier": "physPageAlignedStacks",
                "newPage": false,
                "searchKey": "runtime.physPageAlignedStacks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const physPageAlignedStacks"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst physPageAlignedStacks = GOOS == \"openbsd\"\n```\n\nphysPageAlignedStacks indicates whether stack allocations must be physical page aligned. This is a requirement for MAP_STACK on OpenBSD. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mSpanDead",
              "documentation": {
                "identifier": "mSpanDead",
                "newPage": false,
                "searchKey": "runtime.mSpanDead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mSpanDead"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mSpanDead mSpanState = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mSpanInUse",
              "documentation": {
                "identifier": "mSpanInUse",
                "newPage": false,
                "searchKey": "runtime.mSpanInUse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mSpanInUse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mSpanInUse // allocated for garbage collected heap\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mSpanManual",
              "documentation": {
                "identifier": "mSpanManual",
                "newPage": false,
                "searchKey": "runtime.mSpanManual",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mSpanManual"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mSpanManual // allocated for manual management (e.g., stack allocator)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#numSpanClasses",
              "documentation": {
                "identifier": "numSpanClasses",
                "newPage": false,
                "searchKey": "runtime.numSpanClasses",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const numSpanClasses"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst numSpanClasses = _NumSizeClasses << 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tinySpanClass",
              "documentation": {
                "identifier": "tinySpanClass",
                "newPage": false,
                "searchKey": "runtime.tinySpanClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tinySpanClass"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tinySpanClass = spanClass(tinySizeClass<<1 | 1)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanAllocHeap",
              "documentation": {
                "identifier": "spanAllocHeap",
                "newPage": false,
                "searchKey": "runtime.spanAllocHeap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const spanAllocHeap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst spanAllocHeap spanAllocType = iota // heap span\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanAllocStack",
              "documentation": {
                "identifier": "spanAllocStack",
                "newPage": false,
                "searchKey": "runtime.spanAllocStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const spanAllocStack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst spanAllocStack // stack span\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanAllocPtrScalarBits",
              "documentation": {
                "identifier": "spanAllocPtrScalarBits",
                "newPage": false,
                "searchKey": "runtime.spanAllocPtrScalarBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const spanAllocPtrScalarBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst spanAllocPtrScalarBits // unrolled GC prog bitmap span\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanAllocWorkBuf",
              "documentation": {
                "identifier": "spanAllocWorkBuf",
                "newPage": false,
                "searchKey": "runtime.spanAllocWorkBuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const spanAllocWorkBuf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst spanAllocWorkBuf // work buf span\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_KindSpecialFinalizer",
              "documentation": {
                "identifier": "_KindSpecialFinalizer",
                "newPage": false,
                "searchKey": "runtime._KindSpecialFinalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _KindSpecialFinalizer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _KindSpecialFinalizer = 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_KindSpecialProfile",
              "documentation": {
                "identifier": "_KindSpecialProfile",
                "newPage": false,
                "searchKey": "runtime._KindSpecialProfile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _KindSpecialProfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _KindSpecialProfile = 2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_KindSpecialReachable",
              "documentation": {
                "identifier": "_KindSpecialReachable",
                "newPage": false,
                "searchKey": "runtime._KindSpecialReachable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _KindSpecialReachable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _KindSpecialReachable = 3\n```\n\n_KindSpecialReachable is a special used for tracking reachability during testing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBitsChunkBytes",
              "documentation": {
                "identifier": "gcBitsChunkBytes",
                "newPage": false,
                "searchKey": "runtime.gcBitsChunkBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcBitsChunkBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcBitsChunkBytes = uintptr(64 << 10)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBitsHeaderBytes",
              "documentation": {
                "identifier": "gcBitsHeaderBytes",
                "newPage": false,
                "searchKey": "runtime.gcBitsHeaderBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gcBitsHeaderBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gcBitsHeaderBytes = unsafe.Sizeof(gcBitsHeader{})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pallocChunkPages",
              "documentation": {
                "identifier": "pallocChunkPages",
                "newPage": false,
                "searchKey": "runtime.pallocChunkPages",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pallocChunkPages"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pallocChunkPages = 1 << logPallocChunkPages\n```\n\nThe size of a bitmap chunk, i.e. the amount of bits (that is, pages) to consider in the bitmap at once. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pallocChunkBytes",
              "documentation": {
                "identifier": "pallocChunkBytes",
                "newPage": false,
                "searchKey": "runtime.pallocChunkBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pallocChunkBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pallocChunkBytes = pallocChunkPages * pageSize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#logPallocChunkPages",
              "documentation": {
                "identifier": "logPallocChunkPages",
                "newPage": false,
                "searchKey": "runtime.logPallocChunkPages",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const logPallocChunkPages"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst logPallocChunkPages = 9\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#logPallocChunkBytes",
              "documentation": {
                "identifier": "logPallocChunkBytes",
                "newPage": false,
                "searchKey": "runtime.logPallocChunkBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const logPallocChunkBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst logPallocChunkBytes = logPallocChunkPages + pageShift\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#summaryLevelBits",
              "documentation": {
                "identifier": "summaryLevelBits",
                "newPage": false,
                "searchKey": "runtime.summaryLevelBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const summaryLevelBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst summaryLevelBits = 3\n```\n\nThe number of radix bits for each level. \n\nThe value of 3 is chosen such that the block of summaries we need to scan at each level fits in 64 bytes (2^3 summaries * 8 bytes per summary), which is close to the L1 cache line width on many systems. Also, a value of 3 fits 4 tree levels perfectly into the 21-bit pallocBits summary field at the root level. \n\nThe following equation explains how each of the constants relate: summaryL0Bits + (summaryLevels-1)*summaryLevelBits + logPallocChunkBytes = heapAddrBits \n\nsummaryLevels is an architecture-dependent value defined in mpagealloc_*.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#summaryL0Bits",
              "documentation": {
                "identifier": "summaryL0Bits",
                "newPage": false,
                "searchKey": "runtime.summaryL0Bits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const summaryL0Bits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst summaryL0Bits = heapAddrBits - logPallocChunkBytes - (summaryLevels-1)*summaryLevelBits\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pallocChunksL2Bits",
              "documentation": {
                "identifier": "pallocChunksL2Bits",
                "newPage": false,
                "searchKey": "runtime.pallocChunksL2Bits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pallocChunksL2Bits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pallocChunksL2Bits = heapAddrBits - logPallocChunkBytes - pallocChunksL1Bits\n```\n\npallocChunksL2Bits is the number of bits of the chunk index number covered by the second level of the chunks map. \n\nSee (*pageAlloc).chunks for more details. Update the documentation there should this change. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pallocChunksL1Shift",
              "documentation": {
                "identifier": "pallocChunksL1Shift",
                "newPage": false,
                "searchKey": "runtime.pallocChunksL1Shift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pallocChunksL1Shift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pallocChunksL1Shift = pallocChunksL2Bits\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pallocSumBytes",
              "documentation": {
                "identifier": "pallocSumBytes",
                "newPage": false,
                "searchKey": "runtime.pallocSumBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pallocSumBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pallocSumBytes = unsafe.Sizeof(pallocSum(0))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxPackedValue",
              "documentation": {
                "identifier": "maxPackedValue",
                "newPage": false,
                "searchKey": "runtime.maxPackedValue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxPackedValue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxPackedValue = 1 << logMaxPackedValue\n```\n\nmaxPackedValue is the maximum value that any of the three fields in the pallocSum may take on. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#logMaxPackedValue",
              "documentation": {
                "identifier": "logMaxPackedValue",
                "newPage": false,
                "searchKey": "runtime.logMaxPackedValue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const logMaxPackedValue"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst logMaxPackedValue = logPallocChunkPages + (summaryLevels-1)*summaryLevelBits\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freeChunkSum",
              "documentation": {
                "identifier": "freeChunkSum",
                "newPage": false,
                "searchKey": "runtime.freeChunkSum",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const freeChunkSum"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst freeChunkSum = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#summaryLevels",
              "documentation": {
                "identifier": "summaryLevels",
                "newPage": false,
                "searchKey": "runtime.summaryLevels",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const summaryLevels"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst summaryLevels = 5\n```\n\nThe number of levels in the radix tree. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pageAlloc32Bit",
              "documentation": {
                "identifier": "pageAlloc32Bit",
                "newPage": false,
                "searchKey": "runtime.pageAlloc32Bit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pageAlloc32Bit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pageAlloc32Bit = 0\n```\n\nConstants for testing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pageAlloc64Bit",
              "documentation": {
                "identifier": "pageAlloc64Bit",
                "newPage": false,
                "searchKey": "runtime.pageAlloc64Bit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pageAlloc64Bit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pageAlloc64Bit = 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pallocChunksL1Bits",
              "documentation": {
                "identifier": "pallocChunksL1Bits",
                "newPage": false,
                "searchKey": "runtime.pallocChunksL1Bits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pallocChunksL1Bits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pallocChunksL1Bits = 13\n```\n\nNumber of bits needed to represent all indices into the L1 of the chunks map. \n\nSee (*pageAlloc).chunks for more details. Update the documentation there should this number change. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pageCachePages",
              "documentation": {
                "identifier": "pageCachePages",
                "newPage": false,
                "searchKey": "runtime.pageCachePages",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pageCachePages"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pageCachePages = 8 * unsafe.Sizeof(pageCache{}.cache)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memProfile",
              "documentation": {
                "identifier": "memProfile",
                "newPage": false,
                "searchKey": "runtime.memProfile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const memProfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst memProfile bucketType = 1 + iota\n```\n\nprofile types \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#blockProfile",
              "documentation": {
                "identifier": "blockProfile",
                "newPage": false,
                "searchKey": "runtime.blockProfile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const blockProfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst blockProfile\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mutexProfile",
              "documentation": {
                "identifier": "mutexProfile",
                "newPage": false,
                "searchKey": "runtime.mutexProfile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mutexProfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mutexProfile\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#buckHashSize",
              "documentation": {
                "identifier": "buckHashSize",
                "newPage": false,
                "searchKey": "runtime.buckHashSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const buckHashSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst buckHashSize = 179999\n```\n\nsize of bucket hash table \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxStack",
              "documentation": {
                "identifier": "maxStack",
                "newPage": false,
                "searchKey": "runtime.maxStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxStack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxStack = 32\n```\n\nmax depth of stack to record in bucket \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mProfCycleWrap",
              "documentation": {
                "identifier": "mProfCycleWrap",
                "newPage": false,
                "searchKey": "runtime.mProfCycleWrap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mProfCycleWrap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mProfCycleWrap = uint32(len(memRecord{}.future)) * (2 << 24)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#msanenabled",
              "documentation": {
                "identifier": "msanenabled",
                "newPage": false,
                "searchKey": "runtime.msanenabled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const msanenabled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst msanenabled = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanSetBlockEntries",
              "documentation": {
                "identifier": "spanSetBlockEntries",
                "newPage": false,
                "searchKey": "runtime.spanSetBlockEntries",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const spanSetBlockEntries"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst spanSetBlockEntries = 512 // 4KB on 64-bit\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanSetInitSpineCap",
              "documentation": {
                "identifier": "spanSetInitSpineCap",
                "newPage": false,
                "searchKey": "runtime.spanSetInitSpineCap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const spanSetInitSpineCap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst spanSetInitSpineCap = 256 // Enough for 1GB heap on 64-bit\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#testSmallBuf",
              "documentation": {
                "identifier": "testSmallBuf",
                "newPage": false,
                "searchKey": "runtime.testSmallBuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const testSmallBuf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst testSmallBuf = false\n```\n\ntestSmallBuf forces a small write barrier buffer to stress write barrier flushing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#wbBufEntries",
              "documentation": {
                "identifier": "wbBufEntries",
                "newPage": false,
                "searchKey": "runtime.wbBufEntries",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const wbBufEntries"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst wbBufEntries = 256\n```\n\nwbBufEntries is the number of write barriers between flushes of the write barrier buffer. \n\nThis trades latency for throughput amortization. Higher values amortize flushing overhead more, but increase the latency of flushing. Higher values also increase the cache footprint of the buffer. \n\nTODO: What is the latency cost of this? Tune this value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#wbBufEntryPointers",
              "documentation": {
                "identifier": "wbBufEntryPointers",
                "newPage": false,
                "searchKey": "runtime.wbBufEntryPointers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const wbBufEntryPointers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst wbBufEntryPointers = 2\n```\n\nwbBufEntryPointers is the number of pointers added to the buffer by each write barrier. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pollNoError",
              "documentation": {
                "identifier": "pollNoError",
                "newPage": false,
                "searchKey": "runtime.pollNoError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pollNoError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pollNoError = 0 // no error\n\n```\n\nError codes returned by runtime_pollReset and runtime_pollWait. These must match the values in internal/poll/fd_poll_runtime.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pollErrClosing",
              "documentation": {
                "identifier": "pollErrClosing",
                "newPage": false,
                "searchKey": "runtime.pollErrClosing",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pollErrClosing"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pollErrClosing = 1 // descriptor is closed\n\n```\n\nError codes returned by runtime_pollReset and runtime_pollWait. These must match the values in internal/poll/fd_poll_runtime.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pollErrTimeout",
              "documentation": {
                "identifier": "pollErrTimeout",
                "newPage": false,
                "searchKey": "runtime.pollErrTimeout",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pollErrTimeout"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pollErrTimeout = 2 // I/O timeout\n\n```\n\nError codes returned by runtime_pollReset and runtime_pollWait. These must match the values in internal/poll/fd_poll_runtime.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pollErrNotPollable",
              "documentation": {
                "identifier": "pollErrNotPollable",
                "newPage": false,
                "searchKey": "runtime.pollErrNotPollable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pollErrNotPollable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pollErrNotPollable = 3 // general error polling descriptor\n\n```\n\nError codes returned by runtime_pollReset and runtime_pollWait. These must match the values in internal/poll/fd_poll_runtime.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pdReady",
              "documentation": {
                "identifier": "pdReady",
                "newPage": false,
                "searchKey": "runtime.pdReady",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pdReady"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pdReady uintptr = 1\n```\n\npollDesc contains 2 binary semaphores, rg and wg, to park reader and writer goroutines respectively. The semaphore can be in the following states: pdReady - io readiness notification is pending; \n\n```\na goroutine consumes the notification by changing the state to nil.\n\n```\npdWait - a goroutine prepares to park on the semaphore, but not yet parked; \n\n```\nthe goroutine commits to park by changing the state to G pointer,\nor, alternatively, concurrent io notification changes the state to pdReady,\nor, alternatively, concurrent timeout/close changes the state to nil.\n\n```\nG pointer - the goroutine is blocked on the semaphore; \n\n```\nio notification or timeout/close changes the state to pdReady or nil respectively\nand unparks the goroutine.\n\n```\nnil - none of the above. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pdWait",
              "documentation": {
                "identifier": "pdWait",
                "newPage": false,
                "searchKey": "runtime.pdWait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pdWait"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pdWait uintptr = 2\n```\n\npollDesc contains 2 binary semaphores, rg and wg, to park reader and writer goroutines respectively. The semaphore can be in the following states: pdReady - io readiness notification is pending; \n\n```\na goroutine consumes the notification by changing the state to nil.\n\n```\npdWait - a goroutine prepares to park on the semaphore, but not yet parked; \n\n```\nthe goroutine commits to park by changing the state to G pointer,\nor, alternatively, concurrent io notification changes the state to pdReady,\nor, alternatively, concurrent timeout/close changes the state to nil.\n\n```\nG pointer - the goroutine is blocked on the semaphore; \n\n```\nio notification or timeout/close changes the state to pdReady or nil respectively\nand unparks the goroutine.\n\n```\nnil - none of the above. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pollBlockSize",
              "documentation": {
                "identifier": "pollBlockSize",
                "newPage": false,
                "searchKey": "runtime.pollBlockSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pollBlockSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pollBlockSize = 4 * 1024\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_CTL_HW",
              "documentation": {
                "identifier": "_CTL_HW",
                "newPage": false,
                "searchKey": "runtime._CTL_HW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _CTL_HW"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _CTL_HW = 6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_HW_NCPU",
              "documentation": {
                "identifier": "_HW_NCPU",
                "newPage": false,
                "searchKey": "runtime._HW_NCPU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _HW_NCPU"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _HW_NCPU = 3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_HW_PAGESIZE",
              "documentation": {
                "identifier": "_HW_PAGESIZE",
                "newPage": false,
                "searchKey": "runtime._HW_PAGESIZE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _HW_PAGESIZE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _HW_PAGESIZE = 7\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_NSIG",
              "documentation": {
                "identifier": "_NSIG",
                "newPage": false,
                "searchKey": "runtime._NSIG",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _NSIG"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _NSIG = 32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SI_USER",
              "documentation": {
                "identifier": "_SI_USER",
                "newPage": false,
                "searchKey": "runtime._SI_USER",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SI_USER"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SI_USER = 0 /* empirically true, but not what headers say */\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIG_BLOCK",
              "documentation": {
                "identifier": "_SIG_BLOCK",
                "newPage": false,
                "searchKey": "runtime._SIG_BLOCK",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIG_BLOCK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIG_BLOCK = 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIG_UNBLOCK",
              "documentation": {
                "identifier": "_SIG_UNBLOCK",
                "newPage": false,
                "searchKey": "runtime._SIG_UNBLOCK",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIG_UNBLOCK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIG_UNBLOCK = 2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIG_SETMASK",
              "documentation": {
                "identifier": "_SIG_SETMASK",
                "newPage": false,
                "searchKey": "runtime._SIG_SETMASK",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIG_SETMASK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIG_SETMASK = 3\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SS_DISABLE",
              "documentation": {
                "identifier": "_SS_DISABLE",
                "newPage": false,
                "searchKey": "runtime._SS_DISABLE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SS_DISABLE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SS_DISABLE = 4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deferHeaderSize",
              "documentation": {
                "identifier": "deferHeaderSize",
                "newPage": false,
                "searchKey": "runtime.deferHeaderSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const deferHeaderSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst deferHeaderSize = unsafe.Sizeof(_defer{})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minDeferAlloc",
              "documentation": {
                "identifier": "minDeferAlloc",
                "newPage": false,
                "searchKey": "runtime.minDeferAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const minDeferAlloc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst minDeferAlloc = (deferHeaderSize + 15) &^ 15\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minDeferArgs",
              "documentation": {
                "identifier": "minDeferArgs",
                "newPage": false,
                "searchKey": "runtime.minDeferArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const minDeferArgs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst minDeferArgs = minDeferAlloc - deferHeaderSize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_GoidCacheBatch",
              "documentation": {
                "identifier": "_GoidCacheBatch",
                "newPage": false,
                "searchKey": "runtime._GoidCacheBatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _GoidCacheBatch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _GoidCacheBatch = 16\n```\n\nNumber of goroutine ids to grab from sched.goidgen to local per-P cache at once. 16 seems to provide enough amortization, but other than that it's mostly arbitrary number. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freezeStopWait",
              "documentation": {
                "identifier": "freezeStopWait",
                "newPage": false,
                "searchKey": "runtime.freezeStopWait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const freezeStopWait"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst freezeStopWait = 0x7fffffff\n```\n\nfreezeStopWait is a large value that freezetheworld sets sched.stopwait to in order to request that all Gs permanently stop. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#forcePreemptNS",
              "documentation": {
                "identifier": "forcePreemptNS",
                "newPage": false,
                "searchKey": "runtime.forcePreemptNS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const forcePreemptNS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst forcePreemptNS = 10 * 1000 * 1000 // 10ms\n\n```\n\nforcePreemptNS is the time slice given to a G before it is preempted. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#randomizeScheduler",
              "documentation": {
                "identifier": "randomizeScheduler",
                "newPage": false,
                "searchKey": "runtime.randomizeScheduler",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const randomizeScheduler"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst randomizeScheduler = raceenabled\n```\n\nTo shake out latent assumptions about scheduling order, we introduce some randomness into scheduling decisions when running with the race detector. The need for this was made obvious by changing the (deterministic) scheduling order in Go 1.5 and breaking many poorly-written tests. With the randomness here, as long as the tests pass consistently with -race, they shouldn't have latent scheduling assumptions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#profReaderSleeping",
              "documentation": {
                "identifier": "profReaderSleeping",
                "newPage": false,
                "searchKey": "runtime.profReaderSleeping",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const profReaderSleeping"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst profReaderSleeping profIndex = 1 << 32 // reader is sleeping and must be woken up\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#profWriteExtra",
              "documentation": {
                "identifier": "profWriteExtra",
                "newPage": false,
                "searchKey": "runtime.profWriteExtra",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const profWriteExtra"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst profWriteExtra profIndex = 1 << 33 // overflow or eof waiting\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#profBufBlocking",
              "documentation": {
                "identifier": "profBufBlocking",
                "newPage": false,
                "searchKey": "runtime.profBufBlocking",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const profBufBlocking"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst profBufBlocking profBufReadMode = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#profBufNonBlocking",
              "documentation": {
                "identifier": "profBufNonBlocking",
                "newPage": false,
                "searchKey": "runtime.profBufNonBlocking",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const profBufNonBlocking"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst profBufNonBlocking\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raceenabled",
              "documentation": {
                "identifier": "raceenabled",
                "newPage": false,
                "searchKey": "runtime.raceenabled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const raceenabled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst raceenabled = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#osRelaxMinNS",
              "documentation": {
                "identifier": "osRelaxMinNS",
                "newPage": false,
                "searchKey": "runtime.osRelaxMinNS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const osRelaxMinNS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst osRelaxMinNS = 0\n```\n\nosRelaxMinNS is the number of nanoseconds of idleness to tolerate without performing an osRelax. Since osRelax may reduce the precision of timers, this should be enough larger than the relaxed timer precision to keep the timer error acceptable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracebackCrash",
              "documentation": {
                "identifier": "tracebackCrash",
                "newPage": false,
                "searchKey": "runtime.tracebackCrash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tracebackCrash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tracebackCrash = 1 << iota\n```\n\nKeep a cached value to make gotraceback fast, since we call it on every call to gentraceback. The cached value is a uint32 in which the low bits are the \"crash\" and \"all\" settings and the remaining bits are the traceback value (0 off, 1 on, 2 include system). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracebackAll",
              "documentation": {
                "identifier": "tracebackAll",
                "newPage": false,
                "searchKey": "runtime.tracebackAll",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tracebackAll"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tracebackAll\n```\n\nKeep a cached value to make gotraceback fast, since we call it on every call to gentraceback. The cached value is a uint32 in which the low bits are the \"crash\" and \"all\" settings and the remaining bits are the traceback value (0 off, 1 on, 2 include system). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracebackShift",
              "documentation": {
                "identifier": "tracebackShift",
                "newPage": false,
                "searchKey": "runtime.tracebackShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tracebackShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tracebackShift = iota\n```\n\nKeep a cached value to make gotraceback fast, since we call it on every call to gentraceback. The cached value is a uint32 in which the low bits are the \"crash\" and \"all\" settings and the remaining bits are the traceback value (0 off, 1 on, 2 include system). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gidle",
              "documentation": {
                "identifier": "_Gidle",
                "newPage": false,
                "searchKey": "runtime._Gidle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gidle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gidle = iota // 0\n\n```\n\ndefined constants \n\n_Gidle means this goroutine was just allocated and has not yet been initialized. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Grunnable",
              "documentation": {
                "identifier": "_Grunnable",
                "newPage": false,
                "searchKey": "runtime._Grunnable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Grunnable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Grunnable // 1\n\n```\n\ndefined constants \n\n_Grunnable means this goroutine is on a run queue. It is not currently executing user code. The stack is not owned. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Grunning",
              "documentation": {
                "identifier": "_Grunning",
                "newPage": false,
                "searchKey": "runtime._Grunning",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Grunning"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Grunning // 2\n\n```\n\ndefined constants \n\n_Grunning means this goroutine may execute user code. The stack is owned by this goroutine. It is not on a run queue. It is assigned an M and a P (g.m and g.m.p are valid). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gsyscall",
              "documentation": {
                "identifier": "_Gsyscall",
                "newPage": false,
                "searchKey": "runtime._Gsyscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gsyscall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gsyscall // 3\n\n```\n\ndefined constants \n\n_Gsyscall means this goroutine is executing a system call. It is not executing user code. The stack is owned by this goroutine. It is not on a run queue. It is assigned an M. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gwaiting",
              "documentation": {
                "identifier": "_Gwaiting",
                "newPage": false,
                "searchKey": "runtime._Gwaiting",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gwaiting"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gwaiting // 4\n\n```\n\ndefined constants \n\n_Gwaiting means this goroutine is blocked in the runtime. It is not executing user code. It is not on a run queue, but should be recorded somewhere (e.g., a channel wait queue) so it can be ready()d when necessary. The stack is not owned *except* that a channel operation may read or write parts of the stack under the appropriate channel lock. Otherwise, it is not safe to access the stack after a goroutine enters _Gwaiting (e.g., it may get moved). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gmoribund_unused",
              "documentation": {
                "identifier": "_Gmoribund_unused",
                "newPage": false,
                "searchKey": "runtime._Gmoribund_unused",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gmoribund_unused"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gmoribund_unused // 5\n\n```\n\ndefined constants \n\n_Gmoribund_unused is currently unused, but hardcoded in gdb scripts. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gdead",
              "documentation": {
                "identifier": "_Gdead",
                "newPage": false,
                "searchKey": "runtime._Gdead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gdead"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gdead // 6\n\n```\n\ndefined constants \n\n_Gdead means this goroutine is currently unused. It may be just exited, on a free list, or just being initialized. It is not executing user code. It may or may not have a stack allocated. The G and its stack (if any) are owned by the M that is exiting the G or that obtained the G from the free list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Genqueue_unused",
              "documentation": {
                "identifier": "_Genqueue_unused",
                "newPage": false,
                "searchKey": "runtime._Genqueue_unused",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Genqueue_unused"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Genqueue_unused // 7\n\n```\n\ndefined constants \n\n_Genqueue_unused is currently unused. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gcopystack",
              "documentation": {
                "identifier": "_Gcopystack",
                "newPage": false,
                "searchKey": "runtime._Gcopystack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gcopystack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gcopystack // 8\n\n```\n\ndefined constants \n\n_Gcopystack means this goroutine's stack is being moved. It is not executing user code and is not on a run queue. The stack is owned by the goroutine that put it in _Gcopystack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gpreempted",
              "documentation": {
                "identifier": "_Gpreempted",
                "newPage": false,
                "searchKey": "runtime._Gpreempted",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gpreempted"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gpreempted // 9\n\n```\n\ndefined constants \n\n_Gpreempted means this goroutine stopped itself for a suspendG preemption. It is like _Gwaiting, but nothing is yet responsible for ready()ing it. Some suspendG must CAS the status to _Gwaiting to take responsibility for ready()ing this G. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gscan",
              "documentation": {
                "identifier": "_Gscan",
                "newPage": false,
                "searchKey": "runtime._Gscan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gscan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gscan = 0x1000\n```\n\ndefined constants \n\n_Gscan combined with one of the above states other than _Grunning indicates that GC is scanning the stack. The goroutine is not executing user code and the stack is owned by the goroutine that set the _Gscan bit. \n\n_Gscanrunning is different: it is used to briefly block state transitions while GC signals the G to scan its own stack. This is otherwise like _Grunning. \n\natomicstatus&~Gscan gives the state the goroutine will return to when the scan completes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gscanrunnable",
              "documentation": {
                "identifier": "_Gscanrunnable",
                "newPage": false,
                "searchKey": "runtime._Gscanrunnable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gscanrunnable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gscanrunnable = _Gscan + _Grunnable // 0x1001\n\n```\n\ndefined constants \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gscanrunning",
              "documentation": {
                "identifier": "_Gscanrunning",
                "newPage": false,
                "searchKey": "runtime._Gscanrunning",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gscanrunning"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gscanrunning = _Gscan + _Grunning // 0x1002\n\n```\n\ndefined constants \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gscansyscall",
              "documentation": {
                "identifier": "_Gscansyscall",
                "newPage": false,
                "searchKey": "runtime._Gscansyscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gscansyscall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gscansyscall = _Gscan + _Gsyscall // 0x1003\n\n```\n\ndefined constants \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gscanwaiting",
              "documentation": {
                "identifier": "_Gscanwaiting",
                "newPage": false,
                "searchKey": "runtime._Gscanwaiting",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gscanwaiting"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gscanwaiting = _Gscan + _Gwaiting // 0x1004\n\n```\n\ndefined constants \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Gscanpreempted",
              "documentation": {
                "identifier": "_Gscanpreempted",
                "newPage": false,
                "searchKey": "runtime._Gscanpreempted",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Gscanpreempted"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Gscanpreempted = _Gscan + _Gpreempted // 0x1009\n\n```\n\ndefined constants \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Pidle",
              "documentation": {
                "identifier": "_Pidle",
                "newPage": false,
                "searchKey": "runtime._Pidle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Pidle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Pidle = iota\n```\n\n_Pidle means a P is not being used to run user code or the scheduler. Typically, it's on the idle P list and available to the scheduler, but it may just be transitioning between other states. \n\nThe P is owned by the idle list or by whatever is transitioning its state. Its run queue is empty. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Prunning",
              "documentation": {
                "identifier": "_Prunning",
                "newPage": false,
                "searchKey": "runtime._Prunning",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Prunning"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Prunning\n```\n\n_Prunning means a P is owned by an M and is being used to run user code or the scheduler. Only the M that owns this P is allowed to change the P's status from _Prunning. The M may transition the P to _Pidle (if it has no more work to do), _Psyscall (when entering a syscall), or _Pgcstop (to halt for the GC). The M may also hand ownership of the P off directly to another M (e.g., to schedule a locked G). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Psyscall",
              "documentation": {
                "identifier": "_Psyscall",
                "newPage": false,
                "searchKey": "runtime._Psyscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Psyscall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Psyscall\n```\n\n_Psyscall means a P is not running user code. It has affinity to an M in a syscall but is not owned by it and may be stolen by another M. This is similar to _Pidle but uses lightweight transitions and maintains M affinity. \n\nLeaving _Psyscall must be done with a CAS, either to steal or retake the P. Note that there's an ABA hazard: even if an M successfully CASes its original P back to _Prunning after a syscall, it must understand the P may have been used by another M in the interim. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Pgcstop",
              "documentation": {
                "identifier": "_Pgcstop",
                "newPage": false,
                "searchKey": "runtime._Pgcstop",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Pgcstop"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Pgcstop\n```\n\n_Pgcstop means a P is halted for STW and owned by the M that stopped the world. The M that stopped the world continues to use its P, even in _Pgcstop. Transitioning from _Prunning to _Pgcstop causes an M to release its P and park. \n\nThe P retains its run queue and startTheWorld will restart the scheduler on Ps with non-empty run queues. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_Pdead",
              "documentation": {
                "identifier": "_Pdead",
                "newPage": false,
                "searchKey": "runtime._Pdead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Pdead"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Pdead\n```\n\n_Pdead means a P is no longer used (GOMAXPROCS shrank). We reuse Ps if GOMAXPROCS increases. A dead P is mostly stripped of its resources, though a few things remain (e.g., trace buffers). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gTrackingPeriod",
              "documentation": {
                "identifier": "gTrackingPeriod",
                "newPage": false,
                "searchKey": "runtime.gTrackingPeriod",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const gTrackingPeriod"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst gTrackingPeriod = 8\n```\n\ngTrackingPeriod is the number of transitions out of _Grunning between latency tracking runs. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tlsSlots",
              "documentation": {
                "identifier": "tlsSlots",
                "newPage": false,
                "searchKey": "runtime.tlsSlots",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tlsSlots"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tlsSlots = 6\n```\n\ntlsSlots is the number of pointer-sized slots reserved for TLS on some platforms, like Windows. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tlsSize",
              "documentation": {
                "identifier": "tlsSize",
                "newPage": false,
                "searchKey": "runtime.tlsSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tlsSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tlsSize = tlsSlots * sys.PtrSize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SigNotify",
              "documentation": {
                "identifier": "_SigNotify",
                "newPage": false,
                "searchKey": "runtime._SigNotify",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SigNotify"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SigNotify = 1 << iota // let signal.Notify have signal, even if from kernel\n\n```\n\nValues for the flags field of a sigTabT. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SigKill",
              "documentation": {
                "identifier": "_SigKill",
                "newPage": false,
                "searchKey": "runtime._SigKill",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SigKill"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SigKill // if signal.Notify doesn't take it, exit quietly\n\n```\n\nValues for the flags field of a sigTabT. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SigThrow",
              "documentation": {
                "identifier": "_SigThrow",
                "newPage": false,
                "searchKey": "runtime._SigThrow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SigThrow"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SigThrow // if signal.Notify doesn't take it, exit loudly\n\n```\n\nValues for the flags field of a sigTabT. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SigPanic",
              "documentation": {
                "identifier": "_SigPanic",
                "newPage": false,
                "searchKey": "runtime._SigPanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SigPanic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SigPanic // if the signal is from the kernel, panic\n\n```\n\nValues for the flags field of a sigTabT. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SigDefault",
              "documentation": {
                "identifier": "_SigDefault",
                "newPage": false,
                "searchKey": "runtime._SigDefault",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SigDefault"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SigDefault // if the signal isn't explicitly requested, don't monitor it\n\n```\n\nValues for the flags field of a sigTabT. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SigGoExit",
              "documentation": {
                "identifier": "_SigGoExit",
                "newPage": false,
                "searchKey": "runtime._SigGoExit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SigGoExit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SigGoExit // cause all runtime procs to exit (only used on Plan 9).\n\n```\n\nValues for the flags field of a sigTabT. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SigSetStack",
              "documentation": {
                "identifier": "_SigSetStack",
                "newPage": false,
                "searchKey": "runtime._SigSetStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SigSetStack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SigSetStack // add SA_ONSTACK to libc handler\n\n```\n\nValues for the flags field of a sigTabT. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SigUnblock",
              "documentation": {
                "identifier": "_SigUnblock",
                "newPage": false,
                "searchKey": "runtime._SigUnblock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SigUnblock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SigUnblock // always unblock; see blockableSig\n\n```\n\nValues for the flags field of a sigTabT. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SigIgn",
              "documentation": {
                "identifier": "_SigIgn",
                "newPage": false,
                "searchKey": "runtime._SigIgn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SigIgn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SigIgn // _SIG_DFL action is to ignore the signal\n\n```\n\nValues for the flags field of a sigTabT. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_TraceRuntimeFrames",
              "documentation": {
                "identifier": "_TraceRuntimeFrames",
                "newPage": false,
                "searchKey": "runtime._TraceRuntimeFrames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _TraceRuntimeFrames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _TraceRuntimeFrames = 1 << iota // include frames for internal runtime functions.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_TraceTrap",
              "documentation": {
                "identifier": "_TraceTrap",
                "newPage": false,
                "searchKey": "runtime._TraceTrap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _TraceTrap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _TraceTrap // the initial PC, SP are from a trap, not a return PC from a call\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_TraceJumpStack",
              "documentation": {
                "identifier": "_TraceJumpStack",
                "newPage": false,
                "searchKey": "runtime._TraceJumpStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _TraceJumpStack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _TraceJumpStack // if traceback is on a systemstack, resume trace at g that called into it\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_TracebackMaxFrames",
              "documentation": {
                "identifier": "_TracebackMaxFrames",
                "newPage": false,
                "searchKey": "runtime._TracebackMaxFrames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _TracebackMaxFrames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _TracebackMaxFrames = 100\n```\n\nThe maximum number of frames we print for a traceback \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonZero",
              "documentation": {
                "identifier": "waitReasonZero",
                "newPage": false,
                "searchKey": "runtime.waitReasonZero",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonZero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonZero waitReason = iota // \"\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonGCAssistMarking",
              "documentation": {
                "identifier": "waitReasonGCAssistMarking",
                "newPage": false,
                "searchKey": "runtime.waitReasonGCAssistMarking",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonGCAssistMarking"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonGCAssistMarking // \"GC assist marking\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonIOWait",
              "documentation": {
                "identifier": "waitReasonIOWait",
                "newPage": false,
                "searchKey": "runtime.waitReasonIOWait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonIOWait"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonIOWait // \"IO wait\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonChanReceiveNilChan",
              "documentation": {
                "identifier": "waitReasonChanReceiveNilChan",
                "newPage": false,
                "searchKey": "runtime.waitReasonChanReceiveNilChan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonChanReceiveNilChan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonChanReceiveNilChan // \"chan receive (nil chan)\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonChanSendNilChan",
              "documentation": {
                "identifier": "waitReasonChanSendNilChan",
                "newPage": false,
                "searchKey": "runtime.waitReasonChanSendNilChan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonChanSendNilChan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonChanSendNilChan // \"chan send (nil chan)\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonDumpingHeap",
              "documentation": {
                "identifier": "waitReasonDumpingHeap",
                "newPage": false,
                "searchKey": "runtime.waitReasonDumpingHeap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonDumpingHeap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonDumpingHeap // \"dumping heap\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonGarbageCollection",
              "documentation": {
                "identifier": "waitReasonGarbageCollection",
                "newPage": false,
                "searchKey": "runtime.waitReasonGarbageCollection",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonGarbageCollection"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonGarbageCollection // \"garbage collection\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonGarbageCollectionScan",
              "documentation": {
                "identifier": "waitReasonGarbageCollectionScan",
                "newPage": false,
                "searchKey": "runtime.waitReasonGarbageCollectionScan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonGarbageCollectionScan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonGarbageCollectionScan // \"garbage collection scan\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonPanicWait",
              "documentation": {
                "identifier": "waitReasonPanicWait",
                "newPage": false,
                "searchKey": "runtime.waitReasonPanicWait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonPanicWait"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonPanicWait // \"panicwait\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonSelect",
              "documentation": {
                "identifier": "waitReasonSelect",
                "newPage": false,
                "searchKey": "runtime.waitReasonSelect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonSelect"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonSelect // \"select\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonSelectNoCases",
              "documentation": {
                "identifier": "waitReasonSelectNoCases",
                "newPage": false,
                "searchKey": "runtime.waitReasonSelectNoCases",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonSelectNoCases"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonSelectNoCases // \"select (no cases)\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonGCAssistWait",
              "documentation": {
                "identifier": "waitReasonGCAssistWait",
                "newPage": false,
                "searchKey": "runtime.waitReasonGCAssistWait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonGCAssistWait"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonGCAssistWait // \"GC assist wait\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonGCSweepWait",
              "documentation": {
                "identifier": "waitReasonGCSweepWait",
                "newPage": false,
                "searchKey": "runtime.waitReasonGCSweepWait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonGCSweepWait"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonGCSweepWait // \"GC sweep wait\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonGCScavengeWait",
              "documentation": {
                "identifier": "waitReasonGCScavengeWait",
                "newPage": false,
                "searchKey": "runtime.waitReasonGCScavengeWait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonGCScavengeWait"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonGCScavengeWait // \"GC scavenge wait\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonChanReceive",
              "documentation": {
                "identifier": "waitReasonChanReceive",
                "newPage": false,
                "searchKey": "runtime.waitReasonChanReceive",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonChanReceive"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonChanReceive // \"chan receive\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonChanSend",
              "documentation": {
                "identifier": "waitReasonChanSend",
                "newPage": false,
                "searchKey": "runtime.waitReasonChanSend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonChanSend"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonChanSend // \"chan send\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonFinalizerWait",
              "documentation": {
                "identifier": "waitReasonFinalizerWait",
                "newPage": false,
                "searchKey": "runtime.waitReasonFinalizerWait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonFinalizerWait"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonFinalizerWait // \"finalizer wait\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonForceGCIdle",
              "documentation": {
                "identifier": "waitReasonForceGCIdle",
                "newPage": false,
                "searchKey": "runtime.waitReasonForceGCIdle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonForceGCIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonForceGCIdle // \"force gc (idle)\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonSemacquire",
              "documentation": {
                "identifier": "waitReasonSemacquire",
                "newPage": false,
                "searchKey": "runtime.waitReasonSemacquire",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonSemacquire"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonSemacquire // \"semacquire\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonSleep",
              "documentation": {
                "identifier": "waitReasonSleep",
                "newPage": false,
                "searchKey": "runtime.waitReasonSleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonSleep"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonSleep // \"sleep\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonSyncCondWait",
              "documentation": {
                "identifier": "waitReasonSyncCondWait",
                "newPage": false,
                "searchKey": "runtime.waitReasonSyncCondWait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonSyncCondWait"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonSyncCondWait // \"sync.Cond.Wait\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonTimerGoroutineIdle",
              "documentation": {
                "identifier": "waitReasonTimerGoroutineIdle",
                "newPage": false,
                "searchKey": "runtime.waitReasonTimerGoroutineIdle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonTimerGoroutineIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonTimerGoroutineIdle // \"timer goroutine (idle)\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonTraceReaderBlocked",
              "documentation": {
                "identifier": "waitReasonTraceReaderBlocked",
                "newPage": false,
                "searchKey": "runtime.waitReasonTraceReaderBlocked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonTraceReaderBlocked"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonTraceReaderBlocked // \"trace reader (blocked)\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonWaitForGCCycle",
              "documentation": {
                "identifier": "waitReasonWaitForGCCycle",
                "newPage": false,
                "searchKey": "runtime.waitReasonWaitForGCCycle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonWaitForGCCycle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonWaitForGCCycle // \"wait for GC cycle\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonGCWorkerIdle",
              "documentation": {
                "identifier": "waitReasonGCWorkerIdle",
                "newPage": false,
                "searchKey": "runtime.waitReasonGCWorkerIdle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonGCWorkerIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonGCWorkerIdle // \"GC worker (idle)\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonPreempted",
              "documentation": {
                "identifier": "waitReasonPreempted",
                "newPage": false,
                "searchKey": "runtime.waitReasonPreempted",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonPreempted"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonPreempted // \"preempted\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonDebugCall",
              "documentation": {
                "identifier": "waitReasonDebugCall",
                "newPage": false,
                "searchKey": "runtime.waitReasonDebugCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const waitReasonDebugCall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst waitReasonDebugCall // \"debug call\"\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#framepointer_enabled",
              "documentation": {
                "identifier": "framepointer_enabled",
                "newPage": false,
                "searchKey": "runtime.framepointer_enabled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const framepointer_enabled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst framepointer_enabled = GOARCH == \"amd64\" || GOARCH == \"arm64\"\n```\n\nMust agree with internal/buildcfg.Experiment.FramePointer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#rwmutexMaxReaders",
              "documentation": {
                "identifier": "rwmutexMaxReaders",
                "newPage": false,
                "searchKey": "runtime.rwmutexMaxReaders",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const rwmutexMaxReaders"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst rwmutexMaxReaders = 1 << 30\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugSelect",
              "documentation": {
                "identifier": "debugSelect",
                "newPage": false,
                "searchKey": "runtime.debugSelect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugSelect"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugSelect = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#selectSend",
              "documentation": {
                "identifier": "selectSend",
                "newPage": false,
                "searchKey": "runtime.selectSend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const selectSend"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst selectSend // case Chan <- Send\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#selectRecv",
              "documentation": {
                "identifier": "selectRecv",
                "newPage": false,
                "searchKey": "runtime.selectRecv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const selectRecv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst selectRecv // case <-Chan:\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#selectDefault",
              "documentation": {
                "identifier": "selectDefault",
                "newPage": false,
                "searchKey": "runtime.selectDefault",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const selectDefault"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst selectDefault // default\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semTabSize",
              "documentation": {
                "identifier": "semTabSize",
                "newPage": false,
                "searchKey": "runtime.semTabSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const semTabSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst semTabSize = 251\n```\n\nPrime to not correlate with any user patterns. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semaBlockProfile",
              "documentation": {
                "identifier": "semaBlockProfile",
                "newPage": false,
                "searchKey": "runtime.semaBlockProfile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const semaBlockProfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst semaBlockProfile semaProfileFlags = 1 << iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semaMutexProfile",
              "documentation": {
                "identifier": "semaMutexProfile",
                "newPage": false,
                "searchKey": "runtime.semaMutexProfile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const semaMutexProfile"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst semaMutexProfile\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIG_DFL",
              "documentation": {
                "identifier": "_SIG_DFL",
                "newPage": false,
                "searchKey": "runtime._SIG_DFL",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIG_DFL"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIG_DFL uintptr = 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_SIG_IGN",
              "documentation": {
                "identifier": "_SIG_IGN",
                "newPage": false,
                "searchKey": "runtime._SIG_IGN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _SIG_IGN"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _SIG_IGN uintptr = 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigPreempt",
              "documentation": {
                "identifier": "sigPreempt",
                "newPage": false,
                "searchKey": "runtime.sigPreempt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sigPreempt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sigPreempt = _SIGURG\n```\n\nsigPreempt is the signal used for non-cooperative preemption. \n\nThere's no good way to choose this signal, but there are some heuristics: \n\n1. It should be a signal that's passed-through by debuggers by default. On Linux, this is SIGALRM, SIGURG, SIGCHLD, SIGIO, SIGVTALRM, SIGPROF, and SIGWINCH, plus some glibc-internal signals. \n\n2. It shouldn't be used internally by libc in mixed Go/C binaries because libc may assume it's the only thing that can handle these signals. For example SIGCANCEL or SIGSETXID. \n\n3. It should be a signal that can happen spuriously without consequences. For example, SIGALRM is a bad choice because the signal handler can't tell if it was caused by the real process alarm or not (arguably this means the signal is broken, but I digress). SIGUSR1 and SIGUSR2 are also bad because those are often used in meaningful ways by applications. \n\n4. We need to deal with platforms without real-time signals (like macOS), so those are out. \n\nWe use SIGURG because it meets all of these criteria, is extremely unlikely to be used by an application for its \"real\" meaning (both because out-of-band data is basically unused and because SIGURG doesn't report which socket has the condition, making it pretty useless), and even if it is, the application has to be ready for spurious SIGURG. SIGIO wouldn't be a bad choice either, but is more likely to be used for real. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#preemptMSupported",
              "documentation": {
                "identifier": "preemptMSupported",
                "newPage": false,
                "searchKey": "runtime.preemptMSupported",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const preemptMSupported"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst preemptMSupported = true\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigIdle",
              "documentation": {
                "identifier": "sigIdle",
                "newPage": false,
                "searchKey": "runtime.sigIdle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sigIdle"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sigIdle = iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigReceiving",
              "documentation": {
                "identifier": "sigReceiving",
                "newPage": false,
                "searchKey": "runtime.sigReceiving",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sigReceiving"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sigReceiving\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigSending",
              "documentation": {
                "identifier": "sigSending",
                "newPage": false,
                "searchKey": "runtime.sigSending",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sigSending"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sigSending\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigFixup",
              "documentation": {
                "identifier": "sigFixup",
                "newPage": false,
                "searchKey": "runtime.sigFixup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sigFixup"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sigFixup\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_MaxSmallSize",
              "documentation": {
                "identifier": "_MaxSmallSize",
                "newPage": false,
                "searchKey": "runtime._MaxSmallSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _MaxSmallSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _MaxSmallSize = 32768\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#smallSizeDiv",
              "documentation": {
                "identifier": "smallSizeDiv",
                "newPage": false,
                "searchKey": "runtime.smallSizeDiv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const smallSizeDiv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst smallSizeDiv = 8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#smallSizeMax",
              "documentation": {
                "identifier": "smallSizeMax",
                "newPage": false,
                "searchKey": "runtime.smallSizeMax",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const smallSizeMax"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst smallSizeMax = 1024\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#largeSizeDiv",
              "documentation": {
                "identifier": "largeSizeDiv",
                "newPage": false,
                "searchKey": "runtime.largeSizeDiv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const largeSizeDiv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst largeSizeDiv = 128\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_NumSizeClasses",
              "documentation": {
                "identifier": "_NumSizeClasses",
                "newPage": false,
                "searchKey": "runtime._NumSizeClasses",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _NumSizeClasses"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _NumSizeClasses = 68\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PageShift",
              "documentation": {
                "identifier": "_PageShift",
                "newPage": false,
                "searchKey": "runtime._PageShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PageShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PageShift = 13\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mantbits64",
              "documentation": {
                "identifier": "mantbits64",
                "newPage": false,
                "searchKey": "runtime.mantbits64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mantbits64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mantbits64 uint = 52\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#expbits64",
              "documentation": {
                "identifier": "expbits64",
                "newPage": false,
                "searchKey": "runtime.expbits64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const expbits64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst expbits64 uint = 11\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bias64",
              "documentation": {
                "identifier": "bias64",
                "newPage": false,
                "searchKey": "runtime.bias64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bias64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bias64 = -1<<(expbits64-1) + 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nan64",
              "documentation": {
                "identifier": "nan64",
                "newPage": false,
                "searchKey": "runtime.nan64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const nan64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst nan64 uint64 = (1<<expbits64-1)<<mantbits64 + 1<<(mantbits64-1) // quiet NaN, 0 payload\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inf64",
              "documentation": {
                "identifier": "inf64",
                "newPage": false,
                "searchKey": "runtime.inf64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const inf64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst inf64 uint64 = (1<<expbits64 - 1) << mantbits64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#neg64",
              "documentation": {
                "identifier": "neg64",
                "newPage": false,
                "searchKey": "runtime.neg64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const neg64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst neg64 uint64 = 1 << (expbits64 + mantbits64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mantbits32",
              "documentation": {
                "identifier": "mantbits32",
                "newPage": false,
                "searchKey": "runtime.mantbits32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mantbits32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mantbits32 uint = 23\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#expbits32",
              "documentation": {
                "identifier": "expbits32",
                "newPage": false,
                "searchKey": "runtime.expbits32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const expbits32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst expbits32 uint = 8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bias32",
              "documentation": {
                "identifier": "bias32",
                "newPage": false,
                "searchKey": "runtime.bias32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const bias32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst bias32 = -1<<(expbits32-1) + 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nan32",
              "documentation": {
                "identifier": "nan32",
                "newPage": false,
                "searchKey": "runtime.nan32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const nan32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst nan32 uint32 = (1<<expbits32-1)<<mantbits32 + 1<<(mantbits32-1) // quiet NaN, 0 payload\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inf32",
              "documentation": {
                "identifier": "inf32",
                "newPage": false,
                "searchKey": "runtime.inf32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const inf32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst inf32 uint32 = (1<<expbits32 - 1) << mantbits32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#neg32",
              "documentation": {
                "identifier": "neg32",
                "newPage": false,
                "searchKey": "runtime.neg32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const neg32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst neg32 uint32 = 1 << (expbits32 + mantbits32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_StackSystem",
              "documentation": {
                "identifier": "_StackSystem",
                "newPage": false,
                "searchKey": "runtime._StackSystem",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _StackSystem"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _StackSystem = ...\n```\n\nStackSystem is a number of additional bytes to add to each stack below the usual guard area for OS-specific purposes like signal handling. Used on Windows, Plan 9, and iOS because they do not use a separate stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_StackMin",
              "documentation": {
                "identifier": "_StackMin",
                "newPage": false,
                "searchKey": "runtime._StackMin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _StackMin"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _StackMin = 2048\n```\n\nThe minimum size of stack used by Go code \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FixedStack0",
              "documentation": {
                "identifier": "_FixedStack0",
                "newPage": false,
                "searchKey": "runtime._FixedStack0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FixedStack0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FixedStack0 = _StackMin + _StackSystem\n```\n\nThe minimum stack size to allocate. The hackery here rounds FixedStack0 up to a power of 2. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FixedStack1",
              "documentation": {
                "identifier": "_FixedStack1",
                "newPage": false,
                "searchKey": "runtime._FixedStack1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FixedStack1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FixedStack1 = _FixedStack0 - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FixedStack2",
              "documentation": {
                "identifier": "_FixedStack2",
                "newPage": false,
                "searchKey": "runtime._FixedStack2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FixedStack2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FixedStack2 = _FixedStack1 | (_FixedStack1 >> 1)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FixedStack3",
              "documentation": {
                "identifier": "_FixedStack3",
                "newPage": false,
                "searchKey": "runtime._FixedStack3",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FixedStack3"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FixedStack3 = _FixedStack2 | (_FixedStack2 >> 2)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FixedStack4",
              "documentation": {
                "identifier": "_FixedStack4",
                "newPage": false,
                "searchKey": "runtime._FixedStack4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FixedStack4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FixedStack4 = _FixedStack3 | (_FixedStack3 >> 4)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FixedStack5",
              "documentation": {
                "identifier": "_FixedStack5",
                "newPage": false,
                "searchKey": "runtime._FixedStack5",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FixedStack5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FixedStack5 = _FixedStack4 | (_FixedStack4 >> 8)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FixedStack6",
              "documentation": {
                "identifier": "_FixedStack6",
                "newPage": false,
                "searchKey": "runtime._FixedStack6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FixedStack6"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FixedStack6 = _FixedStack5 | (_FixedStack5 >> 16)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FixedStack",
              "documentation": {
                "identifier": "_FixedStack",
                "newPage": false,
                "searchKey": "runtime._FixedStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FixedStack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FixedStack = _FixedStack6 + 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_StackBig",
              "documentation": {
                "identifier": "_StackBig",
                "newPage": false,
                "searchKey": "runtime._StackBig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _StackBig"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _StackBig = 4096\n```\n\nFunctions that need frames bigger than this use an extra instruction to do the stack split check, to avoid overflow in case SP - framesize wraps below zero. This value can be no bigger than the size of the unmapped space at zero. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_StackGuard",
              "documentation": {
                "identifier": "_StackGuard",
                "newPage": false,
                "searchKey": "runtime._StackGuard",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _StackGuard"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _StackGuard = 928*sys.StackGuardMultiplier + _StackSystem\n```\n\nThe stack guard is a pointer this many bytes above the bottom of the stack. \n\nThe guard leaves enough room for one _StackSmall frame plus a _StackLimit chain of NOSPLIT calls plus _StackSystem bytes for the OS. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_StackSmall",
              "documentation": {
                "identifier": "_StackSmall",
                "newPage": false,
                "searchKey": "runtime._StackSmall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _StackSmall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _StackSmall = 128\n```\n\nAfter a stack split check the SP is allowed to be this many bytes below the stack guard. This saves an instruction in the checking sequence for tiny frames. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_StackLimit",
              "documentation": {
                "identifier": "_StackLimit",
                "newPage": false,
                "searchKey": "runtime._StackLimit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _StackLimit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _StackLimit = _StackGuard - _StackSystem - _StackSmall\n```\n\nThe maximum number of bytes that a chain of NOSPLIT functions can use. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackDebug",
              "documentation": {
                "identifier": "stackDebug",
                "newPage": false,
                "searchKey": "runtime.stackDebug",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stackDebug"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stackDebug = 0\n```\n\nstackDebug == 0: no logging \n\n```\n== 1: logging of per-stack operations\n== 2: logging of per-frame operations\n== 3: logging of per-word updates\n== 4: logging of per-word reads\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackFromSystem",
              "documentation": {
                "identifier": "stackFromSystem",
                "newPage": false,
                "searchKey": "runtime.stackFromSystem",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stackFromSystem"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stackFromSystem = 0 // allocate stacks from system memory instead of the heap\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackFaultOnFree",
              "documentation": {
                "identifier": "stackFaultOnFree",
                "newPage": false,
                "searchKey": "runtime.stackFaultOnFree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stackFaultOnFree"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stackFaultOnFree = 0 // old stacks are mapped noaccess to detect use after free\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackPoisonCopy",
              "documentation": {
                "identifier": "stackPoisonCopy",
                "newPage": false,
                "searchKey": "runtime.stackPoisonCopy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stackPoisonCopy"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stackPoisonCopy // fill stack that should not be accessed with garbage, to detect bad dereferences during copy\n = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackNoCache",
              "documentation": {
                "identifier": "stackNoCache",
                "newPage": false,
                "searchKey": "runtime.stackNoCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stackNoCache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stackNoCache = 0 // disable per-P small stack caches\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCheckBP",
              "documentation": {
                "identifier": "debugCheckBP",
                "newPage": false,
                "searchKey": "runtime.debugCheckBP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugCheckBP"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugCheckBP = false\n```\n\ncheck the BP links during traceback. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#uintptrMask",
              "documentation": {
                "identifier": "uintptrMask",
                "newPage": false,
                "searchKey": "runtime.uintptrMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const uintptrMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst uintptrMask = 1<<(8*sys.PtrSize) - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackPreempt",
              "documentation": {
                "identifier": "stackPreempt",
                "newPage": false,
                "searchKey": "runtime.stackPreempt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stackPreempt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stackPreempt = uintptrMask & -1314\n```\n\nGoroutine preemption request. 0xfffffade in hex. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackFork",
              "documentation": {
                "identifier": "stackFork",
                "newPage": false,
                "searchKey": "runtime.stackFork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stackFork"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stackFork = uintptrMask & -1234\n```\n\nThread is forking. Causes a split stack check failure. 0xfffffb2e in hex. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackForceMove",
              "documentation": {
                "identifier": "stackForceMove",
                "newPage": false,
                "searchKey": "runtime.stackForceMove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const stackForceMove"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst stackForceMove = uintptrMask & -275\n```\n\nForce a stack movement. Used for debugging. 0xfffffeed in hex. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tmpStringBufSize",
              "documentation": {
                "identifier": "tmpStringBufSize",
                "newPage": false,
                "searchKey": "runtime.tmpStringBufSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tmpStringBufSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tmpStringBufSize = 32\n```\n\nThe constant is known to the compiler. There is no fundamental theory behind this number. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxUint",
              "documentation": {
                "identifier": "maxUint",
                "newPage": false,
                "searchKey": "runtime.maxUint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxUint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxUint = ^uint(0)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxInt",
              "documentation": {
                "identifier": "maxInt",
                "newPage": false,
                "searchKey": "runtime.maxInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxInt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxInt = int(maxUint >> 1)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PCDATA_UnsafePoint",
              "documentation": {
                "identifier": "_PCDATA_UnsafePoint",
                "newPage": false,
                "searchKey": "runtime._PCDATA_UnsafePoint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PCDATA_UnsafePoint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PCDATA_UnsafePoint = 0\n```\n\nPCDATA and FUNCDATA table indexes. \n\nSee funcdata.h and ../cmd/internal/objabi/funcdata.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PCDATA_StackMapIndex",
              "documentation": {
                "identifier": "_PCDATA_StackMapIndex",
                "newPage": false,
                "searchKey": "runtime._PCDATA_StackMapIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PCDATA_StackMapIndex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PCDATA_StackMapIndex = 1\n```\n\nPCDATA and FUNCDATA table indexes. \n\nSee funcdata.h and ../cmd/internal/objabi/funcdata.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PCDATA_InlTreeIndex",
              "documentation": {
                "identifier": "_PCDATA_InlTreeIndex",
                "newPage": false,
                "searchKey": "runtime._PCDATA_InlTreeIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PCDATA_InlTreeIndex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PCDATA_InlTreeIndex = 2\n```\n\nPCDATA and FUNCDATA table indexes. \n\nSee funcdata.h and ../cmd/internal/objabi/funcdata.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FUNCDATA_ArgsPointerMaps",
              "documentation": {
                "identifier": "_FUNCDATA_ArgsPointerMaps",
                "newPage": false,
                "searchKey": "runtime._FUNCDATA_ArgsPointerMaps",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FUNCDATA_ArgsPointerMaps"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FUNCDATA_ArgsPointerMaps = 0\n```\n\nPCDATA and FUNCDATA table indexes. \n\nSee funcdata.h and ../cmd/internal/objabi/funcdata.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FUNCDATA_LocalsPointerMaps",
              "documentation": {
                "identifier": "_FUNCDATA_LocalsPointerMaps",
                "newPage": false,
                "searchKey": "runtime._FUNCDATA_LocalsPointerMaps",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FUNCDATA_LocalsPointerMaps"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FUNCDATA_LocalsPointerMaps = 1\n```\n\nPCDATA and FUNCDATA table indexes. \n\nSee funcdata.h and ../cmd/internal/objabi/funcdata.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FUNCDATA_StackObjects",
              "documentation": {
                "identifier": "_FUNCDATA_StackObjects",
                "newPage": false,
                "searchKey": "runtime._FUNCDATA_StackObjects",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FUNCDATA_StackObjects"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FUNCDATA_StackObjects = 2\n```\n\nPCDATA and FUNCDATA table indexes. \n\nSee funcdata.h and ../cmd/internal/objabi/funcdata.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FUNCDATA_InlTree",
              "documentation": {
                "identifier": "_FUNCDATA_InlTree",
                "newPage": false,
                "searchKey": "runtime._FUNCDATA_InlTree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FUNCDATA_InlTree"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FUNCDATA_InlTree = 3\n```\n\nPCDATA and FUNCDATA table indexes. \n\nSee funcdata.h and ../cmd/internal/objabi/funcdata.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FUNCDATA_OpenCodedDeferInfo",
              "documentation": {
                "identifier": "_FUNCDATA_OpenCodedDeferInfo",
                "newPage": false,
                "searchKey": "runtime._FUNCDATA_OpenCodedDeferInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FUNCDATA_OpenCodedDeferInfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FUNCDATA_OpenCodedDeferInfo = 4\n```\n\nPCDATA and FUNCDATA table indexes. \n\nSee funcdata.h and ../cmd/internal/objabi/funcdata.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_FUNCDATA_ArgInfo",
              "documentation": {
                "identifier": "_FUNCDATA_ArgInfo",
                "newPage": false,
                "searchKey": "runtime._FUNCDATA_ArgInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _FUNCDATA_ArgInfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _FUNCDATA_ArgInfo = 5\n```\n\nPCDATA and FUNCDATA table indexes. \n\nSee funcdata.h and ../cmd/internal/objabi/funcdata.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_ArgsSizeUnknown",
              "documentation": {
                "identifier": "_ArgsSizeUnknown",
                "newPage": false,
                "searchKey": "runtime._ArgsSizeUnknown",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _ArgsSizeUnknown"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _ArgsSizeUnknown = -0x80000000\n```\n\nPCDATA and FUNCDATA table indexes. \n\nSee funcdata.h and ../cmd/internal/objabi/funcdata.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PCDATA_UnsafePointSafe",
              "documentation": {
                "identifier": "_PCDATA_UnsafePointSafe",
                "newPage": false,
                "searchKey": "runtime._PCDATA_UnsafePointSafe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PCDATA_UnsafePointSafe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PCDATA_UnsafePointSafe = -1 // Safe for async preemption\n\n```\n\nPCDATA_UnsafePoint values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PCDATA_UnsafePointUnsafe",
              "documentation": {
                "identifier": "_PCDATA_UnsafePointUnsafe",
                "newPage": false,
                "searchKey": "runtime._PCDATA_UnsafePointUnsafe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PCDATA_UnsafePointUnsafe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PCDATA_UnsafePointUnsafe = -2 // Unsafe for async preemption\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PCDATA_Restart1",
              "documentation": {
                "identifier": "_PCDATA_Restart1",
                "newPage": false,
                "searchKey": "runtime._PCDATA_Restart1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PCDATA_Restart1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PCDATA_Restart1 = -3\n```\n\n_PCDATA_Restart1(2) apply on a sequence of instructions, within which if an async preemption happens, we should back off the PC to the start of the sequence when resume. We need two so we can distinguish the start/end of the sequence in case that two sequences are next to each other. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PCDATA_Restart2",
              "documentation": {
                "identifier": "_PCDATA_Restart2",
                "newPage": false,
                "searchKey": "runtime._PCDATA_Restart2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PCDATA_Restart2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PCDATA_Restart2 = -4\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_PCDATA_RestartAtEntry",
              "documentation": {
                "identifier": "_PCDATA_RestartAtEntry",
                "newPage": false,
                "searchKey": "runtime._PCDATA_RestartAtEntry",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _PCDATA_RestartAtEntry"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _PCDATA_RestartAtEntry = -5\n```\n\nLike _PCDATA_RestartAtEntry, but back to function entry if async preempted. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_normal",
              "documentation": {
                "identifier": "funcID_normal",
                "newPage": false,
                "searchKey": "runtime.funcID_normal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_normal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_normal funcID = iota // not a special function\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_abort",
              "documentation": {
                "identifier": "funcID_abort",
                "newPage": false,
                "searchKey": "runtime.funcID_abort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_abort"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_abort\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_asmcgocall",
              "documentation": {
                "identifier": "funcID_asmcgocall",
                "newPage": false,
                "searchKey": "runtime.funcID_asmcgocall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_asmcgocall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_asmcgocall\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_asyncPreempt",
              "documentation": {
                "identifier": "funcID_asyncPreempt",
                "newPage": false,
                "searchKey": "runtime.funcID_asyncPreempt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_asyncPreempt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_asyncPreempt\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_cgocallback",
              "documentation": {
                "identifier": "funcID_cgocallback",
                "newPage": false,
                "searchKey": "runtime.funcID_cgocallback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_cgocallback"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_cgocallback\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_debugCallV2",
              "documentation": {
                "identifier": "funcID_debugCallV2",
                "newPage": false,
                "searchKey": "runtime.funcID_debugCallV2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_debugCallV2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_debugCallV2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_gcBgMarkWorker",
              "documentation": {
                "identifier": "funcID_gcBgMarkWorker",
                "newPage": false,
                "searchKey": "runtime.funcID_gcBgMarkWorker",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_gcBgMarkWorker"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_gcBgMarkWorker\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_goexit",
              "documentation": {
                "identifier": "funcID_goexit",
                "newPage": false,
                "searchKey": "runtime.funcID_goexit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_goexit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_goexit\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_gogo",
              "documentation": {
                "identifier": "funcID_gogo",
                "newPage": false,
                "searchKey": "runtime.funcID_gogo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_gogo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_gogo\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_gopanic",
              "documentation": {
                "identifier": "funcID_gopanic",
                "newPage": false,
                "searchKey": "runtime.funcID_gopanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_gopanic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_gopanic\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_handleAsyncEvent",
              "documentation": {
                "identifier": "funcID_handleAsyncEvent",
                "newPage": false,
                "searchKey": "runtime.funcID_handleAsyncEvent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_handleAsyncEvent"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_handleAsyncEvent\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_jmpdefer",
              "documentation": {
                "identifier": "funcID_jmpdefer",
                "newPage": false,
                "searchKey": "runtime.funcID_jmpdefer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_jmpdefer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_jmpdefer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_mcall",
              "documentation": {
                "identifier": "funcID_mcall",
                "newPage": false,
                "searchKey": "runtime.funcID_mcall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_mcall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_mcall\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_morestack",
              "documentation": {
                "identifier": "funcID_morestack",
                "newPage": false,
                "searchKey": "runtime.funcID_morestack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_morestack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_morestack\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_mstart",
              "documentation": {
                "identifier": "funcID_mstart",
                "newPage": false,
                "searchKey": "runtime.funcID_mstart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_mstart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_mstart\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_panicwrap",
              "documentation": {
                "identifier": "funcID_panicwrap",
                "newPage": false,
                "searchKey": "runtime.funcID_panicwrap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_panicwrap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_panicwrap\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_rt0_go",
              "documentation": {
                "identifier": "funcID_rt0_go",
                "newPage": false,
                "searchKey": "runtime.funcID_rt0_go",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_rt0_go"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_rt0_go\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_runfinq",
              "documentation": {
                "identifier": "funcID_runfinq",
                "newPage": false,
                "searchKey": "runtime.funcID_runfinq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_runfinq"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_runfinq\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_runtime_main",
              "documentation": {
                "identifier": "funcID_runtime_main",
                "newPage": false,
                "searchKey": "runtime.funcID_runtime_main",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_runtime_main"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_runtime_main\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_sigpanic",
              "documentation": {
                "identifier": "funcID_sigpanic",
                "newPage": false,
                "searchKey": "runtime.funcID_sigpanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_sigpanic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_sigpanic\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_systemstack",
              "documentation": {
                "identifier": "funcID_systemstack",
                "newPage": false,
                "searchKey": "runtime.funcID_systemstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_systemstack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_systemstack\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_systemstack_switch",
              "documentation": {
                "identifier": "funcID_systemstack_switch",
                "newPage": false,
                "searchKey": "runtime.funcID_systemstack_switch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_systemstack_switch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_systemstack_switch\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID_wrapper",
              "documentation": {
                "identifier": "funcID_wrapper",
                "newPage": false,
                "searchKey": "runtime.funcID_wrapper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcID_wrapper"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcID_wrapper // any autogenerated code (hash/eq algorithms, method wrappers, etc.)\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcFlag_TOPFRAME",
              "documentation": {
                "identifier": "funcFlag_TOPFRAME",
                "newPage": false,
                "searchKey": "runtime.funcFlag_TOPFRAME",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcFlag_TOPFRAME"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcFlag_TOPFRAME funcFlag = 1 << iota\n```\n\nTOPFRAME indicates a function that appears at the top of its stack. The traceback routine stop at such a function and consider that a successful, complete traversal of the stack. Examples of TOPFRAME functions include goexit, which appears at the top of a user goroutine stack, and mstart, which appears at the top of a system goroutine stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcFlag_SPWRITE",
              "documentation": {
                "identifier": "funcFlag_SPWRITE",
                "newPage": false,
                "searchKey": "runtime.funcFlag_SPWRITE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const funcFlag_SPWRITE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst funcFlag_SPWRITE\n```\n\nSPWRITE indicates a function that writes an arbitrary value to SP (any write other than adding or subtracting a constant amount). The traceback routines cannot encode such changes into the pcsp tables, so the function traceback cannot safely unwind past SPWRITE functions. Stopping at an SPWRITE function is considered to be an incomplete unwinding of the stack. In certain contexts (in particular garbage collector stack scans) that is a fatal error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minfunc",
              "documentation": {
                "identifier": "minfunc",
                "newPage": false,
                "searchKey": "runtime.minfunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const minfunc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst minfunc = 16 // minimum function size\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pcbucketsize",
              "documentation": {
                "identifier": "pcbucketsize",
                "newPage": false,
                "searchKey": "runtime.pcbucketsize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const pcbucketsize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst pcbucketsize = 256 * minfunc // size of bucket in the pc->func lookup table\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugPcln",
              "documentation": {
                "identifier": "debugPcln",
                "newPage": false,
                "searchKey": "runtime.debugPcln",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugPcln"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugPcln = false\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timerNoStatus",
              "documentation": {
                "identifier": "timerNoStatus",
                "newPage": false,
                "searchKey": "runtime.timerNoStatus",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timerNoStatus"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timerNoStatus = iota\n```\n\nValues for the timer status field. \n\nTimer has no status set yet. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timerWaiting",
              "documentation": {
                "identifier": "timerWaiting",
                "newPage": false,
                "searchKey": "runtime.timerWaiting",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timerWaiting"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timerWaiting\n```\n\nValues for the timer status field. \n\nWaiting for timer to fire. The timer is in some P's heap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timerRunning",
              "documentation": {
                "identifier": "timerRunning",
                "newPage": false,
                "searchKey": "runtime.timerRunning",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timerRunning"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timerRunning\n```\n\nValues for the timer status field. \n\nRunning the timer function. A timer will only have this status briefly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timerDeleted",
              "documentation": {
                "identifier": "timerDeleted",
                "newPage": false,
                "searchKey": "runtime.timerDeleted",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timerDeleted"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timerDeleted\n```\n\nValues for the timer status field. \n\nThe timer is deleted and should be removed. It should not be run, but it is still in some P's heap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timerRemoving",
              "documentation": {
                "identifier": "timerRemoving",
                "newPage": false,
                "searchKey": "runtime.timerRemoving",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timerRemoving"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timerRemoving\n```\n\nValues for the timer status field. \n\nThe timer is being removed. The timer will only have this status briefly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timerRemoved",
              "documentation": {
                "identifier": "timerRemoved",
                "newPage": false,
                "searchKey": "runtime.timerRemoved",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timerRemoved"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timerRemoved\n```\n\nValues for the timer status field. \n\nThe timer has been stopped. It is not in any P's heap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timerModifying",
              "documentation": {
                "identifier": "timerModifying",
                "newPage": false,
                "searchKey": "runtime.timerModifying",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timerModifying"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timerModifying\n```\n\nValues for the timer status field. \n\nThe timer is being modified. The timer will only have this status briefly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timerModifiedEarlier",
              "documentation": {
                "identifier": "timerModifiedEarlier",
                "newPage": false,
                "searchKey": "runtime.timerModifiedEarlier",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timerModifiedEarlier"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timerModifiedEarlier\n```\n\nValues for the timer status field. \n\nThe timer has been modified to an earlier time. The new when value is in the nextwhen field. The timer is in some P's heap, possibly in the wrong place. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timerModifiedLater",
              "documentation": {
                "identifier": "timerModifiedLater",
                "newPage": false,
                "searchKey": "runtime.timerModifiedLater",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timerModifiedLater"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timerModifiedLater\n```\n\nValues for the timer status field. \n\nThe timer has been modified to the same or a later time. The new when value is in the nextwhen field. The timer is in some P's heap, possibly in the wrong place. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timerMoving",
              "documentation": {
                "identifier": "timerMoving",
                "newPage": false,
                "searchKey": "runtime.timerMoving",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const timerMoving"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst timerMoving\n```\n\nValues for the timer status field. \n\nThe timer has been modified and is being moved. The timer will only have this status briefly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxWhen",
              "documentation": {
                "identifier": "maxWhen",
                "newPage": false,
                "searchKey": "runtime.maxWhen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxWhen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxWhen = 1<<63 - 1\n```\n\nmaxWhen is the maximum value for timer's when field. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#verifyTimers",
              "documentation": {
                "identifier": "verifyTimers",
                "newPage": false,
                "searchKey": "runtime.verifyTimers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const verifyTimers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst verifyTimers = false\n```\n\nverifyTimers can be set to true to add debugging checks that the timer heaps are valid. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvNone",
              "documentation": {
                "identifier": "traceEvNone",
                "newPage": false,
                "searchKey": "runtime.traceEvNone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvNone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvNone = 0 // unused\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvBatch",
              "documentation": {
                "identifier": "traceEvBatch",
                "newPage": false,
                "searchKey": "runtime.traceEvBatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvBatch"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvBatch = 1 // start of per-P batch of events [pid, timestamp]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvFrequency",
              "documentation": {
                "identifier": "traceEvFrequency",
                "newPage": false,
                "searchKey": "runtime.traceEvFrequency",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvFrequency"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvFrequency = 2 // contains tracer timer frequency [frequency (ticks per second)]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvStack",
              "documentation": {
                "identifier": "traceEvStack",
                "newPage": false,
                "searchKey": "runtime.traceEvStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvStack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvStack // stack [stack id, number of PCs, array of {PC, func string ID, file string ID, line}]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGomaxprocs",
              "documentation": {
                "identifier": "traceEvGomaxprocs",
                "newPage": false,
                "searchKey": "runtime.traceEvGomaxprocs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGomaxprocs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGomaxprocs = 4 // current value of GOMAXPROCS [timestamp, GOMAXPROCS, stack id]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvProcStart",
              "documentation": {
                "identifier": "traceEvProcStart",
                "newPage": false,
                "searchKey": "runtime.traceEvProcStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvProcStart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvProcStart = 5 // start of P [timestamp, thread id]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvProcStop",
              "documentation": {
                "identifier": "traceEvProcStop",
                "newPage": false,
                "searchKey": "runtime.traceEvProcStop",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvProcStop"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvProcStop = 6 // stop of P [timestamp]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGCStart",
              "documentation": {
                "identifier": "traceEvGCStart",
                "newPage": false,
                "searchKey": "runtime.traceEvGCStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGCStart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGCStart = 7 // GC start [timestamp, seq, stack id]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGCDone",
              "documentation": {
                "identifier": "traceEvGCDone",
                "newPage": false,
                "searchKey": "runtime.traceEvGCDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGCDone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGCDone = 8 // GC done [timestamp]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGCSTWStart",
              "documentation": {
                "identifier": "traceEvGCSTWStart",
                "newPage": false,
                "searchKey": "runtime.traceEvGCSTWStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGCSTWStart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGCSTWStart = 9 // GC STW start [timestamp, kind]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGCSTWDone",
              "documentation": {
                "identifier": "traceEvGCSTWDone",
                "newPage": false,
                "searchKey": "runtime.traceEvGCSTWDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGCSTWDone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGCSTWDone = 10 // GC STW done [timestamp]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGCSweepStart",
              "documentation": {
                "identifier": "traceEvGCSweepStart",
                "newPage": false,
                "searchKey": "runtime.traceEvGCSweepStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGCSweepStart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGCSweepStart = 11 // GC sweep start [timestamp, stack id]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGCSweepDone",
              "documentation": {
                "identifier": "traceEvGCSweepDone",
                "newPage": false,
                "searchKey": "runtime.traceEvGCSweepDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGCSweepDone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGCSweepDone = 12 // GC sweep done [timestamp, swept, reclaimed]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoCreate",
              "documentation": {
                "identifier": "traceEvGoCreate",
                "newPage": false,
                "searchKey": "runtime.traceEvGoCreate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoCreate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoCreate // goroutine creation [timestamp, new goroutine id, new stack id, stack id]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoStart",
              "documentation": {
                "identifier": "traceEvGoStart",
                "newPage": false,
                "searchKey": "runtime.traceEvGoStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoStart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoStart = 14 // goroutine starts running [timestamp, goroutine id, seq]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoEnd",
              "documentation": {
                "identifier": "traceEvGoEnd",
                "newPage": false,
                "searchKey": "runtime.traceEvGoEnd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoEnd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoEnd = 15 // goroutine ends [timestamp]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoStop",
              "documentation": {
                "identifier": "traceEvGoStop",
                "newPage": false,
                "searchKey": "runtime.traceEvGoStop",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoStop"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoStop = 16 // goroutine stops (like in select{}) [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoSched",
              "documentation": {
                "identifier": "traceEvGoSched",
                "newPage": false,
                "searchKey": "runtime.traceEvGoSched",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoSched"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoSched = 17 // goroutine calls Gosched [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoPreempt",
              "documentation": {
                "identifier": "traceEvGoPreempt",
                "newPage": false,
                "searchKey": "runtime.traceEvGoPreempt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoPreempt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoPreempt = 18 // goroutine is preempted [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoSleep",
              "documentation": {
                "identifier": "traceEvGoSleep",
                "newPage": false,
                "searchKey": "runtime.traceEvGoSleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoSleep"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoSleep = 19 // goroutine calls Sleep [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoBlock",
              "documentation": {
                "identifier": "traceEvGoBlock",
                "newPage": false,
                "searchKey": "runtime.traceEvGoBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoBlock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoBlock = 20 // goroutine blocks [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoUnblock",
              "documentation": {
                "identifier": "traceEvGoUnblock",
                "newPage": false,
                "searchKey": "runtime.traceEvGoUnblock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoUnblock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoUnblock = 21 // goroutine is unblocked [timestamp, goroutine id, seq, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoBlockSend",
              "documentation": {
                "identifier": "traceEvGoBlockSend",
                "newPage": false,
                "searchKey": "runtime.traceEvGoBlockSend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoBlockSend"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoBlockSend = 22 // goroutine blocks on chan send [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoBlockRecv",
              "documentation": {
                "identifier": "traceEvGoBlockRecv",
                "newPage": false,
                "searchKey": "runtime.traceEvGoBlockRecv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoBlockRecv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoBlockRecv = 23 // goroutine blocks on chan recv [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoBlockSelect",
              "documentation": {
                "identifier": "traceEvGoBlockSelect",
                "newPage": false,
                "searchKey": "runtime.traceEvGoBlockSelect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoBlockSelect"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoBlockSelect = 24 // goroutine blocks on select [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoBlockSync",
              "documentation": {
                "identifier": "traceEvGoBlockSync",
                "newPage": false,
                "searchKey": "runtime.traceEvGoBlockSync",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoBlockSync"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoBlockSync = 25 // goroutine blocks on Mutex/RWMutex [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoBlockCond",
              "documentation": {
                "identifier": "traceEvGoBlockCond",
                "newPage": false,
                "searchKey": "runtime.traceEvGoBlockCond",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoBlockCond"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoBlockCond = 26 // goroutine blocks on Cond [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoBlockNet",
              "documentation": {
                "identifier": "traceEvGoBlockNet",
                "newPage": false,
                "searchKey": "runtime.traceEvGoBlockNet",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoBlockNet"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoBlockNet = 27 // goroutine blocks on network [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoSysCall",
              "documentation": {
                "identifier": "traceEvGoSysCall",
                "newPage": false,
                "searchKey": "runtime.traceEvGoSysCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoSysCall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoSysCall = 28 // syscall enter [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoSysExit",
              "documentation": {
                "identifier": "traceEvGoSysExit",
                "newPage": false,
                "searchKey": "runtime.traceEvGoSysExit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoSysExit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoSysExit = 29 // syscall exit [timestamp, goroutine id, seq, real timestamp]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoSysBlock",
              "documentation": {
                "identifier": "traceEvGoSysBlock",
                "newPage": false,
                "searchKey": "runtime.traceEvGoSysBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoSysBlock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoSysBlock = 30 // syscall blocks [timestamp]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoWaiting",
              "documentation": {
                "identifier": "traceEvGoWaiting",
                "newPage": false,
                "searchKey": "runtime.traceEvGoWaiting",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoWaiting"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoWaiting // denotes that goroutine is blocked when tracing starts [timestamp, goroutine id]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoInSyscall",
              "documentation": {
                "identifier": "traceEvGoInSyscall",
                "newPage": false,
                "searchKey": "runtime.traceEvGoInSyscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoInSyscall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoInSyscall // denotes that goroutine is in syscall when tracing starts [timestamp, goroutine id]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvHeapAlloc",
              "documentation": {
                "identifier": "traceEvHeapAlloc",
                "newPage": false,
                "searchKey": "runtime.traceEvHeapAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvHeapAlloc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvHeapAlloc = 33 // gcController.heapLive change [timestamp, heap_alloc]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvHeapGoal",
              "documentation": {
                "identifier": "traceEvHeapGoal",
                "newPage": false,
                "searchKey": "runtime.traceEvHeapGoal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvHeapGoal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvHeapGoal // gcController.heapGoal (formerly next_gc) change [timestamp, heap goal in bytes]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvTimerGoroutine",
              "documentation": {
                "identifier": "traceEvTimerGoroutine",
                "newPage": false,
                "searchKey": "runtime.traceEvTimerGoroutine",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvTimerGoroutine"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvTimerGoroutine // not currently used; previously denoted timer goroutine [timer goroutine id]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvFutileWakeup",
              "documentation": {
                "identifier": "traceEvFutileWakeup",
                "newPage": false,
                "searchKey": "runtime.traceEvFutileWakeup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvFutileWakeup"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvFutileWakeup // denotes that the previous wakeup of this goroutine was futile [timestamp]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvString",
              "documentation": {
                "identifier": "traceEvString",
                "newPage": false,
                "searchKey": "runtime.traceEvString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvString"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvString = 37 // string dictionary entry [ID, length, string]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoStartLocal",
              "documentation": {
                "identifier": "traceEvGoStartLocal",
                "newPage": false,
                "searchKey": "runtime.traceEvGoStartLocal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoStartLocal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoStartLocal // goroutine starts running on the same P as the last event [timestamp, goroutine id]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoUnblockLocal",
              "documentation": {
                "identifier": "traceEvGoUnblockLocal",
                "newPage": false,
                "searchKey": "runtime.traceEvGoUnblockLocal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoUnblockLocal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoUnblockLocal // goroutine is unblocked on the same P as the last event [timestamp, goroutine id, stack]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoSysExitLocal",
              "documentation": {
                "identifier": "traceEvGoSysExitLocal",
                "newPage": false,
                "searchKey": "runtime.traceEvGoSysExitLocal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoSysExitLocal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoSysExitLocal // syscall exit on the same P as the last event [timestamp, goroutine id, real timestamp]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoStartLabel",
              "documentation": {
                "identifier": "traceEvGoStartLabel",
                "newPage": false,
                "searchKey": "runtime.traceEvGoStartLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoStartLabel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoStartLabel // goroutine starts running with label [timestamp, goroutine id, seq, label string id]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGoBlockGC",
              "documentation": {
                "identifier": "traceEvGoBlockGC",
                "newPage": false,
                "searchKey": "runtime.traceEvGoBlockGC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGoBlockGC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGoBlockGC = 42 // goroutine blocks on GC assist [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGCMarkAssistStart",
              "documentation": {
                "identifier": "traceEvGCMarkAssistStart",
                "newPage": false,
                "searchKey": "runtime.traceEvGCMarkAssistStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGCMarkAssistStart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGCMarkAssistStart = 43 // GC mark assist start [timestamp, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvGCMarkAssistDone",
              "documentation": {
                "identifier": "traceEvGCMarkAssistDone",
                "newPage": false,
                "searchKey": "runtime.traceEvGCMarkAssistDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvGCMarkAssistDone"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvGCMarkAssistDone = 44 // GC mark assist done [timestamp]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvUserTaskCreate",
              "documentation": {
                "identifier": "traceEvUserTaskCreate",
                "newPage": false,
                "searchKey": "runtime.traceEvUserTaskCreate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvUserTaskCreate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvUserTaskCreate // trace.NewContext [timestamp, internal task id, internal parent task id, stack, name string]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvUserTaskEnd",
              "documentation": {
                "identifier": "traceEvUserTaskEnd",
                "newPage": false,
                "searchKey": "runtime.traceEvUserTaskEnd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvUserTaskEnd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvUserTaskEnd = 46 // end of a task [timestamp, internal task id, stack]\n\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvUserRegion",
              "documentation": {
                "identifier": "traceEvUserRegion",
                "newPage": false,
                "searchKey": "runtime.traceEvUserRegion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvUserRegion"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvUserRegion // trace.WithRegion [timestamp, internal task id, mode(0:start, 1:end), stack, name string]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvUserLog",
              "documentation": {
                "identifier": "traceEvUserLog",
                "newPage": false,
                "searchKey": "runtime.traceEvUserLog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvUserLog"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvUserLog // trace.Log [timestamp, internal task id, key string id, stack, value string]\n = ...\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvCount",
              "documentation": {
                "identifier": "traceEvCount",
                "newPage": false,
                "searchKey": "runtime.traceEvCount",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceEvCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceEvCount = 49\n```\n\nEvent types in the trace, args are given in square brackets. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceTickDiv",
              "documentation": {
                "identifier": "traceTickDiv",
                "newPage": false,
                "searchKey": "runtime.traceTickDiv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceTickDiv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceTickDiv = 16 + 48*(sys.Goarch386|sys.GoarchAmd64)\n```\n\nTimestamps in trace are cputicks/traceTickDiv. This makes absolute values of timestamp diffs smaller, and so they are encoded in less number of bytes. 64 on x86 is somewhat arbitrary (one tick is ~20ns on a 3GHz machine). The suggested increment frequency for PowerPC's time base register is 512 MHz according to Power ISA v2.07 section 6.2, so we use 16 on ppc64 and ppc64le. Tracing won't work reliably for architectures where cputicks is emulated by nanotime, so the value doesn't matter for those architectures. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceStackSize",
              "documentation": {
                "identifier": "traceStackSize",
                "newPage": false,
                "searchKey": "runtime.traceStackSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceStackSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceStackSize = 128\n```\n\nMaximum number of PCs in a single stack trace. Since events contain only stack id rather than whole stack trace, we can allow quite large values here. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGlobProc",
              "documentation": {
                "identifier": "traceGlobProc",
                "newPage": false,
                "searchKey": "runtime.traceGlobProc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceGlobProc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceGlobProc = -1\n```\n\nIdentifier of a fake P that is used when we trace without a real P. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceBytesPerNumber",
              "documentation": {
                "identifier": "traceBytesPerNumber",
                "newPage": false,
                "searchKey": "runtime.traceBytesPerNumber",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceBytesPerNumber"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceBytesPerNumber = 10\n```\n\nMaximum number of bytes to encode uint64 in base-128. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceArgCountShift",
              "documentation": {
                "identifier": "traceArgCountShift",
                "newPage": false,
                "searchKey": "runtime.traceArgCountShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceArgCountShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceArgCountShift = 6\n```\n\nShift of the number of arguments in the first event byte. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceFutileWakeup",
              "documentation": {
                "identifier": "traceFutileWakeup",
                "newPage": false,
                "searchKey": "runtime.traceFutileWakeup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const traceFutileWakeup"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst traceFutileWakeup byte = 128\n```\n\nFlag passed to traceGoPark to denote that the previous wakeup of this goroutine was futile. For example, a goroutine was unblocked on a mutex, but another goroutine got ahead and acquired the mutex before the first goroutine is scheduled, so the first goroutine has to block again. Such wakeups happen on buffered channels and sync.Mutex, but are generally not interesting for end user. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#usesLR",
              "documentation": {
                "identifier": "usesLR",
                "newPage": false,
                "searchKey": "runtime.usesLR",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const usesLR"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst usesLR = sys.MinFrameSize > 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tflagUncommon",
              "documentation": {
                "identifier": "tflagUncommon",
                "newPage": false,
                "searchKey": "runtime.tflagUncommon",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tflagUncommon"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tflagUncommon tflag = 1 << 0\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tflagExtraStar",
              "documentation": {
                "identifier": "tflagExtraStar",
                "newPage": false,
                "searchKey": "runtime.tflagExtraStar",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tflagExtraStar"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tflagExtraStar tflag = 1 << 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tflagNamed",
              "documentation": {
                "identifier": "tflagNamed",
                "newPage": false,
                "searchKey": "runtime.tflagNamed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tflagNamed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tflagNamed tflag = 1 << 2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tflagRegularMemory",
              "documentation": {
                "identifier": "tflagRegularMemory",
                "newPage": false,
                "searchKey": "runtime.tflagRegularMemory",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tflagRegularMemory"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tflagRegularMemory tflag // equal and hash can treat values of this type as a single region of t.size bytes\n = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindBool",
              "documentation": {
                "identifier": "kindBool",
                "newPage": false,
                "searchKey": "runtime.kindBool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindBool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindBool = 1 + iota\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindInt",
              "documentation": {
                "identifier": "kindInt",
                "newPage": false,
                "searchKey": "runtime.kindInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindInt"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindInt\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindInt8",
              "documentation": {
                "identifier": "kindInt8",
                "newPage": false,
                "searchKey": "runtime.kindInt8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindInt8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindInt8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindInt16",
              "documentation": {
                "identifier": "kindInt16",
                "newPage": false,
                "searchKey": "runtime.kindInt16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindInt16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindInt16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindInt32",
              "documentation": {
                "identifier": "kindInt32",
                "newPage": false,
                "searchKey": "runtime.kindInt32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindInt32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindInt32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindInt64",
              "documentation": {
                "identifier": "kindInt64",
                "newPage": false,
                "searchKey": "runtime.kindInt64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindInt64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindInt64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindUint",
              "documentation": {
                "identifier": "kindUint",
                "newPage": false,
                "searchKey": "runtime.kindUint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindUint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindUint\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindUint8",
              "documentation": {
                "identifier": "kindUint8",
                "newPage": false,
                "searchKey": "runtime.kindUint8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindUint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindUint8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindUint16",
              "documentation": {
                "identifier": "kindUint16",
                "newPage": false,
                "searchKey": "runtime.kindUint16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindUint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindUint16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindUint32",
              "documentation": {
                "identifier": "kindUint32",
                "newPage": false,
                "searchKey": "runtime.kindUint32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindUint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindUint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindUint64",
              "documentation": {
                "identifier": "kindUint64",
                "newPage": false,
                "searchKey": "runtime.kindUint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindUint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindUint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindUintptr",
              "documentation": {
                "identifier": "kindUintptr",
                "newPage": false,
                "searchKey": "runtime.kindUintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindUintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindUintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindFloat32",
              "documentation": {
                "identifier": "kindFloat32",
                "newPage": false,
                "searchKey": "runtime.kindFloat32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindFloat32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindFloat32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindFloat64",
              "documentation": {
                "identifier": "kindFloat64",
                "newPage": false,
                "searchKey": "runtime.kindFloat64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindFloat64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindFloat64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindComplex64",
              "documentation": {
                "identifier": "kindComplex64",
                "newPage": false,
                "searchKey": "runtime.kindComplex64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindComplex64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindComplex64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindComplex128",
              "documentation": {
                "identifier": "kindComplex128",
                "newPage": false,
                "searchKey": "runtime.kindComplex128",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindComplex128"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindComplex128\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindArray",
              "documentation": {
                "identifier": "kindArray",
                "newPage": false,
                "searchKey": "runtime.kindArray",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindArray"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindArray\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindChan",
              "documentation": {
                "identifier": "kindChan",
                "newPage": false,
                "searchKey": "runtime.kindChan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindChan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindChan\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindFunc",
              "documentation": {
                "identifier": "kindFunc",
                "newPage": false,
                "searchKey": "runtime.kindFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindFunc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindFunc\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindInterface",
              "documentation": {
                "identifier": "kindInterface",
                "newPage": false,
                "searchKey": "runtime.kindInterface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindInterface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindInterface\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindMap",
              "documentation": {
                "identifier": "kindMap",
                "newPage": false,
                "searchKey": "runtime.kindMap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindMap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindMap\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindPtr",
              "documentation": {
                "identifier": "kindPtr",
                "newPage": false,
                "searchKey": "runtime.kindPtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindPtr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindPtr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindSlice",
              "documentation": {
                "identifier": "kindSlice",
                "newPage": false,
                "searchKey": "runtime.kindSlice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindSlice"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindSlice\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindString",
              "documentation": {
                "identifier": "kindString",
                "newPage": false,
                "searchKey": "runtime.kindString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindString"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindString\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindStruct",
              "documentation": {
                "identifier": "kindStruct",
                "newPage": false,
                "searchKey": "runtime.kindStruct",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindStruct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindStruct\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindUnsafePointer",
              "documentation": {
                "identifier": "kindUnsafePointer",
                "newPage": false,
                "searchKey": "runtime.kindUnsafePointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindUnsafePointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindUnsafePointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindDirectIface",
              "documentation": {
                "identifier": "kindDirectIface",
                "newPage": false,
                "searchKey": "runtime.kindDirectIface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindDirectIface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindDirectIface = 1 << 5\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindGCProg",
              "documentation": {
                "identifier": "kindGCProg",
                "newPage": false,
                "searchKey": "runtime.kindGCProg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindGCProg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindGCProg = 1 << 6\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kindMask",
              "documentation": {
                "identifier": "kindMask",
                "newPage": false,
                "searchKey": "runtime.kindMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const kindMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst kindMask = (1 << 5) - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runeError",
              "documentation": {
                "identifier": "runeError",
                "newPage": false,
                "searchKey": "runtime.runeError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const runeError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst runeError = '\\uFFFD' // the \"error\" Rune or \"Unicode replacement character\"\n\n```\n\nNumbers fundamental to the encoding. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runeSelf",
              "documentation": {
                "identifier": "runeSelf",
                "newPage": false,
                "searchKey": "runtime.runeSelf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const runeSelf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst runeSelf = 0x80 // characters below runeSelf are represented as themselves in a single byte.\n\n```\n\nNumbers fundamental to the encoding. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxRune",
              "documentation": {
                "identifier": "maxRune",
                "newPage": false,
                "searchKey": "runtime.maxRune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxRune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxRune = '\\U0010FFFF' // Maximum valid Unicode code point.\n\n```\n\nNumbers fundamental to the encoding. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#surrogateMin",
              "documentation": {
                "identifier": "surrogateMin",
                "newPage": false,
                "searchKey": "runtime.surrogateMin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const surrogateMin"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst surrogateMin = 0xD800\n```\n\nCode points in the surrogate range are not valid for UTF-8. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#surrogateMax",
              "documentation": {
                "identifier": "surrogateMax",
                "newPage": false,
                "searchKey": "runtime.surrogateMax",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const surrogateMax"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst surrogateMax = 0xDFFF\n```\n\nCode points in the surrogate range are not valid for UTF-8. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#t1",
              "documentation": {
                "identifier": "t1",
                "newPage": false,
                "searchKey": "runtime.t1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const t1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst t1 = 0x00 // 0000 0000\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tx",
              "documentation": {
                "identifier": "tx",
                "newPage": false,
                "searchKey": "runtime.tx",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const tx"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst tx = 0x80 // 1000 0000\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#t2",
              "documentation": {
                "identifier": "t2",
                "newPage": false,
                "searchKey": "runtime.t2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const t2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst t2 = 0xC0 // 1100 0000\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#t3",
              "documentation": {
                "identifier": "t3",
                "newPage": false,
                "searchKey": "runtime.t3",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const t3"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst t3 = 0xE0 // 1110 0000\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#t4",
              "documentation": {
                "identifier": "t4",
                "newPage": false,
                "searchKey": "runtime.t4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const t4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst t4 = 0xF0 // 1111 0000\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#t5",
              "documentation": {
                "identifier": "t5",
                "newPage": false,
                "searchKey": "runtime.t5",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const t5"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst t5 = 0xF8 // 1111 1000\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maskx",
              "documentation": {
                "identifier": "maskx",
                "newPage": false,
                "searchKey": "runtime.maskx",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maskx"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maskx = 0x3F // 0011 1111\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mask2",
              "documentation": {
                "identifier": "mask2",
                "newPage": false,
                "searchKey": "runtime.mask2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mask2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mask2 = 0x1F // 0001 1111\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mask3",
              "documentation": {
                "identifier": "mask3",
                "newPage": false,
                "searchKey": "runtime.mask3",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mask3"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mask3 = 0x0F // 0000 1111\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mask4",
              "documentation": {
                "identifier": "mask4",
                "newPage": false,
                "searchKey": "runtime.mask4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const mask4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst mask4 = 0x07 // 0000 0111\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#rune1Max",
              "documentation": {
                "identifier": "rune1Max",
                "newPage": false,
                "searchKey": "runtime.rune1Max",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const rune1Max"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst rune1Max = 1<<7 - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#rune2Max",
              "documentation": {
                "identifier": "rune2Max",
                "newPage": false,
                "searchKey": "runtime.rune2Max",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const rune2Max"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst rune2Max = 1<<11 - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#rune3Max",
              "documentation": {
                "identifier": "rune3Max",
                "newPage": false,
                "searchKey": "runtime.rune3Max",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const rune3Max"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst rune3Max = 1<<16 - 1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#locb",
              "documentation": {
                "identifier": "locb",
                "newPage": false,
                "searchKey": "runtime.locb",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const locb"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst locb = 0x80 // 1000 0000\n\n```\n\nThe default lowest and highest continuation byte. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hicb",
              "documentation": {
                "identifier": "hicb",
                "newPage": false,
                "searchKey": "runtime.hicb",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const hicb"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst hicb = 0xBF // 1011 1111\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#DlogEnabled",
              "documentation": {
                "identifier": "DlogEnabled",
                "newPage": false,
                "searchKey": "runtime.DlogEnabled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const DlogEnabled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst DlogEnabled = dlogEnabled\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#DebugLogBytes",
              "documentation": {
                "identifier": "DebugLogBytes",
                "newPage": false,
                "searchKey": "runtime.DebugLogBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const DebugLogBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst DebugLogBytes = debugLogBytes\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#DebugLogStringLimit",
              "documentation": {
                "identifier": "DebugLogStringLimit",
                "newPage": false,
                "searchKey": "runtime.DebugLogStringLimit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const DebugLogStringLimit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst DebugLogStringLimit = debugLogStringLimit\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ENOMEM",
              "documentation": {
                "identifier": "ENOMEM",
                "newPage": false,
                "searchKey": "runtime.ENOMEM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const ENOMEM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ENOMEM = _ENOMEM\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MAP_ANON",
              "documentation": {
                "identifier": "MAP_ANON",
                "newPage": false,
                "searchKey": "runtime.MAP_ANON",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const MAP_ANON"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MAP_ANON = _MAP_ANON\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MAP_PRIVATE",
              "documentation": {
                "identifier": "MAP_PRIVATE",
                "newPage": false,
                "searchKey": "runtime.MAP_PRIVATE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const MAP_PRIVATE"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MAP_PRIVATE = _MAP_PRIVATE\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MAP_FIXED",
              "documentation": {
                "identifier": "MAP_FIXED",
                "newPage": false,
                "searchKey": "runtime.MAP_FIXED",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const MAP_FIXED"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MAP_FIXED = _MAP_FIXED\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PreemptMSupported",
              "documentation": {
                "identifier": "PreemptMSupported",
                "newPage": false,
                "searchKey": "runtime.PreemptMSupported",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const PreemptMSupported"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PreemptMSupported = preemptMSupported\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PtrSize",
              "documentation": {
                "identifier": "PtrSize",
                "newPage": false,
                "searchKey": "runtime.PtrSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const PtrSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PtrSize = sys.PtrSize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ProfBufBlocking",
              "documentation": {
                "identifier": "ProfBufBlocking",
                "newPage": false,
                "searchKey": "runtime.ProfBufBlocking",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const ProfBufBlocking"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ProfBufBlocking = profBufBlocking\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ProfBufNonBlocking",
              "documentation": {
                "identifier": "ProfBufNonBlocking",
                "newPage": false,
                "searchKey": "runtime.ProfBufNonBlocking",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const ProfBufNonBlocking"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ProfBufNonBlocking = profBufNonBlocking\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#RuntimeHmapSize",
              "documentation": {
                "identifier": "RuntimeHmapSize",
                "newPage": false,
                "searchKey": "runtime.RuntimeHmapSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const RuntimeHmapSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst RuntimeHmapSize = unsafe.Sizeof(hmap{})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PageSize",
              "documentation": {
                "identifier": "PageSize",
                "newPage": false,
                "searchKey": "runtime.PageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const PageSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PageSize = pageSize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PallocChunkPages",
              "documentation": {
                "identifier": "PallocChunkPages",
                "newPage": false,
                "searchKey": "runtime.PallocChunkPages",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const PallocChunkPages"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PallocChunkPages = pallocChunkPages\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PageAlloc64Bit",
              "documentation": {
                "identifier": "PageAlloc64Bit",
                "newPage": false,
                "searchKey": "runtime.PageAlloc64Bit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const PageAlloc64Bit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PageAlloc64Bit = pageAlloc64Bit\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PallocSumBytes",
              "documentation": {
                "identifier": "PallocSumBytes",
                "newPage": false,
                "searchKey": "runtime.PallocSumBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const PallocSumBytes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PallocSumBytes = pallocSumBytes\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PageCachePages",
              "documentation": {
                "identifier": "PageCachePages",
                "newPage": false,
                "searchKey": "runtime.PageCachePages",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const PageCachePages"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst PageCachePages = pageCachePages\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#TimeHistSubBucketBits",
              "documentation": {
                "identifier": "TimeHistSubBucketBits",
                "newPage": false,
                "searchKey": "runtime.TimeHistSubBucketBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const TimeHistSubBucketBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TimeHistSubBucketBits = timeHistSubBucketBits\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#TimeHistNumSubBuckets",
              "documentation": {
                "identifier": "TimeHistNumSubBuckets",
                "newPage": false,
                "searchKey": "runtime.TimeHistNumSubBuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const TimeHistNumSubBuckets"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TimeHistNumSubBuckets = timeHistNumSubBuckets\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#TimeHistNumSuperBuckets",
              "documentation": {
                "identifier": "TimeHistNumSuperBuckets",
                "newPage": false,
                "searchKey": "runtime.TimeHistNumSuperBuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const TimeHistNumSuperBuckets"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst TimeHistNumSuperBuckets = timeHistNumSuperBuckets\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Raceenabled",
              "documentation": {
                "identifier": "Raceenabled",
                "newPage": false,
                "searchKey": "runtime.Raceenabled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const Raceenabled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Raceenabled = raceenabled\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/runtime#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/runtime#useAeshash",
              "documentation": {
                "identifier": "useAeshash",
                "newPage": false,
                "searchKey": "runtime.useAeshash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var useAeshash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar useAeshash bool\n```\n\nruntime variable to check if the processor we're running on actually supports the instructions used by the AES-based hash implementation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#aeskeysched",
              "documentation": {
                "identifier": "aeskeysched",
                "newPage": false,
                "searchKey": "runtime.aeskeysched",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var aeskeysched"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar aeskeysched [hashRandomBytes]byte\n```\n\nused in asm_{386,amd64,arm64}.s to seed the hash function \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hashkey",
              "documentation": {
                "identifier": "hashkey",
                "newPage": false,
                "searchKey": "runtime.hashkey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var hashkey"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar hashkey [4]uintptr\n```\n\nused in hash{32,64}.go to seed the hash function \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_cgo_init",
              "documentation": {
                "identifier": "_cgo_init",
                "newPage": false,
                "searchKey": "runtime._cgo_init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _cgo_init"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _cgo_init unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_cgo_thread_start",
              "documentation": {
                "identifier": "_cgo_thread_start",
                "newPage": false,
                "searchKey": "runtime._cgo_thread_start",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _cgo_thread_start"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _cgo_thread_start unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_cgo_sys_thread_create",
              "documentation": {
                "identifier": "_cgo_sys_thread_create",
                "newPage": false,
                "searchKey": "runtime._cgo_sys_thread_create",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _cgo_sys_thread_create"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _cgo_sys_thread_create unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_cgo_notify_runtime_init_done",
              "documentation": {
                "identifier": "_cgo_notify_runtime_init_done",
                "newPage": false,
                "searchKey": "runtime._cgo_notify_runtime_init_done",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _cgo_notify_runtime_init_done"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _cgo_notify_runtime_init_done unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_cgo_callers",
              "documentation": {
                "identifier": "_cgo_callers",
                "newPage": false,
                "searchKey": "runtime._cgo_callers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _cgo_callers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _cgo_callers unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_cgo_set_context_function",
              "documentation": {
                "identifier": "_cgo_set_context_function",
                "newPage": false,
                "searchKey": "runtime._cgo_set_context_function",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _cgo_set_context_function"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _cgo_set_context_function unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_cgo_yield",
              "documentation": {
                "identifier": "_cgo_yield",
                "newPage": false,
                "searchKey": "runtime._cgo_yield",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _cgo_yield"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _cgo_yield unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#iscgo",
              "documentation": {
                "identifier": "iscgo",
                "newPage": false,
                "searchKey": "runtime.iscgo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var iscgo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar iscgo bool\n```\n\niscgo is set to true by the runtime/cgo package \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoHasExtraM",
              "documentation": {
                "identifier": "cgoHasExtraM",
                "newPage": false,
                "searchKey": "runtime.cgoHasExtraM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cgoHasExtraM"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cgoHasExtraM bool\n```\n\ncgoHasExtraM is set on startup when an extra M is created for cgo. The extra M must be created before any C/C++ code calls cgocallback. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoAlwaysFalse",
              "documentation": {
                "identifier": "cgoAlwaysFalse",
                "newPage": false,
                "searchKey": "runtime.cgoAlwaysFalse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cgoAlwaysFalse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cgoAlwaysFalse bool\n```\n\ncgoAlwaysFalse is a boolean value that is always false. The cgo-generated code says if cgoAlwaysFalse { cgoUse(p) }. The compiler cannot see that cgoAlwaysFalse is always false, so it emits the test and keeps the call, giving the desired escape analysis result. The test is cheaper than the call. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgo_yield",
              "documentation": {
                "identifier": "cgo_yield",
                "newPage": false,
                "searchKey": "runtime.cgo_yield",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cgo_yield"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cgo_yield = &_cgo_yield\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racecgosync",
              "documentation": {
                "identifier": "racecgosync",
                "newPage": false,
                "searchKey": "runtime.racecgosync",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var racecgosync"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar racecgosync uint64 // represents possible synchronization in C code\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#x86HasPOPCNT",
              "documentation": {
                "identifier": "x86HasPOPCNT",
                "newPage": false,
                "searchKey": "runtime.x86HasPOPCNT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var x86HasPOPCNT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar x86HasPOPCNT bool\n```\n\nSet in runtime.cpuinit. TODO: deprecate these; use internal/cpu directly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#x86HasSSE41",
              "documentation": {
                "identifier": "x86HasSSE41",
                "newPage": false,
                "searchKey": "runtime.x86HasSSE41",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var x86HasSSE41"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar x86HasSSE41 bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#x86HasFMA",
              "documentation": {
                "identifier": "x86HasFMA",
                "newPage": false,
                "searchKey": "runtime.x86HasFMA",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var x86HasFMA"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar x86HasFMA bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#armHasVFPv4",
              "documentation": {
                "identifier": "armHasVFPv4",
                "newPage": false,
                "searchKey": "runtime.armHasVFPv4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var armHasVFPv4"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar armHasVFPv4 bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#arm64HasATOMICS",
              "documentation": {
                "identifier": "arm64HasATOMICS",
                "newPage": false,
                "searchKey": "runtime.arm64HasATOMICS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var arm64HasATOMICS"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar arm64HasATOMICS bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#useAVXmemmove",
              "documentation": {
                "identifier": "useAVXmemmove",
                "newPage": false,
                "searchKey": "runtime.useAVXmemmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var useAVXmemmove"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar useAVXmemmove bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cpuprof",
              "documentation": {
                "identifier": "cpuprof",
                "newPage": false,
                "searchKey": "runtime.cpuprof",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cpuprof"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cpuprof cpuProfile\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#allDloggers",
              "documentation": {
                "identifier": "allDloggers",
                "newPage": false,
                "searchKey": "runtime.allDloggers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var allDloggers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allDloggers *dlogger\n```\n\nallDloggers is a list of all dloggers, linked through dlogger.allLink. This is accessed atomically. This is prepend only, so it doesn't need to protect against ABA races. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_cgo_setenv",
              "documentation": {
                "identifier": "_cgo_setenv",
                "newPage": false,
                "searchKey": "runtime._cgo_setenv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _cgo_setenv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _cgo_setenv unsafe.Pointer // pointer to C function\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_cgo_unsetenv",
              "documentation": {
                "identifier": "_cgo_unsetenv",
                "newPage": false,
                "searchKey": "runtime._cgo_unsetenv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _cgo_unsetenv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _cgo_unsetenv unsafe.Pointer // pointer to C function\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsErrorFmts",
              "documentation": {
                "identifier": "boundsErrorFmts",
                "newPage": false,
                "searchKey": "runtime.boundsErrorFmts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var boundsErrorFmts"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar boundsErrorFmts = ...\n```\n\nboundsErrorFmts provide error text for various out-of-bounds panics. Note: if you change these strings, you should adjust the size of the buffer in boundsError.Error below as well. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsNegErrorFmts",
              "documentation": {
                "identifier": "boundsNegErrorFmts",
                "newPage": false,
                "searchKey": "runtime.boundsNegErrorFmts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var boundsNegErrorFmts"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar boundsNegErrorFmts = ...\n```\n\nboundsNegErrorFmts are overriding formats if x is negative. In this case there's no need to report y. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#defaultGOROOT",
              "documentation": {
                "identifier": "defaultGOROOT",
                "newPage": false,
                "searchKey": "runtime.defaultGOROOT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var defaultGOROOT"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar defaultGOROOT string // set by cmd/link\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#buildVersion",
              "documentation": {
                "identifier": "buildVersion",
                "newPage": false,
                "searchKey": "runtime.buildVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var buildVersion"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar buildVersion string\n```\n\nbuildVersion is the Go tree's version string at build time. \n\nIf any GOEXPERIMENTs are set to non-default values, it will include \"X:<GOEXPERIMENT>\". \n\nThis is set by the linker. \n\nThis is accessed by \"go version <binary>\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fastlog2Table",
              "documentation": {
                "identifier": "fastlog2Table",
                "newPage": false,
                "searchKey": "runtime.fastlog2Table",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fastlog2Table"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fastlog2Table = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inf",
              "documentation": {
                "identifier": "inf",
                "newPage": false,
                "searchKey": "runtime.inf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var inf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar inf = float64frombits(0x7FF0000000000000)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpfd",
              "documentation": {
                "identifier": "dumpfd",
                "newPage": false,
                "searchKey": "runtime.dumpfd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dumpfd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dumpfd uintptr // fd to write the dump to.\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tmpbuf",
              "documentation": {
                "identifier": "tmpbuf",
                "newPage": false,
                "searchKey": "runtime.tmpbuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tmpbuf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tmpbuf []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#buf",
              "documentation": {
                "identifier": "buf",
                "newPage": false,
                "searchKey": "runtime.buf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var buf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar buf [bufSize]byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nbuf",
              "documentation": {
                "identifier": "nbuf",
                "newPage": false,
                "searchKey": "runtime.nbuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var nbuf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar nbuf uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typecache",
              "documentation": {
                "identifier": "typecache",
                "newPage": false,
                "searchKey": "runtime.typecache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var typecache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar typecache [typeCacheBuckets]typeCacheBucket\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freemark",
              "documentation": {
                "identifier": "freemark",
                "newPage": false,
                "searchKey": "runtime.freemark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var freemark"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar freemark [_PageSize / 8]bool\n```\n\nBit vector of free marks. Needs to be as big as the largest number of objects per span. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumphdr",
              "documentation": {
                "identifier": "dumphdr",
                "newPage": false,
                "searchKey": "runtime.dumphdr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dumphdr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dumphdr = []byte(\"go1.7 heap dump\\n\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itabLock",
              "documentation": {
                "identifier": "itabLock",
                "newPage": false,
                "searchKey": "runtime.itabLock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var itabLock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar itabLock mutex // lock for accessing itab table\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itabTable",
              "documentation": {
                "identifier": "itabTable",
                "newPage": false,
                "searchKey": "runtime.itabTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var itabTable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar itabTable = &itabTableInit // pointer to current table\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itabTableInit",
              "documentation": {
                "identifier": "itabTableInit",
                "newPage": false,
                "searchKey": "runtime.itabTableInit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var itabTableInit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar itabTableInit = itabTableType{size: itabInitSize} // starter table\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#uint16Eface",
              "documentation": {
                "identifier": "uint16Eface",
                "newPage": false,
                "searchKey": "runtime.uint16Eface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var uint16Eface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar uint16Eface interface{} = uint16InterfacePtr(0)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#uint32Eface",
              "documentation": {
                "identifier": "uint32Eface",
                "newPage": false,
                "searchKey": "runtime.uint32Eface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var uint32Eface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar uint32Eface interface{} = uint32InterfacePtr(0)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#uint64Eface",
              "documentation": {
                "identifier": "uint64Eface",
                "newPage": false,
                "searchKey": "runtime.uint64Eface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var uint64Eface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar uint64Eface interface{} = uint64InterfacePtr(0)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stringEface",
              "documentation": {
                "identifier": "stringEface",
                "newPage": false,
                "searchKey": "runtime.stringEface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var stringEface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar stringEface interface{} = stringInterfacePtr(\"\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sliceEface",
              "documentation": {
                "identifier": "sliceEface",
                "newPage": false,
                "searchKey": "runtime.sliceEface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sliceEface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sliceEface interface{} = sliceInterfacePtr(nil)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#uint16Type",
              "documentation": {
                "identifier": "uint16Type",
                "newPage": false,
                "searchKey": "runtime.uint16Type",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var uint16Type"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar uint16Type *_type = efaceOf(&uint16Eface)._type\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#uint32Type",
              "documentation": {
                "identifier": "uint32Type",
                "newPage": false,
                "searchKey": "runtime.uint32Type",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var uint32Type"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar uint32Type *_type = efaceOf(&uint32Eface)._type\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#uint64Type",
              "documentation": {
                "identifier": "uint64Type",
                "newPage": false,
                "searchKey": "runtime.uint64Type",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var uint64Type"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar uint64Type *_type = efaceOf(&uint64Eface)._type\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stringType",
              "documentation": {
                "identifier": "stringType",
                "newPage": false,
                "searchKey": "runtime.stringType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var stringType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar stringType *_type = efaceOf(&stringEface)._type\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sliceType",
              "documentation": {
                "identifier": "sliceType",
                "newPage": false,
                "searchKey": "runtime.sliceType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sliceType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sliceType *_type = efaceOf(&sliceEface)._type\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#staticuint64s",
              "documentation": {
                "identifier": "staticuint64s",
                "newPage": false,
                "searchKey": "runtime.staticuint64s",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var staticuint64s"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar staticuint64s = ...\n```\n\nstaticuint64s is used to avoid allocating in convTx for small integer values. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockNames",
              "documentation": {
                "identifier": "lockNames",
                "newPage": false,
                "searchKey": "runtime.lockNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lockNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lockNames = ...\n```\n\nlockNames gives the names associated with each of the above ranks \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockPartialOrder",
              "documentation": {
                "identifier": "lockPartialOrder",
                "newPage": false,
                "searchKey": "runtime.lockPartialOrder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lockPartialOrder"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lockPartialOrder [][]lockRank = ...\n```\n\nlockPartialOrder is a partial order among the various lock types, listing the immediate ordering that has actually been observed in the runtime. Each entry (which corresponds to a particular lock rank) specifies the list of locks that can already be held immediately \"above\" it. \n\nSo, for example, the lockRankSched entry shows that all the locks preceding it in rank can actually be held. The allp lock shows that only the sysmon or sched lock can be held immediately above it when it is acquired. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#physPageSize",
              "documentation": {
                "identifier": "physPageSize",
                "newPage": false,
                "searchKey": "runtime.physPageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var physPageSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar physPageSize uintptr\n```\n\nphysPageSize is the size in bytes of the OS's physical pages. Mapping and unmapping operations must be done at multiples of physPageSize. \n\nThis must be set by the OS init code (typically in osinit) before mallocinit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#physHugePageSize",
              "documentation": {
                "identifier": "physHugePageSize",
                "newPage": false,
                "searchKey": "runtime.physHugePageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var physHugePageSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar physHugePageSize uintptr\n```\n\nphysHugePageSize is the size in bytes of the OS's default physical huge page size whose allocation is opaque to the application. It is assumed and verified to be a power of two. \n\nIf set, this must be set by the OS init code (typically in osinit) before mallocinit. However, setting it at all is optional, and leaving the default value is always safe (though potentially less efficient). \n\nSince physHugePageSize is always assumed to be a power of two, physHugePageShift is defined as physHugePageSize == 1 << physHugePageShift. The purpose of physHugePageShift is to avoid doing divisions in performance critical functions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#physHugePageShift",
              "documentation": {
                "identifier": "physHugePageShift",
                "newPage": false,
                "searchKey": "runtime.physHugePageShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var physHugePageShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar physHugePageShift uint\n```\n\nphysHugePageSize is the size in bytes of the OS's default physical huge page size whose allocation is opaque to the application. It is assumed and verified to be a power of two. \n\nIf set, this must be set by the OS init code (typically in osinit) before mallocinit. However, setting it at all is optional, and leaving the default value is always safe (though potentially less efficient). \n\nSince physHugePageSize is always assumed to be a power of two, physHugePageShift is defined as physHugePageSize == 1 << physHugePageShift. The purpose of physHugePageShift is to avoid doing divisions in performance critical functions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#zerobase",
              "documentation": {
                "identifier": "zerobase",
                "newPage": false,
                "searchKey": "runtime.zerobase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var zerobase"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar zerobase uintptr\n```\n\nbase address for all 0-byte allocations \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#globalAlloc",
              "documentation": {
                "identifier": "globalAlloc",
                "newPage": false,
                "searchKey": "runtime.globalAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var globalAlloc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar globalAlloc struct {\n\tmutex\n\tpersistentAlloc\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#persistentChunks",
              "documentation": {
                "identifier": "persistentChunks",
                "newPage": false,
                "searchKey": "runtime.persistentChunks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var persistentChunks"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar persistentChunks *notInHeap\n```\n\npersistentChunks is a list of all the persistent chunks we have allocated. The list is maintained through the first word in the persistent chunk. This is updated atomically. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#zeroVal",
              "documentation": {
                "identifier": "zeroVal",
                "newPage": false,
                "searchKey": "runtime.zeroVal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var zeroVal"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar zeroVal [maxZero]byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugPtrmask",
              "documentation": {
                "identifier": "debugPtrmask",
                "newPage": false,
                "searchKey": "runtime.debugPtrmask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var debugPtrmask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar debugPtrmask struct {\n\tlock mutex\n\tdata *byte\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#emptymspan",
              "documentation": {
                "identifier": "emptymspan",
                "newPage": false,
                "searchKey": "runtime.emptymspan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var emptymspan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar emptymspan mspan\n```\n\ndummy mspan that contains no free objects. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#useCheckmark",
              "documentation": {
                "identifier": "useCheckmark",
                "newPage": false,
                "searchKey": "runtime.useCheckmark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var useCheckmark"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar useCheckmark = false\n```\n\nIf useCheckmark is true, marking of an object uses the checkmark bits instead of the standard mark bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metricsSema",
              "documentation": {
                "identifier": "metricsSema",
                "newPage": false,
                "searchKey": "runtime.metricsSema",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var metricsSema"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar metricsSema uint32 = 1\n```\n\nmetrics is a map of runtime/metrics keys to data used by the runtime to sample each metric's value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metricsInit",
              "documentation": {
                "identifier": "metricsInit",
                "newPage": false,
                "searchKey": "runtime.metricsInit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var metricsInit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar metricsInit bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metrics",
              "documentation": {
                "identifier": "metrics",
                "newPage": false,
                "searchKey": "runtime.metrics",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var metrics"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar metrics map[string]metricData\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sizeClassBuckets",
              "documentation": {
                "identifier": "sizeClassBuckets",
                "newPage": false,
                "searchKey": "runtime.sizeClassBuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sizeClassBuckets"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sizeClassBuckets []float64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timeHistBuckets",
              "documentation": {
                "identifier": "timeHistBuckets",
                "newPage": false,
                "searchKey": "runtime.timeHistBuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var timeHistBuckets"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar timeHistBuckets []float64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#agg",
              "documentation": {
                "identifier": "agg",
                "newPage": false,
                "searchKey": "runtime.agg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var agg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar agg statAggregate\n```\n\nagg is used by readMetrics, and is protected by metricsSema. \n\nManaged as a global variable because its pointer will be an argument to a dynamically-defined function, and we'd like to avoid it escaping to the heap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#finlock",
              "documentation": {
                "identifier": "finlock",
                "newPage": false,
                "searchKey": "runtime.finlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var finlock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar finlock mutex // protects the following variables\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fing",
              "documentation": {
                "identifier": "fing",
                "newPage": false,
                "searchKey": "runtime.fing",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fing"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fing *g // goroutine that runs finalizers\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#finq",
              "documentation": {
                "identifier": "finq",
                "newPage": false,
                "searchKey": "runtime.finq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var finq"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar finq *finblock // list of finalizers that are to be executed\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#finc",
              "documentation": {
                "identifier": "finc",
                "newPage": false,
                "searchKey": "runtime.finc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var finc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar finc *finblock // cache of free blocks\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#finptrmask",
              "documentation": {
                "identifier": "finptrmask",
                "newPage": false,
                "searchKey": "runtime.finptrmask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var finptrmask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar finptrmask [_FinBlockSize / sys.PtrSize / 8]byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fingwait",
              "documentation": {
                "identifier": "fingwait",
                "newPage": false,
                "searchKey": "runtime.fingwait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fingwait"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fingwait bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fingwake",
              "documentation": {
                "identifier": "fingwake",
                "newPage": false,
                "searchKey": "runtime.fingwake",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fingwake"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fingwake bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#allfin",
              "documentation": {
                "identifier": "allfin",
                "newPage": false,
                "searchKey": "runtime.allfin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var allfin"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allfin *finblock // list of all blocks\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#finalizer1",
              "documentation": {
                "identifier": "finalizer1",
                "newPage": false,
                "searchKey": "runtime.finalizer1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var finalizer1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar finalizer1 = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fingCreate",
              "documentation": {
                "identifier": "fingCreate",
                "newPage": false,
                "searchKey": "runtime.fingCreate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fingCreate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fingCreate uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fingRunning",
              "documentation": {
                "identifier": "fingRunning",
                "newPage": false,
                "searchKey": "runtime.fingRunning",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fingRunning"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fingRunning bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcenable_setup",
              "documentation": {
                "identifier": "gcenable_setup",
                "newPage": false,
                "searchKey": "runtime.gcenable_setup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcenable_setup"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcenable_setup chan int\n```\n\nTemporary in order to enable register ABI work. TODO(register args): convert back to local chan in gcenabled, passed to \"go\" stmts. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcphase",
              "documentation": {
                "identifier": "gcphase",
                "newPage": false,
                "searchKey": "runtime.gcphase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcphase"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcphase uint32\n```\n\nGarbage collector phase. Indicates to write barrier and synchronization task to perform. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#writeBarrier",
              "documentation": {
                "identifier": "writeBarrier",
                "newPage": false,
                "searchKey": "runtime.writeBarrier",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var writeBarrier"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar writeBarrier struct {\n\tenabled bool    // compiler emits a check of this before calling write barrier\n\tpad     [3]byte // compiler uses 32-bit load for \"enabled\" field\n\tneeded  bool    // whether we need a write barrier for current GC phase\n\tcgo     bool    // whether we need a write barrier for a cgo check\n\talignme uint64  // guarantee alignment so that compiler can use a 32 or 64-bit load\n} = ...\n```\n\nThe compiler knows about this variable. If you change it, you must change builtin/runtime.go, too. If you change the first four bytes, you must also change the write barrier insertion code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBlackenEnabled",
              "documentation": {
                "identifier": "gcBlackenEnabled",
                "newPage": false,
                "searchKey": "runtime.gcBlackenEnabled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcBlackenEnabled"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcBlackenEnabled uint32\n```\n\ngcBlackenEnabled is 1 if mutator assists and background mark workers are allowed to blacken objects. This must only be set when gcphase == _GCmark. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkWorkerModeStrings",
              "documentation": {
                "identifier": "gcMarkWorkerModeStrings",
                "newPage": false,
                "searchKey": "runtime.gcMarkWorkerModeStrings",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcMarkWorkerModeStrings"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcMarkWorkerModeStrings = ...\n```\n\ngcMarkWorkerModeStrings are the strings labels of gcMarkWorkerModes to use in execution traces. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#work",
              "documentation": {
                "identifier": "work",
                "newPage": false,
                "searchKey": "runtime.work",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var work"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar work struct {\n\tfull  lfstack          // lock-free list of full blocks workbuf\n\tempty lfstack          // lock-free list of empty blocks workbuf\n\tpad0  cpu.CacheLinePad // prevents false-sharing between full/empty and nproc/nwait\n\n\twbufSpans struct {\n\t\tlock mutex\n\t\t// free is a list of spans dedicated to workbufs, but\n\t\t// that don't currently contain any workbufs.\n\t\tfree mSpanList\n\t\t// busy is a list of all spans containing workbufs on\n\t\t// one of the workbuf lists.\n\t\tbusy mSpanList\n\t}\n\n\t// Restore 64-bit alignment on 32-bit.\n\t_ uint32\n\n\t// bytesMarked is the number of bytes marked this cycle. This\n\t// includes bytes blackened in scanned objects, noscan objects\n\t// that go straight to black, and permagrey objects scanned by\n\t// markroot during the concurrent scan phase. This is updated\n\t// atomically during the cycle. Updates may be batched\n\t// arbitrarily, since the value is only read at the end of the\n\t// cycle.\n\t//\n\t// Because of benign races during marking, this number may not\n\t// be the exact number of marked bytes, but it should be very\n\t// close.\n\t//\n\t// Put this field here because it needs 64-bit atomic access\n\t// (and thus 8-byte alignment even on 32-bit architectures).\n\tbytesMarked uint64\n\n\tmarkrootNext uint32 // next markroot job\n\tmarkrootJobs uint32 // number of markroot jobs\n\n\tnproc  uint32\n\ttstart int64\n\tnwait  uint32\n\n\t// Number of roots of various root types. Set by gcMarkRootPrepare.\n\tnDataRoots, nBSSRoots, nSpanRoots, nStackRoots int\n\n\t// Base indexes of each root type. Set by gcMarkRootPrepare.\n\tbaseData, baseBSS, baseSpans, baseStacks, baseEnd uint32\n\n\t// Each type of GC state transition is protected by a lock.\n\t// Since multiple threads can simultaneously detect the state\n\t// transition condition, any thread that detects a transition\n\t// condition must acquire the appropriate transition lock,\n\t// re-check the transition condition and return if it no\n\t// longer holds or perform the transition if it does.\n\t// Likewise, any transition must invalidate the transition\n\t// condition before releasing the lock. This ensures that each\n\t// transition is performed by exactly one thread and threads\n\t// that need the transition to happen block until it has\n\t// happened.\n\t//\n\t// startSema protects the transition from \"off\" to mark or\n\t// mark termination.\n\tstartSema uint32\n\t// markDoneSema protects transitions from mark to mark termination.\n\tmarkDoneSema uint32\n\n\tbgMarkReady note   // signal background mark worker has started\n\tbgMarkDone  uint32 // cas to 1 when at a background mark completion point\n\n\t// mode is the concurrency mode of the current GC cycle.\n\tmode gcMode\n\n\t// userForced indicates the current GC cycle was forced by an\n\t// explicit user call.\n\tuserForced bool\n\n\t// totaltime is the CPU nanoseconds spent in GC since the\n\t// program started if debug.gctrace > 0.\n\ttotaltime int64\n\n\t// initialHeapLive is the value of gcController.heapLive at the\n\t// beginning of this GC cycle.\n\tinitialHeapLive uint64\n\n\t// assistQueue is a queue of assists that are blocked because\n\t// there was neither enough credit to steal or enough work to\n\t// do.\n\tassistQueue struct {\n\t\tlock mutex\n\t\tq    gQueue\n\t}\n\n\t// sweepWaiters is a list of blocked goroutines to wake when\n\t// we transition from mark termination to sweep.\n\tsweepWaiters struct {\n\t\tlock mutex\n\t\tlist gList\n\t}\n\n\t// cycles is the number of completed GC cycles, where a GC\n\t// cycle is sweep termination, mark, mark termination, and\n\t// sweep. This differs from memstats.numgc, which is\n\t// incremented at mark termination.\n\tcycles uint32\n\n\t// Timing/utilization stats for this cycle.\n\tstwprocs, maxprocs                 int32\n\ttSweepTerm, tMark, tMarkTerm, tEnd int64 // nanotime() of phase start\n\n\tpauseNS    int64 // total STW time this cycle\n\tpauseStart int64 // nanotime() of last STW\n\n\t// debug.gctrace heap sizes for this cycle.\n\theap0, heap1, heap2, heapGoal uint64\n} = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkDoneFlushed",
              "documentation": {
                "identifier": "gcMarkDoneFlushed",
                "newPage": false,
                "searchKey": "runtime.gcMarkDoneFlushed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcMarkDoneFlushed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcMarkDoneFlushed uint32\n```\n\ngcMarkDoneFlushed counts the number of P's with flushed work. \n\nIdeally this would be a captured local in gcMarkDone, but forEachP escapes its callback closure, so it can't capture anything. \n\nThis is protected by markDoneSema. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#poolcleanup",
              "documentation": {
                "identifier": "poolcleanup",
                "newPage": false,
                "searchKey": "runtime.poolcleanup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var poolcleanup"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar poolcleanup func()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#oneptrmask",
              "documentation": {
                "identifier": "oneptrmask",
                "newPage": false,
                "searchKey": "runtime.oneptrmask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var oneptrmask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar oneptrmask = [...]uint8{1}\n```\n\nptrmask for an allocation containing a single pointer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcController",
              "documentation": {
                "identifier": "gcController",
                "newPage": false,
                "searchKey": "runtime.gcController",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcController"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcController gcControllerState\n```\n\ngcController implements the GC pacing controller that determines when to trigger concurrent garbage collection and how much marking work to do in mutator assists and background marking. \n\nIt uses a feedback control algorithm to adjust the gcController.trigger trigger based on the heap growth and GC CPU utilization each cycle. This algorithm optimizes for heap growth to match GOGC and for CPU utilization between assist and background marking to be 25% of GOMAXPROCS. The high-level design of this algorithm is documented at [https://golang.org/s/go15gcpacing](https://golang.org/s/go15gcpacing). \n\nAll fields of gcController are used only during a single mark cycle. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#scavenge",
              "documentation": {
                "identifier": "scavenge",
                "newPage": false,
                "searchKey": "runtime.scavenge",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var scavenge"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar scavenge struct {\n\tlock       mutex\n\tg          *g\n\tparked     bool\n\ttimer      *timer\n\tsysmonWake uint32 // Set atomically.\n} = ...\n```\n\nSleep/wait state of the background scavenger. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sweep",
              "documentation": {
                "identifier": "sweep",
                "newPage": false,
                "searchKey": "runtime.sweep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sweep"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sweep sweepdata\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mheap_",
              "documentation": {
                "identifier": "mheap_",
                "newPage": false,
                "searchKey": "runtime.mheap_",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mheap_"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mheap_ mheap\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mSpanStateNames",
              "documentation": {
                "identifier": "mSpanStateNames",
                "newPage": false,
                "searchKey": "runtime.mSpanStateNames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mSpanStateNames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mSpanStateNames = []string{\n\t\"mSpanDead\",\n\t\"mSpanInUse\",\n\t\"mSpanManual\",\n\t\"mSpanFree\",\n}\n```\n\nmSpanStateNames are the names of the span states, indexed by mSpanState. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBitsArenas",
              "documentation": {
                "identifier": "gcBitsArenas",
                "newPage": false,
                "searchKey": "runtime.gcBitsArenas",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcBitsArenas"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcBitsArenas struct {\n\tlock     mutex\n\tfree     *gcBitsArena\n\tnext     *gcBitsArena // Read atomically. Write atomically under lock.\n\tcurrent  *gcBitsArena\n\tprevious *gcBitsArena\n} = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxSearchAddr",
              "documentation": {
                "identifier": "maxSearchAddr",
                "newPage": false,
                "searchKey": "runtime.maxSearchAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var maxSearchAddr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar maxSearchAddr = maxOffAddr\n```\n\nMaximum searchAddr value, which indicates that the heap has no free space. \n\nWe alias maxOffAddr just to make it clear that this is the maximum address for the page allocator's search space. See maxOffAddr for details. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#levelBits",
              "documentation": {
                "identifier": "levelBits",
                "newPage": false,
                "searchKey": "runtime.levelBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var levelBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar levelBits = ...\n```\n\nlevelBits is the number of bits in the radix for a given level in the super summary structure. \n\nThe sum of all the entries of levelBits should equal heapAddrBits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#levelShift",
              "documentation": {
                "identifier": "levelShift",
                "newPage": false,
                "searchKey": "runtime.levelShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var levelShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar levelShift = ...\n```\n\nlevelShift is the number of bits to shift to acquire the radix for a given level in the super summary structure. \n\nWith levelShift, one can compute the index of the summary at level l related to a pointer p by doing: \n\n```\np >> levelShift[l]\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#levelLogPages",
              "documentation": {
                "identifier": "levelLogPages",
                "newPage": false,
                "searchKey": "runtime.levelLogPages",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var levelLogPages"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar levelLogPages = ...\n```\n\nlevelLogPages is log2 the maximum number of runtime pages in the address space a summary in the given level represents. \n\nThe leaf level always represents exactly log2 of 1 chunk's worth of pages. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#proflock",
              "documentation": {
                "identifier": "proflock",
                "newPage": false,
                "searchKey": "runtime.proflock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var proflock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar proflock mutex\n```\n\nNOTE(rsc): Everything here could use cas if contention became an issue. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mbuckets",
              "documentation": {
                "identifier": "mbuckets",
                "newPage": false,
                "searchKey": "runtime.mbuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mbuckets"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mbuckets *bucket // memory profile buckets\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bbuckets",
              "documentation": {
                "identifier": "bbuckets",
                "newPage": false,
                "searchKey": "runtime.bbuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bbuckets"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bbuckets *bucket // blocking profile buckets\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#xbuckets",
              "documentation": {
                "identifier": "xbuckets",
                "newPage": false,
                "searchKey": "runtime.xbuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var xbuckets"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar xbuckets *bucket // mutex profile buckets\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#buckhash",
              "documentation": {
                "identifier": "buckhash",
                "newPage": false,
                "searchKey": "runtime.buckhash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var buckhash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar buckhash *[179999]*bucket\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bucketmem",
              "documentation": {
                "identifier": "bucketmem",
                "newPage": false,
                "searchKey": "runtime.bucketmem",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bucketmem"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bucketmem uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mProf",
              "documentation": {
                "identifier": "mProf",
                "newPage": false,
                "searchKey": "runtime.mProf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mProf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mProf struct {\n\n\t// cycle is the global heap profile cycle. This wraps\n\t// at mProfCycleWrap.\n\tcycle uint32\n\t// flushed indicates that future[cycle] in all buckets\n\t// has been flushed to the active profile.\n\tflushed bool\n} = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#blockprofilerate",
              "documentation": {
                "identifier": "blockprofilerate",
                "newPage": false,
                "searchKey": "runtime.blockprofilerate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var blockprofilerate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar blockprofilerate uint64 // in CPU ticks\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mutexprofilerate",
              "documentation": {
                "identifier": "mutexprofilerate",
                "newPage": false,
                "searchKey": "runtime.mutexprofilerate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mutexprofilerate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mutexprofilerate uint64 // fraction sampled\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MemProfileRate",
              "documentation": {
                "identifier": "MemProfileRate",
                "newPage": false,
                "searchKey": "runtime.MemProfileRate",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "var MemProfileRate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar MemProfileRate int = defaultMemProfileRate(512 * 1024)\n```\n\nMemProfileRate controls the fraction of memory allocations that are recorded and reported in the memory profile. The profiler aims to sample an average of one allocation per MemProfileRate bytes allocated. \n\nTo include every allocated block in the profile, set MemProfileRate to 1. To turn off profiling entirely, set MemProfileRate to 0. \n\nThe tools that process the memory profiles assume that the profile rate is constant across the lifetime of the program and equal to the current value. Programs that change the memory profiling rate should do so just once, as early as possible in the execution of the program (for example, at the beginning of main). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#disableMemoryProfiling",
              "documentation": {
                "identifier": "disableMemoryProfiling",
                "newPage": false,
                "searchKey": "runtime.disableMemoryProfiling",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var disableMemoryProfiling"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar disableMemoryProfiling bool\n```\n\ndisableMemoryProfiling is set by the linker if runtime.MemProfile is not used and the link type guarantees nobody else could use it elsewhere. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracelock",
              "documentation": {
                "identifier": "tracelock",
                "newPage": false,
                "searchKey": "runtime.tracelock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tracelock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tracelock mutex\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minOffAddr",
              "documentation": {
                "identifier": "minOffAddr",
                "newPage": false,
                "searchKey": "runtime.minOffAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var minOffAddr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar minOffAddr = offAddr{arenaBaseOffset}\n```\n\nminOffAddr is the minimum address in the offset space, and it corresponds to the virtual address arenaBaseOffset. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxOffAddr",
              "documentation": {
                "identifier": "maxOffAddr",
                "newPage": false,
                "searchKey": "runtime.maxOffAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var maxOffAddr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar maxOffAddr = offAddr{(((1 << heapAddrBits) - 1) + arenaBaseOffset) & uintptrMask}\n```\n\nmaxOffAddr is the maximum address in the offset address space. It corresponds to the highest virtual address representable by the page alloc chunk and heap arena maps. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanSetBlockPool",
              "documentation": {
                "identifier": "spanSetBlockPool",
                "newPage": false,
                "searchKey": "runtime.spanSetBlockPool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var spanSetBlockPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar spanSetBlockPool spanSetBlockAlloc\n```\n\nspanSetBlockPool is a global pool of spanSetBlocks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memstats",
              "documentation": {
                "identifier": "memstats",
                "newPage": false,
                "searchKey": "runtime.memstats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var memstats"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar memstats mstats\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollInitLock",
              "documentation": {
                "identifier": "netpollInitLock",
                "newPage": false,
                "searchKey": "runtime.netpollInitLock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var netpollInitLock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar netpollInitLock mutex\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollInited",
              "documentation": {
                "identifier": "netpollInited",
                "newPage": false,
                "searchKey": "runtime.netpollInited",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var netpollInited"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar netpollInited uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pollcache",
              "documentation": {
                "identifier": "pollcache",
                "newPage": false,
                "searchKey": "runtime.pollcache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var pollcache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar pollcache pollCache\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollWaiters",
              "documentation": {
                "identifier": "netpollWaiters",
                "newPage": false,
                "searchKey": "runtime.netpollWaiters",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var netpollWaiters"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar netpollWaiters uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pdEface",
              "documentation": {
                "identifier": "pdEface",
                "newPage": false,
                "searchKey": "runtime.pdEface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var pdEface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar pdEface interface{} = (*pollDesc)(nil)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pdType",
              "documentation": {
                "identifier": "pdType",
                "newPage": false,
                "searchKey": "runtime.pdType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var pdType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar pdType *_type = efaceOf(&pdEface)._type\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kq",
              "documentation": {
                "identifier": "kq",
                "newPage": false,
                "searchKey": "runtime.kq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var kq"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar kq int32 = -1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollBreakRd",
              "documentation": {
                "identifier": "netpollBreakRd",
                "newPage": false,
                "searchKey": "runtime.netpollBreakRd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var netpollBreakRd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar netpollBreakRd, netpollBreakWr uintptr // for netpollBreak\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollBreakWr",
              "documentation": {
                "identifier": "netpollBreakWr",
                "newPage": false,
                "searchKey": "runtime.netpollBreakWr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var netpollBreakWr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar netpollBreakRd, netpollBreakWr uintptr // for netpollBreak\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollWakeSig",
              "documentation": {
                "identifier": "netpollWakeSig",
                "newPage": false,
                "searchKey": "runtime.netpollWakeSig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var netpollWakeSig"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar netpollWakeSig uint32 // used to avoid duplicate calls of netpollBreak\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigNoteRead",
              "documentation": {
                "identifier": "sigNoteRead",
                "newPage": false,
                "searchKey": "runtime.sigNoteRead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sigNoteRead"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sigNoteRead, sigNoteWrite int32\n```\n\nThe read and write file descriptors used by the sigNote functions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigNoteWrite",
              "documentation": {
                "identifier": "sigNoteWrite",
                "newPage": false,
                "searchKey": "runtime.sigNoteWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sigNoteWrite"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sigNoteRead, sigNoteWrite int32\n```\n\nThe read and write file descriptors used by the sigNote functions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#urandom_dev",
              "documentation": {
                "identifier": "urandom_dev",
                "newPage": false,
                "searchKey": "runtime.urandom_dev",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var urandom_dev"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar urandom_dev = []byte(\"/dev/urandom\\x00\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#failallocatestack",
              "documentation": {
                "identifier": "failallocatestack",
                "newPage": false,
                "searchKey": "runtime.failallocatestack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var failallocatestack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar failallocatestack = []byte(\"runtime: failed to allocate stack for the new OS thread\\n\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#failthreadcreate",
              "documentation": {
                "identifier": "failthreadcreate",
                "newPage": false,
                "searchKey": "runtime.failthreadcreate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var failthreadcreate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar failthreadcreate = []byte(\"runtime: failed to create new OS thread\\n\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigset_all",
              "documentation": {
                "identifier": "sigset_all",
                "newPage": false,
                "searchKey": "runtime.sigset_all",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sigset_all"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sigset_all = ^sigset(0)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#executablePath",
              "documentation": {
                "identifier": "executablePath",
                "newPage": false,
                "searchKey": "runtime.executablePath",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var executablePath"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar executablePath string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#shiftError",
              "documentation": {
                "identifier": "shiftError",
                "newPage": false,
                "searchKey": "runtime.shiftError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var shiftError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar shiftError = error(errorString(\"negative shift amount\"))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#divideError",
              "documentation": {
                "identifier": "divideError",
                "newPage": false,
                "searchKey": "runtime.divideError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var divideError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar divideError = error(errorString(\"integer divide by zero\"))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#overflowError",
              "documentation": {
                "identifier": "overflowError",
                "newPage": false,
                "searchKey": "runtime.overflowError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var overflowError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar overflowError = error(errorString(\"integer overflow\"))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#floatError",
              "documentation": {
                "identifier": "floatError",
                "newPage": false,
                "searchKey": "runtime.floatError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var floatError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar floatError = error(errorString(\"floating point error\"))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memoryError",
              "documentation": {
                "identifier": "memoryError",
                "newPage": false,
                "searchKey": "runtime.memoryError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var memoryError"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar memoryError = error(errorString(\"invalid memory address or nil pointer dereference\"))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deferType",
              "documentation": {
                "identifier": "deferType",
                "newPage": false,
                "searchKey": "runtime.deferType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var deferType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar deferType *_type // type of _defer struct\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runningPanicDefers",
              "documentation": {
                "identifier": "runningPanicDefers",
                "newPage": false,
                "searchKey": "runtime.runningPanicDefers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var runningPanicDefers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar runningPanicDefers uint32\n```\n\nrunningPanicDefers is non-zero while running deferred functions for panic. runningPanicDefers is incremented and decremented atomically. This is used to try hard to get a panic stack trace out when exiting. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicking",
              "documentation": {
                "identifier": "panicking",
                "newPage": false,
                "searchKey": "runtime.panicking",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var panicking"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar panicking uint32\n```\n\npanicking is non-zero when crashing the program for an unrecovered panic. panicking is incremented and decremented atomically. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#paniclk",
              "documentation": {
                "identifier": "paniclk",
                "newPage": false,
                "searchKey": "runtime.paniclk",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var paniclk"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar paniclk mutex\n```\n\npaniclk is held while printing the panic information and stack trace, so that two concurrent panics don't overlap their output. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#didothers",
              "documentation": {
                "identifier": "didothers",
                "newPage": false,
                "searchKey": "runtime.didothers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var didothers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar didothers bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deadlock",
              "documentation": {
                "identifier": "deadlock",
                "newPage": false,
                "searchKey": "runtime.deadlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var deadlock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar deadlock mutex\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#asyncPreemptStack",
              "documentation": {
                "identifier": "asyncPreemptStack",
                "newPage": false,
                "searchKey": "runtime.asyncPreemptStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var asyncPreemptStack"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar asyncPreemptStack = ^uintptr(0)\n```\n\nasyncPreemptStack is the bytes of stack space required to inject an asyncPreempt call. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#no_pointers_stackmap",
              "documentation": {
                "identifier": "no_pointers_stackmap",
                "newPage": false,
                "searchKey": "runtime.no_pointers_stackmap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var no_pointers_stackmap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar no_pointers_stackmap uint64 // defined in assembly, for NO_LOCAL_POINTERS macro\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printBacklog",
              "documentation": {
                "identifier": "printBacklog",
                "newPage": false,
                "searchKey": "runtime.printBacklog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var printBacklog"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar printBacklog [512]byte\n```\n\nprintBacklog is a circular buffer of messages written with the builtin print* functions, for use in postmortem analysis of core dumps. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printBacklogIndex",
              "documentation": {
                "identifier": "printBacklogIndex",
                "newPage": false,
                "searchKey": "runtime.printBacklogIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var printBacklogIndex"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar printBacklogIndex int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debuglock",
              "documentation": {
                "identifier": "debuglock",
                "newPage": false,
                "searchKey": "runtime.debuglock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var debuglock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar debuglock mutex\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minhexdigits",
              "documentation": {
                "identifier": "minhexdigits",
                "newPage": false,
                "searchKey": "runtime.minhexdigits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var minhexdigits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar minhexdigits = 0 // protected by printlock\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#modinfo",
              "documentation": {
                "identifier": "modinfo",
                "newPage": false,
                "searchKey": "runtime.modinfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var modinfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar modinfo string\n```\n\nset using cmd/go/internal/modload.ModInfoProg \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#m0",
              "documentation": {
                "identifier": "m0",
                "newPage": false,
                "searchKey": "runtime.m0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var m0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar m0 m\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#g0",
              "documentation": {
                "identifier": "g0",
                "newPage": false,
                "searchKey": "runtime.g0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var g0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar g0 g\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mcache0",
              "documentation": {
                "identifier": "mcache0",
                "newPage": false,
                "searchKey": "runtime.mcache0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mcache0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mcache0 *mcache\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raceprocctx0",
              "documentation": {
                "identifier": "raceprocctx0",
                "newPage": false,
                "searchKey": "runtime.raceprocctx0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var raceprocctx0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar raceprocctx0 uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtime_inittask",
              "documentation": {
                "identifier": "runtime_inittask",
                "newPage": false,
                "searchKey": "runtime.runtime_inittask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var runtime_inittask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar runtime_inittask initTask\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#main_inittask",
              "documentation": {
                "identifier": "main_inittask",
                "newPage": false,
                "searchKey": "runtime.main_inittask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var main_inittask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar main_inittask initTask\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#main_init_done",
              "documentation": {
                "identifier": "main_init_done",
                "newPage": false,
                "searchKey": "runtime.main_init_done",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var main_init_done"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar main_init_done chan bool\n```\n\nmain_init_done is a signal used by cgocallbackg that initialization has been completed. It is made before _cgo_notify_runtime_init_done, so all cgo calls can rely on it existing. When main_init is complete, it is closed, meaning cgocallbackg can reliably receive from it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mainStarted",
              "documentation": {
                "identifier": "mainStarted",
                "newPage": false,
                "searchKey": "runtime.mainStarted",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mainStarted"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mainStarted bool\n```\n\nmainStarted indicates that the main M has started. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtimeInitTime",
              "documentation": {
                "identifier": "runtimeInitTime",
                "newPage": false,
                "searchKey": "runtime.runtimeInitTime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var runtimeInitTime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar runtimeInitTime int64\n```\n\nruntimeInitTime is the nanotime() at which the runtime started. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#initSigmask",
              "documentation": {
                "identifier": "initSigmask",
                "newPage": false,
                "searchKey": "runtime.initSigmask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var initSigmask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar initSigmask sigset\n```\n\nValue to use for signal mask for newly created M's. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badmorestackg0Msg",
              "documentation": {
                "identifier": "badmorestackg0Msg",
                "newPage": false,
                "searchKey": "runtime.badmorestackg0Msg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var badmorestackg0Msg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badmorestackg0Msg = \"fatal: morestack on g0\\n\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badmorestackgsignalMsg",
              "documentation": {
                "identifier": "badmorestackgsignalMsg",
                "newPage": false,
                "searchKey": "runtime.badmorestackgsignalMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var badmorestackgsignalMsg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badmorestackgsignalMsg = \"fatal: morestack on gsignal\\n\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#allglock",
              "documentation": {
                "identifier": "allglock",
                "newPage": false,
                "searchKey": "runtime.allglock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var allglock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allglock mutex\n```\n\nallgs contains all Gs ever created (including dead Gs), and thus never shrinks. \n\nAccess via the slice is protected by allglock or stop-the-world. Readers that cannot take the lock may (carefully!) use the atomic variables below. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#allgs",
              "documentation": {
                "identifier": "allgs",
                "newPage": false,
                "searchKey": "runtime.allgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var allgs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allgs []*g\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#allglen",
              "documentation": {
                "identifier": "allglen",
                "newPage": false,
                "searchKey": "runtime.allglen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var allglen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allglen uintptr\n```\n\nallglen and allgptr are atomic variables that contain len(allgs) and &allgs[0] respectively. Proper ordering depends on totally-ordered loads and stores. Writes are protected by allglock. \n\nallgptr is updated before allglen. Readers should read allglen before allgptr to ensure that allglen is always <= len(allgptr). New Gs appended during the race can be missed. For a consistent view of all Gs, allglock must be held. \n\nallgptr copies should always be stored as a concrete type or unsafe.Pointer, not uintptr, to ensure that GC can still reach it even if it points to a stale array. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#allgptr",
              "documentation": {
                "identifier": "allgptr",
                "newPage": false,
                "searchKey": "runtime.allgptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var allgptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allgptr **g\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fastrandseed",
              "documentation": {
                "identifier": "fastrandseed",
                "newPage": false,
                "searchKey": "runtime.fastrandseed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fastrandseed"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fastrandseed uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freezing",
              "documentation": {
                "identifier": "freezing",
                "newPage": false,
                "searchKey": "runtime.freezing",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var freezing"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar freezing uint32\n```\n\nfreezing is set to non-zero if the runtime is trying to freeze the world. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#worldsema",
              "documentation": {
                "identifier": "worldsema",
                "newPage": false,
                "searchKey": "runtime.worldsema",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var worldsema"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar worldsema uint32 = 1\n```\n\nHolding worldsema grants an M the right to try to stop the world. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcsema",
              "documentation": {
                "identifier": "gcsema",
                "newPage": false,
                "searchKey": "runtime.gcsema",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcsema"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcsema uint32 = 1\n```\n\nHolding gcsema grants the M the right to block a GC, and blocks until the current GC is done. In particular, it prevents gomaxprocs from changing concurrently. \n\nTODO(mknyszek): Once gomaxprocs and the execution tracer can handle being changed/enabled during a GC, remove this. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoThreadStart",
              "documentation": {
                "identifier": "cgoThreadStart",
                "newPage": false,
                "searchKey": "runtime.cgoThreadStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cgoThreadStart"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cgoThreadStart unsafe.Pointer\n```\n\nWhen running with cgo, we call _cgo_thread_start to start threads for us so that we can play nicely with foreign code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#earlycgocallback",
              "documentation": {
                "identifier": "earlycgocallback",
                "newPage": false,
                "searchKey": "runtime.earlycgocallback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var earlycgocallback"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar earlycgocallback = []byte(\"fatal error: cgo callback before cgo call\\n\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#extram",
              "documentation": {
                "identifier": "extram",
                "newPage": false,
                "searchKey": "runtime.extram",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var extram"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar extram uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#extraMCount",
              "documentation": {
                "identifier": "extraMCount",
                "newPage": false,
                "searchKey": "runtime.extraMCount",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var extraMCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar extraMCount uint32 // Protected by lockextra\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#extraMWaiters",
              "documentation": {
                "identifier": "extraMWaiters",
                "newPage": false,
                "searchKey": "runtime.extraMWaiters",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var extraMWaiters"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar extraMWaiters uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#execLock",
              "documentation": {
                "identifier": "execLock",
                "newPage": false,
                "searchKey": "runtime.execLock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var execLock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar execLock rwmutex\n```\n\nexecLock serializes exec and clone to avoid bugs or unspecified behaviour around exec'ing while creating/destroying threads.  See issue #19546. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#newmHandoff",
              "documentation": {
                "identifier": "newmHandoff",
                "newPage": false,
                "searchKey": "runtime.newmHandoff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var newmHandoff"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar newmHandoff struct {\n\tlock mutex\n\n\t// newm points to a list of M structures that need new OS\n\t// threads. The list is linked through m.schedlink.\n\tnewm muintptr\n\n\t// waiting indicates that wake needs to be notified when an m\n\t// is put on the list.\n\twaiting bool\n\twake    note\n\n\t// haveTemplateThread indicates that the templateThread has\n\t// been started. This is not protected by lock. Use cas to set\n\t// to 1.\n\thaveTemplateThread uint32\n} = ...\n```\n\nnewmHandoff contains a list of m structures that need new OS threads. This is used by newm in situations where newm itself can't safely start an OS thread. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mFixupRace",
              "documentation": {
                "identifier": "mFixupRace",
                "newPage": false,
                "searchKey": "runtime.mFixupRace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mFixupRace"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mFixupRace struct {\n\tlock mutex\n\tctx  uintptr\n}\n```\n\nmFixupRace is used to temporarily borrow the race context from the coordinating m during a syscall_runtime_doAllThreadsSyscall and loan it out to each of the m's of the runtime so they can execute a mFixup.fn in that context. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inForkedChild",
              "documentation": {
                "identifier": "inForkedChild",
                "newPage": false,
                "searchKey": "runtime.inForkedChild",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var inForkedChild"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar inForkedChild bool\n```\n\ninForkedChild is true while manipulating signals in the child process. This is used to avoid calling libc functions in case we are using vfork. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pendingPreemptSignals",
              "documentation": {
                "identifier": "pendingPreemptSignals",
                "newPage": false,
                "searchKey": "runtime.pendingPreemptSignals",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var pendingPreemptSignals"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar pendingPreemptSignals uint32\n```\n\npendingPreemptSignals is the number of preemption signals that have been sent but not received. This is only used on Darwin. For #41702. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#prof",
              "documentation": {
                "identifier": "prof",
                "newPage": false,
                "searchKey": "runtime.prof",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var prof"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar prof struct {\n\tsignalLock uint32\n\thz         int32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigprofCallers",
              "documentation": {
                "identifier": "sigprofCallers",
                "newPage": false,
                "searchKey": "runtime.sigprofCallers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sigprofCallers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sigprofCallers cgoCallers\n```\n\nIf the signal handler receives a SIGPROF signal on a non-Go thread, it tries to collect a traceback into sigprofCallers. sigprofCallersUse is set to non-zero while sigprofCallers holds a traceback. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigprofCallersUse",
              "documentation": {
                "identifier": "sigprofCallersUse",
                "newPage": false,
                "searchKey": "runtime.sigprofCallersUse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sigprofCallersUse"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sigprofCallersUse uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#forcegcperiod",
              "documentation": {
                "identifier": "forcegcperiod",
                "newPage": false,
                "searchKey": "runtime.forcegcperiod",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var forcegcperiod"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar forcegcperiod int64 = 2 * 60 * 1e9\n```\n\nforcegcperiod is the maximum time in nanoseconds between garbage collections. If we go this long without a garbage collection, one is forced to run. \n\nThis is a variable for testing purposes. It normally doesn't change. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#starttime",
              "documentation": {
                "identifier": "starttime",
                "newPage": false,
                "searchKey": "runtime.starttime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var starttime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar starttime int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stealOrder",
              "documentation": {
                "identifier": "stealOrder",
                "newPage": false,
                "searchKey": "runtime.stealOrder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var stealOrder"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar stealOrder randomOrder\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inittrace",
              "documentation": {
                "identifier": "inittrace",
                "newPage": false,
                "searchKey": "runtime.inittrace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var inittrace"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar inittrace tracestat\n```\n\ninittrace stores statistics for init functions which are updated by malloc and newproc when active is true. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#overflowTag",
              "documentation": {
                "identifier": "overflowTag",
                "newPage": false,
                "searchKey": "runtime.overflowTag",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var overflowTag"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar overflowTag [1]unsafe.Pointer // always nil\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#labelSync",
              "documentation": {
                "identifier": "labelSync",
                "newPage": false,
                "searchKey": "runtime.labelSync",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var labelSync"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar labelSync uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ticks",
              "documentation": {
                "identifier": "ticks",
                "newPage": false,
                "searchKey": "runtime.ticks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ticks"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ticks struct {\n\tlock mutex\n\tpad  uint32 // ensure 8-byte alignment of val on 386\n\tval  uint64\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#envs",
              "documentation": {
                "identifier": "envs",
                "newPage": false,
                "searchKey": "runtime.envs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var envs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar envs []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#argslice",
              "documentation": {
                "identifier": "argslice",
                "newPage": false,
                "searchKey": "runtime.argslice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argslice"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argslice []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceback_cache",
              "documentation": {
                "identifier": "traceback_cache",
                "newPage": false,
                "searchKey": "runtime.traceback_cache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var traceback_cache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar traceback_cache uint32 = 2 << tracebackShift\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceback_env",
              "documentation": {
                "identifier": "traceback_env",
                "newPage": false,
                "searchKey": "runtime.traceback_env",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var traceback_env"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar traceback_env uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#argc",
              "documentation": {
                "identifier": "argc",
                "newPage": false,
                "searchKey": "runtime.argc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argc int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#argv",
              "documentation": {
                "identifier": "argv",
                "newPage": false,
                "searchKey": "runtime.argv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argv"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argv **byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#test_z64",
              "documentation": {
                "identifier": "test_z64",
                "newPage": false,
                "searchKey": "runtime.test_z64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var test_z64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar test_z64, test_x64 uint64\n```\n\nTODO: These should be locals in testAtomic64, but we don't 8-byte align stack variables on 386. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#test_x64",
              "documentation": {
                "identifier": "test_x64",
                "newPage": false,
                "searchKey": "runtime.test_x64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var test_x64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar test_z64, test_x64 uint64\n```\n\nTODO: These should be locals in testAtomic64, but we don't 8-byte align stack variables on 386. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debug",
              "documentation": {
                "identifier": "debug",
                "newPage": false,
                "searchKey": "runtime.debug",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var debug"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar debug struct {\n\tcgocheck           int32\n\tclobberfree        int32\n\tefence             int32\n\tgccheckmark        int32\n\tgcpacertrace       int32\n\tgcshrinkstackoff   int32\n\tgcstoptheworld     int32\n\tgctrace            int32\n\tinvalidptr         int32\n\tmadvdontneed       int32 // for Linux; issue 28466\n\tscavtrace          int32\n\tscheddetail        int32\n\tschedtrace         int32\n\ttracebackancestors int32\n\tasyncpreemptoff    int32\n\n\t// debug.malloc is used as a combined debug check\n\t// in the malloc function and should be set\n\t// if any of the below debug options is != 0.\n\tmalloc         bool\n\tallocfreetrace int32\n\tinittrace      int32\n\tsbrk           int32\n} = ...\n```\n\nHolds variables parsed from GODEBUG env var, except for \"memprofilerate\" since there is an existing int var for that value, which may already have an initial value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dbgvars",
              "documentation": {
                "identifier": "dbgvars",
                "newPage": false,
                "searchKey": "runtime.dbgvars",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var dbgvars"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar dbgvars = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReasonStrings",
              "documentation": {
                "identifier": "waitReasonStrings",
                "newPage": false,
                "searchKey": "runtime.waitReasonStrings",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var waitReasonStrings"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar waitReasonStrings = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#allm",
              "documentation": {
                "identifier": "allm",
                "newPage": false,
                "searchKey": "runtime.allm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var allm"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allm *m\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gomaxprocs",
              "documentation": {
                "identifier": "gomaxprocs",
                "newPage": false,
                "searchKey": "runtime.gomaxprocs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gomaxprocs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gomaxprocs int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ncpu",
              "documentation": {
                "identifier": "ncpu",
                "newPage": false,
                "searchKey": "runtime.ncpu",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ncpu"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ncpu int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#forcegc",
              "documentation": {
                "identifier": "forcegc",
                "newPage": false,
                "searchKey": "runtime.forcegc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var forcegc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar forcegc forcegcstate\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sched",
              "documentation": {
                "identifier": "sched",
                "newPage": false,
                "searchKey": "runtime.sched",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sched"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sched schedt\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#newprocs",
              "documentation": {
                "identifier": "newprocs",
                "newPage": false,
                "searchKey": "runtime.newprocs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var newprocs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar newprocs int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#allpLock",
              "documentation": {
                "identifier": "allpLock",
                "newPage": false,
                "searchKey": "runtime.allpLock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var allpLock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allpLock mutex\n```\n\nallpLock protects P-less reads and size changes of allp, idlepMask, and timerpMask, and all writes to allp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#allp",
              "documentation": {
                "identifier": "allp",
                "newPage": false,
                "searchKey": "runtime.allp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var allp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar allp []*p\n```\n\nlen(allp) == gomaxprocs; may change at safe points, otherwise immutable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#idlepMask",
              "documentation": {
                "identifier": "idlepMask",
                "newPage": false,
                "searchKey": "runtime.idlepMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var idlepMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar idlepMask pMask\n```\n\nBitmask of Ps in _Pidle list, one bit per P. Reads and writes must be atomic. Length may change at safe points. \n\nEach P must update only its own bit. In order to maintain consistency, a P going idle must the idle mask simultaneously with updates to the idle P list under the sched.lock, otherwise a racing pidleget may clear the mask before pidleput sets the mask, corrupting the bitmap. \n\nN.B., procresize takes ownership of all Ps in stopTheWorldWithSema. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timerpMask",
              "documentation": {
                "identifier": "timerpMask",
                "newPage": false,
                "searchKey": "runtime.timerpMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var timerpMask"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar timerpMask pMask\n```\n\nBitmask of Ps that may have a timer, one bit per P. Reads and writes must be atomic. Length may change at safe points. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBgMarkWorkerPool",
              "documentation": {
                "identifier": "gcBgMarkWorkerPool",
                "newPage": false,
                "searchKey": "runtime.gcBgMarkWorkerPool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcBgMarkWorkerPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcBgMarkWorkerPool lfstack\n```\n\nPool of GC parked background workers. Entries are type *gcBgMarkWorkerNode. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBgMarkWorkerCount",
              "documentation": {
                "identifier": "gcBgMarkWorkerCount",
                "newPage": false,
                "searchKey": "runtime.gcBgMarkWorkerCount",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcBgMarkWorkerCount"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcBgMarkWorkerCount int32\n```\n\nTotal number of gcBgMarkWorker goroutines. Protected by worldsema. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#processorVersionInfo",
              "documentation": {
                "identifier": "processorVersionInfo",
                "newPage": false,
                "searchKey": "runtime.processorVersionInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var processorVersionInfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar processorVersionInfo uint32\n```\n\nInformation about what cpu features are available. Packages outside the runtime should not use these as they are not an external api. Set on startup in asm_{386,amd64}.s \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isIntel",
              "documentation": {
                "identifier": "isIntel",
                "newPage": false,
                "searchKey": "runtime.isIntel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var isIntel"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar isIntel bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lfenceBeforeRdtsc",
              "documentation": {
                "identifier": "lfenceBeforeRdtsc",
                "newPage": false,
                "searchKey": "runtime.lfenceBeforeRdtsc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lfenceBeforeRdtsc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lfenceBeforeRdtsc bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goarm",
              "documentation": {
                "identifier": "goarm",
                "newPage": false,
                "searchKey": "runtime.goarm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var goarm"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar goarm uint8 // set by cmd/link on arm systems\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#islibrary",
              "documentation": {
                "identifier": "islibrary",
                "newPage": false,
                "searchKey": "runtime.islibrary",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var islibrary"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar islibrary bool // -buildmode=c-shared\n\n```\n\nSet by the linker so the runtime can determine the buildmode. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isarchive",
              "documentation": {
                "identifier": "isarchive",
                "newPage": false,
                "searchKey": "runtime.isarchive",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var isarchive"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar isarchive bool // -buildmode=c-archive\n\n```\n\nSet by the linker so the runtime can determine the buildmode. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chansendpc",
              "documentation": {
                "identifier": "chansendpc",
                "newPage": false,
                "searchKey": "runtime.chansendpc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var chansendpc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar chansendpc = funcPC(chansend)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chanrecvpc",
              "documentation": {
                "identifier": "chanrecvpc",
                "newPage": false,
                "searchKey": "runtime.chanrecvpc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var chanrecvpc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar chanrecvpc = funcPC(chanrecv)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semtable",
              "documentation": {
                "identifier": "semtable",
                "newPage": false,
                "searchKey": "runtime.semtable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var semtable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar semtable [semTabSize]struct {\n\troot semaRoot\n\tpad  [cpu.CacheLinePadSize - unsafe.Sizeof(semaRoot{})]byte\n} = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigtable",
              "documentation": {
                "identifier": "sigtable",
                "newPage": false,
                "searchKey": "runtime.sigtable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sigtable"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sigtable = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fwdSig",
              "documentation": {
                "identifier": "fwdSig",
                "newPage": false,
                "searchKey": "runtime.fwdSig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fwdSig"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fwdSig [_NSIG]uintptr\n```\n\nStores the signal handlers registered before Go installed its own. These signal handlers will be invoked in cases where Go doesn't want to handle a particular signal (e.g., signal occurred on a non-Go thread). See sigfwdgo for more information on when the signals are forwarded. \n\nThis is read by the signal handler; accesses should use atomic.Loaduintptr and atomic.Storeuintptr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#handlingSig",
              "documentation": {
                "identifier": "handlingSig",
                "newPage": false,
                "searchKey": "runtime.handlingSig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var handlingSig"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar handlingSig [_NSIG]uint32\n```\n\nhandlingSig is indexed by signal number and is non-zero if we are currently handling the signal. Or, to put it another way, whether the signal handler is currently set to the Go signal handler or not. This is uint32 rather than bool so that we can use atomic instructions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#disableSigChan",
              "documentation": {
                "identifier": "disableSigChan",
                "newPage": false,
                "searchKey": "runtime.disableSigChan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var disableSigChan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar disableSigChan chan uint32\n```\n\nchannels for synchronizing signal mask updates with the signal mask thread \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#enableSigChan",
              "documentation": {
                "identifier": "enableSigChan",
                "newPage": false,
                "searchKey": "runtime.enableSigChan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var enableSigChan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar enableSigChan chan uint32\n```\n\nchannels for synchronizing signal mask updates with the signal mask thread \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maskUpdatedChan",
              "documentation": {
                "identifier": "maskUpdatedChan",
                "newPage": false,
                "searchKey": "runtime.maskUpdatedChan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var maskUpdatedChan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar maskUpdatedChan chan struct{}\n```\n\nchannels for synchronizing signal mask updates with the signal mask thread \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#signalsOK",
              "documentation": {
                "identifier": "signalsOK",
                "newPage": false,
                "searchKey": "runtime.signalsOK",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var signalsOK"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar signalsOK bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#crashing",
              "documentation": {
                "identifier": "crashing",
                "newPage": false,
                "searchKey": "runtime.crashing",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var crashing"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar crashing int32\n```\n\ncrashing is the number of m's we have waited for when implementing GOTRACEBACK=crash when a signal is received. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#testSigtrap",
              "documentation": {
                "identifier": "testSigtrap",
                "newPage": false,
                "searchKey": "runtime.testSigtrap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testSigtrap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testSigtrap func(info *siginfo, ctxt *sigctxt, gp *g) bool\n```\n\ntestSigtrap and testSigusr1 are used by the runtime tests. If non-nil, it is called on SIGTRAP/SIGUSR1. If it returns true, the normal behavior on this signal is suppressed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#testSigusr1",
              "documentation": {
                "identifier": "testSigusr1",
                "newPage": false,
                "searchKey": "runtime.testSigusr1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var testSigusr1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar testSigusr1 func(gp *g) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badginsignalMsg",
              "documentation": {
                "identifier": "badginsignalMsg",
                "newPage": false,
                "searchKey": "runtime.badginsignalMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var badginsignalMsg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badginsignalMsg = \"fatal: bad g in signal handler\\n\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigsetAllExiting",
              "documentation": {
                "identifier": "sigsetAllExiting",
                "newPage": false,
                "searchKey": "runtime.sigsetAllExiting",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sigsetAllExiting"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sigsetAllExiting = sigset_all\n```\n\nsigsetAllExiting is used by sigblock(true) when a thread is exiting. sigset_all is defined in OS specific code, and per GOOS behavior may override this default for sigsetAllExiting: see osinit(). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sig",
              "documentation": {
                "identifier": "sig",
                "newPage": false,
                "searchKey": "runtime.sig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sig"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sig struct {\n\tnote       note\n\tmask       [(_NSIG + 31) / 32]uint32\n\twanted     [(_NSIG + 31) / 32]uint32\n\tignored    [(_NSIG + 31) / 32]uint32\n\trecv       [(_NSIG + 31) / 32]uint32\n\tstate      uint32\n\tdelivering uint32\n\tinuse      bool\n} = ...\n```\n\nsig handles communication between the signal handler and os/signal. Other than the inuse and recv fields, the fields are accessed atomically. \n\nThe wanted and ignored fields are only written by one goroutine at a time; access is controlled by the handlers Mutex in os/signal. The fields are only read by that one goroutine and by the signal handler. We access them atomically to minimize the race between setting them in the goroutine calling os/signal and the signal handler, which may be running in a different thread. That race is unavoidable, as there is no connection between handling a signal and receiving one, but atomic instructions should minimize it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#class_to_size",
              "documentation": {
                "identifier": "class_to_size",
                "newPage": false,
                "searchKey": "runtime.class_to_size",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var class_to_size"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar class_to_size = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#class_to_allocnpages",
              "documentation": {
                "identifier": "class_to_allocnpages",
                "newPage": false,
                "searchKey": "runtime.class_to_allocnpages",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var class_to_allocnpages"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar class_to_allocnpages = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#class_to_divmagic",
              "documentation": {
                "identifier": "class_to_divmagic",
                "newPage": false,
                "searchKey": "runtime.class_to_divmagic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var class_to_divmagic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar class_to_divmagic = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#size_to_class8",
              "documentation": {
                "identifier": "size_to_class8",
                "newPage": false,
                "searchKey": "runtime.size_to_class8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var size_to_class8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar size_to_class8 = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#size_to_class128",
              "documentation": {
                "identifier": "size_to_class128",
                "newPage": false,
                "searchKey": "runtime.size_to_class128",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var size_to_class128"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar size_to_class128 = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackpool",
              "documentation": {
                "identifier": "stackpool",
                "newPage": false,
                "searchKey": "runtime.stackpool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var stackpool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar stackpool [_NumStackOrders]struct {\n\titem stackpoolItem\n\t_    [cpu.CacheLinePadSize - unsafe.Sizeof(stackpoolItem{})%cpu.CacheLinePadSize]byte\n} = ...\n```\n\nGlobal pool of spans that have free stacks. Stacks are assigned an order according to size. \n\n```\norder = log_2(size/FixedStack)\n\n```\nThere is a free list for each order. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackLarge",
              "documentation": {
                "identifier": "stackLarge",
                "newPage": false,
                "searchKey": "runtime.stackLarge",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var stackLarge"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar stackLarge struct {\n\tlock mutex\n\tfree [heapAddrBits - pageShift]mSpanList // free lists by log_2(s.npages)\n} = ...\n```\n\nGlobal pool of large stack spans. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxstacksize",
              "documentation": {
                "identifier": "maxstacksize",
                "newPage": false,
                "searchKey": "runtime.maxstacksize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var maxstacksize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar maxstacksize uintptr = 1 << 20 // enough until runtime.main sets it for real\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maxstackceiling",
              "documentation": {
                "identifier": "maxstackceiling",
                "newPage": false,
                "searchKey": "runtime.maxstackceiling",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var maxstackceiling"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar maxstackceiling = maxstacksize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ptrnames",
              "documentation": {
                "identifier": "ptrnames",
                "newPage": false,
                "searchKey": "runtime.ptrnames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ptrnames"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ptrnames = []string{\n\t0: \"scalar\",\n\t1: \"ptr\",\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#abiRegArgsEface",
              "documentation": {
                "identifier": "abiRegArgsEface",
                "newPage": false,
                "searchKey": "runtime.abiRegArgsEface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var abiRegArgsEface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar abiRegArgsEface interface{} = abi.RegArgs{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#abiRegArgsType",
              "documentation": {
                "identifier": "abiRegArgsType",
                "newPage": false,
                "searchKey": "runtime.abiRegArgsType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var abiRegArgsType"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar abiRegArgsType *_type = efaceOf(&abiRegArgsEface)._type\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#methodValueCallFrameObjs",
              "documentation": {
                "identifier": "methodValueCallFrameObjs",
                "newPage": false,
                "searchKey": "runtime.methodValueCallFrameObjs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var methodValueCallFrameObjs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar methodValueCallFrameObjs = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badsystemstackMsg",
              "documentation": {
                "identifier": "badsystemstackMsg",
                "newPage": false,
                "searchKey": "runtime.badsystemstackMsg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var badsystemstackMsg"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar badsystemstackMsg = \"fatal: systemstack called from unexpected goroutine\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hashLoad",
              "documentation": {
                "identifier": "hashLoad",
                "newPage": false,
                "searchKey": "runtime.hashLoad",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var hashLoad"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar hashLoad = float32(loadFactorNum) / float32(loadFactorDen)\n```\n\nexported value for testing \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#intArgRegs",
              "documentation": {
                "identifier": "intArgRegs",
                "newPage": false,
                "searchKey": "runtime.intArgRegs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var intArgRegs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar intArgRegs = abi.IntArgRegs * goexperiment.RegabiArgsInt\n```\n\nintArgRegs is used by the various register assignment algorithm implementations in the runtime. These include:. - Finalizers (mfinal.go) - Windows callbacks (syscall_windows.go) \n\nBoth are stripped-down versions of the algorithm since they only have to deal with a subset of cases (finalizers only take a pointer or interface argument, Go Windows callbacks don't support floating point). \n\nIt should be modified with care and are generally only modified when testing this package. \n\nIt should never be set higher than its internal/abi constant counterparts, because the system relies on a structure that is at least large enough to hold the registers the system supports. \n\nCurrently it's set to zero because using the actual constant will break every part of the toolchain that uses finalizers or Windows callbacks to call functions The value that is currently commented out there should be the actual value once we're ready to use the register ABI everywhere. \n\nProtected by finlock. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pinnedTypemaps",
              "documentation": {
                "identifier": "pinnedTypemaps",
                "newPage": false,
                "searchKey": "runtime.pinnedTypemaps",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var pinnedTypemaps"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar pinnedTypemaps []map[typeOff]*_type\n```\n\npinnedTypemaps are the map[typeOff]*_type from the moduledata objects. \n\nThese typemap objects are allocated at run time on the heap, but the only direct reference to them is in the moduledata, created by the linker and marked SNOPTRDATA so it is ignored by the GC. \n\nTo make sure the map isn't collected, we keep a second reference here. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#firstmoduledata",
              "documentation": {
                "identifier": "firstmoduledata",
                "newPage": false,
                "searchKey": "runtime.firstmoduledata",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var firstmoduledata"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar firstmoduledata moduledata // linker symbol\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lastmoduledatap",
              "documentation": {
                "identifier": "lastmoduledatap",
                "newPage": false,
                "searchKey": "runtime.lastmoduledatap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lastmoduledatap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lastmoduledatap *moduledata // linker symbol\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#modulesSlice",
              "documentation": {
                "identifier": "modulesSlice",
                "newPage": false,
                "searchKey": "runtime.modulesSlice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var modulesSlice"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar modulesSlice *[]*moduledata // see activeModules\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#faketime",
              "documentation": {
                "identifier": "faketime",
                "newPage": false,
                "searchKey": "runtime.faketime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var faketime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar faketime int64\n```\n\nfaketime is the simulated time in nanoseconds since 1970 for the playground. \n\nZero means not to use faketime. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#trace",
              "documentation": {
                "identifier": "trace",
                "newPage": false,
                "searchKey": "runtime.trace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var trace"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar trace struct {\n\tlock          mutex       // protects the following members\n\tlockOwner     *g          // to avoid deadlocks during recursive lock locks\n\tenabled       bool        // when set runtime traces events\n\tshutdown      bool        // set when we are waiting for trace reader to finish after setting enabled to false\n\theaderWritten bool        // whether ReadTrace has emitted trace header\n\tfooterWritten bool        // whether ReadTrace has emitted trace footer\n\tshutdownSema  uint32      // used to wait for ReadTrace completion\n\tseqStart      uint64      // sequence number when tracing was started\n\tticksStart    int64       // cputicks when tracing was started\n\tticksEnd      int64       // cputicks when tracing was stopped\n\ttimeStart     int64       // nanotime when tracing was started\n\ttimeEnd       int64       // nanotime when tracing was stopped\n\tseqGC         uint64      // GC start/done sequencer\n\treading       traceBufPtr // buffer currently handed off to user\n\tempty         traceBufPtr // stack of empty buffers\n\tfullHead      traceBufPtr // queue of full buffers\n\tfullTail      traceBufPtr\n\treader        guintptr        // goroutine that called ReadTrace, or nil\n\tstackTab      traceStackTable // maps stack traces to unique ids\n\n\t// Dictionary for traceEvString.\n\t//\n\t// TODO: central lock to access the map is not ideal.\n\t//   option: pre-assign ids to all user annotation region names and tags\n\t//   option: per-P cache\n\t//   option: sync.Map like data structure\n\tstringsLock mutex\n\tstrings     map[string]uint64\n\tstringSeq   uint64\n\n\t// markWorkerLabels maps gcMarkWorkerMode to string ID.\n\tmarkWorkerLabels [len(gcMarkWorkerModeStrings)]uint64\n\n\tbufLock mutex       // protects buf\n\tbuf     traceBufPtr // global trace buffer, used when running without a p\n} = ...\n```\n\ntrace is global tracing context. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gStatusStrings",
              "documentation": {
                "identifier": "gStatusStrings",
                "newPage": false,
                "searchKey": "runtime.gStatusStrings",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gStatusStrings"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gStatusStrings = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoTraceback",
              "documentation": {
                "identifier": "cgoTraceback",
                "newPage": false,
                "searchKey": "runtime.cgoTraceback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cgoTraceback"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cgoTraceback unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoContext",
              "documentation": {
                "identifier": "cgoContext",
                "newPage": false,
                "searchKey": "runtime.cgoContext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cgoContext"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cgoContext unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoSymbolizer",
              "documentation": {
                "identifier": "cgoSymbolizer",
                "newPage": false,
                "searchKey": "runtime.cgoSymbolizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cgoSymbolizer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cgoSymbolizer unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectOffs",
              "documentation": {
                "identifier": "reflectOffs",
                "newPage": false,
                "searchKey": "runtime.reflectOffs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var reflectOffs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar reflectOffs struct {\n\tlock mutex\n\tnext int32\n\tm    map[int32]unsafe.Pointer\n\tminv map[unsafe.Pointer]int32\n} = ...\n```\n\nreflectOffs holds type offsets defined at run time by the reflect package. \n\nWhen a type is defined at run time, its *rtype data lives on the heap. There are a wide range of possible addresses the heap may use, that may not be representable as a 32-bit offset. Moreover the GC may one day start moving heap memory, in which case there is no stable offset that can be defined. \n\nTo provide stable offsets, we add pin *rtype objects in a global map and treat the offset as an identifier. We use negative offsets that do not overlap with any compile-time module offsets. \n\nEntries are created by reflect.addReflectOff. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Dlog",
              "documentation": {
                "identifier": "Dlog",
                "newPage": false,
                "searchKey": "runtime.Dlog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Dlog"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Dlog = dlog\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Mmap",
              "documentation": {
                "identifier": "Mmap",
                "newPage": false,
                "searchKey": "runtime.Mmap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Mmap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Mmap = mmap\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Munmap",
              "documentation": {
                "identifier": "Munmap",
                "newPage": false,
                "searchKey": "runtime.Munmap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Munmap"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Munmap = munmap\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Pipe",
              "documentation": {
                "identifier": "Pipe",
                "newPage": false,
                "searchKey": "runtime.Pipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Pipe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Pipe = pipe\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Fadd64",
              "documentation": {
                "identifier": "Fadd64",
                "newPage": false,
                "searchKey": "runtime.Fadd64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Fadd64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Fadd64 = fadd64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Fsub64",
              "documentation": {
                "identifier": "Fsub64",
                "newPage": false,
                "searchKey": "runtime.Fsub64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Fsub64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Fsub64 = fsub64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Fmul64",
              "documentation": {
                "identifier": "Fmul64",
                "newPage": false,
                "searchKey": "runtime.Fmul64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Fmul64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Fmul64 = fmul64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Fdiv64",
              "documentation": {
                "identifier": "Fdiv64",
                "newPage": false,
                "searchKey": "runtime.Fdiv64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Fdiv64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Fdiv64 = fdiv64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#F64to32",
              "documentation": {
                "identifier": "F64to32",
                "newPage": false,
                "searchKey": "runtime.F64to32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var F64to32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar F64to32 = f64to32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#F32to64",
              "documentation": {
                "identifier": "F32to64",
                "newPage": false,
                "searchKey": "runtime.F32to64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var F32to64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar F32to64 = f32to64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Fcmp64",
              "documentation": {
                "identifier": "Fcmp64",
                "newPage": false,
                "searchKey": "runtime.Fcmp64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Fcmp64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Fcmp64 = fcmp64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Fintto64",
              "documentation": {
                "identifier": "Fintto64",
                "newPage": false,
                "searchKey": "runtime.Fintto64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Fintto64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Fintto64 = fintto64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#F64toint",
              "documentation": {
                "identifier": "F64toint",
                "newPage": false,
                "searchKey": "runtime.F64toint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var F64toint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar F64toint = f64toint\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Entersyscall",
              "documentation": {
                "identifier": "Entersyscall",
                "newPage": false,
                "searchKey": "runtime.Entersyscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Entersyscall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Entersyscall = entersyscall\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Exitsyscall",
              "documentation": {
                "identifier": "Exitsyscall",
                "newPage": false,
                "searchKey": "runtime.Exitsyscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Exitsyscall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Exitsyscall = exitsyscall\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#LockedOSThread",
              "documentation": {
                "identifier": "LockedOSThread",
                "newPage": false,
                "searchKey": "runtime.LockedOSThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var LockedOSThread"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar LockedOSThread = lockedOSThread\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Xadduintptr",
              "documentation": {
                "identifier": "Xadduintptr",
                "newPage": false,
                "searchKey": "runtime.Xadduintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Xadduintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Xadduintptr = atomic.Xadduintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#FuncPC",
              "documentation": {
                "identifier": "FuncPC",
                "newPage": false,
                "searchKey": "runtime.FuncPC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var FuncPC"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar FuncPC = funcPC\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Fastlog2",
              "documentation": {
                "identifier": "Fastlog2",
                "newPage": false,
                "searchKey": "runtime.Fastlog2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Fastlog2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Fastlog2 = fastlog2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Atoi",
              "documentation": {
                "identifier": "Atoi",
                "newPage": false,
                "searchKey": "runtime.Atoi",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Atoi"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Atoi = atoi\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Atoi32",
              "documentation": {
                "identifier": "Atoi32",
                "newPage": false,
                "searchKey": "runtime.Atoi32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Atoi32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Atoi32 = atoi32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Nanotime",
              "documentation": {
                "identifier": "Nanotime",
                "newPage": false,
                "searchKey": "runtime.Nanotime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Nanotime"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Nanotime = nanotime\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#NetpollBreak",
              "documentation": {
                "identifier": "NetpollBreak",
                "newPage": false,
                "searchKey": "runtime.NetpollBreak",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var NetpollBreak"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar NetpollBreak = netpollBreak\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Usleep",
              "documentation": {
                "identifier": "Usleep",
                "newPage": false,
                "searchKey": "runtime.Usleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Usleep"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Usleep = usleep\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PhysPageSize",
              "documentation": {
                "identifier": "PhysPageSize",
                "newPage": false,
                "searchKey": "runtime.PhysPageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var PhysPageSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar PhysPageSize = physPageSize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PhysHugePageSize",
              "documentation": {
                "identifier": "PhysHugePageSize",
                "newPage": false,
                "searchKey": "runtime.PhysHugePageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var PhysHugePageSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar PhysHugePageSize = physHugePageSize\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#NetpollGenericInit",
              "documentation": {
                "identifier": "NetpollGenericInit",
                "newPage": false,
                "searchKey": "runtime.NetpollGenericInit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var NetpollGenericInit"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar NetpollGenericInit = netpollGenericInit\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Memmove",
              "documentation": {
                "identifier": "Memmove",
                "newPage": false,
                "searchKey": "runtime.Memmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Memmove"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Memmove = memmove\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MemclrNoHeapPointers",
              "documentation": {
                "identifier": "MemclrNoHeapPointers",
                "newPage": false,
                "searchKey": "runtime.MemclrNoHeapPointers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var MemclrNoHeapPointers"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar MemclrNoHeapPointers = memclrNoHeapPointers\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#LockPartialOrder",
              "documentation": {
                "identifier": "LockPartialOrder",
                "newPage": false,
                "searchKey": "runtime.LockPartialOrder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var LockPartialOrder"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar LockPartialOrder = lockPartialOrder\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#RunSchedLocalQueueEmptyState",
              "documentation": {
                "identifier": "RunSchedLocalQueueEmptyState",
                "newPage": false,
                "searchKey": "runtime.RunSchedLocalQueueEmptyState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var RunSchedLocalQueueEmptyState"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar RunSchedLocalQueueEmptyState struct {\n\tdone  chan bool\n\tready *uint32\n\tp     *p\n}\n```\n\nTemporary to enable register ABI bringup. TODO(register args): convert back to local variables in RunSchedLocalQueueEmptyTest that get passed to the \"go\" stmts there. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#StringHash",
              "documentation": {
                "identifier": "StringHash",
                "newPage": false,
                "searchKey": "runtime.StringHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var StringHash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar StringHash = stringHash\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#BytesHash",
              "documentation": {
                "identifier": "BytesHash",
                "newPage": false,
                "searchKey": "runtime.BytesHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var BytesHash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar BytesHash = bytesHash\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Int32Hash",
              "documentation": {
                "identifier": "Int32Hash",
                "newPage": false,
                "searchKey": "runtime.Int32Hash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Int32Hash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Int32Hash = int32Hash\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Int64Hash",
              "documentation": {
                "identifier": "Int64Hash",
                "newPage": false,
                "searchKey": "runtime.Int64Hash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Int64Hash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Int64Hash = int64Hash\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MemHash",
              "documentation": {
                "identifier": "MemHash",
                "newPage": false,
                "searchKey": "runtime.MemHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var MemHash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar MemHash = memhash\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MemHash32",
              "documentation": {
                "identifier": "MemHash32",
                "newPage": false,
                "searchKey": "runtime.MemHash32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var MemHash32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar MemHash32 = memhash32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MemHash64",
              "documentation": {
                "identifier": "MemHash64",
                "newPage": false,
                "searchKey": "runtime.MemHash64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var MemHash64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar MemHash64 = memhash64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#EfaceHash",
              "documentation": {
                "identifier": "EfaceHash",
                "newPage": false,
                "searchKey": "runtime.EfaceHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var EfaceHash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar EfaceHash = efaceHash\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#IfaceHash",
              "documentation": {
                "identifier": "IfaceHash",
                "newPage": false,
                "searchKey": "runtime.IfaceHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var IfaceHash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar IfaceHash = ifaceHash\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#UseAeshash",
              "documentation": {
                "identifier": "UseAeshash",
                "newPage": false,
                "searchKey": "runtime.UseAeshash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var UseAeshash"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar UseAeshash = &useAeshash\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#HashLoad",
              "documentation": {
                "identifier": "HashLoad",
                "newPage": false,
                "searchKey": "runtime.HashLoad",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var HashLoad"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar HashLoad = &hashLoad\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Open",
              "documentation": {
                "identifier": "Open",
                "newPage": false,
                "searchKey": "runtime.Open",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Open"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Open = open\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Close",
              "documentation": {
                "identifier": "Close",
                "newPage": false,
                "searchKey": "runtime.Close",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Close"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Close = closefd\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Read",
              "documentation": {
                "identifier": "Read",
                "newPage": false,
                "searchKey": "runtime.Read",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Read"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Read = read\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Write",
              "documentation": {
                "identifier": "Write",
                "newPage": false,
                "searchKey": "runtime.Write",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Write"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Write = write\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#BigEndian",
              "documentation": {
                "identifier": "BigEndian",
                "newPage": false,
                "searchKey": "runtime.BigEndian",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var BigEndian"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar BigEndian = sys.BigEndian\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ForceGCPeriod",
              "documentation": {
                "identifier": "ForceGCPeriod",
                "newPage": false,
                "searchKey": "runtime.ForceGCPeriod",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ForceGCPeriod"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ForceGCPeriod = &forcegcperiod\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ReadUnaligned32",
              "documentation": {
                "identifier": "ReadUnaligned32",
                "newPage": false,
                "searchKey": "runtime.ReadUnaligned32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ReadUnaligned32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ReadUnaligned32 = readUnaligned32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ReadUnaligned64",
              "documentation": {
                "identifier": "ReadUnaligned64",
                "newPage": false,
                "searchKey": "runtime.ReadUnaligned64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ReadUnaligned64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ReadUnaligned64 = readUnaligned64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#BaseChunkIdx",
              "documentation": {
                "identifier": "BaseChunkIdx",
                "newPage": false,
                "searchKey": "runtime.BaseChunkIdx",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var BaseChunkIdx"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar BaseChunkIdx = ...\n```\n\nBaseChunkIdx is a convenient chunkIdx value which works on both 64 bit and 32 bit platforms, allowing the tests to share code between the two. \n\nThis should not be higher than 0x100*pallocChunkBytes to support mips and mipsle, which only have 31-bit address spaces. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Semacquire",
              "documentation": {
                "identifier": "Semacquire",
                "newPage": false,
                "searchKey": "runtime.Semacquire",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Semacquire"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Semacquire = semacquire\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Semrelease1",
              "documentation": {
                "identifier": "Semrelease1",
                "newPage": false,
                "searchKey": "runtime.Semrelease1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Semrelease1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Semrelease1 = semrelease1\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GCTestMoveStackOnNextCall",
              "documentation": {
                "identifier": "GCTestMoveStackOnNextCall",
                "newPage": false,
                "searchKey": "runtime.GCTestMoveStackOnNextCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var GCTestMoveStackOnNextCall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar GCTestMoveStackOnNextCall = gcTestMoveStackOnNextCall\n```\n\nFor GCTestMoveStackOnNextCall, it's important not to introduce an extra layer of call, since then there's a return before the \"real\" next call. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#NonblockingPipe",
              "documentation": {
                "identifier": "NonblockingPipe",
                "newPage": false,
                "searchKey": "runtime.NonblockingPipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var NonblockingPipe"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar NonblockingPipe = nonblockingPipe\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#SetNonblock",
              "documentation": {
                "identifier": "SetNonblock",
                "newPage": false,
                "searchKey": "runtime.SetNonblock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var SetNonblock"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar SetNonblock = setNonblock\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Closeonexec",
              "documentation": {
                "identifier": "Closeonexec",
                "newPage": false,
                "searchKey": "runtime.Closeonexec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var Closeonexec"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar Closeonexec = closeonexec\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitForSigusr1",
              "documentation": {
                "identifier": "waitForSigusr1",
                "newPage": false,
                "searchKey": "runtime.waitForSigusr1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var waitForSigusr1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar waitForSigusr1 struct {\n\trdpipe int32\n\twrpipe int32\n\tmID    int64\n}\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/runtime#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/runtime#cgoCallers",
              "documentation": {
                "identifier": "cgoCallers",
                "newPage": false,
                "searchKey": "runtime.cgoCallers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cgoCallers [32]uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cgoCallers [32]uintptr\n```\n\nAddresses collected in a cgo backtrace when crashing. Length must match arg.Max in x_cgo_callers in runtime/cgo/gcc_traceback.c. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#argset",
              "documentation": {
                "identifier": "argset",
                "newPage": false,
                "searchKey": "runtime.argset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type argset struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype argset struct {\n\targs   unsafe.Pointer\n\tretval uintptr\n}\n```\n\nargset matches runtime/cgo/linux_syscall.c:argset_t \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hchan",
              "documentation": {
                "identifier": "hchan",
                "newPage": false,
                "searchKey": "runtime.hchan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type hchan struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype hchan struct {\n\tqcount   uint           // total data in the queue\n\tdataqsiz uint           // size of the circular queue\n\tbuf      unsafe.Pointer // points to an array of dataqsiz elements\n\telemsize uint16\n\tclosed   uint32\n\telemtype *_type // element type\n\tsendx    uint   // send index\n\trecvx    uint   // receive index\n\trecvq    waitq  // list of recv waiters\n\tsendq    waitq  // list of send waiters\n\n\t// lock protects all fields in hchan, as well as several\n\t// fields in sudogs blocked on this channel.\n\t//\n\t// Do not change another G's status while holding this lock\n\t// (in particular, do not ready a G), as this can deadlock\n\t// with stack shrinking.\n\tlock mutex\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#reflect_makechan",
                    "documentation": {
                      "identifier": "reflect_makechan",
                      "newPage": false,
                      "searchKey": "runtime.reflect_makechan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func reflect_makechan(t *chantype, size int) *hchan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc reflect_makechan(t *chantype, size int) *hchan\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#makechan64",
                    "documentation": {
                      "identifier": "makechan64",
                      "newPage": false,
                      "searchKey": "runtime.makechan64",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makechan64(t *chantype, size int64) *hchan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makechan64(t *chantype, size int64) *hchan\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#makechan",
                    "documentation": {
                      "identifier": "makechan",
                      "newPage": false,
                      "searchKey": "runtime.makechan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makechan(t *chantype, size int) *hchan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makechan(t *chantype, size int) *hchan\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#hchan.raceaddr",
                    "documentation": {
                      "identifier": "hchan.raceaddr",
                      "newPage": false,
                      "searchKey": "runtime.hchan.raceaddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *hchan) raceaddr() unsafe.Pointer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *hchan) raceaddr() unsafe.Pointer\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#hchan.sortkey",
                    "documentation": {
                      "identifier": "hchan.sortkey",
                      "newPage": false,
                      "searchKey": "runtime.hchan.sortkey",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *hchan) sortkey() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *hchan) sortkey() uintptr\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitq",
              "documentation": {
                "identifier": "waitq",
                "newPage": false,
                "searchKey": "runtime.waitq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type waitq struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype waitq struct {\n\tfirst *sudog\n\tlast  *sudog\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#waitq.enqueue",
                    "documentation": {
                      "identifier": "waitq.enqueue",
                      "newPage": false,
                      "searchKey": "runtime.waitq.enqueue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *waitq) enqueue(sgp *sudog)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *waitq) enqueue(sgp *sudog)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#waitq.dequeue",
                    "documentation": {
                      "identifier": "waitq.dequeue",
                      "newPage": false,
                      "searchKey": "runtime.waitq.dequeue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *waitq) dequeue() *sudog"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *waitq) dequeue() *sudog\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#waitq.dequeueSudoG",
                    "documentation": {
                      "identifier": "waitq.dequeueSudoG",
                      "newPage": false,
                      "searchKey": "runtime.waitq.dequeueSudoG",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *waitq) dequeueSudoG(sgp *sudog)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *waitq) dequeueSudoG(sgp *sudog)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cpuProfile",
              "documentation": {
                "identifier": "cpuProfile",
                "newPage": false,
                "searchKey": "runtime.cpuProfile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cpuProfile struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cpuProfile struct {\n\tlock mutex\n\ton   bool     // profiling is on\n\tlog  *profBuf // profile events written here\n\n\t// extra holds extra stacks accumulated in addNonGo\n\t// corresponding to profiling signals arriving on\n\t// non-Go-created threads. Those stacks are written\n\t// to log the next time a normal Go thread gets the\n\t// signal handler.\n\t// Assuming the stacks are 2 words each (we don't get\n\t// a full traceback from those threads), plus one word\n\t// size for framing, 100 Hz profiling would generate\n\t// 300 words per second.\n\t// Hopefully a normal Go thread will get the profiling\n\t// signal at least once every few seconds.\n\textra      [1000]uintptr\n\tnumExtra   int\n\tlostExtra  uint64 // count of frames lost because extra is full\n\tlostAtomic uint64 // count of frames lost because of being in atomic64 on mips/arm; updated racily\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#cpuProfile.add",
                    "documentation": {
                      "identifier": "cpuProfile.add",
                      "newPage": false,
                      "searchKey": "runtime.cpuProfile.add",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *cpuProfile) add(gp *g, stk []uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *cpuProfile) add(gp *g, stk []uintptr)\n```\n\nadd adds the stack trace to the profile. It is called from signal handlers and other limited environments and cannot allocate memory or acquire locks that might be held at the time of the signal, nor can it use substantial amounts of stack. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#cpuProfile.addNonGo",
                    "documentation": {
                      "identifier": "cpuProfile.addNonGo",
                      "newPage": false,
                      "searchKey": "runtime.cpuProfile.addNonGo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *cpuProfile) addNonGo(stk []uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *cpuProfile) addNonGo(stk []uintptr)\n```\n\naddNonGo adds the non-Go stack trace to the profile. It is called from a non-Go thread, so we cannot use much stack at all, nor do anything that needs a g or an m. In particular, we can't call cpuprof.log.write. Instead, we copy the stack into cpuprof.extra, which will be drained the next time a Go thread gets the signal handling event. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#cpuProfile.addExtra",
                    "documentation": {
                      "identifier": "cpuProfile.addExtra",
                      "newPage": false,
                      "searchKey": "runtime.cpuProfile.addExtra",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *cpuProfile) addExtra()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *cpuProfile) addExtra()\n```\n\naddExtra adds the \"extra\" profiling events, queued by addNonGo, to the profile log. addExtra is called either from a signal handler on a Go thread or from an ordinary goroutine; either way it can use stack and has a g. The world may be stopped, though. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCallWrapArgs",
              "documentation": {
                "identifier": "debugCallWrapArgs",
                "newPage": false,
                "searchKey": "runtime.debugCallWrapArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type debugCallWrapArgs struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype debugCallWrapArgs struct {\n\tdispatch uintptr\n\tcallingG *g\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dlogger",
              "documentation": {
                "identifier": "dlogger",
                "newPage": false,
                "searchKey": "runtime.dlogger",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type dlogger struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dlogger struct {\n\tw debugLogWriter\n\n\t// allLink is the next dlogger in the allDloggers list.\n\tallLink *dlogger\n\n\t// owned indicates that this dlogger is owned by an M. This is\n\t// accessed atomically.\n\towned uint32\n}\n```\n\nA dlogger writes to the debug log. \n\nTo obtain a dlogger, call dlog(). When done with the dlogger, call end(). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#dlog",
                    "documentation": {
                      "identifier": "dlog",
                      "newPage": false,
                      "searchKey": "runtime.dlog",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func dlog() *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc dlog() *dlogger\n```\n\ndlog returns a debug logger. The caller can use methods on the returned logger to add values, which will be space-separated in the final output, much like println. The caller must call end() to finish the message. \n\ndlog can be used from highly-constrained corners of the runtime: it is safe to use in the signal handler, from within the write barrier, from within the stack implementation, and in places that must be recursively nosplit. \n\nThis will be compiled away if built without the debuglog build tag. However, argument construction may not be. If any of the arguments are not literals or trivial expressions, consider protecting the call with \"if dlogEnabled\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#getCachedDlogger",
                    "documentation": {
                      "identifier": "getCachedDlogger",
                      "newPage": false,
                      "searchKey": "runtime.getCachedDlogger",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func getCachedDlogger() *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc getCachedDlogger() *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.end",
                    "documentation": {
                      "identifier": "dlogger.end",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.end",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) end()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) end()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.b",
                    "documentation": {
                      "identifier": "dlogger.b",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.b",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) b(x bool) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) b(x bool) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.i",
                    "documentation": {
                      "identifier": "dlogger.i",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.i",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) i(x int) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) i(x int) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.i8",
                    "documentation": {
                      "identifier": "dlogger.i8",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.i8",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) i8(x int8) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) i8(x int8) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.i16",
                    "documentation": {
                      "identifier": "dlogger.i16",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.i16",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) i16(x int16) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) i16(x int16) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.i32",
                    "documentation": {
                      "identifier": "dlogger.i32",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.i32",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) i32(x int32) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) i32(x int32) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.i64",
                    "documentation": {
                      "identifier": "dlogger.i64",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.i64",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) i64(x int64) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) i64(x int64) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.u",
                    "documentation": {
                      "identifier": "dlogger.u",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.u",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) u(x uint) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) u(x uint) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.uptr",
                    "documentation": {
                      "identifier": "dlogger.uptr",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.uptr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) uptr(x uintptr) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) uptr(x uintptr) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.u8",
                    "documentation": {
                      "identifier": "dlogger.u8",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.u8",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) u8(x uint8) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) u8(x uint8) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.u16",
                    "documentation": {
                      "identifier": "dlogger.u16",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.u16",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) u16(x uint16) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) u16(x uint16) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.u32",
                    "documentation": {
                      "identifier": "dlogger.u32",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.u32",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) u32(x uint32) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) u32(x uint32) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.u64",
                    "documentation": {
                      "identifier": "dlogger.u64",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.u64",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) u64(x uint64) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) u64(x uint64) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.hex",
                    "documentation": {
                      "identifier": "dlogger.hex",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.hex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) hex(x uint64) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) hex(x uint64) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.p",
                    "documentation": {
                      "identifier": "dlogger.p",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.p",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) p(x interface{}) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) p(x interface{}) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.s",
                    "documentation": {
                      "identifier": "dlogger.s",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.s",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) s(x string) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) s(x string) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.pc",
                    "documentation": {
                      "identifier": "dlogger.pc",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.pc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) pc(x uintptr) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) pc(x uintptr) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.traceback",
                    "documentation": {
                      "identifier": "dlogger.traceback",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.traceback",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) traceback(x []uintptr) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) traceback(x []uintptr) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.End",
                    "documentation": {
                      "identifier": "dlogger.End",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.End",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) End()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) End()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.B",
                    "documentation": {
                      "identifier": "dlogger.B",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.B",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) B(x bool) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) B(x bool) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.I",
                    "documentation": {
                      "identifier": "dlogger.I",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.I",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) I(x int) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) I(x int) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.I16",
                    "documentation": {
                      "identifier": "dlogger.I16",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.I16",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) I16(x int16) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) I16(x int16) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.U64",
                    "documentation": {
                      "identifier": "dlogger.U64",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.U64",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) U64(x uint64) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) U64(x uint64) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.Hex",
                    "documentation": {
                      "identifier": "dlogger.Hex",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.Hex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) Hex(x uint64) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) Hex(x uint64) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.P",
                    "documentation": {
                      "identifier": "dlogger.P",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.P",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) P(x interface{}) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) P(x interface{}) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.S",
                    "documentation": {
                      "identifier": "dlogger.S",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.S",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) S(x string) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) S(x string) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#dlogger.PC",
                    "documentation": {
                      "identifier": "dlogger.PC",
                      "newPage": false,
                      "searchKey": "runtime.dlogger.PC",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *dlogger) PC(x uintptr) *dlogger"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *dlogger) PC(x uintptr) *dlogger\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogWriter",
              "documentation": {
                "identifier": "debugLogWriter",
                "newPage": false,
                "searchKey": "runtime.debugLogWriter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type debugLogWriter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype debugLogWriter struct {\n\twrite uint64\n\tdata  debugLogBuf\n\n\t// tick and nano are the time bases from the most recently\n\t// written sync record.\n\ttick, nano uint64\n\n\t// r is a reader that consumes records as they get overwritten\n\t// by the writer. It also acts as the initial reader state\n\t// when printing the log.\n\tr debugLogReader\n\n\t// buf is a scratch buffer for encoding. This is here to\n\t// reduce stack usage.\n\tbuf [10]byte\n}\n```\n\nA debugLogWriter is a ring buffer of binary debug log records. \n\nA log record consists of a 2-byte framing header and a sequence of fields. The framing header gives the size of the record as a little endian 16-bit value. Each field starts with a byte indicating its type, followed by type-specific data. If the size in the framing header is 0, it's a sync record consisting of two little endian 64-bit values giving a new time base. \n\nBecause this is a ring buffer, new records will eventually overwrite old records. Hence, it maintains a reader that consumes the log as it gets overwritten. That reader state is where an actual log reader would start. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogWriter.ensure",
                    "documentation": {
                      "identifier": "debugLogWriter.ensure",
                      "newPage": false,
                      "searchKey": "runtime.debugLogWriter.ensure",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *debugLogWriter) ensure(n uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *debugLogWriter) ensure(n uint64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogWriter.writeFrameAt",
                    "documentation": {
                      "identifier": "debugLogWriter.writeFrameAt",
                      "newPage": false,
                      "searchKey": "runtime.debugLogWriter.writeFrameAt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *debugLogWriter) writeFrameAt(pos, size uint64) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *debugLogWriter) writeFrameAt(pos, size uint64) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogWriter.writeSync",
                    "documentation": {
                      "identifier": "debugLogWriter.writeSync",
                      "newPage": false,
                      "searchKey": "runtime.debugLogWriter.writeSync",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *debugLogWriter) writeSync(tick, nano uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *debugLogWriter) writeSync(tick, nano uint64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogWriter.writeUint64LE",
                    "documentation": {
                      "identifier": "debugLogWriter.writeUint64LE",
                      "newPage": false,
                      "searchKey": "runtime.debugLogWriter.writeUint64LE",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *debugLogWriter) writeUint64LE(x uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *debugLogWriter) writeUint64LE(x uint64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogWriter.byte",
                    "documentation": {
                      "identifier": "debugLogWriter.byte",
                      "newPage": false,
                      "searchKey": "runtime.debugLogWriter.byte",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *debugLogWriter) byte(x byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *debugLogWriter) byte(x byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogWriter.bytes",
                    "documentation": {
                      "identifier": "debugLogWriter.bytes",
                      "newPage": false,
                      "searchKey": "runtime.debugLogWriter.bytes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *debugLogWriter) bytes(x []byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *debugLogWriter) bytes(x []byte)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogWriter.varint",
                    "documentation": {
                      "identifier": "debugLogWriter.varint",
                      "newPage": false,
                      "searchKey": "runtime.debugLogWriter.varint",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *debugLogWriter) varint(x int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *debugLogWriter) varint(x int64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogWriter.uvarint",
                    "documentation": {
                      "identifier": "debugLogWriter.uvarint",
                      "newPage": false,
                      "searchKey": "runtime.debugLogWriter.uvarint",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *debugLogWriter) uvarint(u uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *debugLogWriter) uvarint(u uint64)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogBuf",
              "documentation": {
                "identifier": "debugLogBuf",
                "newPage": false,
                "searchKey": "runtime.debugLogBuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type debugLogBuf [16384]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype debugLogBuf [debugLogBytes]byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugLogReader",
              "documentation": {
                "identifier": "debugLogReader",
                "newPage": false,
                "searchKey": "runtime.debugLogReader",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type debugLogReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype debugLogReader struct {\n\tdata *debugLogBuf\n\n\t// begin and end are the positions in the log of the beginning\n\t// and end of the log data, modulo len(data).\n\tbegin, end uint64\n\n\t// tick and nano are the current time base at begin.\n\ttick, nano uint64\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogReader.skip",
                    "documentation": {
                      "identifier": "debugLogReader.skip",
                      "newPage": false,
                      "searchKey": "runtime.debugLogReader.skip",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *debugLogReader) skip() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *debugLogReader) skip() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogReader.readUint16LEAt",
                    "documentation": {
                      "identifier": "debugLogReader.readUint16LEAt",
                      "newPage": false,
                      "searchKey": "runtime.debugLogReader.readUint16LEAt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *debugLogReader) readUint16LEAt(pos uint64) uint16"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *debugLogReader) readUint16LEAt(pos uint64) uint16\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogReader.readUint64LEAt",
                    "documentation": {
                      "identifier": "debugLogReader.readUint64LEAt",
                      "newPage": false,
                      "searchKey": "runtime.debugLogReader.readUint64LEAt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *debugLogReader) readUint64LEAt(pos uint64) uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *debugLogReader) readUint64LEAt(pos uint64) uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogReader.peek",
                    "documentation": {
                      "identifier": "debugLogReader.peek",
                      "newPage": false,
                      "searchKey": "runtime.debugLogReader.peek",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *debugLogReader) peek() (tick uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *debugLogReader) peek() (tick uint64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogReader.header",
                    "documentation": {
                      "identifier": "debugLogReader.header",
                      "newPage": false,
                      "searchKey": "runtime.debugLogReader.header",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *debugLogReader) header() (end, tick, nano uint64, p int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *debugLogReader) header() (end, tick, nano uint64, p int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogReader.uvarint",
                    "documentation": {
                      "identifier": "debugLogReader.uvarint",
                      "newPage": false,
                      "searchKey": "runtime.debugLogReader.uvarint",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *debugLogReader) uvarint() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *debugLogReader) uvarint() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogReader.varint",
                    "documentation": {
                      "identifier": "debugLogReader.varint",
                      "newPage": false,
                      "searchKey": "runtime.debugLogReader.varint",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *debugLogReader) varint() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *debugLogReader) varint() int64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#debugLogReader.printVal",
                    "documentation": {
                      "identifier": "debugLogReader.printVal",
                      "newPage": false,
                      "searchKey": "runtime.debugLogReader.printVal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *debugLogReader) printVal() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *debugLogReader) printVal() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dlogPerM",
              "documentation": {
                "identifier": "dlogPerM",
                "newPage": false,
                "searchKey": "runtime.dlogPerM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type dlogPerM struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dlogPerM struct{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackt",
              "documentation": {
                "identifier": "stackt",
                "newPage": false,
                "searchKey": "runtime.stackt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stackt struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stackt struct {\n\tss_sp     *byte\n\tss_size   uintptr\n\tss_flags  int32\n\tpad_cgo_0 [4]byte\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigactiont",
              "documentation": {
                "identifier": "sigactiont",
                "newPage": false,
                "searchKey": "runtime.sigactiont",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sigactiont struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sigactiont struct {\n\t__sigaction_u [8]byte\n\tsa_tramp      unsafe.Pointer\n\tsa_mask       uint32\n\tsa_flags      int32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#usigactiont",
              "documentation": {
                "identifier": "usigactiont",
                "newPage": false,
                "searchKey": "runtime.usigactiont",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type usigactiont struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype usigactiont struct {\n\t__sigaction_u [8]byte\n\tsa_mask       uint32\n\tsa_flags      int32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#siginfo",
              "documentation": {
                "identifier": "siginfo",
                "newPage": false,
                "searchKey": "runtime.siginfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type siginfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype siginfo struct {\n\tsi_signo  int32\n\tsi_errno  int32\n\tsi_code   int32\n\tsi_pid    int32\n\tsi_uid    uint32\n\tsi_status int32\n\tsi_addr   uint64\n\tsi_value  [8]byte\n\tsi_band   int64\n\t__pad     [7]uint64\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timeval",
              "documentation": {
                "identifier": "timeval",
                "newPage": false,
                "searchKey": "runtime.timeval",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type timeval struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype timeval struct {\n\ttv_sec    int64\n\ttv_usec   int32\n\tpad_cgo_0 [4]byte\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#timeval.set_usec",
                    "documentation": {
                      "identifier": "timeval.set_usec",
                      "newPage": false,
                      "searchKey": "runtime.timeval.set_usec",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tv *timeval) set_usec(x int32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tv *timeval) set_usec(x int32)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itimerval",
              "documentation": {
                "identifier": "itimerval",
                "newPage": false,
                "searchKey": "runtime.itimerval",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type itimerval struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype itimerval struct {\n\tit_interval timeval\n\tit_value    timeval\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timespec",
              "documentation": {
                "identifier": "timespec",
                "newPage": false,
                "searchKey": "runtime.timespec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type timespec struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype timespec struct {\n\ttv_sec  int64\n\ttv_nsec int64\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#timespec.setNsec",
                    "documentation": {
                      "identifier": "timespec.setNsec",
                      "newPage": false,
                      "searchKey": "runtime.timespec.setNsec",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ts *timespec) setNsec(ns int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ts *timespec) setNsec(ns int64)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fpcontrol",
              "documentation": {
                "identifier": "fpcontrol",
                "newPage": false,
                "searchKey": "runtime.fpcontrol",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type fpcontrol struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fpcontrol struct {\n\tpad_cgo_0 [2]byte\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fpstatus",
              "documentation": {
                "identifier": "fpstatus",
                "newPage": false,
                "searchKey": "runtime.fpstatus",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type fpstatus struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fpstatus struct {\n\tpad_cgo_0 [2]byte\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#regmmst",
              "documentation": {
                "identifier": "regmmst",
                "newPage": false,
                "searchKey": "runtime.regmmst",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type regmmst struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype regmmst struct {\n\tmmst_reg  [10]int8\n\tmmst_rsrv [6]int8\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#regxmm",
              "documentation": {
                "identifier": "regxmm",
                "newPage": false,
                "searchKey": "runtime.regxmm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type regxmm struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype regxmm struct {\n\txmm_reg [16]int8\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#regs64",
              "documentation": {
                "identifier": "regs64",
                "newPage": false,
                "searchKey": "runtime.regs64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type regs64 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype regs64 struct {\n\trax    uint64\n\trbx    uint64\n\trcx    uint64\n\trdx    uint64\n\trdi    uint64\n\trsi    uint64\n\trbp    uint64\n\trsp    uint64\n\tr8     uint64\n\tr9     uint64\n\tr10    uint64\n\tr11    uint64\n\tr12    uint64\n\tr13    uint64\n\tr14    uint64\n\tr15    uint64\n\trip    uint64\n\trflags uint64\n\tcs     uint64\n\tfs     uint64\n\tgs     uint64\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#floatstate64",
              "documentation": {
                "identifier": "floatstate64",
                "newPage": false,
                "searchKey": "runtime.floatstate64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type floatstate64 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype floatstate64 struct {\n\tfpu_reserved  [2]int32\n\tfpu_fcw       fpcontrol\n\tfpu_fsw       fpstatus\n\tfpu_ftw       uint8\n\tfpu_rsrv1     uint8\n\tfpu_fop       uint16\n\tfpu_ip        uint32\n\tfpu_cs        uint16\n\tfpu_rsrv2     uint16\n\tfpu_dp        uint32\n\tfpu_ds        uint16\n\tfpu_rsrv3     uint16\n\tfpu_mxcsr     uint32\n\tfpu_mxcsrmask uint32\n\tfpu_stmm0     regmmst\n\tfpu_stmm1     regmmst\n\tfpu_stmm2     regmmst\n\tfpu_stmm3     regmmst\n\tfpu_stmm4     regmmst\n\tfpu_stmm5     regmmst\n\tfpu_stmm6     regmmst\n\tfpu_stmm7     regmmst\n\tfpu_xmm0      regxmm\n\tfpu_xmm1      regxmm\n\tfpu_xmm2      regxmm\n\tfpu_xmm3      regxmm\n\tfpu_xmm4      regxmm\n\tfpu_xmm5      regxmm\n\tfpu_xmm6      regxmm\n\tfpu_xmm7      regxmm\n\tfpu_xmm8      regxmm\n\tfpu_xmm9      regxmm\n\tfpu_xmm10     regxmm\n\tfpu_xmm11     regxmm\n\tfpu_xmm12     regxmm\n\tfpu_xmm13     regxmm\n\tfpu_xmm14     regxmm\n\tfpu_xmm15     regxmm\n\tfpu_rsrv4     [96]int8\n\tfpu_reserved1 int32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#exceptionstate64",
              "documentation": {
                "identifier": "exceptionstate64",
                "newPage": false,
                "searchKey": "runtime.exceptionstate64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type exceptionstate64 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype exceptionstate64 struct {\n\ttrapno     uint16\n\tcpu        uint16\n\terr        uint32\n\tfaultvaddr uint64\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mcontext64",
              "documentation": {
                "identifier": "mcontext64",
                "newPage": false,
                "searchKey": "runtime.mcontext64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mcontext64 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mcontext64 struct {\n\tes        exceptionstate64\n\tss        regs64\n\tfs        floatstate64\n\tpad_cgo_0 [4]byte\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#regs32",
              "documentation": {
                "identifier": "regs32",
                "newPage": false,
                "searchKey": "runtime.regs32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type regs32 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype regs32 struct {\n\teax    uint32\n\tebx    uint32\n\tecx    uint32\n\tedx    uint32\n\tedi    uint32\n\tesi    uint32\n\tebp    uint32\n\tesp    uint32\n\tss     uint32\n\teflags uint32\n\teip    uint32\n\tcs     uint32\n\tds     uint32\n\tes     uint32\n\tfs     uint32\n\tgs     uint32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#floatstate32",
              "documentation": {
                "identifier": "floatstate32",
                "newPage": false,
                "searchKey": "runtime.floatstate32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type floatstate32 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype floatstate32 struct {\n\tfpu_reserved  [2]int32\n\tfpu_fcw       fpcontrol\n\tfpu_fsw       fpstatus\n\tfpu_ftw       uint8\n\tfpu_rsrv1     uint8\n\tfpu_fop       uint16\n\tfpu_ip        uint32\n\tfpu_cs        uint16\n\tfpu_rsrv2     uint16\n\tfpu_dp        uint32\n\tfpu_ds        uint16\n\tfpu_rsrv3     uint16\n\tfpu_mxcsr     uint32\n\tfpu_mxcsrmask uint32\n\tfpu_stmm0     regmmst\n\tfpu_stmm1     regmmst\n\tfpu_stmm2     regmmst\n\tfpu_stmm3     regmmst\n\tfpu_stmm4     regmmst\n\tfpu_stmm5     regmmst\n\tfpu_stmm6     regmmst\n\tfpu_stmm7     regmmst\n\tfpu_xmm0      regxmm\n\tfpu_xmm1      regxmm\n\tfpu_xmm2      regxmm\n\tfpu_xmm3      regxmm\n\tfpu_xmm4      regxmm\n\tfpu_xmm5      regxmm\n\tfpu_xmm6      regxmm\n\tfpu_xmm7      regxmm\n\tfpu_rsrv4     [224]int8\n\tfpu_reserved1 int32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#exceptionstate32",
              "documentation": {
                "identifier": "exceptionstate32",
                "newPage": false,
                "searchKey": "runtime.exceptionstate32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type exceptionstate32 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype exceptionstate32 struct {\n\ttrapno     uint16\n\tcpu        uint16\n\terr        uint32\n\tfaultvaddr uint32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mcontext32",
              "documentation": {
                "identifier": "mcontext32",
                "newPage": false,
                "searchKey": "runtime.mcontext32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mcontext32 struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mcontext32 struct {\n\tes exceptionstate32\n\tss regs32\n\tfs floatstate32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ucontext",
              "documentation": {
                "identifier": "ucontext",
                "newPage": false,
                "searchKey": "runtime.ucontext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ucontext struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ucontext struct {\n\tuc_onstack  int32\n\tuc_sigmask  uint32\n\tuc_stack    stackt\n\tuc_link     *ucontext\n\tuc_mcsize   uint64\n\tuc_mcontext *mcontext64\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#keventt",
              "documentation": {
                "identifier": "keventt",
                "newPage": false,
                "searchKey": "runtime.keventt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type keventt struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype keventt struct {\n\tident  uint64\n\tfilter int16\n\tflags  uint16\n\tfflags uint32\n\tdata   int64\n\tudata  *byte\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread",
              "documentation": {
                "identifier": "pthread",
                "newPage": false,
                "searchKey": "runtime.pthread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pthread uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pthread uintptr\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#pthread_self",
                    "documentation": {
                      "identifier": "pthread_self",
                      "newPage": false,
                      "searchKey": "runtime.pthread_self",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func pthread_self() (t pthread)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc pthread_self() (t pthread)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthreadattr",
              "documentation": {
                "identifier": "pthreadattr",
                "newPage": false,
                "searchKey": "runtime.pthreadattr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pthreadattr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pthreadattr struct {\n\tX__sig    int64\n\tX__opaque [56]int8\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthreadmutex",
              "documentation": {
                "identifier": "pthreadmutex",
                "newPage": false,
                "searchKey": "runtime.pthreadmutex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pthreadmutex struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pthreadmutex struct {\n\tX__sig    int64\n\tX__opaque [56]int8\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthreadmutexattr",
              "documentation": {
                "identifier": "pthreadmutexattr",
                "newPage": false,
                "searchKey": "runtime.pthreadmutexattr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pthreadmutexattr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pthreadmutexattr struct {\n\tX__sig    int64\n\tX__opaque [8]int8\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthreadcond",
              "documentation": {
                "identifier": "pthreadcond",
                "newPage": false,
                "searchKey": "runtime.pthreadcond",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pthreadcond struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pthreadcond struct {\n\tX__sig    int64\n\tX__opaque [40]int8\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthreadcondattr",
              "documentation": {
                "identifier": "pthreadcondattr",
                "newPage": false,
                "searchKey": "runtime.pthreadcondattr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pthreadcondattr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pthreadcondattr struct {\n\tX__sig    int64\n\tX__opaque [8]int8\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#machTimebaseInfo",
              "documentation": {
                "identifier": "machTimebaseInfo",
                "newPage": false,
                "searchKey": "runtime.machTimebaseInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type machTimebaseInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype machTimebaseInfo struct {\n\tnumer uint32\n\tdenom uint32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Error",
              "documentation": {
                "identifier": "Error",
                "newPage": false,
                "searchKey": "runtime.Error",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Error interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Error interface {\n\terror\n\n\t// RuntimeError is a no-op function but\n\t// serves to distinguish types that are run time\n\t// errors from ordinary errors: a type is a\n\t// run time error if it has a RuntimeError method.\n\tRuntimeError()\n}\n```\n\nThe Error interface identifies a run time error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#TypeAssertionError",
              "documentation": {
                "identifier": "TypeAssertionError",
                "newPage": false,
                "searchKey": "runtime.TypeAssertionError",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type TypeAssertionError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype TypeAssertionError struct {\n\t_interface    *_type\n\tconcrete      *_type\n\tasserted      *_type\n\tmissingMethod string // one method needed by Interface, missing from Concrete\n}\n```\n\nA TypeAssertionError explains a failed type assertion. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#TypeAssertionError.RuntimeError",
                    "documentation": {
                      "identifier": "TypeAssertionError.RuntimeError",
                      "newPage": false,
                      "searchKey": "runtime.TypeAssertionError.RuntimeError",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (*TypeAssertionError) RuntimeError()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (*TypeAssertionError) RuntimeError()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#TypeAssertionError.Error",
                    "documentation": {
                      "identifier": "TypeAssertionError.Error",
                      "newPage": false,
                      "searchKey": "runtime.TypeAssertionError.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e *TypeAssertionError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e *TypeAssertionError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#errorString",
              "documentation": {
                "identifier": "errorString",
                "newPage": false,
                "searchKey": "runtime.errorString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type errorString string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype errorString string\n```\n\nAn errorString represents a runtime error described by a single string. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#errorString.RuntimeError",
                    "documentation": {
                      "identifier": "errorString.RuntimeError",
                      "newPage": false,
                      "searchKey": "runtime.errorString.RuntimeError",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e errorString) RuntimeError()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e errorString) RuntimeError()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#errorString.Error",
                    "documentation": {
                      "identifier": "errorString.Error",
                      "newPage": false,
                      "searchKey": "runtime.errorString.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e errorString) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e errorString) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#errorAddressString",
              "documentation": {
                "identifier": "errorAddressString",
                "newPage": false,
                "searchKey": "runtime.errorAddressString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type errorAddressString struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype errorAddressString struct {\n\tmsg  string  // error message\n\taddr uintptr // memory address where the error occurred\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#errorAddressString.RuntimeError",
                    "documentation": {
                      "identifier": "errorAddressString.RuntimeError",
                      "newPage": false,
                      "searchKey": "runtime.errorAddressString.RuntimeError",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e errorAddressString) RuntimeError()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e errorAddressString) RuntimeError()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#errorAddressString.Error",
                    "documentation": {
                      "identifier": "errorAddressString.Error",
                      "newPage": false,
                      "searchKey": "runtime.errorAddressString.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e errorAddressString) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e errorAddressString) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#errorAddressString.Addr",
                    "documentation": {
                      "identifier": "errorAddressString.Addr",
                      "newPage": false,
                      "searchKey": "runtime.errorAddressString.Addr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e errorAddressString) Addr() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e errorAddressString) Addr() uintptr\n```\n\nAddr returns the memory address where a fault occurred. The address provided is best-effort. The veracity of the result may depend on the platform. Errors providing this method will only be returned as a result of using runtime/debug.SetPanicOnFault. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#plainError",
              "documentation": {
                "identifier": "plainError",
                "newPage": false,
                "searchKey": "runtime.plainError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type plainError string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype plainError string\n```\n\nplainError represents a runtime error described a string without the prefix \"runtime error: \" after invoking errorString.Error(). See Issue #14965. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#plainError.RuntimeError",
                    "documentation": {
                      "identifier": "plainError.RuntimeError",
                      "newPage": false,
                      "searchKey": "runtime.plainError.RuntimeError",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e plainError) RuntimeError()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e plainError) RuntimeError()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#plainError.Error",
                    "documentation": {
                      "identifier": "plainError.Error",
                      "newPage": false,
                      "searchKey": "runtime.plainError.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e plainError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e plainError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsError",
              "documentation": {
                "identifier": "boundsError",
                "newPage": false,
                "searchKey": "runtime.boundsError",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type boundsError struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype boundsError struct {\n\tx int64\n\ty int\n\t// Values in an index or slice expression can be signed or unsigned.\n\t// That means we'd need 65 bits to encode all possible indexes, from -2^63 to 2^64-1.\n\t// Instead, we keep track of whether x should be interpreted as signed or unsigned.\n\t// y is known to be nonnegative and to fit in an int.\n\tsigned bool\n\tcode   boundsErrorCode\n}\n```\n\nA boundsError represents an indexing or slicing operation gone wrong. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#boundsError.RuntimeError",
                    "documentation": {
                      "identifier": "boundsError.RuntimeError",
                      "newPage": false,
                      "searchKey": "runtime.boundsError.RuntimeError",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e boundsError) RuntimeError()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e boundsError) RuntimeError()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#boundsError.Error",
                    "documentation": {
                      "identifier": "boundsError.Error",
                      "newPage": false,
                      "searchKey": "runtime.boundsError.Error",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (e boundsError) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (e boundsError) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#boundsErrorCode",
              "documentation": {
                "identifier": "boundsErrorCode",
                "newPage": false,
                "searchKey": "runtime.boundsErrorCode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type boundsErrorCode uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype boundsErrorCode uint8\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stringer",
              "documentation": {
                "identifier": "stringer",
                "newPage": false,
                "searchKey": "runtime.stringer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stringer interface"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stringer interface {\n\tString() string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typeCacheBucket",
              "documentation": {
                "identifier": "typeCacheBucket",
                "newPage": false,
                "searchKey": "runtime.typeCacheBucket",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type typeCacheBucket struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype typeCacheBucket struct {\n\tt [typeCacheAssoc]*_type\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#childInfo",
              "documentation": {
                "identifier": "childInfo",
                "newPage": false,
                "searchKey": "runtime.childInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type childInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype childInfo struct {\n\t// Information passed up from the callee frame about\n\t// the layout of the outargs region.\n\targoff uintptr   // where the arguments start in the frame\n\targlen uintptr   // size of args region\n\targs   bitvector // if args.n >= 0, pointer map of args region\n\tsp     *uint8    // callee sp\n\tdepth  uintptr   // depth in call stack (0 == most recent)\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timeHistogram",
              "documentation": {
                "identifier": "timeHistogram",
                "newPage": false,
                "searchKey": "runtime.timeHistogram",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type timeHistogram struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype timeHistogram struct {\n\tcounts [timeHistNumSuperBuckets * timeHistNumSubBuckets]uint64\n\n\t// underflow counts all the times we got a negative duration\n\t// sample. Because of how time works on some platforms, it's\n\t// possible to measure negative durations. We could ignore them,\n\t// but we record them anyway because it's better to have some\n\t// signal that it's happening than just missing samples.\n\tunderflow uint64\n}\n```\n\ntimeHistogram represents a distribution of durations in nanoseconds. \n\nThe accuracy and range of the histogram is defined by the timeHistSubBucketBits and timeHistNumSuperBuckets constants. \n\nIt is an HDR histogram with exponentially-distributed buckets and linearly distributed sub-buckets. \n\nCounts in the histogram are updated atomically, so it is safe for concurrent use. It is also safe to read all the values atomically. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#timeHistogram.record",
                    "documentation": {
                      "identifier": "timeHistogram.record",
                      "newPage": false,
                      "searchKey": "runtime.timeHistogram.record",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *timeHistogram) record(duration int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *timeHistogram) record(duration int64)\n```\n\nrecord adds the given duration to the distribution. \n\nDisallow preemptions and stack growths because this function may run in sensitive locations. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itabTableType",
              "documentation": {
                "identifier": "itabTableType",
                "newPage": false,
                "searchKey": "runtime.itabTableType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type itabTableType struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype itabTableType struct {\n\tsize    uintptr             // length of entries array. Always a power of 2.\n\tcount   uintptr             // current number of filled entries.\n\tentries [itabInitSize]*itab // really [size] large\n}\n```\n\nNote: change the formula in the mallocgc call in itabAdd if you change these fields. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#itabTableType.find",
                    "documentation": {
                      "identifier": "itabTableType.find",
                      "newPage": false,
                      "searchKey": "runtime.itabTableType.find",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *itabTableType) find(inter *interfacetype, typ *_type) *itab"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *itabTableType) find(inter *interfacetype, typ *_type) *itab\n```\n\nfind finds the given interface/type pair in t. Returns nil if the given interface/type pair isn't present. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#itabTableType.add",
                    "documentation": {
                      "identifier": "itabTableType.add",
                      "newPage": false,
                      "searchKey": "runtime.itabTableType.add",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *itabTableType) add(m *itab)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *itabTableType) add(m *itab)\n```\n\nadd adds the given itab to itab table t. itabLock must be held. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#uint16InterfacePtr",
              "documentation": {
                "identifier": "uint16InterfacePtr",
                "newPage": false,
                "searchKey": "runtime.uint16InterfacePtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type uint16InterfacePtr uint16"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype uint16InterfacePtr uint16\n```\n\nThe specialized convTx routines need a type descriptor to use when calling mallocgc. We don't need the type to be exact, just to have the correct size, alignment, and pointer-ness. However, when debugging, it'd be nice to have some indication in mallocgc where the types came from, so we use named types here. We then construct interface values of these types, and then extract the type word to use as needed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#uint32InterfacePtr",
              "documentation": {
                "identifier": "uint32InterfacePtr",
                "newPage": false,
                "searchKey": "runtime.uint32InterfacePtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type uint32InterfacePtr uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype uint32InterfacePtr uint32\n```\n\nThe specialized convTx routines need a type descriptor to use when calling mallocgc. We don't need the type to be exact, just to have the correct size, alignment, and pointer-ness. However, when debugging, it'd be nice to have some indication in mallocgc where the types came from, so we use named types here. We then construct interface values of these types, and then extract the type word to use as needed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#uint64InterfacePtr",
              "documentation": {
                "identifier": "uint64InterfacePtr",
                "newPage": false,
                "searchKey": "runtime.uint64InterfacePtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type uint64InterfacePtr uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype uint64InterfacePtr uint64\n```\n\nThe specialized convTx routines need a type descriptor to use when calling mallocgc. We don't need the type to be exact, just to have the correct size, alignment, and pointer-ness. However, when debugging, it'd be nice to have some indication in mallocgc where the types came from, so we use named types here. We then construct interface values of these types, and then extract the type word to use as needed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stringInterfacePtr",
              "documentation": {
                "identifier": "stringInterfacePtr",
                "newPage": false,
                "searchKey": "runtime.stringInterfacePtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stringInterfacePtr string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stringInterfacePtr string\n```\n\nThe specialized convTx routines need a type descriptor to use when calling mallocgc. We don't need the type to be exact, just to have the correct size, alignment, and pointer-ness. However, when debugging, it'd be nice to have some indication in mallocgc where the types came from, so we use named types here. We then construct interface values of these types, and then extract the type word to use as needed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sliceInterfacePtr",
              "documentation": {
                "identifier": "sliceInterfacePtr",
                "newPage": false,
                "searchKey": "runtime.sliceInterfacePtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sliceInterfacePtr []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sliceInterfacePtr []byte\n```\n\nThe specialized convTx routines need a type descriptor to use when calling mallocgc. We don't need the type to be exact, just to have the correct size, alignment, and pointer-ness. However, when debugging, it'd be nice to have some indication in mallocgc where the types came from, so we use named types here. We then construct interface values of these types, and then extract the type word to use as needed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lfstack",
              "documentation": {
                "identifier": "lfstack",
                "newPage": false,
                "searchKey": "runtime.lfstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type lfstack uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype lfstack uint64\n```\n\nlfstack is the head of a lock-free stack. \n\nThe zero value of lfstack is an empty list. \n\nThis stack is intrusive. Nodes must embed lfnode as the first field. \n\nThe stack does not keep GC-visible pointers to nodes, so the caller is responsible for ensuring the nodes are not garbage collected (typically by allocating them from manually-managed memory). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#lfstack.push",
                    "documentation": {
                      "identifier": "lfstack.push",
                      "newPage": false,
                      "searchKey": "runtime.lfstack.push",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (head *lfstack) push(node *lfnode)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (head *lfstack) push(node *lfnode)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#lfstack.pop",
                    "documentation": {
                      "identifier": "lfstack.pop",
                      "newPage": false,
                      "searchKey": "runtime.lfstack.pop",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (head *lfstack) pop() unsafe.Pointer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (head *lfstack) pop() unsafe.Pointer\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#lfstack.empty",
                    "documentation": {
                      "identifier": "lfstack.empty",
                      "newPage": false,
                      "searchKey": "runtime.lfstack.empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (head *lfstack) empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (head *lfstack) empty() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRank",
              "documentation": {
                "identifier": "lockRank",
                "newPage": false,
                "searchKey": "runtime.lockRank",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type lockRank int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype lockRank int\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#getLockRank",
                    "documentation": {
                      "identifier": "getLockRank",
                      "newPage": false,
                      "searchKey": "runtime.getLockRank",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func getLockRank(l *mutex) lockRank"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc getLockRank(l *mutex) lockRank\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#lockRank.String",
                    "documentation": {
                      "identifier": "lockRank.String",
                      "newPage": false,
                      "searchKey": "runtime.lockRank.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rank lockRank) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rank lockRank) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockRankStruct",
              "documentation": {
                "identifier": "lockRankStruct",
                "newPage": false,
                "searchKey": "runtime.lockRankStruct",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type lockRankStruct struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype lockRankStruct struct {\n}\n```\n\n// lockRankStruct is embedded in mutex, but is empty when staticklockranking is disabled (the default) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#persistentAlloc",
              "documentation": {
                "identifier": "persistentAlloc",
                "newPage": false,
                "searchKey": "runtime.persistentAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type persistentAlloc struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype persistentAlloc struct {\n\tbase *notInHeap\n\toff  uintptr\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#linearAlloc",
              "documentation": {
                "identifier": "linearAlloc",
                "newPage": false,
                "searchKey": "runtime.linearAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type linearAlloc struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype linearAlloc struct {\n\tnext   uintptr // next free byte\n\tmapped uintptr // one byte past end of mapped space\n\tend    uintptr // end of reserved space\n\n\tmapMemory bool // transition memory from Reserved to Ready if true\n}\n```\n\nlinearAlloc is a simple linear allocator that pre-reserves a region of memory and then optionally maps that region into the Ready state as needed. \n\nThe caller is responsible for locking. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#linearAlloc.init",
                    "documentation": {
                      "identifier": "linearAlloc.init",
                      "newPage": false,
                      "searchKey": "runtime.linearAlloc.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *linearAlloc) init(base, size uintptr, mapMemory bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *linearAlloc) init(base, size uintptr, mapMemory bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#linearAlloc.alloc",
                    "documentation": {
                      "identifier": "linearAlloc.alloc",
                      "newPage": false,
                      "searchKey": "runtime.linearAlloc.alloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *linearAlloc) alloc(size, align uintptr, sysStat *sysMemStat) unsafe.Pointer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *linearAlloc) alloc(size, align uintptr, sysStat *sysMemStat) unsafe.Pointer\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notInHeap",
              "documentation": {
                "identifier": "notInHeap",
                "newPage": false,
                "searchKey": "runtime.notInHeap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type notInHeap struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype notInHeap struct{}\n```\n\nnotInHeap is off-heap memory allocated by a lower-level allocator like sysAlloc or persistentAlloc. \n\nIn general, it's better to use real types marked as go:notinheap, but this serves as a generic type for situations where that isn't possible (like in the allocators). \n\nTODO: Use this as the return type of sysAlloc, persistentAlloc, etc? \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#persistentalloc1",
                    "documentation": {
                      "identifier": "persistentalloc1",
                      "newPage": false,
                      "searchKey": "runtime.persistentalloc1",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func persistentalloc1(size, align uintptr, sysStat *sysMemStat) *notInHeap"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc persistentalloc1(size, align uintptr, sysStat *sysMemStat) *notInHeap\n```\n\nMust run on system stack because stack growth can (re)invoke it. See issue 9174. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#notInHeap.add",
                    "documentation": {
                      "identifier": "notInHeap.add",
                      "newPage": false,
                      "searchKey": "runtime.notInHeap.add",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *notInHeap) add(bytes uintptr) *notInHeap"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *notInHeap) add(bytes uintptr) *notInHeap\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hmap",
              "documentation": {
                "identifier": "hmap",
                "newPage": false,
                "searchKey": "runtime.hmap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type hmap struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype hmap struct {\n\t// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.\n\t// Make sure this stays in sync with the compiler's definition.\n\tcount     int // # live cells == size of map.  Must be first (used by len() builtin)\n\tflags     uint8\n\tB         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)\n\tnoverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details\n\thash0     uint32 // hash seed\n\n\tbuckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.\n\toldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing\n\tnevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)\n\n\textra *mapextra // optional fields\n}\n```\n\nA header for a Go map. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#makemap64",
                    "documentation": {
                      "identifier": "makemap64",
                      "newPage": false,
                      "searchKey": "runtime.makemap64",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makemap64(t *maptype, hint int64, h *hmap) *hmap"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makemap64(t *maptype, hint int64, h *hmap) *hmap\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#makemap_small",
                    "documentation": {
                      "identifier": "makemap_small",
                      "newPage": false,
                      "searchKey": "runtime.makemap_small",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makemap_small() *hmap"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makemap_small() *hmap\n```\n\nmakemap_small implements Go map creation for make(map[k]v) and make(map[k]v, hint) when hint is known to be at most bucketCnt at compile time and the map needs to be allocated on the heap. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#makemap",
                    "documentation": {
                      "identifier": "makemap",
                      "newPage": false,
                      "searchKey": "runtime.makemap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makemap(t *maptype, hint int, h *hmap) *hmap"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makemap(t *maptype, hint int, h *hmap) *hmap\n```\n\nmakemap implements Go map creation for make(map[k]v, hint). If the compiler has determined that the map or the first bucket can be created on the stack, h and/or bucket may be non-nil. If h != nil, the map can be created directly in h. If h.buckets != nil, bucket pointed to can be used as the first bucket. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#reflect_makemap",
                    "documentation": {
                      "identifier": "reflect_makemap",
                      "newPage": false,
                      "searchKey": "runtime.reflect_makemap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func reflect_makemap(t *maptype, cap int) *hmap"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc reflect_makemap(t *maptype, cap int) *hmap\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#hmap.incrnoverflow",
                    "documentation": {
                      "identifier": "hmap.incrnoverflow",
                      "newPage": false,
                      "searchKey": "runtime.hmap.incrnoverflow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *hmap) incrnoverflow()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *hmap) incrnoverflow()\n```\n\nincrnoverflow increments h.noverflow. noverflow counts the number of overflow buckets. This is used to trigger same-size map growth. See also tooManyOverflowBuckets. To keep hmap small, noverflow is a uint16. When there are few buckets, noverflow is an exact count. When there are many buckets, noverflow is an approximate count. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#hmap.newoverflow",
                    "documentation": {
                      "identifier": "hmap.newoverflow",
                      "newPage": false,
                      "searchKey": "runtime.hmap.newoverflow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *hmap) newoverflow(t *maptype, b *bmap) *bmap\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#hmap.createOverflow",
                    "documentation": {
                      "identifier": "hmap.createOverflow",
                      "newPage": false,
                      "searchKey": "runtime.hmap.createOverflow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *hmap) createOverflow()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *hmap) createOverflow()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#hmap.growing",
                    "documentation": {
                      "identifier": "hmap.growing",
                      "newPage": false,
                      "searchKey": "runtime.hmap.growing",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *hmap) growing() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *hmap) growing() bool\n```\n\ngrowing reports whether h is growing. The growth may be to the same size or bigger. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#hmap.sameSizeGrow",
                    "documentation": {
                      "identifier": "hmap.sameSizeGrow",
                      "newPage": false,
                      "searchKey": "runtime.hmap.sameSizeGrow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *hmap) sameSizeGrow() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *hmap) sameSizeGrow() bool\n```\n\nsameSizeGrow reports whether the current growth is to a map of the same size. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#hmap.noldbuckets",
                    "documentation": {
                      "identifier": "hmap.noldbuckets",
                      "newPage": false,
                      "searchKey": "runtime.hmap.noldbuckets",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *hmap) noldbuckets() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *hmap) noldbuckets() uintptr\n```\n\nnoldbuckets calculates the number of buckets prior to the current map growth. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#hmap.oldbucketmask",
                    "documentation": {
                      "identifier": "hmap.oldbucketmask",
                      "newPage": false,
                      "searchKey": "runtime.hmap.oldbucketmask",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *hmap) oldbucketmask() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *hmap) oldbucketmask() uintptr\n```\n\noldbucketmask provides a mask that can be applied to calculate n % noldbuckets(). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapextra",
              "documentation": {
                "identifier": "mapextra",
                "newPage": false,
                "searchKey": "runtime.mapextra",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mapextra struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mapextra struct {\n\t// If both key and elem do not contain pointers and are inline, then we mark bucket\n\t// type as containing no pointers. This avoids scanning such maps.\n\t// However, bmap.overflow is a pointer. In order to keep overflow buckets\n\t// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.\n\t// overflow and oldoverflow are only used if key and elem do not contain pointers.\n\t// overflow contains overflow buckets for hmap.buckets.\n\t// oldoverflow contains overflow buckets for hmap.oldbuckets.\n\t// The indirection allows to store a pointer to the slice in hiter.\n\toverflow    *[]*bmap\n\toldoverflow *[]*bmap\n\n\t// nextOverflow holds a pointer to a free overflow bucket.\n\tnextOverflow *bmap\n}\n```\n\nmapextra holds fields that are not present on all maps. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bmap",
              "documentation": {
                "identifier": "bmap",
                "newPage": false,
                "searchKey": "runtime.bmap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type bmap struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bmap struct {\n\t// tophash generally contains the top byte of the hash value\n\t// for each key in this bucket. If tophash[0] < minTopHash,\n\t// tophash[0] is a bucket evacuation state instead.\n\ttophash [bucketCnt]uint8\n}\n```\n\nA bucket for a Go map. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#makeBucketArray",
                    "documentation": {
                      "identifier": "makeBucketArray",
                      "newPage": false,
                      "searchKey": "runtime.makeBucketArray",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap)\n```\n\nmakeBucketArray initializes a backing array for map buckets. 1<<b is the minimum number of buckets to allocate. dirtyalloc should either be nil or a bucket array previously allocated by makeBucketArray with the same t and b parameters. If dirtyalloc is nil a new backing array will be alloced and otherwise dirtyalloc will be cleared and reused as backing array. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#bmap.overflow",
                    "documentation": {
                      "identifier": "bmap.overflow",
                      "newPage": false,
                      "searchKey": "runtime.bmap.overflow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *bmap) overflow(t *maptype) *bmap"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *bmap) overflow(t *maptype) *bmap\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#bmap.setoverflow",
                    "documentation": {
                      "identifier": "bmap.setoverflow",
                      "newPage": false,
                      "searchKey": "runtime.bmap.setoverflow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *bmap) setoverflow(t *maptype, ovf *bmap)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *bmap) setoverflow(t *maptype, ovf *bmap)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#bmap.keys",
                    "documentation": {
                      "identifier": "bmap.keys",
                      "newPage": false,
                      "searchKey": "runtime.bmap.keys",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *bmap) keys() unsafe.Pointer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *bmap) keys() unsafe.Pointer\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hiter",
              "documentation": {
                "identifier": "hiter",
                "newPage": false,
                "searchKey": "runtime.hiter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type hiter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype hiter struct {\n\tkey         unsafe.Pointer // Must be in first position.  Write nil to indicate iteration end (see cmd/compile/internal/walk/range.go).\n\telem        unsafe.Pointer // Must be in second position (see cmd/compile/internal/walk/range.go).\n\tt           *maptype\n\th           *hmap\n\tbuckets     unsafe.Pointer // bucket ptr at hash_iter initialization time\n\tbptr        *bmap          // current bucket\n\toverflow    *[]*bmap       // keeps overflow buckets of hmap.buckets alive\n\toldoverflow *[]*bmap       // keeps overflow buckets of hmap.oldbuckets alive\n\tstartBucket uintptr        // bucket iteration started at\n\toffset      uint8          // intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1)\n\twrapped     bool           // already wrapped around from end of bucket array to beginning\n\tB           uint8\n\ti           uint8\n\tbucket      uintptr\n\tcheckBucket uintptr\n}\n```\n\nA hash iteration structure. If you modify hiter, also change cmd/compile/internal/reflectdata/reflect.go to indicate the layout of this structure. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#reflect_mapiterinit",
                    "documentation": {
                      "identifier": "reflect_mapiterinit",
                      "newPage": false,
                      "searchKey": "runtime.reflect_mapiterinit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func reflect_mapiterinit(t *maptype, h *hmap) *hiter"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc reflect_mapiterinit(t *maptype, h *hmap) *hiter\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#evacDst",
              "documentation": {
                "identifier": "evacDst",
                "newPage": false,
                "searchKey": "runtime.evacDst",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type evacDst struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype evacDst struct {\n\tb *bmap          // current destination bucket\n\ti int            // key/elem index into b\n\tk unsafe.Pointer // pointer to current key storage\n\te unsafe.Pointer // pointer to current elem storage\n}\n```\n\nevacDst is an evacuation destination. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapBits",
              "documentation": {
                "identifier": "heapBits",
                "newPage": false,
                "searchKey": "runtime.heapBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type heapBits struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype heapBits struct {\n\tbitp  *uint8\n\tshift uint32\n\tarena uint32 // Index of heap arena containing bitp\n\tlast  *uint8 // Last byte arena's bitmap\n}\n```\n\nheapBits provides access to the bitmap bits for a single heap word. The methods on heapBits take value receivers so that the compiler can more easily inline calls to those methods and registerize the struct fields independently. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#heapBitsForAddr",
                    "documentation": {
                      "identifier": "heapBitsForAddr",
                      "newPage": false,
                      "searchKey": "runtime.heapBitsForAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func heapBitsForAddr(addr uintptr) (h heapBits)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc heapBitsForAddr(addr uintptr) (h heapBits)\n```\n\nheapBitsForAddr returns the heapBits for the address addr. The caller must ensure addr is in an allocated span. In particular, be careful not to point past the end of an object. \n\nnosplit because it is used during write barriers and must not be preempted. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#heapBits.next",
                    "documentation": {
                      "identifier": "heapBits.next",
                      "newPage": false,
                      "searchKey": "runtime.heapBits.next",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h heapBits) next() heapBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h heapBits) next() heapBits\n```\n\nnext returns the heapBits describing the next pointer-sized word in memory. That is, if h describes address p, h.next() describes p+ptrSize. Note that next does not modify h. The caller must record the result. \n\nnosplit because it is used during write barriers and must not be preempted. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#heapBits.nextArena",
                    "documentation": {
                      "identifier": "heapBits.nextArena",
                      "newPage": false,
                      "searchKey": "runtime.heapBits.nextArena",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h heapBits) nextArena() heapBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h heapBits) nextArena() heapBits\n```\n\nnextArena advances h to the beginning of the next heap arena. \n\nThis is a slow-path helper to next. gc's inliner knows that heapBits.next can be inlined even though it calls this. This is marked noinline so it doesn't get inlined into next and cause next to be too big to inline. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#heapBits.forward",
                    "documentation": {
                      "identifier": "heapBits.forward",
                      "newPage": false,
                      "searchKey": "runtime.heapBits.forward",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h heapBits) forward(n uintptr) heapBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h heapBits) forward(n uintptr) heapBits\n```\n\nforward returns the heapBits describing n pointer-sized words ahead of h in memory. That is, if h describes address p, h.forward(n) describes p+n*ptrSize. h.forward(1) is equivalent to h.next(), just slower. Note that forward does not modify h. The caller must record the result. bits returns the heap bits for the current word. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#heapBits.forwardOrBoundary",
                    "documentation": {
                      "identifier": "heapBits.forwardOrBoundary",
                      "newPage": false,
                      "searchKey": "runtime.heapBits.forwardOrBoundary",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h heapBits) forwardOrBoundary(n uintptr) (heapBits, uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h heapBits) forwardOrBoundary(n uintptr) (heapBits, uintptr)\n```\n\nforwardOrBoundary is like forward, but stops at boundaries between contiguous sections of the bitmap. It returns the number of words advanced over, which will be <= n. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#heapBits.bits",
                    "documentation": {
                      "identifier": "heapBits.bits",
                      "newPage": false,
                      "searchKey": "runtime.heapBits.bits",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h heapBits) bits() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h heapBits) bits() uint32\n```\n\nThe caller can test morePointers and isPointer by &-ing with bitScan and bitPointer. The result includes in its higher bits the bits for subsequent words described by the same bitmap byte. \n\nnosplit because it is used during write barriers and must not be preempted. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#heapBits.morePointers",
                    "documentation": {
                      "identifier": "heapBits.morePointers",
                      "newPage": false,
                      "searchKey": "runtime.heapBits.morePointers",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h heapBits) morePointers() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h heapBits) morePointers() bool\n```\n\nmorePointers reports whether this word and all remaining words in this object are scalars. h must not describe the second word of the object. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#heapBits.isPointer",
                    "documentation": {
                      "identifier": "heapBits.isPointer",
                      "newPage": false,
                      "searchKey": "runtime.heapBits.isPointer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h heapBits) isPointer() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h heapBits) isPointer() bool\n```\n\nisPointer reports whether the heap bits describe a pointer word. \n\nnosplit because it is used during write barriers and must not be preempted. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#heapBits.initSpan",
                    "documentation": {
                      "identifier": "heapBits.initSpan",
                      "newPage": false,
                      "searchKey": "runtime.heapBits.initSpan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h heapBits) initSpan(s *mspan)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h heapBits) initSpan(s *mspan)\n```\n\ninitSpan initializes the heap bitmap for a span. If this is a span of pointer-sized objects, it initializes all words to pointer/scan. Otherwise, it initializes all words to scalar/dead. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#markBits",
              "documentation": {
                "identifier": "markBits",
                "newPage": false,
                "searchKey": "runtime.markBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type markBits struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype markBits struct {\n\tbytep *uint8\n\tmask  uint8\n\tindex uintptr\n}\n```\n\nmarkBits provides access to the mark bit for an object in the heap. bytep points to the byte holding the mark bit. mask is a byte with a single bit set that can be &ed with *bytep to see if the bit has been set. *m.byte&m.mask != 0 indicates the mark bit is set. index can be used along with span information to generate the address of the object in the heap. We maintain one set of mark bits for allocation and one for marking purposes. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#markBitsForAddr",
                    "documentation": {
                      "identifier": "markBitsForAddr",
                      "newPage": false,
                      "searchKey": "runtime.markBitsForAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func markBitsForAddr(p uintptr) markBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc markBitsForAddr(p uintptr) markBits\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#markBitsForSpan",
                    "documentation": {
                      "identifier": "markBitsForSpan",
                      "newPage": false,
                      "searchKey": "runtime.markBitsForSpan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func markBitsForSpan(base uintptr) (mbits markBits)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc markBitsForSpan(base uintptr) (mbits markBits)\n```\n\nmarkBitsForSpan returns the markBits for the span base address base. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#markBits.isMarked",
                    "documentation": {
                      "identifier": "markBits.isMarked",
                      "newPage": false,
                      "searchKey": "runtime.markBits.isMarked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m markBits) isMarked() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m markBits) isMarked() bool\n```\n\nisMarked reports whether mark bit m is set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#markBits.setMarked",
                    "documentation": {
                      "identifier": "markBits.setMarked",
                      "newPage": false,
                      "searchKey": "runtime.markBits.setMarked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m markBits) setMarked()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m markBits) setMarked()\n```\n\nsetMarked sets the marked bit in the markbits, atomically. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#markBits.setMarkedNonAtomic",
                    "documentation": {
                      "identifier": "markBits.setMarkedNonAtomic",
                      "newPage": false,
                      "searchKey": "runtime.markBits.setMarkedNonAtomic",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m markBits) setMarkedNonAtomic()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m markBits) setMarkedNonAtomic()\n```\n\nsetMarkedNonAtomic sets the marked bit in the markbits, non-atomically. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#markBits.clearMarked",
                    "documentation": {
                      "identifier": "markBits.clearMarked",
                      "newPage": false,
                      "searchKey": "runtime.markBits.clearMarked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m markBits) clearMarked()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m markBits) clearMarked()\n```\n\nclearMarked clears the marked bit in the markbits, atomically. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#markBits.advance",
                    "documentation": {
                      "identifier": "markBits.advance",
                      "newPage": false,
                      "searchKey": "runtime.markBits.advance",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *markBits) advance()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *markBits) advance()\n```\n\nadvance advances the markBits to the next object in the span. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mcache",
              "documentation": {
                "identifier": "mcache",
                "newPage": false,
                "searchKey": "runtime.mcache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mcache struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mcache struct {\n\t// The following members are accessed on every malloc,\n\t// so they are grouped here for better caching.\n\tnextSample uintptr // trigger heap sample after allocating this many bytes\n\tscanAlloc  uintptr // bytes of scannable heap allocated\n\n\t// tiny points to the beginning of the current tiny block, or\n\t// nil if there is no current tiny block.\n\t//\n\t// tiny is a heap pointer. Since mcache is in non-GC'd memory,\n\t// we handle it by clearing it in releaseAll during mark\n\t// termination.\n\t//\n\t// tinyAllocs is the number of tiny allocations performed\n\t// by the P that owns this mcache.\n\ttiny       uintptr\n\ttinyoffset uintptr\n\ttinyAllocs uintptr\n\n\talloc [numSpanClasses]*mspan // spans to allocate from, indexed by spanClass\n\n\tstackcache [_NumStackOrders]stackfreelist\n\n\t// flushGen indicates the sweepgen during which this mcache\n\t// was last flushed. If flushGen != mheap_.sweepgen, the spans\n\t// in this mcache are stale and need to the flushed so they\n\t// can be swept. This is done in acquirep.\n\tflushGen uint32\n}\n```\n\nPer-thread (in Go, per-P) cache for small objects. This includes a small object cache and local allocation stats. No locking needed because it is per-thread (per-P). \n\nmcaches are allocated from non-GC'd memory, so any heap pointers must be specially handled. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#allocmcache",
                    "documentation": {
                      "identifier": "allocmcache",
                      "newPage": false,
                      "searchKey": "runtime.allocmcache",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func allocmcache() *mcache"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc allocmcache() *mcache\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#getMCache",
                    "documentation": {
                      "identifier": "getMCache",
                      "newPage": false,
                      "searchKey": "runtime.getMCache",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func getMCache() *mcache"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc getMCache() *mcache\n```\n\ngetMCache is a convenience function which tries to obtain an mcache. \n\nReturns nil if we're not bootstrapping or we don't have a P. The caller's P must not change, so we must be in a non-preemptible state. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcache.nextFree",
                    "documentation": {
                      "identifier": "mcache.nextFree",
                      "newPage": false,
                      "searchKey": "runtime.mcache.nextFree",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcache) nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcache) nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc bool)\n```\n\nnextFree returns the next free object from the cached span if one is available. Otherwise it refills the cache with a span with an available object and returns that object along with a flag indicating that this was a heavy weight allocation. If it is a heavy weight allocation the caller must determine whether a new GC cycle needs to be started or if the GC is active whether this goroutine needs to assist the GC. \n\nMust run in a non-preemptible context since otherwise the owner of c could change. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcache.refill",
                    "documentation": {
                      "identifier": "mcache.refill",
                      "newPage": false,
                      "searchKey": "runtime.mcache.refill",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcache) refill(spc spanClass)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcache) refill(spc spanClass)\n```\n\nrefill acquires a new span of span class spc for c. This span will have at least one free object. The current span in c must be full. \n\nMust run in a non-preemptible context since otherwise the owner of c could change. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcache.allocLarge",
                    "documentation": {
                      "identifier": "mcache.allocLarge",
                      "newPage": false,
                      "searchKey": "runtime.mcache.allocLarge",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcache) allocLarge(size uintptr, needzero bool, noscan bool) (*mspan, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcache) allocLarge(size uintptr, needzero bool, noscan bool) (*mspan, bool)\n```\n\nallocLarge allocates a span for a large object. The boolean result indicates whether the span is known-zeroed. If it did not need to be zeroed, it may not have been zeroed; but if it came directly from the OS, it is already zeroed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcache.releaseAll",
                    "documentation": {
                      "identifier": "mcache.releaseAll",
                      "newPage": false,
                      "searchKey": "runtime.mcache.releaseAll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcache) releaseAll()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcache) releaseAll()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcache.prepareForSweep",
                    "documentation": {
                      "identifier": "mcache.prepareForSweep",
                      "newPage": false,
                      "searchKey": "runtime.mcache.prepareForSweep",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcache) prepareForSweep()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcache) prepareForSweep()\n```\n\nprepareForSweep flushes c if the system has entered a new sweep phase since c was populated. This must happen between the sweep phase starting and the first allocation from c. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gclink",
              "documentation": {
                "identifier": "gclink",
                "newPage": false,
                "searchKey": "runtime.gclink",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gclink struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gclink struct {\n\tnext gclinkptr\n}\n```\n\nA gclink is a node in a linked list of blocks, like mlink, but it is opaque to the garbage collector. The GC does not trace the pointers during collection, and the compiler does not emit write barriers for assignments of gclinkptr values. Code should store references to gclinks as gclinkptr, not as *gclink. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gclinkptr",
              "documentation": {
                "identifier": "gclinkptr",
                "newPage": false,
                "searchKey": "runtime.gclinkptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gclinkptr uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gclinkptr uintptr\n```\n\nA gclinkptr is a pointer to a gclink, but it is opaque to the garbage collector. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#nextFreeFast",
                    "documentation": {
                      "identifier": "nextFreeFast",
                      "newPage": false,
                      "searchKey": "runtime.nextFreeFast",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func nextFreeFast(s *mspan) gclinkptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc nextFreeFast(s *mspan) gclinkptr\n```\n\nnextFreeFast returns the next free object if one is quickly available. Otherwise it returns 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#stackpoolalloc",
                    "documentation": {
                      "identifier": "stackpoolalloc",
                      "newPage": false,
                      "searchKey": "runtime.stackpoolalloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func stackpoolalloc(order uint8) gclinkptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc stackpoolalloc(order uint8) gclinkptr\n```\n\nAllocates a stack from the free pool. Must be called with stackpool[order].item.mu held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gclinkptr.ptr",
                    "documentation": {
                      "identifier": "gclinkptr.ptr",
                      "newPage": false,
                      "searchKey": "runtime.gclinkptr.ptr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p gclinkptr) ptr() *gclink"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p gclinkptr) ptr() *gclink\n```\n\nptr returns the *gclink form of p. The result should be used for accessing fields, not stored in other data structures. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackfreelist",
              "documentation": {
                "identifier": "stackfreelist",
                "newPage": false,
                "searchKey": "runtime.stackfreelist",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stackfreelist struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stackfreelist struct {\n\tlist gclinkptr // linked list of free stacks\n\tsize uintptr   // total size of stacks in list\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mcentral",
              "documentation": {
                "identifier": "mcentral",
                "newPage": false,
                "searchKey": "runtime.mcentral",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mcentral struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mcentral struct {\n\tspanclass spanClass\n\n\t// partial and full contain two mspan sets: one of swept in-use\n\t// spans, and one of unswept in-use spans. These two trade\n\t// roles on each GC cycle. The unswept set is drained either by\n\t// allocation or by the background sweeper in every GC cycle,\n\t// so only two roles are necessary.\n\t//\n\t// sweepgen is increased by 2 on each GC cycle, so the swept\n\t// spans are in partial[sweepgen/2%2] and the unswept spans are in\n\t// partial[1-sweepgen/2%2]. Sweeping pops spans from the\n\t// unswept set and pushes spans that are still in-use on the\n\t// swept set. Likewise, allocating an in-use span pushes it\n\t// on the swept set.\n\t//\n\t// Some parts of the sweeper can sweep arbitrary spans, and hence\n\t// can't remove them from the unswept set, but will add the span\n\t// to the appropriate swept list. As a result, the parts of the\n\t// sweeper and mcentral that do consume from the unswept list may\n\t// encounter swept spans, and these should be ignored.\n\tpartial [2]spanSet // list of spans with a free object\n\tfull    [2]spanSet // list of spans with no free objects\n}\n```\n\nCentral list of free objects of a given size. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#mcentral.init",
                    "documentation": {
                      "identifier": "mcentral.init",
                      "newPage": false,
                      "searchKey": "runtime.mcentral.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcentral) init(spc spanClass)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcentral) init(spc spanClass)\n```\n\nInitialize a single central free list. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcentral.partialUnswept",
                    "documentation": {
                      "identifier": "mcentral.partialUnswept",
                      "newPage": false,
                      "searchKey": "runtime.mcentral.partialUnswept",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcentral) partialUnswept(sweepgen uint32) *spanSet"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcentral) partialUnswept(sweepgen uint32) *spanSet\n```\n\npartialUnswept returns the spanSet which holds partially-filled unswept spans for this sweepgen. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcentral.partialSwept",
                    "documentation": {
                      "identifier": "mcentral.partialSwept",
                      "newPage": false,
                      "searchKey": "runtime.mcentral.partialSwept",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcentral) partialSwept(sweepgen uint32) *spanSet"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcentral) partialSwept(sweepgen uint32) *spanSet\n```\n\npartialSwept returns the spanSet which holds partially-filled swept spans for this sweepgen. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcentral.fullUnswept",
                    "documentation": {
                      "identifier": "mcentral.fullUnswept",
                      "newPage": false,
                      "searchKey": "runtime.mcentral.fullUnswept",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcentral) fullUnswept(sweepgen uint32) *spanSet"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcentral) fullUnswept(sweepgen uint32) *spanSet\n```\n\nfullUnswept returns the spanSet which holds unswept spans without any free slots for this sweepgen. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcentral.fullSwept",
                    "documentation": {
                      "identifier": "mcentral.fullSwept",
                      "newPage": false,
                      "searchKey": "runtime.mcentral.fullSwept",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcentral) fullSwept(sweepgen uint32) *spanSet"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcentral) fullSwept(sweepgen uint32) *spanSet\n```\n\nfullSwept returns the spanSet which holds swept spans without any free slots for this sweepgen. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcentral.cacheSpan",
                    "documentation": {
                      "identifier": "mcentral.cacheSpan",
                      "newPage": false,
                      "searchKey": "runtime.mcentral.cacheSpan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcentral) cacheSpan() *mspan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcentral) cacheSpan() *mspan\n```\n\nAllocate a span to use in an mcache. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcentral.uncacheSpan",
                    "documentation": {
                      "identifier": "mcentral.uncacheSpan",
                      "newPage": false,
                      "searchKey": "runtime.mcentral.uncacheSpan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcentral) uncacheSpan(s *mspan)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcentral) uncacheSpan(s *mspan)\n```\n\nReturn span from an mcache. \n\ns must have a span class corresponding to this mcentral and it must not be empty. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mcentral.grow",
                    "documentation": {
                      "identifier": "mcentral.grow",
                      "newPage": false,
                      "searchKey": "runtime.mcentral.grow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *mcentral) grow() *mspan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *mcentral) grow() *mspan\n```\n\ngrow allocates a new empty span from the heap and initializes it for c's size class. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#checkmarksMap",
              "documentation": {
                "identifier": "checkmarksMap",
                "newPage": false,
                "searchKey": "runtime.checkmarksMap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type checkmarksMap [1048576]uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype checkmarksMap [heapArenaBytes / sys.PtrSize / 8]uint8\n```\n\nA checkmarksMap stores the GC marks in \"checkmarks\" mode. It is a per-arena bitmap with a bit for every word in the arena. The mark is stored on the bit corresponding to the first word of the marked allocation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metricData",
              "documentation": {
                "identifier": "metricData",
                "newPage": false,
                "searchKey": "runtime.metricData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type metricData struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype metricData struct {\n\t// deps is the set of runtime statistics that this metric\n\t// depends on. Before compute is called, the statAggregate\n\t// which will be passed must ensure() these dependencies.\n\tdeps statDepSet\n\n\t// compute is a function that populates a metricValue\n\t// given a populated statAggregate structure.\n\tcompute func(in *statAggregate, out *metricValue)\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#statDep",
              "documentation": {
                "identifier": "statDep",
                "newPage": false,
                "searchKey": "runtime.statDep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type statDep uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype statDep uint\n```\n\nstatDep is a dependency on a group of statistics that a metric might have. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#statDepSet",
              "documentation": {
                "identifier": "statDepSet",
                "newPage": false,
                "searchKey": "runtime.statDepSet",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type statDepSet [1]uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype statDepSet [1]uint64\n```\n\nstatDepSet represents a set of statDeps. \n\nUnder the hood, it's a bitmap. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#makeStatDepSet",
                    "documentation": {
                      "identifier": "makeStatDepSet",
                      "newPage": false,
                      "searchKey": "runtime.makeStatDepSet",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeStatDepSet(deps ...statDep) statDepSet"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeStatDepSet(deps ...statDep) statDepSet\n```\n\nmakeStatDepSet creates a new statDepSet from a list of statDeps. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#statDepSet.difference",
                    "documentation": {
                      "identifier": "statDepSet.difference",
                      "newPage": false,
                      "searchKey": "runtime.statDepSet.difference",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s statDepSet) difference(b statDepSet) statDepSet"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s statDepSet) difference(b statDepSet) statDepSet\n```\n\ndifferennce returns set difference of s from b as a new set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#statDepSet.union",
                    "documentation": {
                      "identifier": "statDepSet.union",
                      "newPage": false,
                      "searchKey": "runtime.statDepSet.union",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s statDepSet) union(b statDepSet) statDepSet"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s statDepSet) union(b statDepSet) statDepSet\n```\n\nunion returns the union of the two sets as a new set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#statDepSet.empty",
                    "documentation": {
                      "identifier": "statDepSet.empty",
                      "newPage": false,
                      "searchKey": "runtime.statDepSet.empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *statDepSet) empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *statDepSet) empty() bool\n```\n\nempty returns true if there are no dependencies in the set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#statDepSet.has",
                    "documentation": {
                      "identifier": "statDepSet.has",
                      "newPage": false,
                      "searchKey": "runtime.statDepSet.has",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *statDepSet) has(d statDep) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *statDepSet) has(d statDep) bool\n```\n\nhas returns true if the set contains a given statDep. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapStatsAggregate",
              "documentation": {
                "identifier": "heapStatsAggregate",
                "newPage": false,
                "searchKey": "runtime.heapStatsAggregate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type heapStatsAggregate struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype heapStatsAggregate struct {\n\theapStatsDelta\n\n\t// inObjects is the bytes of memory occupied by objects,\n\tinObjects uint64\n\n\t// numObjects is the number of live objects in the heap.\n\tnumObjects uint64\n\n\t// totalAllocated is the total bytes of heap objects allocated\n\t// over the lifetime of the program.\n\ttotalAllocated uint64\n\n\t// totalFreed is the total bytes of heap objects freed\n\t// over the lifetime of the program.\n\ttotalFreed uint64\n\n\t// totalAllocs is the number of heap objects allocated over\n\t// the lifetime of the program.\n\ttotalAllocs uint64\n\n\t// totalFrees is the number of heap objects freed over\n\t// the lifetime of the program.\n\ttotalFrees uint64\n}\n```\n\nheapStatsAggregate represents memory stats obtained from the runtime. This set of stats is grouped together because they depend on each other in some way to make sense of the runtime's current heap memory use. They're also sharded across Ps, so it makes sense to grab them all at once. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#heapStatsAggregate.compute",
                    "documentation": {
                      "identifier": "heapStatsAggregate.compute",
                      "newPage": false,
                      "searchKey": "runtime.heapStatsAggregate.compute",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *heapStatsAggregate) compute()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *heapStatsAggregate) compute()\n```\n\ncompute populates the heapStatsAggregate with values from the runtime. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysStatsAggregate",
              "documentation": {
                "identifier": "sysStatsAggregate",
                "newPage": false,
                "searchKey": "runtime.sysStatsAggregate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sysStatsAggregate struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sysStatsAggregate struct {\n\tstacksSys      uint64\n\tmSpanSys       uint64\n\tmSpanInUse     uint64\n\tmCacheSys      uint64\n\tmCacheInUse    uint64\n\tbuckHashSys    uint64\n\tgcMiscSys      uint64\n\totherSys       uint64\n\theapGoal       uint64\n\tgcCyclesDone   uint64\n\tgcCyclesForced uint64\n}\n```\n\nsysStatsAggregate represents system memory stats obtained from the runtime. This set of stats is grouped together because they're all relatively cheap to acquire and generally independent of one another and other runtime memory stats. The fact that they may be acquired at different times, especially with respect to heapStatsAggregate, means there could be some skew, but because of these stats are independent, there's no real consistency issue here. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#sysStatsAggregate.compute",
                    "documentation": {
                      "identifier": "sysStatsAggregate.compute",
                      "newPage": false,
                      "searchKey": "runtime.sysStatsAggregate.compute",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *sysStatsAggregate) compute()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *sysStatsAggregate) compute()\n```\n\ncompute populates the sysStatsAggregate with values from the runtime. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#statAggregate",
              "documentation": {
                "identifier": "statAggregate",
                "newPage": false,
                "searchKey": "runtime.statAggregate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type statAggregate struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype statAggregate struct {\n\tensured   statDepSet\n\theapStats heapStatsAggregate\n\tsysStats  sysStatsAggregate\n}\n```\n\nstatAggregate is the main driver of the metrics implementation. \n\nIt contains multiple aggregates of runtime statistics, as well as a set of these aggregates that it has populated. The aggergates are populated lazily by its ensure method. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#statAggregate.ensure",
                    "documentation": {
                      "identifier": "statAggregate.ensure",
                      "newPage": false,
                      "searchKey": "runtime.statAggregate.ensure",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *statAggregate) ensure(deps *statDepSet)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *statAggregate) ensure(deps *statDepSet)\n```\n\nensure populates statistics aggregates determined by deps if they haven't yet been populated. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metricKind",
              "documentation": {
                "identifier": "metricKind",
                "newPage": false,
                "searchKey": "runtime.metricKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type metricKind int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype metricKind int\n```\n\nmetricValidKind is a runtime copy of runtime/metrics.ValueKind and must be kept structurally identical to that type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metricSample",
              "documentation": {
                "identifier": "metricSample",
                "newPage": false,
                "searchKey": "runtime.metricSample",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type metricSample struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype metricSample struct {\n\tname  string\n\tvalue metricValue\n}\n```\n\nmetricSample is a runtime copy of runtime/metrics.Sample and must be kept structurally identical to that type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metricValue",
              "documentation": {
                "identifier": "metricValue",
                "newPage": false,
                "searchKey": "runtime.metricValue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type metricValue struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype metricValue struct {\n\tkind    metricKind\n\tscalar  uint64         // contains scalar values for scalar Kinds.\n\tpointer unsafe.Pointer // contains non-scalar values.\n}\n```\n\nmetricValue is a runtime copy of runtime/metrics.Sample and must be kept structurally identical to that type. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#metricValue.float64HistOrInit",
                    "documentation": {
                      "identifier": "metricValue.float64HistOrInit",
                      "newPage": false,
                      "searchKey": "runtime.metricValue.float64HistOrInit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (v *metricValue) float64HistOrInit(buckets []float64) *metricFloat64Histogram"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (v *metricValue) float64HistOrInit(buckets []float64) *metricFloat64Histogram\n```\n\nfloat64HistOrInit tries to pull out an existing float64Histogram from the value, but if none exists, then it allocates one with the given buckets. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#metricFloat64Histogram",
              "documentation": {
                "identifier": "metricFloat64Histogram",
                "newPage": false,
                "searchKey": "runtime.metricFloat64Histogram",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type metricFloat64Histogram struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype metricFloat64Histogram struct {\n\tcounts  []uint64\n\tbuckets []float64\n}\n```\n\nmetricFloat64Histogram is a runtime copy of runtime/metrics.Float64Histogram and must be kept structurally identical to that type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#finblock",
              "documentation": {
                "identifier": "finblock",
                "newPage": false,
                "searchKey": "runtime.finblock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type finblock struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype finblock struct {\n\talllink *finblock\n\tnext    *finblock\n\tcnt     uint32\n\t_       int32\n\tfin     [(_FinBlockSize - 2*sys.PtrSize - 2*4) / unsafe.Sizeof(finalizer{})]finalizer\n}\n```\n\nfinblock is an array of finalizers to be executed. finblocks are arranged in a linked list for the finalizer queue. \n\nfinblock is allocated from non-GC'd memory, so any heap pointers must be specially handled. GC currently assumes that the finalizer queue does not grow during marking (but it can shrink). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#finalizer",
              "documentation": {
                "identifier": "finalizer",
                "newPage": false,
                "searchKey": "runtime.finalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type finalizer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype finalizer struct {\n\tfn   *funcval       // function to call (may be a heap pointer)\n\targ  unsafe.Pointer // ptr to object (may be a heap pointer)\n\tnret uintptr        // bytes of return values from fn\n\tfint *_type         // type of first argument of fn\n\tot   *ptrtype       // type of ptr to object (may be a heap pointer)\n}\n```\n\nNOTE: Layout known to queuefinalizer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fixalloc",
              "documentation": {
                "identifier": "fixalloc",
                "newPage": false,
                "searchKey": "runtime.fixalloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type fixalloc struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype fixalloc struct {\n\tsize   uintptr\n\tfirst  func(arg, p unsafe.Pointer) // called first time p is returned\n\targ    unsafe.Pointer\n\tlist   *mlink\n\tchunk  uintptr // use uintptr instead of unsafe.Pointer to avoid write barriers\n\tnchunk uint32\n\tinuse  uintptr // in-use bytes now\n\tstat   *sysMemStat\n\tzero   bool // zero allocations\n}\n```\n\nFixAlloc is a simple free-list allocator for fixed size objects. Malloc uses a FixAlloc wrapped around sysAlloc to manage its mcache and mspan objects. \n\nMemory returned by fixalloc.alloc is zeroed by default, but the caller may take responsibility for zeroing allocations by setting the zero flag to false. This is only safe if the memory never contains heap pointers. \n\nThe caller is responsible for locking around FixAlloc calls. Callers can keep state in the object but the first word is smashed by freeing and reallocating. \n\nConsider marking fixalloc'd types go:notinheap. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#fixalloc.init",
                    "documentation": {
                      "identifier": "fixalloc.init",
                      "newPage": false,
                      "searchKey": "runtime.fixalloc.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fixalloc) init(size uintptr, first func(arg, p unsafe.Pointer), arg unsafe.Pointer, stat *sysMemStat)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fixalloc) init(size uintptr, first func(arg, p unsafe.Pointer), arg unsafe.Pointer, stat *sysMemStat)\n```\n\nInitialize f to allocate objects of the given size, using the allocator to obtain chunks of memory. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#fixalloc.alloc",
                    "documentation": {
                      "identifier": "fixalloc.alloc",
                      "newPage": false,
                      "searchKey": "runtime.fixalloc.alloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fixalloc) alloc() unsafe.Pointer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fixalloc) alloc() unsafe.Pointer\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#fixalloc.free",
                    "documentation": {
                      "identifier": "fixalloc.free",
                      "newPage": false,
                      "searchKey": "runtime.fixalloc.free",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *fixalloc) free(p unsafe.Pointer)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *fixalloc) free(p unsafe.Pointer)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mlink",
              "documentation": {
                "identifier": "mlink",
                "newPage": false,
                "searchKey": "runtime.mlink",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mlink struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mlink struct {\n\tnext *mlink\n}\n```\n\nA generic linked list of blocks.  (Typically the block is bigger than sizeof(MLink).) Since assignments to mlink.next will result in a write barrier being performed this cannot be used by some of the internal GC structures. For example when the sweeper is placing an unmarked object on the free list it does not want the write barrier to be called since that could result in the object being reachable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkWorkerMode",
              "documentation": {
                "identifier": "gcMarkWorkerMode",
                "newPage": false,
                "searchKey": "runtime.gcMarkWorkerMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gcMarkWorkerMode int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gcMarkWorkerMode int\n```\n\ngcMarkWorkerMode represents the mode that a concurrent mark worker should operate in. \n\nConcurrent marking happens through four different mechanisms. One is mutator assists, which happen in response to allocations and are not scheduled. The other three are variations in the per-P mark workers and are distinguished by gcMarkWorkerMode. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMode",
              "documentation": {
                "identifier": "gcMode",
                "newPage": false,
                "searchKey": "runtime.gcMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gcMode int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gcMode int\n```\n\ngcMode indicates how concurrent a GC cycle should be. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcTrigger",
              "documentation": {
                "identifier": "gcTrigger",
                "newPage": false,
                "searchKey": "runtime.gcTrigger",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gcTrigger struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gcTrigger struct {\n\tkind gcTriggerKind\n\tnow  int64  // gcTriggerTime: current time\n\tn    uint32 // gcTriggerCycle: cycle number to start\n}\n```\n\nA gcTrigger is a predicate for starting a GC cycle. Specifically, it is an exit condition for the _GCoff phase. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#gcTrigger.test",
                    "documentation": {
                      "identifier": "gcTrigger.test",
                      "newPage": false,
                      "searchKey": "runtime.gcTrigger.test",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t gcTrigger) test() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t gcTrigger) test() bool\n```\n\ntest reports whether the trigger condition is satisfied, meaning that the exit condition for the _GCoff phase has been met. The exit condition should be tested when allocating. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcTriggerKind",
              "documentation": {
                "identifier": "gcTriggerKind",
                "newPage": false,
                "searchKey": "runtime.gcTriggerKind",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gcTriggerKind int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gcTriggerKind int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBgMarkWorkerNode",
              "documentation": {
                "identifier": "gcBgMarkWorkerNode",
                "newPage": false,
                "searchKey": "runtime.gcBgMarkWorkerNode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gcBgMarkWorkerNode struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gcBgMarkWorkerNode struct {\n\t// Unused workers are managed in a lock-free stack. This field must be first.\n\tnode lfnode\n\n\t// The g of this worker.\n\tgp guintptr\n\n\t// Release this m on park. This is used to communicate with the unlock\n\t// function, which cannot access the G's stack. It is unused outside of\n\t// gcBgMarkWorker().\n\tm muintptr\n}\n```\n\ngcBgMarkWorker is an entry in the gcBgMarkWorkerPool. It points to a single gcBgMarkWorker goroutine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcDrainFlags",
              "documentation": {
                "identifier": "gcDrainFlags",
                "newPage": false,
                "searchKey": "runtime.gcDrainFlags",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gcDrainFlags int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gcDrainFlags int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcControllerState",
              "documentation": {
                "identifier": "gcControllerState",
                "newPage": false,
                "searchKey": "runtime.gcControllerState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gcControllerState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gcControllerState struct {\n\t// Initialized from $GOGC. GOGC=off means no GC.\n\tgcPercent int32\n\n\t_ uint32 // padding so following 64-bit values are 8-byte aligned\n\n\t// heapMinimum is the minimum heap size at which to trigger GC.\n\t// For small heaps, this overrides the usual GOGC*live set rule.\n\t//\n\t// When there is a very small live set but a lot of allocation, simply\n\t// collecting when the heap reaches GOGC*live results in many GC\n\t// cycles and high total per-GC overhead. This minimum amortizes this\n\t// per-GC overhead while keeping the heap reasonably small.\n\t//\n\t// During initialization this is set to 4MB*GOGC/100. In the case of\n\t// GOGC==0, this will set heapMinimum to 0, resulting in constant\n\t// collection even when the heap size is small, which is useful for\n\t// debugging.\n\theapMinimum uint64\n\n\t// triggerRatio is the heap growth ratio that triggers marking.\n\t//\n\t// E.g., if this is 0.6, then GC should start when the live\n\t// heap has reached 1.6 times the heap size marked by the\n\t// previous cycle. This should be ≤ GOGC/100 so the trigger\n\t// heap size is less than the goal heap size. This is set\n\t// during mark termination for the next cycle's trigger.\n\t//\n\t// Protected by mheap_.lock or a STW.\n\ttriggerRatio float64\n\n\t// trigger is the heap size that triggers marking.\n\t//\n\t// When heapLive ≥ trigger, the mark phase will start.\n\t// This is also the heap size by which proportional sweeping\n\t// must be complete.\n\t//\n\t// This is computed from triggerRatio during mark termination\n\t// for the next cycle's trigger.\n\t//\n\t// Protected by mheap_.lock or a STW.\n\ttrigger uint64\n\n\t// heapGoal is the goal heapLive for when next GC ends.\n\t// Set to ^uint64(0) if disabled.\n\t//\n\t// Read and written atomically, unless the world is stopped.\n\theapGoal uint64\n\n\t// lastHeapGoal is the value of heapGoal for the previous GC.\n\t// Note that this is distinct from the last value heapGoal had,\n\t// because it could change if e.g. gcPercent changes.\n\t//\n\t// Read and written with the world stopped or with mheap_.lock held.\n\tlastHeapGoal uint64\n\n\t// heapLive is the number of bytes considered live by the GC.\n\t// That is: retained by the most recent GC plus allocated\n\t// since then. heapLive ≤ memstats.heapAlloc, since heapAlloc includes\n\t// unmarked objects that have not yet been swept (and hence goes up as we\n\t// allocate and down as we sweep) while heapLive excludes these\n\t// objects (and hence only goes up between GCs).\n\t//\n\t// This is updated atomically without locking. To reduce\n\t// contention, this is updated only when obtaining a span from\n\t// an mcentral and at this point it counts all of the\n\t// unallocated slots in that span (which will be allocated\n\t// before that mcache obtains another span from that\n\t// mcentral). Hence, it slightly overestimates the \"true\" live\n\t// heap size. It's better to overestimate than to\n\t// underestimate because 1) this triggers the GC earlier than\n\t// necessary rather than potentially too late and 2) this\n\t// leads to a conservative GC rate rather than a GC rate that\n\t// is potentially too low.\n\t//\n\t// Reads should likewise be atomic (or during STW).\n\t//\n\t// Whenever this is updated, call traceHeapAlloc() and\n\t// this gcControllerState's revise() method.\n\theapLive uint64\n\n\t// heapScan is the number of bytes of \"scannable\" heap. This\n\t// is the live heap (as counted by heapLive), but omitting\n\t// no-scan objects and no-scan tails of objects.\n\t//\n\t// Whenever this is updated, call this gcControllerState's\n\t// revise() method.\n\t//\n\t// Read and written atomically or with the world stopped.\n\theapScan uint64\n\n\t// heapMarked is the number of bytes marked by the previous\n\t// GC. After mark termination, heapLive == heapMarked, but\n\t// unlike heapLive, heapMarked does not change until the\n\t// next mark termination.\n\theapMarked uint64\n\n\t// scanWork is the total scan work performed this cycle. This\n\t// is updated atomically during the cycle. Updates occur in\n\t// bounded batches, since it is both written and read\n\t// throughout the cycle. At the end of the cycle, this is how\n\t// much of the retained heap is scannable.\n\t//\n\t// Currently this is the bytes of heap scanned. For most uses,\n\t// this is an opaque unit of work, but for estimation the\n\t// definition is important.\n\tscanWork int64\n\n\t// bgScanCredit is the scan work credit accumulated by the\n\t// concurrent background scan. This credit is accumulated by\n\t// the background scan and stolen by mutator assists. This is\n\t// updated atomically. Updates occur in bounded batches, since\n\t// it is both written and read throughout the cycle.\n\tbgScanCredit int64\n\n\t// assistTime is the nanoseconds spent in mutator assists\n\t// during this cycle. This is updated atomically. Updates\n\t// occur in bounded batches, since it is both written and read\n\t// throughout the cycle.\n\tassistTime int64\n\n\t// dedicatedMarkTime is the nanoseconds spent in dedicated\n\t// mark workers during this cycle. This is updated atomically\n\t// at the end of the concurrent mark phase.\n\tdedicatedMarkTime int64\n\n\t// fractionalMarkTime is the nanoseconds spent in the\n\t// fractional mark worker during this cycle. This is updated\n\t// atomically throughout the cycle and will be up-to-date if\n\t// the fractional mark worker is not currently running.\n\tfractionalMarkTime int64\n\n\t// idleMarkTime is the nanoseconds spent in idle marking\n\t// during this cycle. This is updated atomically throughout\n\t// the cycle.\n\tidleMarkTime int64\n\n\t// markStartTime is the absolute start time in nanoseconds\n\t// that assists and background mark workers started.\n\tmarkStartTime int64\n\n\t// dedicatedMarkWorkersNeeded is the number of dedicated mark\n\t// workers that need to be started. This is computed at the\n\t// beginning of each cycle and decremented atomically as\n\t// dedicated mark workers get started.\n\tdedicatedMarkWorkersNeeded int64\n\n\t// assistWorkPerByte is the ratio of scan work to allocated\n\t// bytes that should be performed by mutator assists. This is\n\t// computed at the beginning of each cycle and updated every\n\t// time heapScan is updated.\n\t//\n\t// Stored as a uint64, but it's actually a float64. Use\n\t// float64frombits to get the value.\n\t//\n\t// Read and written atomically.\n\tassistWorkPerByte uint64\n\n\t// assistBytesPerWork is 1/assistWorkPerByte.\n\t//\n\t// Stored as a uint64, but it's actually a float64. Use\n\t// float64frombits to get the value.\n\t//\n\t// Read and written atomically.\n\t//\n\t// Note that because this is read and written independently\n\t// from assistWorkPerByte users may notice a skew between\n\t// the two values, and such a state should be safe.\n\tassistBytesPerWork uint64\n\n\t// fractionalUtilizationGoal is the fraction of wall clock\n\t// time that should be spent in the fractional mark worker on\n\t// each P that isn't running a dedicated worker.\n\t//\n\t// For example, if the utilization goal is 25% and there are\n\t// no dedicated workers, this will be 0.25. If the goal is\n\t// 25%, there is one dedicated worker, and GOMAXPROCS is 5,\n\t// this will be 0.05 to make up the missing 5%.\n\t//\n\t// If this is zero, no fractional workers are needed.\n\tfractionalUtilizationGoal float64\n\n\t_ cpu.CacheLinePad\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#gcControllerState.init",
                    "documentation": {
                      "identifier": "gcControllerState.init",
                      "newPage": false,
                      "searchKey": "runtime.gcControllerState.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *gcControllerState) init(gcPercent int32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *gcControllerState) init(gcPercent int32)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcControllerState.startCycle",
                    "documentation": {
                      "identifier": "gcControllerState.startCycle",
                      "newPage": false,
                      "searchKey": "runtime.gcControllerState.startCycle",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *gcControllerState) startCycle()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *gcControllerState) startCycle()\n```\n\nstartCycle resets the GC controller's state and computes estimates for a new GC cycle. The caller must hold worldsema and the world must be stopped. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcControllerState.revise",
                    "documentation": {
                      "identifier": "gcControllerState.revise",
                      "newPage": false,
                      "searchKey": "runtime.gcControllerState.revise",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *gcControllerState) revise()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *gcControllerState) revise()\n```\n\nrevise updates the assist ratio during the GC cycle to account for improved estimates. This should be called whenever gcController.heapScan, gcController.heapLive, or gcController.heapGoal is updated. It is safe to call concurrently, but it may race with other calls to revise. \n\nThe result of this race is that the two assist ratio values may not line up or may be stale. In practice this is OK because the assist ratio moves slowly throughout a GC cycle, and the assist ratio is a best-effort heuristic anyway. Furthermore, no part of the heuristic depends on the two assist ratio values being exact reciprocals of one another, since the two values are used to convert values from different sources. \n\nThe worst case result of this raciness is that we may miss a larger shift in the ratio (say, if we decide to pace more aggressively against the hard heap goal) but even this \"hard goal\" is best-effort (see #40460). The dedicated GC should ensure we don't exceed the hard goal by too much in the rare case we do exceed it. \n\nIt should only be called when gcBlackenEnabled != 0 (because this is when assists are enabled and the necessary statistics are available). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcControllerState.endCycle",
                    "documentation": {
                      "identifier": "gcControllerState.endCycle",
                      "newPage": false,
                      "searchKey": "runtime.gcControllerState.endCycle",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *gcControllerState) endCycle(userForced bool) float64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *gcControllerState) endCycle(userForced bool) float64\n```\n\nendCycle computes the trigger ratio for the next cycle. userForced indicates whether the current GC cycle was forced by the application. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcControllerState.enlistWorker",
                    "documentation": {
                      "identifier": "gcControllerState.enlistWorker",
                      "newPage": false,
                      "searchKey": "runtime.gcControllerState.enlistWorker",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *gcControllerState) enlistWorker()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *gcControllerState) enlistWorker()\n```\n\nenlistWorker encourages another dedicated mark worker to start on another P if there are spare worker slots. It is used by putfull when more work is made available. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcControllerState.findRunnableGCWorker",
                    "documentation": {
                      "identifier": "gcControllerState.findRunnableGCWorker",
                      "newPage": false,
                      "searchKey": "runtime.gcControllerState.findRunnableGCWorker",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *gcControllerState) findRunnableGCWorker(_p_ *p) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *gcControllerState) findRunnableGCWorker(_p_ *p) *g\n```\n\nfindRunnableGCWorker returns a background mark worker for _p_ if it should be run. This must only be called when gcBlackenEnabled != 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcControllerState.commit",
                    "documentation": {
                      "identifier": "gcControllerState.commit",
                      "newPage": false,
                      "searchKey": "runtime.gcControllerState.commit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *gcControllerState) commit(triggerRatio float64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *gcControllerState) commit(triggerRatio float64)\n```\n\ncommit sets the trigger ratio and updates everything derived from it: the absolute trigger, the heap goal, mark pacing, and sweep pacing. \n\nThis can be called any time. If GC is the in the middle of a concurrent phase, it will adjust the pacing of that phase. \n\nThis depends on gcPercent, gcController.heapMarked, and gcController.heapLive. These must be up to date. \n\nmheap_.lock must be held or the world must be stopped. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcControllerState.effectiveGrowthRatio",
                    "documentation": {
                      "identifier": "gcControllerState.effectiveGrowthRatio",
                      "newPage": false,
                      "searchKey": "runtime.gcControllerState.effectiveGrowthRatio",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *gcControllerState) effectiveGrowthRatio() float64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *gcControllerState) effectiveGrowthRatio() float64\n```\n\neffectiveGrowthRatio returns the current effective heap growth ratio (GOGC/100) based on heapMarked from the previous GC and heapGoal for the current GC. \n\nThis may differ from gcPercent/100 because of various upper and lower bounds on gcPercent. For example, if the heap is smaller than heapMinimum, this can be higher than gcPercent/100. \n\nmheap_.lock must be held or the world must be stopped. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcControllerState.setGCPercent",
                    "documentation": {
                      "identifier": "gcControllerState.setGCPercent",
                      "newPage": false,
                      "searchKey": "runtime.gcControllerState.setGCPercent",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *gcControllerState) setGCPercent(in int32) int32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *gcControllerState) setGCPercent(in int32) int32\n```\n\nsetGCPercent updates gcPercent and all related pacer state. Returns the old value of gcPercent. \n\nThe world must be stopped, or mheap_.lock must be held. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackWorkBuf",
              "documentation": {
                "identifier": "stackWorkBuf",
                "newPage": false,
                "searchKey": "runtime.stackWorkBuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stackWorkBuf struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stackWorkBuf struct {\n\tstackWorkBufHdr\n\tobj [(_WorkbufSize - unsafe.Sizeof(stackWorkBufHdr{})) / sys.PtrSize]uintptr\n}\n```\n\nBuffer for pointers found during stack tracing. Must be smaller than or equal to workbuf. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackWorkBufHdr",
              "documentation": {
                "identifier": "stackWorkBufHdr",
                "newPage": false,
                "searchKey": "runtime.stackWorkBufHdr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stackWorkBufHdr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stackWorkBufHdr struct {\n\tworkbufhdr\n\tnext *stackWorkBuf // linked list of workbufs\n\n}\n```\n\nHeader declaration must come after the buf declaration above, because of issue #14620. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackObjectBuf",
              "documentation": {
                "identifier": "stackObjectBuf",
                "newPage": false,
                "searchKey": "runtime.stackObjectBuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stackObjectBuf struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stackObjectBuf struct {\n\tstackObjectBufHdr\n\tobj [(_WorkbufSize - unsafe.Sizeof(stackObjectBufHdr{})) / unsafe.Sizeof(stackObject{})]stackObject\n}\n```\n\nBuffer for stack objects found on a goroutine stack. Must be smaller than or equal to workbuf. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#binarySearchTree",
                    "documentation": {
                      "identifier": "binarySearchTree",
                      "newPage": false,
                      "searchKey": "runtime.binarySearchTree",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func binarySearchTree(x *stackObjectBuf, idx int, n int) (root *stackObject, restBuf *stackObjectBuf, restIdx int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc binarySearchTree(x *stackObjectBuf, idx int, n int) (root *stackObject, restBuf *stackObjectBuf, restIdx int)\n```\n\nBuild a binary search tree with the n objects in the list x.obj[idx], x.obj[idx+1], ..., x.next.obj[0], ... Returns the root of that tree, and the buf+idx of the nth object after x.obj[idx]. (The first object that was not included in the binary search tree.) If n == 0, returns nil, x. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackObjectBufHdr",
              "documentation": {
                "identifier": "stackObjectBufHdr",
                "newPage": false,
                "searchKey": "runtime.stackObjectBufHdr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stackObjectBufHdr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stackObjectBufHdr struct {\n\tworkbufhdr\n\tnext *stackObjectBuf\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackObject",
              "documentation": {
                "identifier": "stackObject",
                "newPage": false,
                "searchKey": "runtime.stackObject",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stackObject struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stackObject struct {\n\toff   uint32             // offset above stack.lo\n\tsize  uint32             // size of object\n\tr     *stackObjectRecord // info of the object (for ptr/nonptr bits). nil if object has been scanned.\n\tleft  *stackObject       // objects with lower addresses\n\tright *stackObject       // objects with higher addresses\n}\n```\n\nA stackObject represents a variable on the stack that has had its address taken. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#binarySearchTree",
                    "documentation": {
                      "identifier": "binarySearchTree",
                      "newPage": false,
                      "searchKey": "runtime.binarySearchTree",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func binarySearchTree(x *stackObjectBuf, idx int, n int) (root *stackObject, restBuf *stackObjectBuf, restIdx int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc binarySearchTree(x *stackObjectBuf, idx int, n int) (root *stackObject, restBuf *stackObjectBuf, restIdx int)\n```\n\nBuild a binary search tree with the n objects in the list x.obj[idx], x.obj[idx+1], ..., x.next.obj[0], ... Returns the root of that tree, and the buf+idx of the nth object after x.obj[idx]. (The first object that was not included in the binary search tree.) If n == 0, returns nil, x. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#stackObject.setRecord",
                    "documentation": {
                      "identifier": "stackObject.setRecord",
                      "newPage": false,
                      "searchKey": "runtime.stackObject.setRecord",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (obj *stackObject) setRecord(r *stackObjectRecord)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (obj *stackObject) setRecord(r *stackObjectRecord)\n```\n\nobj.r = r, but with no write barrier. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackScanState",
              "documentation": {
                "identifier": "stackScanState",
                "newPage": false,
                "searchKey": "runtime.stackScanState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stackScanState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stackScanState struct {\n\tcache pcvalueCache\n\n\t// stack limits\n\tstack stack\n\n\t// conservative indicates that the next frame must be scanned conservatively.\n\t// This applies only to the innermost frame at an async safe-point.\n\tconservative bool\n\n\t// buf contains the set of possible pointers to stack objects.\n\t// Organized as a LIFO linked list of buffers.\n\t// All buffers except possibly the head buffer are full.\n\tbuf     *stackWorkBuf\n\tfreeBuf *stackWorkBuf // keep around one free buffer for allocation hysteresis\n\n\t// cbuf contains conservative pointers to stack objects. If\n\t// all pointers to a stack object are obtained via\n\t// conservative scanning, then the stack object may be dead\n\t// and may contain dead pointers, so it must be scanned\n\t// defensively.\n\tcbuf *stackWorkBuf\n\n\t// list of stack objects\n\t// Objects are in increasing address order.\n\thead  *stackObjectBuf\n\ttail  *stackObjectBuf\n\tnobjs int\n\n\t// root of binary tree for fast object lookup by address\n\t// Initialized by buildIndex.\n\troot *stackObject\n}\n```\n\nA stackScanState keeps track of the state used during the GC walk of a goroutine. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#stackScanState.putPtr",
                    "documentation": {
                      "identifier": "stackScanState.putPtr",
                      "newPage": false,
                      "searchKey": "runtime.stackScanState.putPtr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *stackScanState) putPtr(p uintptr, conservative bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *stackScanState) putPtr(p uintptr, conservative bool)\n```\n\nAdd p as a potential pointer to a stack object. p must be a stack address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#stackScanState.getPtr",
                    "documentation": {
                      "identifier": "stackScanState.getPtr",
                      "newPage": false,
                      "searchKey": "runtime.stackScanState.getPtr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *stackScanState) getPtr() (p uintptr, conservative bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *stackScanState) getPtr() (p uintptr, conservative bool)\n```\n\nRemove and return a potential pointer to a stack object. Returns 0 if there are no more pointers available. \n\nThis prefers non-conservative pointers so we scan stack objects precisely if there are any non-conservative pointers to them. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#stackScanState.addObject",
                    "documentation": {
                      "identifier": "stackScanState.addObject",
                      "newPage": false,
                      "searchKey": "runtime.stackScanState.addObject",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *stackScanState) addObject(addr uintptr, r *stackObjectRecord)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *stackScanState) addObject(addr uintptr, r *stackObjectRecord)\n```\n\naddObject adds a stack object at addr of type typ to the set of stack objects. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#stackScanState.buildIndex",
                    "documentation": {
                      "identifier": "stackScanState.buildIndex",
                      "newPage": false,
                      "searchKey": "runtime.stackScanState.buildIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *stackScanState) buildIndex()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *stackScanState) buildIndex()\n```\n\nbuildIndex initializes s.root to a binary search tree. It should be called after all addObject calls but before any call of findObject. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#stackScanState.findObject",
                    "documentation": {
                      "identifier": "stackScanState.findObject",
                      "newPage": false,
                      "searchKey": "runtime.stackScanState.findObject",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *stackScanState) findObject(a uintptr) *stackObject"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *stackScanState) findObject(a uintptr) *stackObject\n```\n\nfindObject returns the stack object containing address a, if any. Must have called buildIndex previously. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sweepdata",
              "documentation": {
                "identifier": "sweepdata",
                "newPage": false,
                "searchKey": "runtime.sweepdata",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sweepdata struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sweepdata struct {\n\tlock    mutex\n\tg       *g\n\tparked  bool\n\tstarted bool\n\n\tnbgsweep    uint32\n\tnpausesweep uint32\n\n\t// centralIndex is the current unswept span class.\n\t// It represents an index into the mcentral span\n\t// sets. Accessed and updated via its load and\n\t// update methods. Not protected by a lock.\n\t//\n\t// Reset at mark termination.\n\t// Used by mheap.nextSpanForSweep.\n\tcentralIndex sweepClass\n}\n```\n\nState of background sweep. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sweepClass",
              "documentation": {
                "identifier": "sweepClass",
                "newPage": false,
                "searchKey": "runtime.sweepClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sweepClass uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sweepClass uint32\n```\n\nsweepClass is a spanClass and one bit to represent whether we're currently sweeping partial or full spans. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#sweepClass.load",
                    "documentation": {
                      "identifier": "sweepClass.load",
                      "newPage": false,
                      "searchKey": "runtime.sweepClass.load",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *sweepClass) load() sweepClass"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *sweepClass) load() sweepClass\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sweepClass.update",
                    "documentation": {
                      "identifier": "sweepClass.update",
                      "newPage": false,
                      "searchKey": "runtime.sweepClass.update",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *sweepClass) update(sNew sweepClass)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *sweepClass) update(sNew sweepClass)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sweepClass.clear",
                    "documentation": {
                      "identifier": "sweepClass.clear",
                      "newPage": false,
                      "searchKey": "runtime.sweepClass.clear",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *sweepClass) clear()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *sweepClass) clear()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sweepClass.split",
                    "documentation": {
                      "identifier": "sweepClass.split",
                      "newPage": false,
                      "searchKey": "runtime.sweepClass.split",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s sweepClass) split() (spc spanClass, full bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s sweepClass) split() (spc spanClass, full bool)\n```\n\nsplit returns the underlying span class as well as whether we're interested in the full or partial unswept lists for that class, indicated as a boolean (true means \"full\"). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sweepLocker",
              "documentation": {
                "identifier": "sweepLocker",
                "newPage": false,
                "searchKey": "runtime.sweepLocker",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sweepLocker struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sweepLocker struct {\n\t// sweepGen is the sweep generation of the heap.\n\tsweepGen uint32\n\t// blocking indicates that this tracker is blocking sweep\n\t// completion, usually as a result of acquiring sweep\n\t// ownership of at least one span.\n\tblocking bool\n}\n```\n\nsweepLocker acquires sweep ownership of spans and blocks sweep completion. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#newSweepLocker",
                    "documentation": {
                      "identifier": "newSweepLocker",
                      "newPage": false,
                      "searchKey": "runtime.newSweepLocker",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newSweepLocker() sweepLocker"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newSweepLocker() sweepLocker\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sweepLocker.tryAcquire",
                    "documentation": {
                      "identifier": "sweepLocker.tryAcquire",
                      "newPage": false,
                      "searchKey": "runtime.sweepLocker.tryAcquire",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *sweepLocker) tryAcquire(s *mspan) (sweepLocked, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *sweepLocker) tryAcquire(s *mspan) (sweepLocked, bool)\n```\n\ntryAcquire attempts to acquire sweep ownership of span s. If it successfully acquires ownership, it blocks sweep completion. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sweepLocker.blockCompletion",
                    "documentation": {
                      "identifier": "sweepLocker.blockCompletion",
                      "newPage": false,
                      "searchKey": "runtime.sweepLocker.blockCompletion",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *sweepLocker) blockCompletion()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *sweepLocker) blockCompletion()\n```\n\nblockCompletion blocks sweep completion without acquiring any specific spans. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sweepLocker.dispose",
                    "documentation": {
                      "identifier": "sweepLocker.dispose",
                      "newPage": false,
                      "searchKey": "runtime.sweepLocker.dispose",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *sweepLocker) dispose()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *sweepLocker) dispose()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sweepLocker.sweepIsDone",
                    "documentation": {
                      "identifier": "sweepLocker.sweepIsDone",
                      "newPage": false,
                      "searchKey": "runtime.sweepLocker.sweepIsDone",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *sweepLocker) sweepIsDone()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *sweepLocker) sweepIsDone()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sweepLocked",
              "documentation": {
                "identifier": "sweepLocked",
                "newPage": false,
                "searchKey": "runtime.sweepLocked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sweepLocked struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sweepLocked struct {\n\t*mspan\n}\n```\n\nsweepLocked represents sweep ownership of a span. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#sweepLocked.sweep",
                    "documentation": {
                      "identifier": "sweepLocked.sweep",
                      "newPage": false,
                      "searchKey": "runtime.sweepLocked.sweep",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sl *sweepLocked) sweep(preserve bool) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sl *sweepLocked) sweep(preserve bool) bool\n```\n\nSweep frees or collects finalizers for blocks not marked in the mark phase. It clears the mark bits in preparation for the next GC round. Returns true if the span was returned to heap. If preserve=true, don't return it to heap nor relink in mcentral lists; caller takes care of it. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcWork",
              "documentation": {
                "identifier": "gcWork",
                "newPage": false,
                "searchKey": "runtime.gcWork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gcWork struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gcWork struct {\n\t// wbuf1 and wbuf2 are the primary and secondary work buffers.\n\t//\n\t// This can be thought of as a stack of both work buffers'\n\t// pointers concatenated. When we pop the last pointer, we\n\t// shift the stack up by one work buffer by bringing in a new\n\t// full buffer and discarding an empty one. When we fill both\n\t// buffers, we shift the stack down by one work buffer by\n\t// bringing in a new empty buffer and discarding a full one.\n\t// This way we have one buffer's worth of hysteresis, which\n\t// amortizes the cost of getting or putting a work buffer over\n\t// at least one buffer of work and reduces contention on the\n\t// global work lists.\n\t//\n\t// wbuf1 is always the buffer we're currently pushing to and\n\t// popping from and wbuf2 is the buffer that will be discarded\n\t// next.\n\t//\n\t// Invariant: Both wbuf1 and wbuf2 are nil or neither are.\n\twbuf1, wbuf2 *workbuf\n\n\t// Bytes marked (blackened) on this gcWork. This is aggregated\n\t// into work.bytesMarked by dispose.\n\tbytesMarked uint64\n\n\t// Scan work performed on this gcWork. This is aggregated into\n\t// gcController by dispose and may also be flushed by callers.\n\tscanWork int64\n\n\t// flushedWork indicates that a non-empty work buffer was\n\t// flushed to the global work list since the last gcMarkDone\n\t// termination check. Specifically, this indicates that this\n\t// gcWork may have communicated work to another gcWork.\n\tflushedWork bool\n}\n```\n\nA gcWork provides the interface to produce and consume work for the garbage collector. \n\nA gcWork can be used on the stack as follows: \n\n```\n(preemption must be disabled)\ngcw := &getg().m.p.ptr().gcw\n.. call gcw.put() to produce and gcw.tryGet() to consume ..\n\n```\nIt's important that any use of gcWork during the mark phase prevent the garbage collector from transitioning to mark termination since gcWork may locally hold GC work buffers. This can be done by disabling preemption (systemstack or acquirem). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#gcWork.init",
                    "documentation": {
                      "identifier": "gcWork.init",
                      "newPage": false,
                      "searchKey": "runtime.gcWork.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *gcWork) init()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *gcWork) init()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcWork.put",
                    "documentation": {
                      "identifier": "gcWork.put",
                      "newPage": false,
                      "searchKey": "runtime.gcWork.put",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *gcWork) put(obj uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *gcWork) put(obj uintptr)\n```\n\nput enqueues a pointer for the garbage collector to trace. obj must point to the beginning of a heap object or an oblet. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcWork.putFast",
                    "documentation": {
                      "identifier": "gcWork.putFast",
                      "newPage": false,
                      "searchKey": "runtime.gcWork.putFast",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *gcWork) putFast(obj uintptr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *gcWork) putFast(obj uintptr) bool\n```\n\nputFast does a put and reports whether it can be done quickly otherwise it returns false and the caller needs to call put. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcWork.putBatch",
                    "documentation": {
                      "identifier": "gcWork.putBatch",
                      "newPage": false,
                      "searchKey": "runtime.gcWork.putBatch",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *gcWork) putBatch(obj []uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *gcWork) putBatch(obj []uintptr)\n```\n\nputBatch performs a put on every pointer in obj. See put for constraints on these pointers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcWork.tryGet",
                    "documentation": {
                      "identifier": "gcWork.tryGet",
                      "newPage": false,
                      "searchKey": "runtime.gcWork.tryGet",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *gcWork) tryGet() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *gcWork) tryGet() uintptr\n```\n\ntryGet dequeues a pointer for the garbage collector to trace. \n\nIf there are no pointers remaining in this gcWork or in the global queue, tryGet returns 0.  Note that there may still be pointers in other gcWork instances or other caches. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcWork.tryGetFast",
                    "documentation": {
                      "identifier": "gcWork.tryGetFast",
                      "newPage": false,
                      "searchKey": "runtime.gcWork.tryGetFast",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *gcWork) tryGetFast() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *gcWork) tryGetFast() uintptr\n```\n\ntryGetFast dequeues a pointer for the garbage collector to trace if one is readily available. Otherwise it returns 0 and the caller is expected to call tryGet(). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcWork.dispose",
                    "documentation": {
                      "identifier": "gcWork.dispose",
                      "newPage": false,
                      "searchKey": "runtime.gcWork.dispose",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *gcWork) dispose()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *gcWork) dispose()\n```\n\ndispose returns any cached pointers to the global queue. The buffers are being put on the full queue so that the write barriers will not simply reacquire them before the GC can inspect them. This helps reduce the mutator's ability to hide pointers during the concurrent mark phase. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcWork.balance",
                    "documentation": {
                      "identifier": "gcWork.balance",
                      "newPage": false,
                      "searchKey": "runtime.gcWork.balance",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *gcWork) balance()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *gcWork) balance()\n```\n\nbalance moves some work that's cached in this gcWork back on the global queue. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcWork.empty",
                    "documentation": {
                      "identifier": "gcWork.empty",
                      "newPage": false,
                      "searchKey": "runtime.gcWork.empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w *gcWork) empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w *gcWork) empty() bool\n```\n\nempty reports whether w has no mark work available. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#workbufhdr",
              "documentation": {
                "identifier": "workbufhdr",
                "newPage": false,
                "searchKey": "runtime.workbufhdr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type workbufhdr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype workbufhdr struct {\n\tnode lfnode // must be first\n\tnobj int\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#workbuf",
              "documentation": {
                "identifier": "workbuf",
                "newPage": false,
                "searchKey": "runtime.workbuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type workbuf struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype workbuf struct {\n\tworkbufhdr\n\t// account for the above fields\n\tobj [(_WorkbufSize - unsafe.Sizeof(workbufhdr{})) / sys.PtrSize]uintptr\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#getempty",
                    "documentation": {
                      "identifier": "getempty",
                      "newPage": false,
                      "searchKey": "runtime.getempty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func getempty() *workbuf"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc getempty() *workbuf\n```\n\ngetempty pops an empty work buffer off the work.empty list, allocating new buffers if none are available. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#trygetfull",
                    "documentation": {
                      "identifier": "trygetfull",
                      "newPage": false,
                      "searchKey": "runtime.trygetfull",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func trygetfull() *workbuf"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc trygetfull() *workbuf\n```\n\ntrygetfull tries to get a full or partially empty workbuffer. If one is not immediately available return nil \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#handoff",
                    "documentation": {
                      "identifier": "handoff",
                      "newPage": false,
                      "searchKey": "runtime.handoff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func handoff(b *workbuf) *workbuf"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc handoff(b *workbuf) *workbuf\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#workbuf.checknonempty",
                    "documentation": {
                      "identifier": "workbuf.checknonempty",
                      "newPage": false,
                      "searchKey": "runtime.workbuf.checknonempty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *workbuf) checknonempty()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *workbuf) checknonempty()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#workbuf.checkempty",
                    "documentation": {
                      "identifier": "workbuf.checkempty",
                      "newPage": false,
                      "searchKey": "runtime.workbuf.checkempty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *workbuf) checkempty()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *workbuf) checkempty()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mheap",
              "documentation": {
                "identifier": "mheap",
                "newPage": false,
                "searchKey": "runtime.mheap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mheap struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mheap struct {\n\t// lock must only be acquired on the system stack, otherwise a g\n\t// could self-deadlock if its stack grows with the lock held.\n\tlock  mutex\n\tpages pageAlloc // page allocation data structure\n\n\tsweepgen     uint32 // sweep generation, see comment in mspan; written during STW\n\tsweepDrained uint32 // all spans are swept or are being swept\n\tsweepers     uint32 // number of active sweepone calls\n\n\t// allspans is a slice of all mspans ever created. Each mspan\n\t// appears exactly once.\n\t//\n\t// The memory for allspans is manually managed and can be\n\t// reallocated and move as the heap grows.\n\t//\n\t// In general, allspans is protected by mheap_.lock, which\n\t// prevents concurrent access as well as freeing the backing\n\t// store. Accesses during STW might not hold the lock, but\n\t// must ensure that allocation cannot happen around the\n\t// access (since that may free the backing store).\n\tallspans []*mspan // all spans out there\n\n\t_ uint32 // align uint64 fields on 32-bit for atomics\n\n\t// Proportional sweep\n\t//\n\t// These parameters represent a linear function from gcController.heapLive\n\t// to page sweep count. The proportional sweep system works to\n\t// stay in the black by keeping the current page sweep count\n\t// above this line at the current gcController.heapLive.\n\t//\n\t// The line has slope sweepPagesPerByte and passes through a\n\t// basis point at (sweepHeapLiveBasis, pagesSweptBasis). At\n\t// any given time, the system is at (gcController.heapLive,\n\t// pagesSwept) in this space.\n\t//\n\t// It's important that the line pass through a point we\n\t// control rather than simply starting at a (0,0) origin\n\t// because that lets us adjust sweep pacing at any time while\n\t// accounting for current progress. If we could only adjust\n\t// the slope, it would create a discontinuity in debt if any\n\t// progress has already been made.\n\tpagesInUse         uint64  // pages of spans in stats mSpanInUse; updated atomically\n\tpagesSwept         uint64  // pages swept this cycle; updated atomically\n\tpagesSweptBasis    uint64  // pagesSwept to use as the origin of the sweep ratio; updated atomically\n\tsweepHeapLiveBasis uint64  // value of gcController.heapLive to use as the origin of sweep ratio; written with lock, read without\n\tsweepPagesPerByte  float64 // proportional sweep ratio; written with lock, read without\n\n\t// scavengeGoal is the amount of total retained heap memory (measured by\n\t// heapRetained) that the runtime will try to maintain by returning memory\n\t// to the OS.\n\tscavengeGoal uint64\n\n\t// reclaimIndex is the page index in allArenas of next page to\n\t// reclaim. Specifically, it refers to page (i %\n\t// pagesPerArena) of arena allArenas[i / pagesPerArena].\n\t//\n\t// If this is >= 1<<63, the page reclaimer is done scanning\n\t// the page marks.\n\t//\n\t// This is accessed atomically.\n\treclaimIndex uint64\n\t// reclaimCredit is spare credit for extra pages swept. Since\n\t// the page reclaimer works in large chunks, it may reclaim\n\t// more than requested. Any spare pages released go to this\n\t// credit pool.\n\t//\n\t// This is accessed atomically.\n\treclaimCredit uintptr\n\n\t// arenas is the heap arena map. It points to the metadata for\n\t// the heap for every arena frame of the entire usable virtual\n\t// address space.\n\t//\n\t// Use arenaIndex to compute indexes into this array.\n\t//\n\t// For regions of the address space that are not backed by the\n\t// Go heap, the arena map contains nil.\n\t//\n\t// Modifications are protected by mheap_.lock. Reads can be\n\t// performed without locking; however, a given entry can\n\t// transition from nil to non-nil at any time when the lock\n\t// isn't held. (Entries never transitions back to nil.)\n\t//\n\t// In general, this is a two-level mapping consisting of an L1\n\t// map and possibly many L2 maps. This saves space when there\n\t// are a huge number of arena frames. However, on many\n\t// platforms (even 64-bit), arenaL1Bits is 0, making this\n\t// effectively a single-level map. In this case, arenas[0]\n\t// will never be nil.\n\tarenas [1 << arenaL1Bits]*[1 << arenaL2Bits]*heapArena\n\n\t// heapArenaAlloc is pre-reserved space for allocating heapArena\n\t// objects. This is only used on 32-bit, where we pre-reserve\n\t// this space to avoid interleaving it with the heap itself.\n\theapArenaAlloc linearAlloc\n\n\t// arenaHints is a list of addresses at which to attempt to\n\t// add more heap arenas. This is initially populated with a\n\t// set of general hint addresses, and grown with the bounds of\n\t// actual heap arena ranges.\n\tarenaHints *arenaHint\n\n\t// arena is a pre-reserved space for allocating heap arenas\n\t// (the actual arenas). This is only used on 32-bit.\n\tarena linearAlloc\n\n\t// allArenas is the arenaIndex of every mapped arena. This can\n\t// be used to iterate through the address space.\n\t//\n\t// Access is protected by mheap_.lock. However, since this is\n\t// append-only and old backing arrays are never freed, it is\n\t// safe to acquire mheap_.lock, copy the slice header, and\n\t// then release mheap_.lock.\n\tallArenas []arenaIdx\n\n\t// sweepArenas is a snapshot of allArenas taken at the\n\t// beginning of the sweep cycle. This can be read safely by\n\t// simply blocking GC (by disabling preemption).\n\tsweepArenas []arenaIdx\n\n\t// markArenas is a snapshot of allArenas taken at the beginning\n\t// of the mark cycle. Because allArenas is append-only, neither\n\t// this slice nor its contents will change during the mark, so\n\t// it can be read safely.\n\tmarkArenas []arenaIdx\n\n\t// curArena is the arena that the heap is currently growing\n\t// into. This should always be physPageSize-aligned.\n\tcurArena struct {\n\t\tbase, end uintptr\n\t}\n\n\t_ uint32 // ensure 64-bit alignment of central\n\n\t// central free lists for small size classes.\n\t// the padding makes sure that the mcentrals are\n\t// spaced CacheLinePadSize bytes apart, so that each mcentral.lock\n\t// gets its own cache line.\n\t// central is indexed by spanClass.\n\tcentral [numSpanClasses]struct {\n\t\tmcentral mcentral\n\t\tpad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral{})%cpu.CacheLinePadSize]byte\n\t}\n\n\tspanalloc             fixalloc // allocator for span*\n\tcachealloc            fixalloc // allocator for mcache*\n\tspecialfinalizeralloc fixalloc // allocator for specialfinalizer*\n\tspecialprofilealloc   fixalloc // allocator for specialprofile*\n\tspecialReachableAlloc fixalloc // allocator for specialReachable\n\tspeciallock           mutex    // lock for special record allocators.\n\tarenaHintAlloc        fixalloc // allocator for arenaHints\n\n\tunused *specialfinalizer // never set, just here to force the specialfinalizer type into DWARF\n}\n```\n\nMain malloc heap. The heap itself is the \"free\" and \"scav\" treaps, but all the other global data is here too. \n\nmheap must not be heap-allocated because it contains mSpanLists, which must not be heap-allocated. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.sysAlloc",
                    "documentation": {
                      "identifier": "mheap.sysAlloc",
                      "newPage": false,
                      "searchKey": "runtime.mheap.sysAlloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr)\n```\n\nsysAlloc allocates heap arena space for at least n bytes. The returned pointer is always heapArenaBytes-aligned and backed by h.arenas metadata. The returned size is always a multiple of heapArenaBytes. sysAlloc returns nil on failure. There is no corresponding free function. \n\nsysAlloc returns a memory region in the Reserved state. This region must be transitioned to Prepared and then Ready before use. \n\nh must be locked. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.nextSpanForSweep",
                    "documentation": {
                      "identifier": "mheap.nextSpanForSweep",
                      "newPage": false,
                      "searchKey": "runtime.mheap.nextSpanForSweep",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) nextSpanForSweep() *mspan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) nextSpanForSweep() *mspan\n```\n\nnextSpanForSweep finds and pops the next span for sweeping from the central sweep buffers. It returns ownership of the span to the caller. Returns nil if no such span exists. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.init",
                    "documentation": {
                      "identifier": "mheap.init",
                      "newPage": false,
                      "searchKey": "runtime.mheap.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) init()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) init()\n```\n\nInitialize the heap. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.reclaim",
                    "documentation": {
                      "identifier": "mheap.reclaim",
                      "newPage": false,
                      "searchKey": "runtime.mheap.reclaim",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) reclaim(npage uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) reclaim(npage uintptr)\n```\n\nreclaim sweeps and reclaims at least npage pages into the heap. It is called before allocating npage pages to keep growth in check. \n\nreclaim implements the page-reclaimer half of the sweeper. \n\nh.lock must NOT be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.reclaimChunk",
                    "documentation": {
                      "identifier": "mheap.reclaimChunk",
                      "newPage": false,
                      "searchKey": "runtime.mheap.reclaimChunk",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) reclaimChunk(arenas []arenaIdx, pageIdx, n uintptr) uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) reclaimChunk(arenas []arenaIdx, pageIdx, n uintptr) uintptr\n```\n\nreclaimChunk sweeps unmarked spans that start at page indexes [pageIdx, pageIdx+n). It returns the number of pages returned to the heap. \n\nh.lock must be held and the caller must be non-preemptible. Note: h.lock may be temporarily unlocked and re-locked in order to do sweeping or if tracing is enabled. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.alloc",
                    "documentation": {
                      "identifier": "mheap.alloc",
                      "newPage": false,
                      "searchKey": "runtime.mheap.alloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) alloc(npages uintptr, spanclass spanClass, needzero bool) (*mspan, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) alloc(npages uintptr, spanclass spanClass, needzero bool) (*mspan, bool)\n```\n\nalloc allocates a new span of npage pages from the GC'd heap. \n\nspanclass indicates the span's size class and scannability. \n\nIf needzero is true, the memory for the returned span will be zeroed. The boolean returned indicates whether the returned span contains zeroes, either because this was requested, or because it was already zeroed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.allocManual",
                    "documentation": {
                      "identifier": "mheap.allocManual",
                      "newPage": false,
                      "searchKey": "runtime.mheap.allocManual",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) allocManual(npages uintptr, typ spanAllocType) *mspan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) allocManual(npages uintptr, typ spanAllocType) *mspan\n```\n\nallocManual allocates a manually-managed span of npage pages. allocManual returns nil if allocation fails. \n\nallocManual adds the bytes used to *stat, which should be a memstats in-use field. Unlike allocations in the GC'd heap, the allocation does *not* count toward heap_inuse or heap_sys. \n\nThe memory backing the returned span may not be zeroed if span.needzero is set. \n\nallocManual must be called on the system stack because it may acquire the heap lock via allocSpan. See mheap for details. \n\nIf new code is written to call allocManual, do NOT use an existing spanAllocType value and instead declare a new one. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.setSpans",
                    "documentation": {
                      "identifier": "mheap.setSpans",
                      "newPage": false,
                      "searchKey": "runtime.mheap.setSpans",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) setSpans(base, npage uintptr, s *mspan)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) setSpans(base, npage uintptr, s *mspan)\n```\n\nsetSpans modifies the span map so [spanOf(base), spanOf(base+npage*pageSize)) is s. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.allocNeedsZero",
                    "documentation": {
                      "identifier": "mheap.allocNeedsZero",
                      "newPage": false,
                      "searchKey": "runtime.mheap.allocNeedsZero",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) allocNeedsZero(base, npage uintptr) (needZero bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) allocNeedsZero(base, npage uintptr) (needZero bool)\n```\n\nallocNeedsZero checks if the region of address space [base, base+npage*pageSize), assumed to be allocated, needs to be zeroed, updating heap arena metadata for future allocations. \n\nThis must be called each time pages are allocated from the heap, even if the page allocator can otherwise prove the memory it's allocating is already zero because they're fresh from the operating system. It updates heapArena metadata that is critical for future page allocations. \n\nThere are no locking constraints on this method. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.tryAllocMSpan",
                    "documentation": {
                      "identifier": "mheap.tryAllocMSpan",
                      "newPage": false,
                      "searchKey": "runtime.mheap.tryAllocMSpan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) tryAllocMSpan() *mspan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) tryAllocMSpan() *mspan\n```\n\ntryAllocMSpan attempts to allocate an mspan object from the P-local cache, but may fail. \n\nh.lock need not be held. \n\nThis caller must ensure that its P won't change underneath it during this function. Currently to ensure that we enforce that the function is run on the system stack, because that's the only place it is used now. In the future, this requirement may be relaxed if its use is necessary elsewhere. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.allocMSpanLocked",
                    "documentation": {
                      "identifier": "mheap.allocMSpanLocked",
                      "newPage": false,
                      "searchKey": "runtime.mheap.allocMSpanLocked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) allocMSpanLocked() *mspan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) allocMSpanLocked() *mspan\n```\n\nallocMSpanLocked allocates an mspan object. \n\nh.lock must be held. \n\nallocMSpanLocked must be called on the system stack because its caller holds the heap lock. See mheap for details. Running on the system stack also ensures that we won't switch Ps during this function. See tryAllocMSpan for details. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.freeMSpanLocked",
                    "documentation": {
                      "identifier": "mheap.freeMSpanLocked",
                      "newPage": false,
                      "searchKey": "runtime.mheap.freeMSpanLocked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) freeMSpanLocked(s *mspan)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) freeMSpanLocked(s *mspan)\n```\n\nfreeMSpanLocked free an mspan object. \n\nh.lock must be held. \n\nfreeMSpanLocked must be called on the system stack because its caller holds the heap lock. See mheap for details. Running on the system stack also ensures that we won't switch Ps during this function. See tryAllocMSpan for details. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.allocSpan",
                    "documentation": {
                      "identifier": "mheap.allocSpan",
                      "newPage": false,
                      "searchKey": "runtime.mheap.allocSpan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) allocSpan(npages uintptr, typ spanAllocType, spanclass spanClass) (s *mspan)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) allocSpan(npages uintptr, typ spanAllocType, spanclass spanClass) (s *mspan)\n```\n\nallocSpan allocates an mspan which owns npages worth of memory. \n\nIf typ.manual() == false, allocSpan allocates a heap span of class spanclass and updates heap accounting. If manual == true, allocSpan allocates a manually-managed span (spanclass is ignored), and the caller is responsible for any accounting related to its use of the span. Either way, allocSpan will atomically add the bytes in the newly allocated span to *sysStat. \n\nThe returned span is fully initialized. \n\nh.lock must not be held. \n\nallocSpan must be called on the system stack both because it acquires the heap lock and because it must block GC transitions. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.grow",
                    "documentation": {
                      "identifier": "mheap.grow",
                      "newPage": false,
                      "searchKey": "runtime.mheap.grow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) grow(npage uintptr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) grow(npage uintptr) bool\n```\n\nTry to add at least npage pages of memory to the heap, returning whether it worked. \n\nh.lock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.freeSpan",
                    "documentation": {
                      "identifier": "mheap.freeSpan",
                      "newPage": false,
                      "searchKey": "runtime.mheap.freeSpan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) freeSpan(s *mspan)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) freeSpan(s *mspan)\n```\n\nFree the span back into the heap. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.freeManual",
                    "documentation": {
                      "identifier": "mheap.freeManual",
                      "newPage": false,
                      "searchKey": "runtime.mheap.freeManual",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) freeManual(s *mspan, typ spanAllocType)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) freeManual(s *mspan, typ spanAllocType)\n```\n\nfreeManual frees a manually-managed span returned by allocManual. typ must be the same as the spanAllocType passed to the allocManual that allocated s. \n\nThis must only be called when gcphase == _GCoff. See mSpanState for an explanation. \n\nfreeManual must be called on the system stack because it acquires the heap lock. See mheap for details. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.freeSpanLocked",
                    "documentation": {
                      "identifier": "mheap.freeSpanLocked",
                      "newPage": false,
                      "searchKey": "runtime.mheap.freeSpanLocked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) freeSpanLocked(s *mspan, typ spanAllocType)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) freeSpanLocked(s *mspan, typ spanAllocType)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mheap.scavengeAll",
                    "documentation": {
                      "identifier": "mheap.scavengeAll",
                      "newPage": false,
                      "searchKey": "runtime.mheap.scavengeAll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *mheap) scavengeAll()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *mheap) scavengeAll()\n```\n\nscavengeAll acquires the heap lock (blocking any additional manipulation of the page allocator) and iterates over the whole heap, scavenging every free page available. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapArena",
              "documentation": {
                "identifier": "heapArena",
                "newPage": false,
                "searchKey": "runtime.heapArena",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type heapArena struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype heapArena struct {\n\t// bitmap stores the pointer/scalar bitmap for the words in\n\t// this arena. See mbitmap.go for a description. Use the\n\t// heapBits type to access this.\n\tbitmap [heapArenaBitmapBytes]byte\n\n\t// spans maps from virtual address page ID within this arena to *mspan.\n\t// For allocated spans, their pages map to the span itself.\n\t// For free spans, only the lowest and highest pages map to the span itself.\n\t// Internal pages map to an arbitrary span.\n\t// For pages that have never been allocated, spans entries are nil.\n\t//\n\t// Modifications are protected by mheap.lock. Reads can be\n\t// performed without locking, but ONLY from indexes that are\n\t// known to contain in-use or stack spans. This means there\n\t// must not be a safe-point between establishing that an\n\t// address is live and looking it up in the spans array.\n\tspans [pagesPerArena]*mspan\n\n\t// pageInUse is a bitmap that indicates which spans are in\n\t// state mSpanInUse. This bitmap is indexed by page number,\n\t// but only the bit corresponding to the first page in each\n\t// span is used.\n\t//\n\t// Reads and writes are atomic.\n\tpageInUse [pagesPerArena / 8]uint8\n\n\t// pageMarks is a bitmap that indicates which spans have any\n\t// marked objects on them. Like pageInUse, only the bit\n\t// corresponding to the first page in each span is used.\n\t//\n\t// Writes are done atomically during marking. Reads are\n\t// non-atomic and lock-free since they only occur during\n\t// sweeping (and hence never race with writes).\n\t//\n\t// This is used to quickly find whole spans that can be freed.\n\t//\n\t// TODO(austin): It would be nice if this was uint64 for\n\t// faster scanning, but we don't have 64-bit atomic bit\n\t// operations.\n\tpageMarks [pagesPerArena / 8]uint8\n\n\t// pageSpecials is a bitmap that indicates which spans have\n\t// specials (finalizers or other). Like pageInUse, only the bit\n\t// corresponding to the first page in each span is used.\n\t//\n\t// Writes are done atomically whenever a special is added to\n\t// a span and whenever the last special is removed from a span.\n\t// Reads are done atomically to find spans containing specials\n\t// during marking.\n\tpageSpecials [pagesPerArena / 8]uint8\n\n\t// checkmarks stores the debug.gccheckmark state. It is only\n\t// used if debug.gccheckmark > 0.\n\tcheckmarks *checkmarksMap\n\n\t// zeroedBase marks the first byte of the first page in this\n\t// arena which hasn't been used yet and is therefore already\n\t// zero. zeroedBase is relative to the arena base.\n\t// Increases monotonically until it hits heapArenaBytes.\n\t//\n\t// This field is sufficient to determine if an allocation\n\t// needs to be zeroed because the page allocator follows an\n\t// address-ordered first-fit policy.\n\t//\n\t// Read atomically and written with an atomic CAS.\n\tzeroedBase uintptr\n}\n```\n\nA heapArena stores metadata for a heap arena. heapArenas are stored outside of the Go heap and accessed via the mheap_.arenas index. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#pageIndexOf",
                    "documentation": {
                      "identifier": "pageIndexOf",
                      "newPage": false,
                      "searchKey": "runtime.pageIndexOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func pageIndexOf(p uintptr) (arena *heapArena, pageIdx uintptr, pageMask uint8)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc pageIndexOf(p uintptr) (arena *heapArena, pageIdx uintptr, pageMask uint8)\n```\n\npageIndexOf returns the arena, page index, and page mask for pointer p. The caller must ensure p is in the heap. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#arenaHint",
              "documentation": {
                "identifier": "arenaHint",
                "newPage": false,
                "searchKey": "runtime.arenaHint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type arenaHint struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype arenaHint struct {\n\taddr uintptr\n\tdown bool\n\tnext *arenaHint\n}\n```\n\narenaHint is a hint for where to grow the heap arenas. See mheap_.arenaHints. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mSpanState",
              "documentation": {
                "identifier": "mSpanState",
                "newPage": false,
                "searchKey": "runtime.mSpanState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mSpanState uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mSpanState uint8\n```\n\nAn mspan representing actual memory has state mSpanInUse, mSpanManual, or mSpanFree. Transitions between these states are constrained as follows: \n\n* A span may transition from free to in-use or manual during any GC \n\n```\nphase.\n\n```\n* During sweeping (gcphase == _GCoff), a span may transition from \n\n```\nin-use to free (as a result of sweeping) or manual to free (as a\nresult of stacks being freed).\n\n```\n* During GC (gcphase != _GCoff), a span *must not* transition from \n\n```\nmanual or in-use to free. Because concurrent GC may read a pointer\nand then look up its span, the span state must be monotonic.\n\n```\nSetting mspan.state to mSpanInUse or mSpanManual must be done atomically and only after all other span fields are valid. Likewise, if inspecting a span is contingent on it being mSpanInUse, the state should be loaded atomically and checked before depending on other fields. This allows the garbage collector to safely deal with potentially invalid pointers, since resolving such pointers may race with a span being allocated. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mSpanStateBox",
              "documentation": {
                "identifier": "mSpanStateBox",
                "newPage": false,
                "searchKey": "runtime.mSpanStateBox",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mSpanStateBox struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mSpanStateBox struct {\n\ts mSpanState\n}\n```\n\nmSpanStateBox holds an mSpanState and provides atomic operations on it. This is a separate type to disallow accidental comparison or assignment with mSpanState. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#mSpanStateBox.set",
                    "documentation": {
                      "identifier": "mSpanStateBox.set",
                      "newPage": false,
                      "searchKey": "runtime.mSpanStateBox.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *mSpanStateBox) set(s mSpanState)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *mSpanStateBox) set(s mSpanState)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mSpanStateBox.get",
                    "documentation": {
                      "identifier": "mSpanStateBox.get",
                      "newPage": false,
                      "searchKey": "runtime.mSpanStateBox.get",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *mSpanStateBox) get() mSpanState"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *mSpanStateBox) get() mSpanState\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mSpanList",
              "documentation": {
                "identifier": "mSpanList",
                "newPage": false,
                "searchKey": "runtime.mSpanList",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mSpanList struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mSpanList struct {\n\tfirst *mspan // first span in list, or nil if none\n\tlast  *mspan // last span in list, or nil if none\n}\n```\n\nmSpanList heads a linked list of spans. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#mSpanList.init",
                    "documentation": {
                      "identifier": "mSpanList.init",
                      "newPage": false,
                      "searchKey": "runtime.mSpanList.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (list *mSpanList) init()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (list *mSpanList) init()\n```\n\nInitialize an empty doubly-linked list. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mSpanList.remove",
                    "documentation": {
                      "identifier": "mSpanList.remove",
                      "newPage": false,
                      "searchKey": "runtime.mSpanList.remove",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (list *mSpanList) remove(span *mspan)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (list *mSpanList) remove(span *mspan)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mSpanList.isEmpty",
                    "documentation": {
                      "identifier": "mSpanList.isEmpty",
                      "newPage": false,
                      "searchKey": "runtime.mSpanList.isEmpty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (list *mSpanList) isEmpty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (list *mSpanList) isEmpty() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mSpanList.insert",
                    "documentation": {
                      "identifier": "mSpanList.insert",
                      "newPage": false,
                      "searchKey": "runtime.mSpanList.insert",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (list *mSpanList) insert(span *mspan)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (list *mSpanList) insert(span *mspan)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mSpanList.insertBack",
                    "documentation": {
                      "identifier": "mSpanList.insertBack",
                      "newPage": false,
                      "searchKey": "runtime.mSpanList.insertBack",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (list *mSpanList) insertBack(span *mspan)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (list *mSpanList) insertBack(span *mspan)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mSpanList.takeAll",
                    "documentation": {
                      "identifier": "mSpanList.takeAll",
                      "newPage": false,
                      "searchKey": "runtime.mSpanList.takeAll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (list *mSpanList) takeAll(other *mSpanList)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (list *mSpanList) takeAll(other *mSpanList)\n```\n\ntakeAll removes all spans from other and inserts them at the front of list. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mspan",
              "documentation": {
                "identifier": "mspan",
                "newPage": false,
                "searchKey": "runtime.mspan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mspan struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mspan struct {\n\tnext *mspan     // next span in list, or nil if none\n\tprev *mspan     // previous span in list, or nil if none\n\tlist *mSpanList // For debugging. TODO: Remove.\n\n\tstartAddr uintptr // address of first byte of span aka s.base()\n\tnpages    uintptr // number of pages in span\n\n\tmanualFreeList gclinkptr // list of free objects in mSpanManual spans\n\n\t// freeindex is the slot index between 0 and nelems at which to begin scanning\n\t// for the next free object in this span.\n\t// Each allocation scans allocBits starting at freeindex until it encounters a 0\n\t// indicating a free object. freeindex is then adjusted so that subsequent scans begin\n\t// just past the newly discovered free object.\n\t//\n\t// If freeindex == nelem, this span has no free objects.\n\t//\n\t// allocBits is a bitmap of objects in this span.\n\t// If n >= freeindex and allocBits[n/8] & (1<<(n%8)) is 0\n\t// then object n is free;\n\t// otherwise, object n is allocated. Bits starting at nelem are\n\t// undefined and should never be referenced.\n\t//\n\t// Object n starts at address n*elemsize + (start << pageShift).\n\tfreeindex uintptr\n\t// TODO: Look up nelems from sizeclass and remove this field if it\n\t// helps performance.\n\tnelems uintptr // number of object in the span.\n\n\t// Cache of the allocBits at freeindex. allocCache is shifted\n\t// such that the lowest bit corresponds to the bit freeindex.\n\t// allocCache holds the complement of allocBits, thus allowing\n\t// ctz (count trailing zero) to use it directly.\n\t// allocCache may contain bits beyond s.nelems; the caller must ignore\n\t// these.\n\tallocCache uint64\n\n\t// allocBits and gcmarkBits hold pointers to a span's mark and\n\t// allocation bits. The pointers are 8 byte aligned.\n\t// There are three arenas where this data is held.\n\t// free: Dirty arenas that are no longer accessed\n\t//       and can be reused.\n\t// next: Holds information to be used in the next GC cycle.\n\t// current: Information being used during this GC cycle.\n\t// previous: Information being used during the last GC cycle.\n\t// A new GC cycle starts with the call to finishsweep_m.\n\t// finishsweep_m moves the previous arena to the free arena,\n\t// the current arena to the previous arena, and\n\t// the next arena to the current arena.\n\t// The next arena is populated as the spans request\n\t// memory to hold gcmarkBits for the next GC cycle as well\n\t// as allocBits for newly allocated spans.\n\t//\n\t// The pointer arithmetic is done \"by hand\" instead of using\n\t// arrays to avoid bounds checks along critical performance\n\t// paths.\n\t// The sweep will free the old allocBits and set allocBits to the\n\t// gcmarkBits. The gcmarkBits are replaced with a fresh zeroed\n\t// out memory.\n\tallocBits  *gcBits\n\tgcmarkBits *gcBits\n\n\tsweepgen    uint32\n\tdivMul      uint32        // for divide by elemsize\n\tallocCount  uint16        // number of allocated objects\n\tspanclass   spanClass     // size class and noscan (uint8)\n\tstate       mSpanStateBox // mSpanInUse etc; accessed atomically (get/set methods)\n\tneedzero    uint8         // needs to be zeroed before allocation\n\telemsize    uintptr       // computed from sizeclass or from npages\n\tlimit       uintptr       // end of data in span\n\tspeciallock mutex         // guards specials list\n\tspecials    *special      // linked list of special records sorted by offset.\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#findObject",
                    "documentation": {
                      "identifier": "findObject",
                      "newPage": false,
                      "searchKey": "runtime.findObject",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func findObject(p, refBase, refOff uintptr) (base uintptr, s *mspan, objIndex uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc findObject(p, refBase, refOff uintptr) (base uintptr, s *mspan, objIndex uintptr)\n```\n\nfindObject returns the base address for the heap object containing the address p, the object's span, and the index of the object in s. If p does not point into a heap object, it returns base == 0. \n\nIf p points is an invalid heap pointer and debug.invalidptr != 0, findObject panics. \n\nrefBase and refOff optionally give the base address of the object in which the pointer p was found and the byte offset at which it was found. These are used for error reporting. \n\nIt is nosplit so it is safe for p to be a pointer to the current goroutine's stack. Since p is a uintptr, it would not be adjusted if the stack were to move. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#materializeGCProg",
                    "documentation": {
                      "identifier": "materializeGCProg",
                      "newPage": false,
                      "searchKey": "runtime.materializeGCProg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func materializeGCProg(ptrdata uintptr, prog *byte) *mspan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc materializeGCProg(ptrdata uintptr, prog *byte) *mspan\n```\n\nmaterializeGCProg allocates space for the (1-bit) pointer bitmask for an object of size ptrdata.  Then it fills that space with the pointer bitmask specified by the program prog. The bitmask starts at s.startAddr. The result must be deallocated with dematerializeGCProg. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#spanOf",
                    "documentation": {
                      "identifier": "spanOf",
                      "newPage": false,
                      "searchKey": "runtime.spanOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func spanOf(p uintptr) *mspan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc spanOf(p uintptr) *mspan\n```\n\nspanOf returns the span of p. If p does not point into the heap arena or no span has ever contained p, spanOf returns nil. \n\nIf p does not point to allocated memory, this may return a non-nil span that does *not* contain p. If this is a possibility, the caller should either call spanOfHeap or check the span bounds explicitly. \n\nMust be nosplit because it has callers that are nosplit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#spanOfUnchecked",
                    "documentation": {
                      "identifier": "spanOfUnchecked",
                      "newPage": false,
                      "searchKey": "runtime.spanOfUnchecked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func spanOfUnchecked(p uintptr) *mspan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc spanOfUnchecked(p uintptr) *mspan\n```\n\nspanOfUnchecked is equivalent to spanOf, but the caller must ensure that p points into an allocated heap arena. \n\nMust be nosplit because it has callers that are nosplit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#spanOfHeap",
                    "documentation": {
                      "identifier": "spanOfHeap",
                      "newPage": false,
                      "searchKey": "runtime.spanOfHeap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func spanOfHeap(p uintptr) *mspan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc spanOfHeap(p uintptr) *mspan\n```\n\nspanOfHeap is like spanOf, but returns nil if p does not point to a heap object. \n\nMust be nosplit because it has callers that are nosplit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.allocBitsForIndex",
                    "documentation": {
                      "identifier": "mspan.allocBitsForIndex",
                      "newPage": false,
                      "searchKey": "runtime.mspan.allocBitsForIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) allocBitsForIndex(allocBitIndex uintptr) markBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) allocBitsForIndex(allocBitIndex uintptr) markBits\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.refillAllocCache",
                    "documentation": {
                      "identifier": "mspan.refillAllocCache",
                      "newPage": false,
                      "searchKey": "runtime.mspan.refillAllocCache",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) refillAllocCache(whichByte uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) refillAllocCache(whichByte uintptr)\n```\n\nrefillAllocCache takes 8 bytes s.allocBits starting at whichByte and negates them so that ctz (count trailing zeros) instructions can be used. It then places these 8 bytes into the cached 64 bit s.allocCache. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.nextFreeIndex",
                    "documentation": {
                      "identifier": "mspan.nextFreeIndex",
                      "newPage": false,
                      "searchKey": "runtime.mspan.nextFreeIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) nextFreeIndex() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) nextFreeIndex() uintptr\n```\n\nnextFreeIndex returns the index of the next free object in s at or after s.freeindex. There are hardware instructions that can be used to make this faster if profiling warrants it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.isFree",
                    "documentation": {
                      "identifier": "mspan.isFree",
                      "newPage": false,
                      "searchKey": "runtime.mspan.isFree",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) isFree(index uintptr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) isFree(index uintptr) bool\n```\n\nisFree reports whether the index'th object in s is unallocated. \n\nThe caller must ensure s.state is mSpanInUse, and there must have been no preemption points since ensuring this (which could allow a GC transition, which would allow the state to change). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.divideByElemSize",
                    "documentation": {
                      "identifier": "mspan.divideByElemSize",
                      "newPage": false,
                      "searchKey": "runtime.mspan.divideByElemSize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) divideByElemSize(n uintptr) uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) divideByElemSize(n uintptr) uintptr\n```\n\ndivideByElemSize returns n/s.elemsize. n must be within [0, s.npages*_PageSize), or may be exactly s.npages*_PageSize if s.elemsize is from sizeclasses.go. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.objIndex",
                    "documentation": {
                      "identifier": "mspan.objIndex",
                      "newPage": false,
                      "searchKey": "runtime.mspan.objIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) objIndex(p uintptr) uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) objIndex(p uintptr) uintptr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.markBitsForIndex",
                    "documentation": {
                      "identifier": "mspan.markBitsForIndex",
                      "newPage": false,
                      "searchKey": "runtime.mspan.markBitsForIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) markBitsForIndex(objIndex uintptr) markBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) markBitsForIndex(objIndex uintptr) markBits\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.markBitsForBase",
                    "documentation": {
                      "identifier": "mspan.markBitsForBase",
                      "newPage": false,
                      "searchKey": "runtime.mspan.markBitsForBase",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) markBitsForBase() markBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) markBitsForBase() markBits\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.countAlloc",
                    "documentation": {
                      "identifier": "mspan.countAlloc",
                      "newPage": false,
                      "searchKey": "runtime.mspan.countAlloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) countAlloc() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) countAlloc() int\n```\n\ncountAlloc returns the number of objects allocated in span s by scanning the allocation bitmap. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.ensureSwept",
                    "documentation": {
                      "identifier": "mspan.ensureSwept",
                      "newPage": false,
                      "searchKey": "runtime.mspan.ensureSwept",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) ensureSwept()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) ensureSwept()\n```\n\nReturns only when span s has been swept. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.reportZombies",
                    "documentation": {
                      "identifier": "mspan.reportZombies",
                      "newPage": false,
                      "searchKey": "runtime.mspan.reportZombies",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) reportZombies()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) reportZombies()\n```\n\nreportZombies reports any marked but free objects in s and throws. \n\nThis generally means one of the following: \n\n1. User code converted a pointer to a uintptr and then back unsafely, and a GC ran while the uintptr was the only reference to an object. \n\n2. User code (or a compiler bug) constructed a bad pointer that points to a free slot, often a past-the-end pointer. \n\n3. The GC two cycles ago missed a pointer and freed a live object, but it was still live in the last cycle, so this GC cycle found a pointer to that object and marked it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.base",
                    "documentation": {
                      "identifier": "mspan.base",
                      "newPage": false,
                      "searchKey": "runtime.mspan.base",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) base() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) base() uintptr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.layout",
                    "documentation": {
                      "identifier": "mspan.layout",
                      "newPage": false,
                      "searchKey": "runtime.mspan.layout",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *mspan) layout() (size, n, total uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *mspan) layout() (size, n, total uintptr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.init",
                    "documentation": {
                      "identifier": "mspan.init",
                      "newPage": false,
                      "searchKey": "runtime.mspan.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (span *mspan) init(base uintptr, npages uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (span *mspan) init(base uintptr, npages uintptr)\n```\n\nInitialize a new span with the given start and npages. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mspan.inList",
                    "documentation": {
                      "identifier": "mspan.inList",
                      "newPage": false,
                      "searchKey": "runtime.mspan.inList",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (span *mspan) inList() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (span *mspan) inList() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanClass",
              "documentation": {
                "identifier": "spanClass",
                "newPage": false,
                "searchKey": "runtime.spanClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type spanClass uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype spanClass uint8\n```\n\nA spanClass represents the size class and noscan-ness of a span. \n\nEach size class has a noscan spanClass and a scan spanClass. The noscan spanClass contains only noscan objects, which do not contain pointers and thus do not need to be scanned by the garbage collector. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#makeSpanClass",
                    "documentation": {
                      "identifier": "makeSpanClass",
                      "newPage": false,
                      "searchKey": "runtime.makeSpanClass",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeSpanClass(sizeclass uint8, noscan bool) spanClass"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeSpanClass(sizeclass uint8, noscan bool) spanClass\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#spanClass.sizeclass",
                    "documentation": {
                      "identifier": "spanClass.sizeclass",
                      "newPage": false,
                      "searchKey": "runtime.spanClass.sizeclass",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc spanClass) sizeclass() int8"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc spanClass) sizeclass() int8\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#spanClass.noscan",
                    "documentation": {
                      "identifier": "spanClass.noscan",
                      "newPage": false,
                      "searchKey": "runtime.spanClass.noscan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (sc spanClass) noscan() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (sc spanClass) noscan() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#arenaIdx",
              "documentation": {
                "identifier": "arenaIdx",
                "newPage": false,
                "searchKey": "runtime.arenaIdx",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type arenaIdx uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype arenaIdx uint\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#arenaIndex",
                    "documentation": {
                      "identifier": "arenaIndex",
                      "newPage": false,
                      "searchKey": "runtime.arenaIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func arenaIndex(p uintptr) arenaIdx"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc arenaIndex(p uintptr) arenaIdx\n```\n\narenaIndex returns the index into mheap_.arenas of the arena containing metadata for p. This index combines of an index into the L1 map and an index into the L2 map and should be used as mheap_.arenas[ai.l1()][ai.l2()]. \n\nIf p is outside the range of valid heap addresses, either l1() or l2() will be out of bounds. \n\nIt is nosplit because it's called by spanOf and several other nosplit functions. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#arenaIdx.l1",
                    "documentation": {
                      "identifier": "arenaIdx.l1",
                      "newPage": false,
                      "searchKey": "runtime.arenaIdx.l1",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i arenaIdx) l1() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i arenaIdx) l1() uint\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#arenaIdx.l2",
                    "documentation": {
                      "identifier": "arenaIdx.l2",
                      "newPage": false,
                      "searchKey": "runtime.arenaIdx.l2",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i arenaIdx) l2() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i arenaIdx) l2() uint\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanAllocType",
              "documentation": {
                "identifier": "spanAllocType",
                "newPage": false,
                "searchKey": "runtime.spanAllocType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type spanAllocType uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype spanAllocType uint8\n```\n\nspanAllocType represents the type of allocation to make, or the type of allocation to be freed. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#spanAllocType.manual",
                    "documentation": {
                      "identifier": "spanAllocType.manual",
                      "newPage": false,
                      "searchKey": "runtime.spanAllocType.manual",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s spanAllocType) manual() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s spanAllocType) manual() bool\n```\n\nmanual returns true if the span allocation is manually managed. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#special",
              "documentation": {
                "identifier": "special",
                "newPage": false,
                "searchKey": "runtime.special",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type special struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype special struct {\n\tnext   *special // linked list in span\n\toffset uint16   // span offset of object\n\tkind   byte     // kind of special\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#removespecial",
                    "documentation": {
                      "identifier": "removespecial",
                      "newPage": false,
                      "searchKey": "runtime.removespecial",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func removespecial(p unsafe.Pointer, kind uint8) *special"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc removespecial(p unsafe.Pointer, kind uint8) *special\n```\n\nRemoves the Special record of the given kind for the object p. Returns the record if the record existed, nil otherwise. The caller must FixAlloc_Free the result. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#specialfinalizer",
              "documentation": {
                "identifier": "specialfinalizer",
                "newPage": false,
                "searchKey": "runtime.specialfinalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type specialfinalizer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype specialfinalizer struct {\n\tspecial special\n\tfn      *funcval // May be a heap pointer.\n\tnret    uintptr\n\tfint    *_type   // May be a heap pointer, but always live.\n\tot      *ptrtype // May be a heap pointer, but always live.\n}\n```\n\nThe described object has a finalizer set for it. \n\nspecialfinalizer is allocated from non-GC'd memory, so any heap pointers must be specially handled. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#specialprofile",
              "documentation": {
                "identifier": "specialprofile",
                "newPage": false,
                "searchKey": "runtime.specialprofile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type specialprofile struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype specialprofile struct {\n\tspecial special\n\tb       *bucket\n}\n```\n\nThe described object is being heap profiled. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#specialReachable",
              "documentation": {
                "identifier": "specialReachable",
                "newPage": false,
                "searchKey": "runtime.specialReachable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type specialReachable struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype specialReachable struct {\n\tspecial   special\n\tdone      bool\n\treachable bool\n}\n```\n\nspecialReachable tracks whether an object is reachable on the next GC cycle. This is used by testing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#specialsIter",
              "documentation": {
                "identifier": "specialsIter",
                "newPage": false,
                "searchKey": "runtime.specialsIter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type specialsIter struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype specialsIter struct {\n\tpprev **special\n\ts     *special\n}\n```\n\nspecialsIter helps iterate over specials lists. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#newSpecialsIter",
                    "documentation": {
                      "identifier": "newSpecialsIter",
                      "newPage": false,
                      "searchKey": "runtime.newSpecialsIter",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newSpecialsIter(span *mspan) specialsIter"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newSpecialsIter(span *mspan) specialsIter\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#specialsIter.valid",
                    "documentation": {
                      "identifier": "specialsIter.valid",
                      "newPage": false,
                      "searchKey": "runtime.specialsIter.valid",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *specialsIter) valid() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *specialsIter) valid() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#specialsIter.next",
                    "documentation": {
                      "identifier": "specialsIter.next",
                      "newPage": false,
                      "searchKey": "runtime.specialsIter.next",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *specialsIter) next()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *specialsIter) next()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#specialsIter.unlinkAndNext",
                    "documentation": {
                      "identifier": "specialsIter.unlinkAndNext",
                      "newPage": false,
                      "searchKey": "runtime.specialsIter.unlinkAndNext",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i *specialsIter) unlinkAndNext() *special"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i *specialsIter) unlinkAndNext() *special\n```\n\nunlinkAndNext removes the current special from the list and moves the iterator to the next special. It returns the unlinked special. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBits",
              "documentation": {
                "identifier": "gcBits",
                "newPage": false,
                "searchKey": "runtime.gcBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gcBits uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gcBits uint8\n```\n\ngcBits is an alloc/mark bitmap. This is always used as *gcBits. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#newMarkBits",
                    "documentation": {
                      "identifier": "newMarkBits",
                      "newPage": false,
                      "searchKey": "runtime.newMarkBits",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newMarkBits(nelems uintptr) *gcBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newMarkBits(nelems uintptr) *gcBits\n```\n\nnewMarkBits returns a pointer to 8 byte aligned bytes to be used for a span's mark bits. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#newAllocBits",
                    "documentation": {
                      "identifier": "newAllocBits",
                      "newPage": false,
                      "searchKey": "runtime.newAllocBits",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newAllocBits(nelems uintptr) *gcBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newAllocBits(nelems uintptr) *gcBits\n```\n\nnewAllocBits returns a pointer to 8 byte aligned bytes to be used for this span's alloc bits. newAllocBits is used to provide newly initialized spans allocation bits. For spans not being initialized the mark bits are repurposed as allocation bits when the span is swept. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcBits.bytep",
                    "documentation": {
                      "identifier": "gcBits.bytep",
                      "newPage": false,
                      "searchKey": "runtime.gcBits.bytep",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *gcBits) bytep(n uintptr) *uint8"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *gcBits) bytep(n uintptr) *uint8\n```\n\nbytep returns a pointer to the n'th byte of b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcBits.bitp",
                    "documentation": {
                      "identifier": "gcBits.bitp",
                      "newPage": false,
                      "searchKey": "runtime.gcBits.bitp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *gcBits) bitp(n uintptr) (bytep *uint8, mask uint8)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *gcBits) bitp(n uintptr) (bytep *uint8, mask uint8)\n```\n\nbitp returns a pointer to the byte containing bit n and a mask for selecting that bit from *bytep. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBitsHeader",
              "documentation": {
                "identifier": "gcBitsHeader",
                "newPage": false,
                "searchKey": "runtime.gcBitsHeader",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gcBitsHeader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gcBitsHeader struct {\n\tfree uintptr // free is the index into bits of the next free byte.\n\tnext uintptr // *gcBits triggers recursive type bug. (issue 14620)\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBitsArena",
              "documentation": {
                "identifier": "gcBitsArena",
                "newPage": false,
                "searchKey": "runtime.gcBitsArena",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gcBitsArena struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gcBitsArena struct {\n\t// gcBitsHeader // side step recursive type bug (issue 14620) by including fields by hand.\n\tfree uintptr // free is the index into bits of the next free byte; read/write atomically\n\tnext *gcBitsArena\n\tbits [gcBitsChunkBytes - gcBitsHeaderBytes]gcBits\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#newArenaMayUnlock",
                    "documentation": {
                      "identifier": "newArenaMayUnlock",
                      "newPage": false,
                      "searchKey": "runtime.newArenaMayUnlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newArenaMayUnlock() *gcBitsArena"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newArenaMayUnlock() *gcBitsArena\n```\n\nnewArenaMayUnlock allocates and zeroes a gcBits arena. The caller must hold gcBitsArena.lock. This may temporarily release it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gcBitsArena.tryAlloc",
                    "documentation": {
                      "identifier": "gcBitsArena.tryAlloc",
                      "newPage": false,
                      "searchKey": "runtime.gcBitsArena.tryAlloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *gcBitsArena) tryAlloc(bytes uintptr) *gcBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *gcBitsArena) tryAlloc(bytes uintptr) *gcBits\n```\n\ntryAlloc allocates from b or returns nil if b does not have enough room. This is safe to call concurrently. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chunkIdx",
              "documentation": {
                "identifier": "chunkIdx",
                "newPage": false,
                "searchKey": "runtime.chunkIdx",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type chunkIdx uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype chunkIdx uint\n```\n\nGlobal chunk index. \n\nRepresents an index into the leaf level of the radix tree. Similar to arenaIndex, except instead of arenas, it divides the address space into chunks. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#chunkIndex",
                    "documentation": {
                      "identifier": "chunkIndex",
                      "newPage": false,
                      "searchKey": "runtime.chunkIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func chunkIndex(p uintptr) chunkIdx"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc chunkIndex(p uintptr) chunkIdx\n```\n\nchunkIndex returns the global index of the palloc chunk containing the pointer p. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#chunkIdx.l1",
                    "documentation": {
                      "identifier": "chunkIdx.l1",
                      "newPage": false,
                      "searchKey": "runtime.chunkIdx.l1",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i chunkIdx) l1() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i chunkIdx) l1() uint\n```\n\nl1 returns the index into the first level of (*pageAlloc).chunks. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#chunkIdx.l2",
                    "documentation": {
                      "identifier": "chunkIdx.l2",
                      "newPage": false,
                      "searchKey": "runtime.chunkIdx.l2",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i chunkIdx) l2() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i chunkIdx) l2() uint\n```\n\nl2 returns the index into the second level of (*pageAlloc).chunks. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pageAlloc",
              "documentation": {
                "identifier": "pageAlloc",
                "newPage": false,
                "searchKey": "runtime.pageAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pageAlloc struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pageAlloc struct {\n\t// Radix tree of summaries.\n\t//\n\t// Each slice's cap represents the whole memory reservation.\n\t// Each slice's len reflects the allocator's maximum known\n\t// mapped heap address for that level.\n\t//\n\t// The backing store of each summary level is reserved in init\n\t// and may or may not be committed in grow (small address spaces\n\t// may commit all the memory in init).\n\t//\n\t// The purpose of keeping len <= cap is to enforce bounds checks\n\t// on the top end of the slice so that instead of an unknown\n\t// runtime segmentation fault, we get a much friendlier out-of-bounds\n\t// error.\n\t//\n\t// To iterate over a summary level, use inUse to determine which ranges\n\t// are currently available. Otherwise one might try to access\n\t// memory which is only Reserved which may result in a hard fault.\n\t//\n\t// We may still get segmentation faults < len since some of that\n\t// memory may not be committed yet.\n\tsummary [summaryLevels][]pallocSum\n\n\t// chunks is a slice of bitmap chunks.\n\t//\n\t// The total size of chunks is quite large on most 64-bit platforms\n\t// (O(GiB) or more) if flattened, so rather than making one large mapping\n\t// (which has problems on some platforms, even when PROT_NONE) we use a\n\t// two-level sparse array approach similar to the arena index in mheap.\n\t//\n\t// To find the chunk containing a memory address `a`, do:\n\t//   chunkOf(chunkIndex(a))\n\t//\n\t// Below is a table describing the configuration for chunks for various\n\t// heapAddrBits supported by the runtime.\n\t//\n\t// heapAddrBits | L1 Bits | L2 Bits | L2 Entry Size\n\t// ------------------------------------------------\n\t// 32           | 0       | 10      | 128 KiB\n\t// 33 (iOS)     | 0       | 11      | 256 KiB\n\t// 48           | 13      | 13      | 1 MiB\n\t//\n\t// There's no reason to use the L1 part of chunks on 32-bit, the\n\t// address space is small so the L2 is small. For platforms with a\n\t// 48-bit address space, we pick the L1 such that the L2 is 1 MiB\n\t// in size, which is a good balance between low granularity without\n\t// making the impact on BSS too high (note the L1 is stored directly\n\t// in pageAlloc).\n\t//\n\t// To iterate over the bitmap, use inUse to determine which ranges\n\t// are currently available. Otherwise one might iterate over unused\n\t// ranges.\n\t//\n\t// TODO(mknyszek): Consider changing the definition of the bitmap\n\t// such that 1 means free and 0 means in-use so that summaries and\n\t// the bitmaps align better on zero-values.\n\tchunks [1 << pallocChunksL1Bits]*[1 << pallocChunksL2Bits]pallocData\n\n\t// The address to start an allocation search with. It must never\n\t// point to any memory that is not contained in inUse, i.e.\n\t// inUse.contains(searchAddr.addr()) must always be true. The one\n\t// exception to this rule is that it may take on the value of\n\t// maxOffAddr to indicate that the heap is exhausted.\n\t//\n\t// We guarantee that all valid heap addresses below this value\n\t// are allocated and not worth searching.\n\tsearchAddr offAddr\n\n\t// start and end represent the chunk indices\n\t// which pageAlloc knows about. It assumes\n\t// chunks in the range [start, end) are\n\t// currently ready to use.\n\tstart, end chunkIdx\n\n\t// inUse is a slice of ranges of address space which are\n\t// known by the page allocator to be currently in-use (passed\n\t// to grow).\n\t//\n\t// This field is currently unused on 32-bit architectures but\n\t// is harmless to track. We care much more about having a\n\t// contiguous heap in these cases and take additional measures\n\t// to ensure that, so in nearly all cases this should have just\n\t// 1 element.\n\t//\n\t// All access is protected by the mheapLock.\n\tinUse addrRanges\n\n\t// scav stores the scavenger state.\n\t//\n\t// All fields are protected by mheapLock.\n\tscav struct {\n\t\t// inUse is a slice of ranges of address space which have not\n\t\t// yet been looked at by the scavenger.\n\t\tinUse addrRanges\n\n\t\t// gen is the scavenge generation number.\n\t\tgen uint32\n\n\t\t// reservationBytes is how large of a reservation should be made\n\t\t// in bytes of address space for each scavenge iteration.\n\t\treservationBytes uintptr\n\n\t\t// released is the amount of memory released this generation.\n\t\treleased uintptr\n\n\t\t// scavLWM is the lowest (offset) address that the scavenger reached this\n\t\t// scavenge generation.\n\t\tscavLWM offAddr\n\n\t\t// freeHWM is the highest (offset) address of a page that was freed to\n\t\t// the page allocator this scavenge generation.\n\t\tfreeHWM offAddr\n\t}\n\n\t// mheap_.lock. This level of indirection makes it possible\n\t// to test pageAlloc indepedently of the runtime allocator.\n\tmheapLock *mutex\n\n\t// sysStat is the runtime memstat to update when new system\n\t// memory is committed by the pageAlloc for allocation metadata.\n\tsysStat *sysMemStat\n\n\t// Whether or not this struct is being used in tests.\n\ttest bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.scavenge",
                    "documentation": {
                      "identifier": "pageAlloc.scavenge",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.scavenge",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) scavenge(nbytes uintptr, mayUnlock bool) uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) scavenge(nbytes uintptr, mayUnlock bool) uintptr\n```\n\nscavenge scavenges nbytes worth of free pages, starting with the highest address first. Successive calls continue from where it left off until the heap is exhausted. Call scavengeStartGen to bring it back to the top of the heap. \n\nReturns the amount of memory scavenged in bytes. \n\np.mheapLock must be held, but may be temporarily released if mayUnlock == true. \n\nMust run on the system stack because p.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.scavengeStartGen",
                    "documentation": {
                      "identifier": "pageAlloc.scavengeStartGen",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.scavengeStartGen",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) scavengeStartGen()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) scavengeStartGen()\n```\n\nscavengeStartGen starts a new scavenge generation, resetting the scavenger's search space to the full in-use address space. \n\np.mheapLock must be held. \n\nMust run on the system stack because p.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.scavengeReserve",
                    "documentation": {
                      "identifier": "pageAlloc.scavengeReserve",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.scavengeReserve",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) scavengeReserve() (addrRange, uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) scavengeReserve() (addrRange, uint32)\n```\n\nscavengeReserve reserves a contiguous range of the address space for scavenging. The maximum amount of space it reserves is proportional to the size of the heap. The ranges are reserved from the high addresses first. \n\nReturns the reserved range and the scavenge generation number for it. \n\np.mheapLock must be held. \n\nMust run on the system stack because p.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.scavengeUnreserve",
                    "documentation": {
                      "identifier": "pageAlloc.scavengeUnreserve",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.scavengeUnreserve",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) scavengeUnreserve(r addrRange, gen uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) scavengeUnreserve(r addrRange, gen uint32)\n```\n\nscavengeUnreserve returns an unscavenged portion of a range that was previously reserved with scavengeReserve. \n\np.mheapLock must be held. \n\nMust run on the system stack because p.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.scavengeOne",
                    "documentation": {
                      "identifier": "pageAlloc.scavengeOne",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.scavengeOne",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) scavengeOne(work addrRange, max uintptr, mayUnlock bool) (uintptr, addrRange)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) scavengeOne(work addrRange, max uintptr, mayUnlock bool) (uintptr, addrRange)\n```\n\nscavengeOne walks over address range work until it finds a contiguous run of pages to scavenge. It will try to scavenge at most max bytes at once, but may scavenge more to avoid breaking huge pages. Once it scavenges some memory it returns how much it scavenged in bytes. \n\nReturns the number of bytes scavenged and the part of work which was not yet searched. \n\nwork's base address must be aligned to pallocChunkBytes. \n\np.mheapLock must be held, but may be temporarily released if mayUnlock == true. \n\nMust run on the system stack because p.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.scavengeRangeLocked",
                    "documentation": {
                      "identifier": "pageAlloc.scavengeRangeLocked",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.scavengeRangeLocked",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) scavengeRangeLocked(ci chunkIdx, base, npages uint) uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) scavengeRangeLocked(ci chunkIdx, base, npages uint) uintptr\n```\n\nscavengeRangeLocked scavenges the given region of memory. The region of memory is described by its chunk index (ci), the starting page index of the region relative to that chunk (base), and the length of the region in pages (npages). \n\nReturns the base address of the scavenged region. \n\np.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.init",
                    "documentation": {
                      "identifier": "pageAlloc.init",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) init(mheapLock *mutex, sysStat *sysMemStat)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) init(mheapLock *mutex, sysStat *sysMemStat)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.tryChunkOf",
                    "documentation": {
                      "identifier": "pageAlloc.tryChunkOf",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.tryChunkOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) tryChunkOf(ci chunkIdx) *pallocData"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) tryChunkOf(ci chunkIdx) *pallocData\n```\n\ntryChunkOf returns the bitmap data for the given chunk. \n\nReturns nil if the chunk data has not been mapped. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.chunkOf",
                    "documentation": {
                      "identifier": "pageAlloc.chunkOf",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.chunkOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) chunkOf(ci chunkIdx) *pallocData"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) chunkOf(ci chunkIdx) *pallocData\n```\n\nchunkOf returns the chunk at the given chunk index. \n\nThe chunk index must be valid or this method may throw. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.grow",
                    "documentation": {
                      "identifier": "pageAlloc.grow",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.grow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) grow(base, size uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) grow(base, size uintptr)\n```\n\ngrow sets up the metadata for the address range [base, base+size). It may allocate metadata, in which case *p.sysStat will be updated. \n\np.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.update",
                    "documentation": {
                      "identifier": "pageAlloc.update",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.update",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) update(base, npages uintptr, contig, alloc bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) update(base, npages uintptr, contig, alloc bool)\n```\n\nupdate updates heap metadata. It must be called each time the bitmap is updated. \n\nIf contig is true, update does some optimizations assuming that there was a contiguous allocation or free between addr and addr+npages. alloc indicates whether the operation performed was an allocation or a free. \n\np.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.allocRange",
                    "documentation": {
                      "identifier": "pageAlloc.allocRange",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.allocRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) allocRange(base, npages uintptr) uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) allocRange(base, npages uintptr) uintptr\n```\n\nallocRange marks the range of memory [base, base+npages*pageSize) as allocated. It also updates the summaries to reflect the newly-updated bitmap. \n\nReturns the amount of scavenged memory in bytes present in the allocated range. \n\np.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.findMappedAddr",
                    "documentation": {
                      "identifier": "pageAlloc.findMappedAddr",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.findMappedAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) findMappedAddr(addr offAddr) offAddr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) findMappedAddr(addr offAddr) offAddr\n```\n\nfindMappedAddr returns the smallest mapped offAddr that is >= addr. That is, if addr refers to mapped memory, then it is returned. If addr is higher than any mapped region, then it returns maxOffAddr. \n\np.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.find",
                    "documentation": {
                      "identifier": "pageAlloc.find",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.find",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) find(npages uintptr) (uintptr, offAddr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) find(npages uintptr) (uintptr, offAddr)\n```\n\nfind searches for the first (address-ordered) contiguous free region of npages in size and returns a base address for that region. \n\nIt uses p.searchAddr to prune its search and assumes that no palloc chunks below chunkIndex(p.searchAddr) contain any free memory at all. \n\nfind also computes and returns a candidate p.searchAddr, which may or may not prune more of the address space than p.searchAddr already does. This candidate is always a valid p.searchAddr. \n\nfind represents the slow path and the full radix tree search. \n\nReturns a base address of 0 on failure, in which case the candidate searchAddr returned is invalid and must be ignored. \n\np.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.alloc",
                    "documentation": {
                      "identifier": "pageAlloc.alloc",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.alloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) alloc(npages uintptr) (addr uintptr, scav uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) alloc(npages uintptr) (addr uintptr, scav uintptr)\n```\n\nalloc allocates npages worth of memory from the page heap, returning the base address for the allocation and the amount of scavenged memory in bytes contained in the region [base address, base address + npages*pageSize). \n\nReturns a 0 base address on failure, in which case other returned values should be ignored. \n\np.mheapLock must be held. \n\nMust run on the system stack because p.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.free",
                    "documentation": {
                      "identifier": "pageAlloc.free",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.free",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) free(base, npages uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) free(base, npages uintptr)\n```\n\nfree returns npages worth of memory starting at base back to the page heap. \n\np.mheapLock must be held. \n\nMust run on the system stack because p.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.sysInit",
                    "documentation": {
                      "identifier": "pageAlloc.sysInit",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.sysInit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) sysInit()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) sysInit()\n```\n\nsysInit performs architecture-dependent initialization of fields in pageAlloc. pageAlloc should be uninitialized except for sysStat if any runtime statistic should be updated. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.sysGrow",
                    "documentation": {
                      "identifier": "pageAlloc.sysGrow",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.sysGrow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) sysGrow(base, limit uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) sysGrow(base, limit uintptr)\n```\n\nsysGrow performs architecture-dependent operations on heap growth for the page allocator, such as mapping in new memory for summaries. It also updates the length of the slices in [.summary. \n\nbase is the base of the newly-added heap memory and limit is the first address past the end of the newly-added heap memory. Both must be aligned to pallocChunkBytes. \n\nThe caller must update p.start and p.end after calling sysGrow. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageAlloc.allocToCache",
                    "documentation": {
                      "identifier": "pageAlloc.allocToCache",
                      "newPage": false,
                      "searchKey": "runtime.pageAlloc.allocToCache",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *pageAlloc) allocToCache() pageCache"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *pageAlloc) allocToCache() pageCache\n```\n\nallocToCache acquires a pageCachePages-aligned chunk of free pages which may not be contiguous, and returns a pageCache structure which owns the chunk. \n\np.mheapLock must be held. \n\nMust run on the system stack because p.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pallocSum",
              "documentation": {
                "identifier": "pallocSum",
                "newPage": false,
                "searchKey": "runtime.pallocSum",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pallocSum uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pallocSum uint64\n```\n\npallocSum is a packed summary type which packs three numbers: start, max, and end into a single 8-byte value. Each of these values are a summary of a bitmap and are thus counts, each of which may have a maximum value of 2^21 - 1, or all three may be equal to 2^21. The latter case is represented by just setting the 64th bit. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#packPallocSum",
                    "documentation": {
                      "identifier": "packPallocSum",
                      "newPage": false,
                      "searchKey": "runtime.packPallocSum",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func packPallocSum(start, max, end uint) pallocSum"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc packPallocSum(start, max, end uint) pallocSum\n```\n\npackPallocSum takes a start, max, and end value and produces a pallocSum. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mergeSummaries",
                    "documentation": {
                      "identifier": "mergeSummaries",
                      "newPage": false,
                      "searchKey": "runtime.mergeSummaries",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mergeSummaries(sums []pallocSum, logMaxPagesPerSum uint) pallocSum"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mergeSummaries(sums []pallocSum, logMaxPagesPerSum uint) pallocSum\n```\n\nmergeSummaries merges consecutive summaries which may each represent at most 1 << logMaxPagesPerSum pages each together into one. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocSum.start",
                    "documentation": {
                      "identifier": "pallocSum.start",
                      "newPage": false,
                      "searchKey": "runtime.pallocSum.start",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p pallocSum) start() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p pallocSum) start() uint\n```\n\nstart extracts the start value from a packed sum. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocSum.max",
                    "documentation": {
                      "identifier": "pallocSum.max",
                      "newPage": false,
                      "searchKey": "runtime.pallocSum.max",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p pallocSum) max() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p pallocSum) max() uint\n```\n\nmax extracts the max value from a packed sum. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocSum.end",
                    "documentation": {
                      "identifier": "pallocSum.end",
                      "newPage": false,
                      "searchKey": "runtime.pallocSum.end",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p pallocSum) end() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p pallocSum) end() uint\n```\n\nend extracts the end value from a packed sum. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocSum.unpack",
                    "documentation": {
                      "identifier": "pallocSum.unpack",
                      "newPage": false,
                      "searchKey": "runtime.pallocSum.unpack",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p pallocSum) unpack() (uint, uint, uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p pallocSum) unpack() (uint, uint, uint)\n```\n\nunpack unpacks all three values from the summary. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pageCache",
              "documentation": {
                "identifier": "pageCache",
                "newPage": false,
                "searchKey": "runtime.pageCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pageCache struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pageCache struct {\n\tbase  uintptr // base address of the chunk\n\tcache uint64  // 64-bit bitmap representing free pages (1 means free)\n\tscav  uint64  // 64-bit bitmap representing scavenged pages (1 means scavenged)\n}\n```\n\npageCache represents a per-p cache of pages the allocator can allocate from without a lock. More specifically, it represents a pageCachePages*pageSize chunk of memory with 0 or more free pages in it. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#pageCache.empty",
                    "documentation": {
                      "identifier": "pageCache.empty",
                      "newPage": false,
                      "searchKey": "runtime.pageCache.empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *pageCache) empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *pageCache) empty() bool\n```\n\nempty returns true if the pageCache has any free pages, and false otherwise. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageCache.alloc",
                    "documentation": {
                      "identifier": "pageCache.alloc",
                      "newPage": false,
                      "searchKey": "runtime.pageCache.alloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *pageCache) alloc(npages uintptr) (uintptr, uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *pageCache) alloc(npages uintptr) (uintptr, uintptr)\n```\n\nalloc allocates npages from the page cache and is the main entry point for allocation. \n\nReturns a base address and the amount of scavenged memory in the allocated region in bytes. \n\nReturns a base address of zero on failure, in which case the amount of scavenged memory should be ignored. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageCache.allocN",
                    "documentation": {
                      "identifier": "pageCache.allocN",
                      "newPage": false,
                      "searchKey": "runtime.pageCache.allocN",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *pageCache) allocN(npages uintptr) (uintptr, uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *pageCache) allocN(npages uintptr) (uintptr, uintptr)\n```\n\nallocN is a helper which attempts to allocate npages worth of pages from the cache. It represents the general case for allocating from the page cache. \n\nReturns a base address and the amount of scavenged memory in the allocated region in bytes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageCache.flush",
                    "documentation": {
                      "identifier": "pageCache.flush",
                      "newPage": false,
                      "searchKey": "runtime.pageCache.flush",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *pageCache) flush(p *pageAlloc)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *pageCache) flush(p *pageAlloc)\n```\n\nflush empties out unallocated free pages in the given cache into s. Then, it clears the cache, such that empty returns true. \n\np.mheapLock must be held. \n\nMust run on the system stack because p.mheapLock must be held. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pageBits",
              "documentation": {
                "identifier": "pageBits",
                "newPage": false,
                "searchKey": "runtime.pageBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pageBits [8]uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pageBits [pallocChunkPages / 64]uint64\n```\n\npageBits is a bitmap representing one bit per page in a palloc chunk. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#pageBits.get",
                    "documentation": {
                      "identifier": "pageBits.get",
                      "newPage": false,
                      "searchKey": "runtime.pageBits.get",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pageBits) get(i uint) uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pageBits) get(i uint) uint\n```\n\nget returns the value of the i'th bit in the bitmap. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageBits.block64",
                    "documentation": {
                      "identifier": "pageBits.block64",
                      "newPage": false,
                      "searchKey": "runtime.pageBits.block64",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pageBits) block64(i uint) uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pageBits) block64(i uint) uint64\n```\n\nblock64 returns the 64-bit aligned block of bits containing the i'th bit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageBits.set",
                    "documentation": {
                      "identifier": "pageBits.set",
                      "newPage": false,
                      "searchKey": "runtime.pageBits.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pageBits) set(i uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pageBits) set(i uint)\n```\n\nset sets bit i of pageBits. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageBits.setRange",
                    "documentation": {
                      "identifier": "pageBits.setRange",
                      "newPage": false,
                      "searchKey": "runtime.pageBits.setRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pageBits) setRange(i, n uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pageBits) setRange(i, n uint)\n```\n\nsetRange sets bits in the range [i, i+n). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageBits.setAll",
                    "documentation": {
                      "identifier": "pageBits.setAll",
                      "newPage": false,
                      "searchKey": "runtime.pageBits.setAll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pageBits) setAll()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pageBits) setAll()\n```\n\nsetAll sets all the bits of b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageBits.clear",
                    "documentation": {
                      "identifier": "pageBits.clear",
                      "newPage": false,
                      "searchKey": "runtime.pageBits.clear",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pageBits) clear(i uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pageBits) clear(i uint)\n```\n\nclear clears bit i of pageBits. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageBits.clearRange",
                    "documentation": {
                      "identifier": "pageBits.clearRange",
                      "newPage": false,
                      "searchKey": "runtime.pageBits.clearRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pageBits) clearRange(i, n uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pageBits) clearRange(i, n uint)\n```\n\nclearRange clears bits in the range [i, i+n). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageBits.clearAll",
                    "documentation": {
                      "identifier": "pageBits.clearAll",
                      "newPage": false,
                      "searchKey": "runtime.pageBits.clearAll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pageBits) clearAll()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pageBits) clearAll()\n```\n\nclearAll frees all the bits of b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pageBits.popcntRange",
                    "documentation": {
                      "identifier": "pageBits.popcntRange",
                      "newPage": false,
                      "searchKey": "runtime.pageBits.popcntRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pageBits) popcntRange(i, n uint) (s uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pageBits) popcntRange(i, n uint) (s uint)\n```\n\npopcntRange counts the number of set bits in the range [i, i+n). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pallocBits",
              "documentation": {
                "identifier": "pallocBits",
                "newPage": false,
                "searchKey": "runtime.pallocBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pallocBits runtime.pageBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pallocBits pageBits\n```\n\npallocBits is a bitmap that tracks page allocations for at most one palloc chunk. \n\nThe precise representation is an implementation detail, but for the sake of documentation, 0s are free pages and 1s are allocated pages. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#pallocBits.summarize",
                    "documentation": {
                      "identifier": "pallocBits.summarize",
                      "newPage": false,
                      "searchKey": "runtime.pallocBits.summarize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pallocBits) summarize() pallocSum"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pallocBits) summarize() pallocSum\n```\n\nsummarize returns a packed summary of the bitmap in pallocBits. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocBits.find",
                    "documentation": {
                      "identifier": "pallocBits.find",
                      "newPage": false,
                      "searchKey": "runtime.pallocBits.find",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pallocBits) find(npages uintptr, searchIdx uint) (uint, uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pallocBits) find(npages uintptr, searchIdx uint) (uint, uint)\n```\n\nfind searches for npages contiguous free pages in pallocBits and returns the index where that run starts, as well as the index of the first free page it found in the search. searchIdx represents the first known free page and where to begin the next search from. \n\nIf find fails to find any free space, it returns an index of ^uint(0) and the new searchIdx should be ignored. \n\nNote that if npages == 1, the two returned values will always be identical. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocBits.find1",
                    "documentation": {
                      "identifier": "pallocBits.find1",
                      "newPage": false,
                      "searchKey": "runtime.pallocBits.find1",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pallocBits) find1(searchIdx uint) uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pallocBits) find1(searchIdx uint) uint\n```\n\nfind1 is a helper for find which searches for a single free page in the pallocBits and returns the index. \n\nSee find for an explanation of the searchIdx parameter. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocBits.findSmallN",
                    "documentation": {
                      "identifier": "pallocBits.findSmallN",
                      "newPage": false,
                      "searchKey": "runtime.pallocBits.findSmallN",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pallocBits) findSmallN(npages uintptr, searchIdx uint) (uint, uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pallocBits) findSmallN(npages uintptr, searchIdx uint) (uint, uint)\n```\n\nfindSmallN is a helper for find which searches for npages contiguous free pages in this pallocBits and returns the index where that run of contiguous pages starts as well as the index of the first free page it finds in its search. \n\nSee find for an explanation of the searchIdx parameter. \n\nReturns a ^uint(0) index on failure and the new searchIdx should be ignored. \n\nfindSmallN assumes npages <= 64, where any such contiguous run of pages crosses at most one aligned 64-bit boundary in the bits. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocBits.findLargeN",
                    "documentation": {
                      "identifier": "pallocBits.findLargeN",
                      "newPage": false,
                      "searchKey": "runtime.pallocBits.findLargeN",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pallocBits) findLargeN(npages uintptr, searchIdx uint) (uint, uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pallocBits) findLargeN(npages uintptr, searchIdx uint) (uint, uint)\n```\n\nfindLargeN is a helper for find which searches for npages contiguous free pages in this pallocBits and returns the index where that run starts, as well as the index of the first free page it found it its search. \n\nSee alloc for an explanation of the searchIdx parameter. \n\nReturns a ^uint(0) index on failure and the new searchIdx should be ignored. \n\nfindLargeN assumes npages > 64, where any such run of free pages crosses at least one aligned 64-bit boundary in the bits. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocBits.allocRange",
                    "documentation": {
                      "identifier": "pallocBits.allocRange",
                      "newPage": false,
                      "searchKey": "runtime.pallocBits.allocRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pallocBits) allocRange(i, n uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pallocBits) allocRange(i, n uint)\n```\n\nallocRange allocates the range [i, i+n). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocBits.allocAll",
                    "documentation": {
                      "identifier": "pallocBits.allocAll",
                      "newPage": false,
                      "searchKey": "runtime.pallocBits.allocAll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pallocBits) allocAll()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pallocBits) allocAll()\n```\n\nallocAll allocates all the bits of b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocBits.free1",
                    "documentation": {
                      "identifier": "pallocBits.free1",
                      "newPage": false,
                      "searchKey": "runtime.pallocBits.free1",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pallocBits) free1(i uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pallocBits) free1(i uint)\n```\n\nfree1 frees a single page in the pallocBits at i. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocBits.free",
                    "documentation": {
                      "identifier": "pallocBits.free",
                      "newPage": false,
                      "searchKey": "runtime.pallocBits.free",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pallocBits) free(i, n uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pallocBits) free(i, n uint)\n```\n\nfree frees the range [i, i+n) of pages in the pallocBits. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocBits.freeAll",
                    "documentation": {
                      "identifier": "pallocBits.freeAll",
                      "newPage": false,
                      "searchKey": "runtime.pallocBits.freeAll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pallocBits) freeAll()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pallocBits) freeAll()\n```\n\nfreeAll frees all the bits of b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocBits.pages64",
                    "documentation": {
                      "identifier": "pallocBits.pages64",
                      "newPage": false,
                      "searchKey": "runtime.pallocBits.pages64",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *pallocBits) pages64(i uint) uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *pallocBits) pages64(i uint) uint64\n```\n\npages64 returns a 64-bit bitmap representing a block of 64 pages aligned to 64 pages. The returned block of pages is the one containing the i'th page in this pallocBits. Each bit represents whether the page is in-use. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pallocData",
              "documentation": {
                "identifier": "pallocData",
                "newPage": false,
                "searchKey": "runtime.pallocData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pallocData struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pallocData struct {\n\tpallocBits\n\tscavenged pageBits\n}\n```\n\npallocData encapsulates pallocBits and a bitmap for whether or not a given page is scavenged in a single structure. It's effectively a pallocBits with additional functionality. \n\nUpdate the comment on (*pageAlloc).chunks should this structure change. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#pallocData.hasScavengeCandidate",
                    "documentation": {
                      "identifier": "pallocData.hasScavengeCandidate",
                      "newPage": false,
                      "searchKey": "runtime.pallocData.hasScavengeCandidate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *pallocData) hasScavengeCandidate(min uintptr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *pallocData) hasScavengeCandidate(min uintptr) bool\n```\n\nhasScavengeCandidate returns true if there's any min-page-aligned groups of min pages of free-and-unscavenged memory in the region represented by this pallocData. \n\nmin must be a non-zero power of 2 <= maxPagesPerPhysPage. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocData.findScavengeCandidate",
                    "documentation": {
                      "identifier": "pallocData.findScavengeCandidate",
                      "newPage": false,
                      "searchKey": "runtime.pallocData.findScavengeCandidate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *pallocData) findScavengeCandidate(searchIdx uint, min, max uintptr) (uint, uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *pallocData) findScavengeCandidate(searchIdx uint, min, max uintptr) (uint, uint)\n```\n\nfindScavengeCandidate returns a start index and a size for this pallocData segment which represents a contiguous region of free and unscavenged memory. \n\nsearchIdx indicates the page index within this chunk to start the search, but note that findScavengeCandidate searches backwards through the pallocData. As a a result, it will return the highest scavenge candidate in address order. \n\nmin indicates a hard minimum size and alignment for runs of pages. That is, findScavengeCandidate will not return a region smaller than min pages in size, or that is min pages or greater in size but not aligned to min. min must be a non-zero power of 2 <= maxPagesPerPhysPage. \n\nmax is a hint for how big of a region is desired. If max >= pallocChunkPages, then findScavengeCandidate effectively returns entire free and unscavenged regions. If max < pallocChunkPages, it may truncate the returned region such that size is max. However, findScavengeCandidate may still return a larger region if, for example, it chooses to preserve huge pages, or if max is not aligned to min (it will round up). That is, even if max is small, the returned size is not guaranteed to be equal to max. max is allowed to be less than min, in which case it is as if max == min. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocData.allocRange",
                    "documentation": {
                      "identifier": "pallocData.allocRange",
                      "newPage": false,
                      "searchKey": "runtime.pallocData.allocRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *pallocData) allocRange(i, n uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *pallocData) allocRange(i, n uint)\n```\n\nallocRange sets bits [i, i+n) in the bitmap to 1 and updates the scavenged bits appropriately. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pallocData.allocAll",
                    "documentation": {
                      "identifier": "pallocData.allocAll",
                      "newPage": false,
                      "searchKey": "runtime.pallocData.allocAll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *pallocData) allocAll()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *pallocData) allocAll()\n```\n\nallocAll sets every bit in the bitmap to 1 and updates the scavenged bits appropriately. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bucketType",
              "documentation": {
                "identifier": "bucketType",
                "newPage": false,
                "searchKey": "runtime.bucketType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type bucketType int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bucketType int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bucket",
              "documentation": {
                "identifier": "bucket",
                "newPage": false,
                "searchKey": "runtime.bucket",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type bucket struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bucket struct {\n\tnext    *bucket\n\tallnext *bucket\n\ttyp     bucketType // memBucket or blockBucket (includes mutexProfile)\n\thash    uintptr\n\tsize    uintptr\n\tnstk    uintptr\n}\n```\n\nA bucket holds per-call-stack profiling information. The representation is a bit sleazy, inherited from C. This struct defines the bucket header. It is followed in memory by the stack words and then the actual record data, either a memRecord or a blockRecord. \n\nPer-call-stack profiling information. Lookup by hashing call stack into a linked-list hash table. \n\nNo heap pointers. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#newBucket",
                    "documentation": {
                      "identifier": "newBucket",
                      "newPage": false,
                      "searchKey": "runtime.newBucket",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newBucket(typ bucketType, nstk int) *bucket"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newBucket(typ bucketType, nstk int) *bucket\n```\n\nnewBucket allocates a bucket with the given type and number of stack entries. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#stkbucket",
                    "documentation": {
                      "identifier": "stkbucket",
                      "newPage": false,
                      "searchKey": "runtime.stkbucket",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func stkbucket(typ bucketType, size uintptr, stk []uintptr, alloc bool) *bucket"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc stkbucket(typ bucketType, size uintptr, stk []uintptr, alloc bool) *bucket\n```\n\nReturn the bucket for stk[0:nstk], allocating new bucket if needed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#bucket.stk",
                    "documentation": {
                      "identifier": "bucket.stk",
                      "newPage": false,
                      "searchKey": "runtime.bucket.stk",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *bucket) stk() []uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *bucket) stk() []uintptr\n```\n\nstk returns the slice in b holding the stack. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#bucket.mp",
                    "documentation": {
                      "identifier": "bucket.mp",
                      "newPage": false,
                      "searchKey": "runtime.bucket.mp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *bucket) mp() *memRecord"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *bucket) mp() *memRecord\n```\n\nmp returns the memRecord associated with the memProfile bucket b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#bucket.bp",
                    "documentation": {
                      "identifier": "bucket.bp",
                      "newPage": false,
                      "searchKey": "runtime.bucket.bp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *bucket) bp() *blockRecord"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *bucket) bp() *blockRecord\n```\n\nbp returns the blockRecord associated with the blockProfile bucket b. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memRecord",
              "documentation": {
                "identifier": "memRecord",
                "newPage": false,
                "searchKey": "runtime.memRecord",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type memRecord struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype memRecord struct {\n\n\t// active is the currently published profile. A profiling\n\t// cycle can be accumulated into active once its complete.\n\tactive memRecordCycle\n\n\t// future records the profile events we're counting for cycles\n\t// that have not yet been published. This is ring buffer\n\t// indexed by the global heap profile cycle C and stores\n\t// cycles C, C+1, and C+2. Unlike active, these counts are\n\t// only for a single cycle; they are not cumulative across\n\t// cycles.\n\t//\n\t// We store cycle C here because there's a window between when\n\t// C becomes the active cycle and when we've flushed it to\n\t// active.\n\tfuture [3]memRecordCycle\n}\n```\n\nA memRecord is the bucket data for a bucket of type memProfile, part of the memory profile. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memRecordCycle",
              "documentation": {
                "identifier": "memRecordCycle",
                "newPage": false,
                "searchKey": "runtime.memRecordCycle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type memRecordCycle struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype memRecordCycle struct {\n\tallocs, frees           uintptr\n\talloc_bytes, free_bytes uintptr\n}\n```\n\nmemRecordCycle \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#memRecordCycle.add",
                    "documentation": {
                      "identifier": "memRecordCycle.add",
                      "newPage": false,
                      "searchKey": "runtime.memRecordCycle.add",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *memRecordCycle) add(b *memRecordCycle)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *memRecordCycle) add(b *memRecordCycle)\n```\n\nadd accumulates b into a. It does not zero b. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#blockRecord",
              "documentation": {
                "identifier": "blockRecord",
                "newPage": false,
                "searchKey": "runtime.blockRecord",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type blockRecord struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype blockRecord struct {\n\tcount  float64\n\tcycles int64\n}\n```\n\nA blockRecord is the bucket data for a bucket of type blockProfile, which is used in blocking and mutex profiles. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#StackRecord",
              "documentation": {
                "identifier": "StackRecord",
                "newPage": false,
                "searchKey": "runtime.StackRecord",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type StackRecord struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype StackRecord struct {\n\tStack0 [32]uintptr // stack trace for this record; ends at first 0 entry\n}\n```\n\nA StackRecord describes a single execution stack. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#StackRecord.Stack",
                    "documentation": {
                      "identifier": "StackRecord.Stack",
                      "newPage": false,
                      "searchKey": "runtime.StackRecord.Stack",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *StackRecord) Stack() []uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *StackRecord) Stack() []uintptr\n```\n\nStack returns the stack trace associated with the record, a prefix of r.Stack0. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MemProfileRecord",
              "documentation": {
                "identifier": "MemProfileRecord",
                "newPage": false,
                "searchKey": "runtime.MemProfileRecord",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type MemProfileRecord struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype MemProfileRecord struct {\n\tAllocBytes, FreeBytes     int64       // number of bytes allocated, freed\n\tAllocObjects, FreeObjects int64       // number of objects allocated, freed\n\tStack0                    [32]uintptr // stack trace for this record; ends at first 0 entry\n}\n```\n\nA MemProfileRecord describes the live objects allocated by a particular call sequence (stack trace). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#MemProfileRecord.InUseBytes",
                    "documentation": {
                      "identifier": "MemProfileRecord.InUseBytes",
                      "newPage": false,
                      "searchKey": "runtime.MemProfileRecord.InUseBytes",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *MemProfileRecord) InUseBytes() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *MemProfileRecord) InUseBytes() int64\n```\n\nInUseBytes returns the number of bytes in use (AllocBytes - FreeBytes). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#MemProfileRecord.InUseObjects",
                    "documentation": {
                      "identifier": "MemProfileRecord.InUseObjects",
                      "newPage": false,
                      "searchKey": "runtime.MemProfileRecord.InUseObjects",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *MemProfileRecord) InUseObjects() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *MemProfileRecord) InUseObjects() int64\n```\n\nInUseObjects returns the number of objects in use (AllocObjects - FreeObjects). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#MemProfileRecord.Stack",
                    "documentation": {
                      "identifier": "MemProfileRecord.Stack",
                      "newPage": false,
                      "searchKey": "runtime.MemProfileRecord.Stack",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *MemProfileRecord) Stack() []uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *MemProfileRecord) Stack() []uintptr\n```\n\nStack returns the stack trace associated with the record, a prefix of r.Stack0. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#BlockProfileRecord",
              "documentation": {
                "identifier": "BlockProfileRecord",
                "newPage": false,
                "searchKey": "runtime.BlockProfileRecord",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type BlockProfileRecord struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype BlockProfileRecord struct {\n\tCount  int64\n\tCycles int64\n\tStackRecord\n}\n```\n\nBlockProfileRecord describes blocking events originated at a particular call sequence (stack trace). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#addrRange",
              "documentation": {
                "identifier": "addrRange",
                "newPage": false,
                "searchKey": "runtime.addrRange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type addrRange struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype addrRange struct {\n\t// base and limit together represent the region of address space\n\t// [base, limit). That is, base is inclusive, limit is exclusive.\n\t// These are address over an offset view of the address space on\n\t// platforms with a segmented address space, that is, on platforms\n\t// where arenaBaseOffset != 0.\n\tbase, limit offAddr\n}\n```\n\naddrRange represents a region of address space. \n\nAn addrRange must never span a gap in the address space. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#makeAddrRange",
                    "documentation": {
                      "identifier": "makeAddrRange",
                      "newPage": false,
                      "searchKey": "runtime.makeAddrRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeAddrRange(base, limit uintptr) addrRange"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeAddrRange(base, limit uintptr) addrRange\n```\n\nmakeAddrRange creates a new address range from two virtual addresses. \n\nThrows if the base and limit are not in the same memory segment. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#addrRange.size",
                    "documentation": {
                      "identifier": "addrRange.size",
                      "newPage": false,
                      "searchKey": "runtime.addrRange.size",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a addrRange) size() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a addrRange) size() uintptr\n```\n\nsize returns the size of the range represented in bytes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#addrRange.contains",
                    "documentation": {
                      "identifier": "addrRange.contains",
                      "newPage": false,
                      "searchKey": "runtime.addrRange.contains",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a addrRange) contains(addr uintptr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a addrRange) contains(addr uintptr) bool\n```\n\ncontains returns whether or not the range contains a given address. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#addrRange.subtract",
                    "documentation": {
                      "identifier": "addrRange.subtract",
                      "newPage": false,
                      "searchKey": "runtime.addrRange.subtract",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a addrRange) subtract(b addrRange) addrRange"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a addrRange) subtract(b addrRange) addrRange\n```\n\nsubtract takes the addrRange toPrune and cuts out any overlap with from, then returns the new range. subtract assumes that a and b either don't overlap at all, only overlap on one side, or are equal. If b is strictly contained in a, thus forcing a split, it will throw. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#addrRange.removeGreaterEqual",
                    "documentation": {
                      "identifier": "addrRange.removeGreaterEqual",
                      "newPage": false,
                      "searchKey": "runtime.addrRange.removeGreaterEqual",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a addrRange) removeGreaterEqual(addr uintptr) addrRange"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a addrRange) removeGreaterEqual(addr uintptr) addrRange\n```\n\nremoveGreaterEqual removes all addresses in a greater than or equal to addr and returns the new range. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#offAddr",
              "documentation": {
                "identifier": "offAddr",
                "newPage": false,
                "searchKey": "runtime.offAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type offAddr struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype offAddr struct {\n\t// a is just the virtual address, but should never be used\n\t// directly. Call addr() to get this value instead.\n\ta uintptr\n}\n```\n\noffAddr represents an address in a contiguous view of the address space on systems where the address space is segmented. On other systems, it's just a normal address. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#levelIndexToOffAddr",
                    "documentation": {
                      "identifier": "levelIndexToOffAddr",
                      "newPage": false,
                      "searchKey": "runtime.levelIndexToOffAddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func levelIndexToOffAddr(level, idx int) offAddr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc levelIndexToOffAddr(level, idx int) offAddr\n```\n\nlevelIndexToOffAddr converts an index into summary[level] into the corresponding address in the offset address space. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#offAddr.add",
                    "documentation": {
                      "identifier": "offAddr.add",
                      "newPage": false,
                      "searchKey": "runtime.offAddr.add",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l offAddr) add(bytes uintptr) offAddr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l offAddr) add(bytes uintptr) offAddr\n```\n\nadd adds a uintptr offset to the offAddr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#offAddr.sub",
                    "documentation": {
                      "identifier": "offAddr.sub",
                      "newPage": false,
                      "searchKey": "runtime.offAddr.sub",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l offAddr) sub(bytes uintptr) offAddr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l offAddr) sub(bytes uintptr) offAddr\n```\n\nsub subtracts a uintptr offset from the offAddr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#offAddr.diff",
                    "documentation": {
                      "identifier": "offAddr.diff",
                      "newPage": false,
                      "searchKey": "runtime.offAddr.diff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l1 offAddr) diff(l2 offAddr) uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l1 offAddr) diff(l2 offAddr) uintptr\n```\n\ndiff returns the amount of bytes in between the two offAddrs. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#offAddr.lessThan",
                    "documentation": {
                      "identifier": "offAddr.lessThan",
                      "newPage": false,
                      "searchKey": "runtime.offAddr.lessThan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l1 offAddr) lessThan(l2 offAddr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l1 offAddr) lessThan(l2 offAddr) bool\n```\n\nlessThan returns true if l1 is less than l2 in the offset address space. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#offAddr.lessEqual",
                    "documentation": {
                      "identifier": "offAddr.lessEqual",
                      "newPage": false,
                      "searchKey": "runtime.offAddr.lessEqual",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l1 offAddr) lessEqual(l2 offAddr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l1 offAddr) lessEqual(l2 offAddr) bool\n```\n\nlessEqual returns true if l1 is less than or equal to l2 in the offset address space. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#offAddr.equal",
                    "documentation": {
                      "identifier": "offAddr.equal",
                      "newPage": false,
                      "searchKey": "runtime.offAddr.equal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l1 offAddr) equal(l2 offAddr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l1 offAddr) equal(l2 offAddr) bool\n```\n\nequal returns true if the two offAddr values are equal. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#offAddr.addr",
                    "documentation": {
                      "identifier": "offAddr.addr",
                      "newPage": false,
                      "searchKey": "runtime.offAddr.addr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l offAddr) addr() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l offAddr) addr() uintptr\n```\n\naddr returns the virtual address for this offset address. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#addrRanges",
              "documentation": {
                "identifier": "addrRanges",
                "newPage": false,
                "searchKey": "runtime.addrRanges",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type addrRanges struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype addrRanges struct {\n\t// ranges is a slice of ranges sorted by base.\n\tranges []addrRange\n\n\t// totalBytes is the total amount of address space in bytes counted by\n\t// this addrRanges.\n\ttotalBytes uintptr\n\n\t// sysStat is the stat to track allocations by this type\n\tsysStat *sysMemStat\n}\n```\n\naddrRanges is a data structure holding a collection of ranges of address space. \n\nThe ranges are coalesced eagerly to reduce the number ranges it holds. \n\nThe slice backing store for this field is persistentalloc'd and thus there is no way to free it. \n\naddrRanges is not thread-safe. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#addrRanges.init",
                    "documentation": {
                      "identifier": "addrRanges.init",
                      "newPage": false,
                      "searchKey": "runtime.addrRanges.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *addrRanges) init(sysStat *sysMemStat)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *addrRanges) init(sysStat *sysMemStat)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#addrRanges.findSucc",
                    "documentation": {
                      "identifier": "addrRanges.findSucc",
                      "newPage": false,
                      "searchKey": "runtime.addrRanges.findSucc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *addrRanges) findSucc(addr uintptr) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *addrRanges) findSucc(addr uintptr) int\n```\n\nfindSucc returns the first index in a such that addr is less than the base of the addrRange at that index. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#addrRanges.findAddrGreaterEqual",
                    "documentation": {
                      "identifier": "addrRanges.findAddrGreaterEqual",
                      "newPage": false,
                      "searchKey": "runtime.addrRanges.findAddrGreaterEqual",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *addrRanges) findAddrGreaterEqual(addr uintptr) (uintptr, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *addrRanges) findAddrGreaterEqual(addr uintptr) (uintptr, bool)\n```\n\nfindAddrGreaterEqual returns the smallest address represented by a that is >= addr. Thus, if the address is represented by a, then it returns addr. The second return value indicates whether such an address exists for addr in a. That is, if addr is larger than any address known to a, the second return value will be false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#addrRanges.contains",
                    "documentation": {
                      "identifier": "addrRanges.contains",
                      "newPage": false,
                      "searchKey": "runtime.addrRanges.contains",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *addrRanges) contains(addr uintptr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *addrRanges) contains(addr uintptr) bool\n```\n\ncontains returns true if a covers the address addr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#addrRanges.add",
                    "documentation": {
                      "identifier": "addrRanges.add",
                      "newPage": false,
                      "searchKey": "runtime.addrRanges.add",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *addrRanges) add(r addrRange)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *addrRanges) add(r addrRange)\n```\n\nadd inserts a new address range to a. \n\nr must not overlap with any address range in a and r.size() must be > 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#addrRanges.removeLast",
                    "documentation": {
                      "identifier": "addrRanges.removeLast",
                      "newPage": false,
                      "searchKey": "runtime.addrRanges.removeLast",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *addrRanges) removeLast(nBytes uintptr) addrRange"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *addrRanges) removeLast(nBytes uintptr) addrRange\n```\n\nremoveLast removes and returns the highest-addressed contiguous range of a, or the last nBytes of that range, whichever is smaller. If a is empty, it returns an empty range. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#addrRanges.removeGreaterEqual",
                    "documentation": {
                      "identifier": "addrRanges.removeGreaterEqual",
                      "newPage": false,
                      "searchKey": "runtime.addrRanges.removeGreaterEqual",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *addrRanges) removeGreaterEqual(addr uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *addrRanges) removeGreaterEqual(addr uintptr)\n```\n\nremoveGreaterEqual removes the ranges of a which are above addr, and additionally splits any range containing addr. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#addrRanges.cloneInto",
                    "documentation": {
                      "identifier": "addrRanges.cloneInto",
                      "newPage": false,
                      "searchKey": "runtime.addrRanges.cloneInto",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *addrRanges) cloneInto(b *addrRanges)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *addrRanges) cloneInto(b *addrRanges)\n```\n\ncloneInto makes a deep clone of a's state into b, re-using b's ranges if able. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanSet",
              "documentation": {
                "identifier": "spanSet",
                "newPage": false,
                "searchKey": "runtime.spanSet",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type spanSet struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype spanSet struct {\n\tspineLock mutex\n\tspine     unsafe.Pointer // *[N]*spanSetBlock, accessed atomically\n\tspineLen  uintptr        // Spine array length, accessed atomically\n\tspineCap  uintptr        // Spine array cap, accessed under lock\n\n\t// index is the head and tail of the spanSet in a single field.\n\t// The head and the tail both represent an index into the logical\n\t// concatenation of all blocks, with the head always behind or\n\t// equal to the tail (indicating an empty set). This field is\n\t// always accessed atomically.\n\t//\n\t// The head and the tail are only 32 bits wide, which means we\n\t// can only support up to 2^32 pushes before a reset. If every\n\t// span in the heap were stored in this set, and each span were\n\t// the minimum size (1 runtime page, 8 KiB), then roughly the\n\t// smallest heap which would be unrepresentable is 32 TiB in size.\n\tindex headTailIndex\n}\n```\n\nA spanSet is a set of *mspans. \n\nspanSet is safe for concurrent push and pop operations. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#spanSet.push",
                    "documentation": {
                      "identifier": "spanSet.push",
                      "newPage": false,
                      "searchKey": "runtime.spanSet.push",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *spanSet) push(s *mspan)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *spanSet) push(s *mspan)\n```\n\npush adds span s to buffer b. push is safe to call concurrently with other push and pop operations. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#spanSet.pop",
                    "documentation": {
                      "identifier": "spanSet.pop",
                      "newPage": false,
                      "searchKey": "runtime.spanSet.pop",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *spanSet) pop() *mspan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *spanSet) pop() *mspan\n```\n\npop removes and returns a span from buffer b, or nil if b is empty. pop is safe to call concurrently with other pop and push operations. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#spanSet.reset",
                    "documentation": {
                      "identifier": "spanSet.reset",
                      "newPage": false,
                      "searchKey": "runtime.spanSet.reset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *spanSet) reset()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *spanSet) reset()\n```\n\nreset resets a spanSet which is empty. It will also clean up any left over blocks. \n\nThrows if the buf is not empty. \n\nreset may not be called concurrently with any other operations on the span set. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanSetBlock",
              "documentation": {
                "identifier": "spanSetBlock",
                "newPage": false,
                "searchKey": "runtime.spanSetBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type spanSetBlock struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype spanSetBlock struct {\n\t// Free spanSetBlocks are managed via a lock-free stack.\n\tlfnode\n\n\t// popped is the number of pop operations that have occurred on\n\t// this block. This number is used to help determine when a block\n\t// may be safely recycled.\n\tpopped uint32\n\n\t// spans is the set of spans in this block.\n\tspans [spanSetBlockEntries]*mspan\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanSetBlockAlloc",
              "documentation": {
                "identifier": "spanSetBlockAlloc",
                "newPage": false,
                "searchKey": "runtime.spanSetBlockAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type spanSetBlockAlloc struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype spanSetBlockAlloc struct {\n\tstack lfstack\n}\n```\n\nspanSetBlockAlloc represents a concurrent pool of spanSetBlocks. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#spanSetBlockAlloc.alloc",
                    "documentation": {
                      "identifier": "spanSetBlockAlloc.alloc",
                      "newPage": false,
                      "searchKey": "runtime.spanSetBlockAlloc.alloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *spanSetBlockAlloc) alloc() *spanSetBlock"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *spanSetBlockAlloc) alloc() *spanSetBlock\n```\n\nalloc tries to grab a spanSetBlock out of the pool, and if it fails persistentallocs a new one and returns it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#spanSetBlockAlloc.free",
                    "documentation": {
                      "identifier": "spanSetBlockAlloc.free",
                      "newPage": false,
                      "searchKey": "runtime.spanSetBlockAlloc.free",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *spanSetBlockAlloc) free(block *spanSetBlock)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *spanSetBlockAlloc) free(block *spanSetBlock)\n```\n\nfree returns a spanSetBlock back to the pool. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#headTailIndex",
              "documentation": {
                "identifier": "headTailIndex",
                "newPage": false,
                "searchKey": "runtime.headTailIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type headTailIndex uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype headTailIndex uint64\n```\n\nhaidTailIndex represents a combined 32-bit head and 32-bit tail of a queue into a single 64-bit value. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#makeHeadTailIndex",
                    "documentation": {
                      "identifier": "makeHeadTailIndex",
                      "newPage": false,
                      "searchKey": "runtime.makeHeadTailIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeHeadTailIndex(head, tail uint32) headTailIndex"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeHeadTailIndex(head, tail uint32) headTailIndex\n```\n\nmakeHeadTailIndex creates a headTailIndex value from a separate head and tail. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#headTailIndex.head",
                    "documentation": {
                      "identifier": "headTailIndex.head",
                      "newPage": false,
                      "searchKey": "runtime.headTailIndex.head",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h headTailIndex) head() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h headTailIndex) head() uint32\n```\n\nhead returns the head of a headTailIndex value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#headTailIndex.tail",
                    "documentation": {
                      "identifier": "headTailIndex.tail",
                      "newPage": false,
                      "searchKey": "runtime.headTailIndex.tail",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h headTailIndex) tail() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h headTailIndex) tail() uint32\n```\n\ntail returns the tail of a headTailIndex value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#headTailIndex.split",
                    "documentation": {
                      "identifier": "headTailIndex.split",
                      "newPage": false,
                      "searchKey": "runtime.headTailIndex.split",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h headTailIndex) split() (head uint32, tail uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h headTailIndex) split() (head uint32, tail uint32)\n```\n\nsplit splits the headTailIndex value into its parts. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#headTailIndex.load",
                    "documentation": {
                      "identifier": "headTailIndex.load",
                      "newPage": false,
                      "searchKey": "runtime.headTailIndex.load",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headTailIndex) load() headTailIndex"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headTailIndex) load() headTailIndex\n```\n\nload atomically reads a headTailIndex value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#headTailIndex.cas",
                    "documentation": {
                      "identifier": "headTailIndex.cas",
                      "newPage": false,
                      "searchKey": "runtime.headTailIndex.cas",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headTailIndex) cas(old, new headTailIndex) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headTailIndex) cas(old, new headTailIndex) bool\n```\n\ncas atomically compares-and-swaps a headTailIndex value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#headTailIndex.incHead",
                    "documentation": {
                      "identifier": "headTailIndex.incHead",
                      "newPage": false,
                      "searchKey": "runtime.headTailIndex.incHead",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headTailIndex) incHead() headTailIndex"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headTailIndex) incHead() headTailIndex\n```\n\nincHead atomically increments the head of a headTailIndex. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#headTailIndex.decHead",
                    "documentation": {
                      "identifier": "headTailIndex.decHead",
                      "newPage": false,
                      "searchKey": "runtime.headTailIndex.decHead",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headTailIndex) decHead() headTailIndex"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headTailIndex) decHead() headTailIndex\n```\n\ndecHead atomically decrements the head of a headTailIndex. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#headTailIndex.incTail",
                    "documentation": {
                      "identifier": "headTailIndex.incTail",
                      "newPage": false,
                      "searchKey": "runtime.headTailIndex.incTail",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headTailIndex) incTail() headTailIndex"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headTailIndex) incTail() headTailIndex\n```\n\nincTail atomically increments the tail of a headTailIndex. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#headTailIndex.reset",
                    "documentation": {
                      "identifier": "headTailIndex.reset",
                      "newPage": false,
                      "searchKey": "runtime.headTailIndex.reset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (h *headTailIndex) reset()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (h *headTailIndex) reset()\n```\n\nreset clears the headTailIndex to (0, 0). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mstats",
              "documentation": {
                "identifier": "mstats",
                "newPage": false,
                "searchKey": "runtime.mstats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mstats struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mstats struct {\n\t// General statistics.\n\talloc       uint64 // bytes allocated and not yet freed\n\ttotal_alloc uint64 // bytes allocated (even if freed)\n\tsys         uint64 // bytes obtained from system (should be sum of xxx_sys below, no locking, approximate)\n\tnlookup     uint64 // number of pointer lookups (unused)\n\tnmalloc     uint64 // number of mallocs\n\tnfree       uint64 // number of frees\n\n\t// Statistics about malloc heap.\n\t// Updated atomically, or with the world stopped.\n\t//\n\t// Like MemStats, heap_sys and heap_inuse do not count memory\n\t// in manually-managed spans.\n\theap_sys      sysMemStat // virtual address space obtained from system for GC'd heap\n\theap_inuse    uint64     // bytes in mSpanInUse spans\n\theap_released uint64     // bytes released to the os\n\n\t// heap_objects is not used by the runtime directly and instead\n\t// computed on the fly by updatememstats.\n\theap_objects uint64 // total number of allocated objects\n\n\t// Statistics about stacks.\n\tstacks_inuse uint64     // bytes in manually-managed stack spans; computed by updatememstats\n\tstacks_sys   sysMemStat // only counts newosproc0 stack in mstats; differs from MemStats.StackSys\n\n\t// Statistics about allocation of low-level fixed-size structures.\n\t// Protected by FixAlloc locks.\n\tmspan_inuse  uint64 // mspan structures\n\tmspan_sys    sysMemStat\n\tmcache_inuse uint64 // mcache structures\n\tmcache_sys   sysMemStat\n\tbuckhash_sys sysMemStat // profiling bucket hash table\n\n\t// Statistics about GC overhead.\n\tgcWorkBufInUse           uint64     // computed by updatememstats\n\tgcProgPtrScalarBitsInUse uint64     // computed by updatememstats\n\tgcMiscSys                sysMemStat // updated atomically or during STW\n\n\t// Miscellaneous statistics.\n\tother_sys sysMemStat // updated atomically or during STW\n\n\t// Protected by mheap or stopping the world during GC.\n\tlast_gc_unix    uint64 // last gc (in unix time)\n\tpause_total_ns  uint64\n\tpause_ns        [256]uint64 // circular buffer of recent gc pause lengths\n\tpause_end       [256]uint64 // circular buffer of recent gc end times (nanoseconds since 1970)\n\tnumgc           uint32\n\tnumforcedgc     uint32  // number of user-forced GCs\n\tgc_cpu_fraction float64 // fraction of CPU time used by GC\n\tenablegc        bool\n\tdebuggc         bool\n\n\tby_size [_NumSizeClasses]struct {\n\t\tsize    uint32\n\t\tnmalloc uint64\n\t\tnfree   uint64\n\t}\n\n\t// Add an uint32 for even number of size classes to align below fields\n\t// to 64 bits for atomic operations on 32 bit platforms.\n\t_ [1 - _NumSizeClasses%2]uint32\n\n\tlast_gc_nanotime uint64 // last gc (monotonic time)\n\tlast_heap_inuse  uint64 // heap_inuse at mark termination of the previous GC\n\n\t// heapStats is a set of statistics\n\theapStats consistentHeapStats\n\n\t// gcPauseDist represents the distribution of all GC-related\n\t// application pauses in the runtime.\n\t//\n\t// Each individual pause is counted separately, unlike pause_ns.\n\tgcPauseDist timeHistogram\n}\n```\n\nStatistics. \n\nFor detailed descriptions see the documentation for MemStats. Fields that differ from MemStats are further documented here. \n\nMany of these fields are updated on the fly, while others are only updated when updatememstats is called. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MemStats",
              "documentation": {
                "identifier": "MemStats",
                "newPage": false,
                "searchKey": "runtime.MemStats",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type MemStats struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype MemStats struct {\n\n\t// Alloc is bytes of allocated heap objects.\n\t//\n\t// This is the same as HeapAlloc (see below).\n\tAlloc uint64\n\n\t// TotalAlloc is cumulative bytes allocated for heap objects.\n\t//\n\t// TotalAlloc increases as heap objects are allocated, but\n\t// unlike Alloc and HeapAlloc, it does not decrease when\n\t// objects are freed.\n\tTotalAlloc uint64\n\n\t// Sys is the total bytes of memory obtained from the OS.\n\t//\n\t// Sys is the sum of the XSys fields below. Sys measures the\n\t// virtual address space reserved by the Go runtime for the\n\t// heap, stacks, and other internal data structures. It's\n\t// likely that not all of the virtual address space is backed\n\t// by physical memory at any given moment, though in general\n\t// it all was at some point.\n\tSys uint64\n\n\t// Lookups is the number of pointer lookups performed by the\n\t// runtime.\n\t//\n\t// This is primarily useful for debugging runtime internals.\n\tLookups uint64\n\n\t// Mallocs is the cumulative count of heap objects allocated.\n\t// The number of live objects is Mallocs - Frees.\n\tMallocs uint64\n\n\t// Frees is the cumulative count of heap objects freed.\n\tFrees uint64\n\n\t// HeapAlloc is bytes of allocated heap objects.\n\t//\n\t// \"Allocated\" heap objects include all reachable objects, as\n\t// well as unreachable objects that the garbage collector has\n\t// not yet freed. Specifically, HeapAlloc increases as heap\n\t// objects are allocated and decreases as the heap is swept\n\t// and unreachable objects are freed. Sweeping occurs\n\t// incrementally between GC cycles, so these two processes\n\t// occur simultaneously, and as a result HeapAlloc tends to\n\t// change smoothly (in contrast with the sawtooth that is\n\t// typical of stop-the-world garbage collectors).\n\tHeapAlloc uint64\n\n\t// HeapSys is bytes of heap memory obtained from the OS.\n\t//\n\t// HeapSys measures the amount of virtual address space\n\t// reserved for the heap. This includes virtual address space\n\t// that has been reserved but not yet used, which consumes no\n\t// physical memory, but tends to be small, as well as virtual\n\t// address space for which the physical memory has been\n\t// returned to the OS after it became unused (see HeapReleased\n\t// for a measure of the latter).\n\t//\n\t// HeapSys estimates the largest size the heap has had.\n\tHeapSys uint64\n\n\t// HeapIdle is bytes in idle (unused) spans.\n\t//\n\t// Idle spans have no objects in them. These spans could be\n\t// (and may already have been) returned to the OS, or they can\n\t// be reused for heap allocations, or they can be reused as\n\t// stack memory.\n\t//\n\t// HeapIdle minus HeapReleased estimates the amount of memory\n\t// that could be returned to the OS, but is being retained by\n\t// the runtime so it can grow the heap without requesting more\n\t// memory from the OS. If this difference is significantly\n\t// larger than the heap size, it indicates there was a recent\n\t// transient spike in live heap size.\n\tHeapIdle uint64\n\n\t// HeapInuse is bytes in in-use spans.\n\t//\n\t// In-use spans have at least one object in them. These spans\n\t// can only be used for other objects of roughly the same\n\t// size.\n\t//\n\t// HeapInuse minus HeapAlloc estimates the amount of memory\n\t// that has been dedicated to particular size classes, but is\n\t// not currently being used. This is an upper bound on\n\t// fragmentation, but in general this memory can be reused\n\t// efficiently.\n\tHeapInuse uint64\n\n\t// HeapReleased is bytes of physical memory returned to the OS.\n\t//\n\t// This counts heap memory from idle spans that was returned\n\t// to the OS and has not yet been reacquired for the heap.\n\tHeapReleased uint64\n\n\t// HeapObjects is the number of allocated heap objects.\n\t//\n\t// Like HeapAlloc, this increases as objects are allocated and\n\t// decreases as the heap is swept and unreachable objects are\n\t// freed.\n\tHeapObjects uint64\n\n\t// StackInuse is bytes in stack spans.\n\t//\n\t// In-use stack spans have at least one stack in them. These\n\t// spans can only be used for other stacks of the same size.\n\t//\n\t// There is no StackIdle because unused stack spans are\n\t// returned to the heap (and hence counted toward HeapIdle).\n\tStackInuse uint64\n\n\t// StackSys is bytes of stack memory obtained from the OS.\n\t//\n\t// StackSys is StackInuse, plus any memory obtained directly\n\t// from the OS for OS thread stacks (which should be minimal).\n\tStackSys uint64\n\n\t// MSpanInuse is bytes of allocated mspan structures.\n\tMSpanInuse uint64\n\n\t// MSpanSys is bytes of memory obtained from the OS for mspan\n\t// structures.\n\tMSpanSys uint64\n\n\t// MCacheInuse is bytes of allocated mcache structures.\n\tMCacheInuse uint64\n\n\t// MCacheSys is bytes of memory obtained from the OS for\n\t// mcache structures.\n\tMCacheSys uint64\n\n\t// BuckHashSys is bytes of memory in profiling bucket hash tables.\n\tBuckHashSys uint64\n\n\t// GCSys is bytes of memory in garbage collection metadata.\n\tGCSys uint64\n\n\t// OtherSys is bytes of memory in miscellaneous off-heap\n\t// runtime allocations.\n\tOtherSys uint64\n\n\t// NextGC is the target heap size of the next GC cycle.\n\t//\n\t// The garbage collector's goal is to keep HeapAlloc ≤ NextGC.\n\t// At the end of each GC cycle, the target for the next cycle\n\t// is computed based on the amount of reachable data and the\n\t// value of GOGC.\n\tNextGC uint64\n\n\t// LastGC is the time the last garbage collection finished, as\n\t// nanoseconds since 1970 (the UNIX epoch).\n\tLastGC uint64\n\n\t// PauseTotalNs is the cumulative nanoseconds in GC\n\t// stop-the-world pauses since the program started.\n\t//\n\t// During a stop-the-world pause, all goroutines are paused\n\t// and only the garbage collector can run.\n\tPauseTotalNs uint64\n\n\t// PauseNs is a circular buffer of recent GC stop-the-world\n\t// pause times in nanoseconds.\n\t//\n\t// The most recent pause is at PauseNs[(NumGC+255)%256]. In\n\t// general, PauseNs[N%256] records the time paused in the most\n\t// recent N%256th GC cycle. There may be multiple pauses per\n\t// GC cycle; this is the sum of all pauses during a cycle.\n\tPauseNs [256]uint64\n\n\t// PauseEnd is a circular buffer of recent GC pause end times,\n\t// as nanoseconds since 1970 (the UNIX epoch).\n\t//\n\t// This buffer is filled the same way as PauseNs. There may be\n\t// multiple pauses per GC cycle; this records the end of the\n\t// last pause in a cycle.\n\tPauseEnd [256]uint64\n\n\t// NumGC is the number of completed GC cycles.\n\tNumGC uint32\n\n\t// NumForcedGC is the number of GC cycles that were forced by\n\t// the application calling the GC function.\n\tNumForcedGC uint32\n\n\t// GCCPUFraction is the fraction of this program's available\n\t// CPU time used by the GC since the program started.\n\t//\n\t// GCCPUFraction is expressed as a number between 0 and 1,\n\t// where 0 means GC has consumed none of this program's CPU. A\n\t// program's available CPU time is defined as the integral of\n\t// GOMAXPROCS since the program started. That is, if\n\t// GOMAXPROCS is 2 and a program has been running for 10\n\t// seconds, its \"available CPU\" is 20 seconds. GCCPUFraction\n\t// does not include CPU time used for write barrier activity.\n\t//\n\t// This is the same as the fraction of CPU reported by\n\t// GODEBUG=gctrace=1.\n\tGCCPUFraction float64\n\n\t// EnableGC indicates that GC is enabled. It is always true,\n\t// even if GOGC=off.\n\tEnableGC bool\n\n\t// DebugGC is currently unused.\n\tDebugGC bool\n\n\t// BySize reports per-size class allocation statistics.\n\t//\n\t// BySize[N] gives statistics for allocations of size S where\n\t// BySize[N-1].Size < S ≤ BySize[N].Size.\n\t//\n\t// This does not report allocations larger than BySize[60].Size.\n\tBySize [61]struct {\n\t\t// Size is the maximum byte size of an object in this\n\t\t// size class.\n\t\tSize uint32\n\n\t\t// Mallocs is the cumulative count of heap objects\n\t\t// allocated in this size class. The cumulative bytes\n\t\t// of allocation is Size*Mallocs. The number of live\n\t\t// objects in this size class is Mallocs - Frees.\n\t\tMallocs uint64\n\n\t\t// Frees is the cumulative count of heap objects freed\n\t\t// in this size class.\n\t\tFrees uint64\n\t}\n}\n```\n\nA MemStats records statistics about the memory allocator. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#ReadMemStatsSlow",
                    "documentation": {
                      "identifier": "ReadMemStatsSlow",
                      "newPage": false,
                      "searchKey": "runtime.ReadMemStatsSlow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ReadMemStatsSlow() (base, slow MemStats)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ReadMemStatsSlow() (base, slow MemStats)\n```\n\nReadMemStatsSlow returns both the runtime-computed MemStats and MemStats accumulated by scanning the heap. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysMemStat",
              "documentation": {
                "identifier": "sysMemStat",
                "newPage": false,
                "searchKey": "runtime.sysMemStat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sysMemStat uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sysMemStat uint64\n```\n\nsysMemStat represents a global system statistic that is managed atomically. \n\nThis type must structurally be a uint64 so that mstats aligns with MemStats. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#sysMemStat.load",
                    "documentation": {
                      "identifier": "sysMemStat.load",
                      "newPage": false,
                      "searchKey": "runtime.sysMemStat.load",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *sysMemStat) load() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *sysMemStat) load() uint64\n```\n\nload atomically reads the value of the stat. \n\nMust be nosplit as it is called in runtime initialization, e.g. newosproc0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sysMemStat.add",
                    "documentation": {
                      "identifier": "sysMemStat.add",
                      "newPage": false,
                      "searchKey": "runtime.sysMemStat.add",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (s *sysMemStat) add(n int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (s *sysMemStat) add(n int64)\n```\n\nadd atomically adds the sysMemStat by n. \n\nMust be nosplit as it is called in runtime initialization, e.g. newosproc0. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapStatsDelta",
              "documentation": {
                "identifier": "heapStatsDelta",
                "newPage": false,
                "searchKey": "runtime.heapStatsDelta",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type heapStatsDelta struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype heapStatsDelta struct {\n\t// Memory stats.\n\tcommitted       int64 // byte delta of memory committed\n\treleased        int64 // byte delta of released memory generated\n\tinHeap          int64 // byte delta of memory placed in the heap\n\tinStacks        int64 // byte delta of memory reserved for stacks\n\tinWorkBufs      int64 // byte delta of memory reserved for work bufs\n\tinPtrScalarBits int64 // byte delta of memory reserved for unrolled GC prog bits\n\n\t// Allocator stats.\n\ttinyAllocCount  uintptr                  // number of tiny allocations\n\tlargeAlloc      uintptr                  // bytes allocated for large objects\n\tlargeAllocCount uintptr                  // number of large object allocations\n\tsmallAllocCount [_NumSizeClasses]uintptr // number of allocs for small objects\n\tlargeFree       uintptr                  // bytes freed for large objects (>maxSmallSize)\n\tlargeFreeCount  uintptr                  // number of frees for large objects (>maxSmallSize)\n\tsmallFreeCount  [_NumSizeClasses]uintptr // number of frees for small objects (<=maxSmallSize)\n\n\t// Add a uint32 to ensure this struct is a multiple of 8 bytes in size.\n\t// Only necessary on 32-bit platforms.\n\t_ [(sys.PtrSize / 4) % 2]uint32\n}\n```\n\nheapStatsDelta contains deltas of various runtime memory statistics that need to be updated together in order for them to be kept consistent with one another. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#heapStatsDelta.merge",
                    "documentation": {
                      "identifier": "heapStatsDelta.merge",
                      "newPage": false,
                      "searchKey": "runtime.heapStatsDelta.merge",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *heapStatsDelta) merge(b *heapStatsDelta)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *heapStatsDelta) merge(b *heapStatsDelta)\n```\n\nmerge adds in the deltas from b into a. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#consistentHeapStats",
              "documentation": {
                "identifier": "consistentHeapStats",
                "newPage": false,
                "searchKey": "runtime.consistentHeapStats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type consistentHeapStats struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype consistentHeapStats struct {\n\t// stats is a ring buffer of heapStatsDelta values.\n\t// Writers always atomically update the delta at index gen.\n\t//\n\t// Readers operate by rotating gen (0 -> 1 -> 2 -> 0 -> ...)\n\t// and synchronizing with writers by observing each P's\n\t// statsSeq field. If the reader observes a P not writing,\n\t// it can be sure that it will pick up the new gen value the\n\t// next time it writes.\n\t//\n\t// The reader then takes responsibility by clearing space\n\t// in the ring buffer for the next reader to rotate gen to\n\t// that space (i.e. it merges in values from index (gen-2) mod 3\n\t// to index (gen-1) mod 3, then clears the former).\n\t//\n\t// Note that this means only one reader can be reading at a time.\n\t// There is no way for readers to synchronize.\n\t//\n\t// This process is why we need a ring buffer of size 3 instead\n\t// of 2: one is for the writers, one contains the most recent\n\t// data, and the last one is clear so writers can begin writing\n\t// to it the moment gen is updated.\n\tstats [3]heapStatsDelta\n\n\t// gen represents the current index into which writers\n\t// are writing, and can take on the value of 0, 1, or 2.\n\t// This value is updated atomically.\n\tgen uint32\n\n\t// noPLock is intended to provide mutual exclusion for updating\n\t// stats when no P is available. It does not block other writers\n\t// with a P, only other writers without a P and the reader. Because\n\t// stats are usually updated when a P is available, contention on\n\t// this lock should be minimal.\n\tnoPLock mutex\n}\n```\n\nconsistentHeapStats represents a set of various memory statistics whose updates must be viewed completely to get a consistent state of the world. \n\nTo write updates to memory stats use the acquire and release methods. To obtain a consistent global snapshot of these statistics, use read. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#consistentHeapStats.acquire",
                    "documentation": {
                      "identifier": "consistentHeapStats.acquire",
                      "newPage": false,
                      "searchKey": "runtime.consistentHeapStats.acquire",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *consistentHeapStats) acquire() *heapStatsDelta"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *consistentHeapStats) acquire() *heapStatsDelta\n```\n\nacquire returns a heapStatsDelta to be updated. In effect, it acquires the shard for writing. release must be called as soon as the relevant deltas are updated. \n\nThe returned heapStatsDelta must be updated atomically. \n\nThe caller's P must not change between acquire and release. This also means that the caller should not acquire a P or release its P in between. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#consistentHeapStats.release",
                    "documentation": {
                      "identifier": "consistentHeapStats.release",
                      "newPage": false,
                      "searchKey": "runtime.consistentHeapStats.release",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *consistentHeapStats) release()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *consistentHeapStats) release()\n```\n\nrelease indicates that the writer is done modifying the delta. The value returned by the corresponding acquire must no longer be accessed or modified after release is called. \n\nThe caller's P must not change between acquire and release. This also means that the caller should not acquire a P or release its P in between. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#consistentHeapStats.unsafeRead",
                    "documentation": {
                      "identifier": "consistentHeapStats.unsafeRead",
                      "newPage": false,
                      "searchKey": "runtime.consistentHeapStats.unsafeRead",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *consistentHeapStats) unsafeRead(out *heapStatsDelta)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *consistentHeapStats) unsafeRead(out *heapStatsDelta)\n```\n\nunsafeRead aggregates the delta for this shard into out. \n\nUnsafe because it does so without any synchronization. The world must be stopped. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#consistentHeapStats.unsafeClear",
                    "documentation": {
                      "identifier": "consistentHeapStats.unsafeClear",
                      "newPage": false,
                      "searchKey": "runtime.consistentHeapStats.unsafeClear",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *consistentHeapStats) unsafeClear()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *consistentHeapStats) unsafeClear()\n```\n\nunsafeClear clears the shard. \n\nUnsafe because the world must be stopped and values should be donated elsewhere before clearing. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#consistentHeapStats.read",
                    "documentation": {
                      "identifier": "consistentHeapStats.read",
                      "newPage": false,
                      "searchKey": "runtime.consistentHeapStats.read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *consistentHeapStats) read(out *heapStatsDelta)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *consistentHeapStats) read(out *heapStatsDelta)\n```\n\nread takes a globally consistent snapshot of m and puts the aggregated value in out. Even though out is a heapStatsDelta, the resulting values should be complete and valid statistic values. \n\nNot safe to call concurrently. The world must be stopped or metricsSema must be held. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#wbBuf",
              "documentation": {
                "identifier": "wbBuf",
                "newPage": false,
                "searchKey": "runtime.wbBuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type wbBuf struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype wbBuf struct {\n\t// next points to the next slot in buf. It must not be a\n\t// pointer type because it can point past the end of buf and\n\t// must be updated without write barriers.\n\t//\n\t// This is a pointer rather than an index to optimize the\n\t// write barrier assembly.\n\tnext uintptr\n\n\t// end points to just past the end of buf. It must not be a\n\t// pointer type because it points past the end of buf and must\n\t// be updated without write barriers.\n\tend uintptr\n\n\t// buf stores a series of pointers to execute write barriers\n\t// on. This must be a multiple of wbBufEntryPointers because\n\t// the write barrier only checks for overflow once per entry.\n\tbuf [wbBufEntryPointers * wbBufEntries]uintptr\n}\n```\n\nwbBuf is a per-P buffer of pointers queued by the write barrier. This buffer is flushed to the GC workbufs when it fills up and on various GC transitions. \n\nThis is closely related to a \"sequential store buffer\" (SSB), except that SSBs are usually used for maintaining remembered sets, while this is used for marking. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#wbBuf.reset",
                    "documentation": {
                      "identifier": "wbBuf.reset",
                      "newPage": false,
                      "searchKey": "runtime.wbBuf.reset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *wbBuf) reset()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *wbBuf) reset()\n```\n\nreset empties b by resetting its next and end pointers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#wbBuf.discard",
                    "documentation": {
                      "identifier": "wbBuf.discard",
                      "newPage": false,
                      "searchKey": "runtime.wbBuf.discard",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *wbBuf) discard()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *wbBuf) discard()\n```\n\ndiscard resets b's next pointer, but not its end pointer. \n\nThis must be nosplit because it's called by wbBufFlush. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#wbBuf.empty",
                    "documentation": {
                      "identifier": "wbBuf.empty",
                      "newPage": false,
                      "searchKey": "runtime.wbBuf.empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *wbBuf) empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *wbBuf) empty() bool\n```\n\nempty reports whether b contains no pointers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#wbBuf.putFast",
                    "documentation": {
                      "identifier": "wbBuf.putFast",
                      "newPage": false,
                      "searchKey": "runtime.wbBuf.putFast",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *wbBuf) putFast(old, new uintptr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *wbBuf) putFast(old, new uintptr) bool\n```\n\nputFast adds old and new to the write barrier buffer and returns false if a flush is necessary. Callers should use this as: \n\n```\nbuf := &getg().m.p.ptr().wbBuf\nif !buf.putFast(old, new) {\n    wbBufFlush(...)\n}\n... actual memory write ...\n\n```\nThe arguments to wbBufFlush depend on whether the caller is doing its own cgo pointer checks. If it is, then this can be wbBufFlush(nil, 0). Otherwise, it must pass the slot address and new. \n\nThe caller must ensure there are no preemption points during the above sequence. There must be no preemption points while buf is in use because it is a per-P resource. There must be no preemption points between the buffer put and the write to memory because this could allow a GC phase change, which could result in missed write barriers. \n\nputFast must be nowritebarrierrec to because write barriers here would corrupt the write barrier buffer. It (and everything it calls, if it called anything) has to be nosplit to avoid scheduling on to a different P and a different buffer. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pollDesc",
              "documentation": {
                "identifier": "pollDesc",
                "newPage": false,
                "searchKey": "runtime.pollDesc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pollDesc struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pollDesc struct {\n\tlink *pollDesc // in pollcache, protected by pollcache.lock\n\n\t// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.\n\t// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.\n\t// pollReset, pollWait, pollWaitCanceled and runtime·netpollready (IO readiness notification)\n\t// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated\n\t// in a lock-free way by all operations.\n\t// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),\n\t// that will blow up when GC starts moving objects.\n\tlock    mutex // protects the following fields\n\tfd      uintptr\n\tclosing bool\n\teverr   bool      // marks event scanning error happened\n\tuser    uint32    // user settable cookie\n\trseq    uintptr   // protects from stale read timers\n\trg      uintptr   // pdReady, pdWait, G waiting for read or nil\n\trt      timer     // read deadline timer (set if rt.f != nil)\n\trd      int64     // read deadline\n\twseq    uintptr   // protects from stale write timers\n\twg      uintptr   // pdReady, pdWait, G waiting for write or nil\n\twt      timer     // write deadline timer\n\twd      int64     // write deadline\n\tself    *pollDesc // storage for indirect interface. See (*pollDesc).makeArg.\n}\n```\n\nNetwork poller descriptor. \n\nNo heap pointers. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#poll_runtime_pollOpen",
                    "documentation": {
                      "identifier": "poll_runtime_pollOpen",
                      "newPage": false,
                      "searchKey": "runtime.poll_runtime_pollOpen",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func poll_runtime_pollOpen(fd uintptr) (*pollDesc, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc poll_runtime_pollOpen(fd uintptr) (*pollDesc, int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pollDesc.makeArg",
                    "documentation": {
                      "identifier": "pollDesc.makeArg",
                      "newPage": false,
                      "searchKey": "runtime.pollDesc.makeArg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pd *pollDesc) makeArg() (i interface{})"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pd *pollDesc) makeArg() (i interface{})\n```\n\nmakeArg converts pd to an interface{}. makeArg does not do any allocation. Normally, such a conversion requires an allocation because pointers to go:notinheap types (which pollDesc is) must be stored in interfaces indirectly. See issue 42076. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pollCache",
              "documentation": {
                "identifier": "pollCache",
                "newPage": false,
                "searchKey": "runtime.pollCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pollCache struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pollCache struct {\n\tlock  mutex\n\tfirst *pollDesc\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#pollCache.free",
                    "documentation": {
                      "identifier": "pollCache.free",
                      "newPage": false,
                      "searchKey": "runtime.pollCache.free",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *pollCache) free(pd *pollDesc)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *pollCache) free(pd *pollDesc)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pollCache.alloc",
                    "documentation": {
                      "identifier": "pollCache.alloc",
                      "newPage": false,
                      "searchKey": "runtime.pollCache.alloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *pollCache) alloc() *pollDesc"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *pollCache) alloc() *pollDesc\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mOS",
              "documentation": {
                "identifier": "mOS",
                "newPage": false,
                "searchKey": "runtime.mOS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mOS struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mOS struct {\n\tinitialized bool\n\tmutex       pthreadmutex\n\tcond        pthreadcond\n\tcount       int\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigset",
              "documentation": {
                "identifier": "sigset",
                "newPage": false,
                "searchKey": "runtime.sigset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sigset uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sigset uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ptabEntry",
              "documentation": {
                "identifier": "ptabEntry",
                "newPage": false,
                "searchKey": "runtime.ptabEntry",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ptabEntry struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ptabEntry struct {\n\tname nameOff\n\ttyp  typeOff\n}\n```\n\nA ptabEntry is generated by the compiler for each exported function and global variable in the main package of a plugin. It is used to initialize the plugin module's symbol map. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#suspendGState",
              "documentation": {
                "identifier": "suspendGState",
                "newPage": false,
                "searchKey": "runtime.suspendGState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type suspendGState struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype suspendGState struct {\n\tg *g\n\n\t// dead indicates the goroutine was not suspended because it\n\t// is dead. This goroutine could be reused after the dead\n\t// state was observed, so the caller must not assume that it\n\t// remains dead.\n\tdead bool\n\n\t// stopped indicates that this suspendG transitioned the G to\n\t// _Gwaiting via g.preemptStop and thus is responsible for\n\t// readying it when done.\n\tstopped bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#suspendG",
                    "documentation": {
                      "identifier": "suspendG",
                      "newPage": false,
                      "searchKey": "runtime.suspendG",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func suspendG(gp *g) suspendGState"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc suspendG(gp *g) suspendGState\n```\n\nsuspendG suspends goroutine gp at a safe-point and returns the state of the suspended goroutine. The caller gets read access to the goroutine until it calls resumeG. \n\nIt is safe for multiple callers to attempt to suspend the same goroutine at the same time. The goroutine may execute between subsequent successful suspend operations. The current implementation grants exclusive access to the goroutine, and hence multiple callers will serialize. However, the intent is to grant shared read access, so please don't depend on exclusive access. \n\nThis must be called from the system stack and the user goroutine on the current M (if any) must be in a preemptible state. This prevents deadlocks where two goroutines attempt to suspend each other and both are in non-preemptible states. There are other ways to resolve this deadlock, but this seems simplest. \n\nTODO(austin): What if we instead required this to be called from a user goroutine? Then we could deschedule the goroutine while waiting instead of blocking the thread. If two goroutines tried to suspend each other, one of them would win and the other wouldn't complete the suspend until it was resumed. We would have to be careful that they couldn't actually queue up suspend for each other and then both be suspended. This would also avoid the need for a kernel context switch in the synchronous case because we could just directly schedule the waiter. The context switch is unavoidable in the signal case. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hex",
              "documentation": {
                "identifier": "hex",
                "newPage": false,
                "searchKey": "runtime.hex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type hex uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype hex uint64\n```\n\nThe compiler knows that a print of a value of this type should use printhex instead of printuint (decimal). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgothreadstart",
              "documentation": {
                "identifier": "cgothreadstart",
                "newPage": false,
                "searchKey": "runtime.cgothreadstart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cgothreadstart struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cgothreadstart struct {\n\tg   guintptr\n\ttls *uint64\n\tfn  unsafe.Pointer\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysmontick",
              "documentation": {
                "identifier": "sysmontick",
                "newPage": false,
                "searchKey": "runtime.sysmontick",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sysmontick struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sysmontick struct {\n\tschedtick   uint32\n\tschedwhen   int64\n\tsyscalltick uint32\n\tsyscallwhen int64\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pMask",
              "documentation": {
                "identifier": "pMask",
                "newPage": false,
                "searchKey": "runtime.pMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pMask []uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pMask []uint32\n```\n\npMask is an atomic bitstring with one bit per P. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#pMask.read",
                    "documentation": {
                      "identifier": "pMask.read",
                      "newPage": false,
                      "searchKey": "runtime.pMask.read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p pMask) read(id uint32) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p pMask) read(id uint32) bool\n```\n\nread returns true if P id's bit is set. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pMask.set",
                    "documentation": {
                      "identifier": "pMask.set",
                      "newPage": false,
                      "searchKey": "runtime.pMask.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p pMask) set(id int32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p pMask) set(id int32)\n```\n\nset sets P id's bit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pMask.clear",
                    "documentation": {
                      "identifier": "pMask.clear",
                      "newPage": false,
                      "searchKey": "runtime.pMask.clear",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p pMask) clear(id int32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p pMask) clear(id int32)\n```\n\nclear clears P id's bit. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gQueue",
              "documentation": {
                "identifier": "gQueue",
                "newPage": false,
                "searchKey": "runtime.gQueue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gQueue struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gQueue struct {\n\thead guintptr\n\ttail guintptr\n}\n```\n\nA gQueue is a dequeue of Gs linked through g.schedlink. A G can only be on one gQueue or gList at a time. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#runqdrain",
                    "documentation": {
                      "identifier": "runqdrain",
                      "newPage": false,
                      "searchKey": "runtime.runqdrain",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func runqdrain(_p_ *p) (drainQ gQueue, n uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc runqdrain(_p_ *p) (drainQ gQueue, n uint32)\n```\n\nrunqdrain drains the local runnable queue of _p_ and returns all goroutines in it. Executed only by the owner P. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gQueue.empty",
                    "documentation": {
                      "identifier": "gQueue.empty",
                      "newPage": false,
                      "searchKey": "runtime.gQueue.empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *gQueue) empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *gQueue) empty() bool\n```\n\nempty reports whether q is empty. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gQueue.push",
                    "documentation": {
                      "identifier": "gQueue.push",
                      "newPage": false,
                      "searchKey": "runtime.gQueue.push",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *gQueue) push(gp *g)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *gQueue) push(gp *g)\n```\n\npush adds gp to the head of q. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gQueue.pushBack",
                    "documentation": {
                      "identifier": "gQueue.pushBack",
                      "newPage": false,
                      "searchKey": "runtime.gQueue.pushBack",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *gQueue) pushBack(gp *g)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *gQueue) pushBack(gp *g)\n```\n\npushBack adds gp to the tail of q. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gQueue.pushBackAll",
                    "documentation": {
                      "identifier": "gQueue.pushBackAll",
                      "newPage": false,
                      "searchKey": "runtime.gQueue.pushBackAll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *gQueue) pushBackAll(q2 gQueue)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *gQueue) pushBackAll(q2 gQueue)\n```\n\npushBackAll adds all Gs in l2 to the tail of q. After this q2 must not be used. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gQueue.pop",
                    "documentation": {
                      "identifier": "gQueue.pop",
                      "newPage": false,
                      "searchKey": "runtime.gQueue.pop",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *gQueue) pop() *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *gQueue) pop() *g\n```\n\npop removes and returns the head of queue q. It returns nil if q is empty. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gQueue.popList",
                    "documentation": {
                      "identifier": "gQueue.popList",
                      "newPage": false,
                      "searchKey": "runtime.gQueue.popList",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q *gQueue) popList() gList"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q *gQueue) popList() gList\n```\n\npopList takes all Gs in q and returns them as a gList. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gList",
              "documentation": {
                "identifier": "gList",
                "newPage": false,
                "searchKey": "runtime.gList",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gList struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gList struct {\n\thead guintptr\n}\n```\n\nA gList is a list of Gs linked through g.schedlink. A G can only be on one gQueue or gList at a time. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#netpoll",
                    "documentation": {
                      "identifier": "netpoll",
                      "newPage": false,
                      "searchKey": "runtime.netpoll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func netpoll(delay int64) gList"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc netpoll(delay int64) gList\n```\n\nnetpoll checks for ready network connections. Returns list of goroutines that become runnable. delay < 0: blocks indefinitely delay == 0: does not block, just polls delay > 0: block for up to that many nanoseconds \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gList.empty",
                    "documentation": {
                      "identifier": "gList.empty",
                      "newPage": false,
                      "searchKey": "runtime.gList.empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *gList) empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *gList) empty() bool\n```\n\nempty reports whether l is empty. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gList.push",
                    "documentation": {
                      "identifier": "gList.push",
                      "newPage": false,
                      "searchKey": "runtime.gList.push",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *gList) push(gp *g)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *gList) push(gp *g)\n```\n\npush adds gp to the head of l. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gList.pushAll",
                    "documentation": {
                      "identifier": "gList.pushAll",
                      "newPage": false,
                      "searchKey": "runtime.gList.pushAll",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *gList) pushAll(q gQueue)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *gList) pushAll(q gQueue)\n```\n\npushAll prepends all Gs in q to l. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gList.pop",
                    "documentation": {
                      "identifier": "gList.pop",
                      "newPage": false,
                      "searchKey": "runtime.gList.pop",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l *gList) pop() *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l *gList) pop() *g\n```\n\npop removes and returns the head of l. If l is empty, it returns nil. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#randomOrder",
              "documentation": {
                "identifier": "randomOrder",
                "newPage": false,
                "searchKey": "runtime.randomOrder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type randomOrder struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype randomOrder struct {\n\tcount    uint32\n\tcoprimes []uint32\n}\n```\n\nrandomOrder/randomEnum are helper types for randomized work stealing. They allow to enumerate all Ps in different pseudo-random orders without repetitions. The algorithm is based on the fact that if we have X such that X and GOMAXPROCS are coprime, then a sequences of (i + X) % GOMAXPROCS gives the required enumeration. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#randomOrder.reset",
                    "documentation": {
                      "identifier": "randomOrder.reset",
                      "newPage": false,
                      "searchKey": "runtime.randomOrder.reset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ord *randomOrder) reset(count uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ord *randomOrder) reset(count uint32)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#randomOrder.start",
                    "documentation": {
                      "identifier": "randomOrder.start",
                      "newPage": false,
                      "searchKey": "runtime.randomOrder.start",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ord *randomOrder) start(i uint32) randomEnum"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ord *randomOrder) start(i uint32) randomEnum\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#randomEnum",
              "documentation": {
                "identifier": "randomEnum",
                "newPage": false,
                "searchKey": "runtime.randomEnum",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type randomEnum struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype randomEnum struct {\n\ti     uint32\n\tcount uint32\n\tpos   uint32\n\tinc   uint32\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#randomEnum.done",
                    "documentation": {
                      "identifier": "randomEnum.done",
                      "newPage": false,
                      "searchKey": "runtime.randomEnum.done",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (enum *randomEnum) done() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (enum *randomEnum) done() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#randomEnum.next",
                    "documentation": {
                      "identifier": "randomEnum.next",
                      "newPage": false,
                      "searchKey": "runtime.randomEnum.next",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (enum *randomEnum) next()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (enum *randomEnum) next()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#randomEnum.position",
                    "documentation": {
                      "identifier": "randomEnum.position",
                      "newPage": false,
                      "searchKey": "runtime.randomEnum.position",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (enum *randomEnum) position() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (enum *randomEnum) position() uint32\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#initTask",
              "documentation": {
                "identifier": "initTask",
                "newPage": false,
                "searchKey": "runtime.initTask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type initTask struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype initTask struct {\n\t// TODO: pack the first 3 fields more tightly?\n\tstate uintptr // 0 = uninitialized, 1 = in progress, 2 = done\n\tndeps uintptr\n\tnfns  uintptr\n}\n```\n\nAn initTask represents the set of initializations that need to be done for a package. Keep in sync with ../../test/initempty.go:initTask \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracestat",
              "documentation": {
                "identifier": "tracestat",
                "newPage": false,
                "searchKey": "runtime.tracestat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type tracestat struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype tracestat struct {\n\tactive bool   // init tracing activation status\n\tid     int64  // init goroutine id\n\tallocs uint64 // heap allocations\n\tbytes  uint64 // heap allocated bytes\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#profBuf",
              "documentation": {
                "identifier": "profBuf",
                "newPage": false,
                "searchKey": "runtime.profBuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type profBuf struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype profBuf struct {\n\t// accessed atomically\n\tr, w         profAtomic\n\toverflow     uint64\n\toverflowTime uint64\n\teof          uint32\n\n\t// immutable (excluding slice content)\n\thdrsize uintptr\n\tdata    []uint64\n\ttags    []unsafe.Pointer\n\n\t// owned by reader\n\trNext       profIndex\n\toverflowBuf []uint64 // for use by reader to return overflow record\n\twait        note\n}\n```\n\nA profBuf is a lock-free buffer for profiling events, safe for concurrent use by one reader and one writer. The writer may be a signal handler running without a user g. The reader is assumed to be a user g. \n\nEach logged event corresponds to a fixed size header, a list of uintptrs (typically a stack), and exactly one unsafe.Pointer tag. The header and uintptrs are stored in the circular buffer data and the tag is stored in a circular buffer tags, running in parallel. In the circular buffer data, each event takes 2+hdrsize+len(stk) words: the value 2+hdrsize+len(stk), then the time of the event, then hdrsize words giving the fixed-size header, and then len(stk) words for the stack. \n\nThe current effective offsets into the tags and data circular buffers for reading and writing are stored in the high 30 and low 32 bits of r and w. The bottom bits of the high 32 are additional flag bits in w, unused in r. \"Effective\" offsets means the total number of reads or writes, mod 2^length. The offset in the buffer is the effective offset mod the length of the buffer. To make wraparound mod 2^length match wraparound mod length of the buffer, the length of the buffer must be a power of two. \n\nIf the reader catches up to the writer, a flag passed to read controls whether the read blocks until more data is available. A read returns a pointer to the buffer data itself; the caller is assumed to be done with that data at the next read. The read offset rNext tracks the next offset to be returned by read. By definition, r ≤ rNext ≤ w (before wraparound), and rNext is only used by the reader, so it can be accessed without atomics. \n\nIf the writer gets ahead of the reader, so that the buffer fills, future writes are discarded and replaced in the output stream by an overflow entry, which has size 2+hdrsize+1, time set to the time of the first discarded write, a header of all zeroed words, and a \"stack\" containing one word, the number of discarded writes. \n\nBetween the time the buffer fills and the buffer becomes empty enough to hold more data, the overflow entry is stored as a pending overflow entry in the fields overflow and overflowTime. The pending overflow entry can be turned into a real record by either the writer or the reader. If the writer is called to write a new record and finds that the output buffer has room for both the pending overflow entry and the new record, the writer emits the pending overflow entry and the new record into the buffer. If the reader is called to read data and finds that the output buffer is empty but that there is a pending overflow entry, the reader will return a synthesized record for the pending overflow entry. \n\nOnly the writer can create or add to a pending overflow entry, but either the reader or the writer can clear the pending overflow entry. A pending overflow entry is indicated by the low 32 bits of 'overflow' holding the number of discarded writes, and overflowTime holding the time of the first discarded write. The high 32 bits of 'overflow' increment each time the low 32 bits transition from zero to non-zero or vice versa. This sequence number avoids ABA problems in the use of compare-and-swap to coordinate between reader and writer. The overflowTime is only written when the low 32 bits of overflow are zero, that is, only when there is no pending overflow entry, in preparation for creating a new one. The reader can therefore fetch and clear the entry atomically using \n\n```\nfor {\n\toverflow = load(&b.overflow)\n\tif uint32(overflow) == 0 {\n\t\t// no pending entry\n\t\tbreak\n\t}\n\ttime = load(&b.overflowTime)\n\tif cas(&b.overflow, overflow, ((overflow>>32)+1)<<32) {\n\t\t// pending entry cleared\n\t\tbreak\n\t}\n}\nif uint32(overflow) > 0 {\n\temit entry for uint32(overflow), time\n}\n\n```\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#newProfBuf",
                    "documentation": {
                      "identifier": "newProfBuf",
                      "newPage": false,
                      "searchKey": "runtime.newProfBuf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newProfBuf(hdrsize, bufwords, tags int) *profBuf"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newProfBuf(hdrsize, bufwords, tags int) *profBuf\n```\n\nnewProfBuf returns a new profiling buffer with room for a header of hdrsize words and a buffer of at least bufwords words. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profBuf.hasOverflow",
                    "documentation": {
                      "identifier": "profBuf.hasOverflow",
                      "newPage": false,
                      "searchKey": "runtime.profBuf.hasOverflow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *profBuf) hasOverflow() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *profBuf) hasOverflow() bool\n```\n\nhasOverflow reports whether b has any overflow records pending. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profBuf.takeOverflow",
                    "documentation": {
                      "identifier": "profBuf.takeOverflow",
                      "newPage": false,
                      "searchKey": "runtime.profBuf.takeOverflow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *profBuf) takeOverflow() (count uint32, time uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *profBuf) takeOverflow() (count uint32, time uint64)\n```\n\ntakeOverflow consumes the pending overflow records, returning the overflow count and the time of the first overflow. When called by the reader, it is racing against incrementOverflow. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profBuf.incrementOverflow",
                    "documentation": {
                      "identifier": "profBuf.incrementOverflow",
                      "newPage": false,
                      "searchKey": "runtime.profBuf.incrementOverflow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *profBuf) incrementOverflow(now int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *profBuf) incrementOverflow(now int64)\n```\n\nincrementOverflow records a single overflow at time now. It is racing against a possible takeOverflow in the reader. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profBuf.canWriteRecord",
                    "documentation": {
                      "identifier": "profBuf.canWriteRecord",
                      "newPage": false,
                      "searchKey": "runtime.profBuf.canWriteRecord",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *profBuf) canWriteRecord(nstk int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *profBuf) canWriteRecord(nstk int) bool\n```\n\ncanWriteRecord reports whether the buffer has room for a single contiguous record with a stack of length nstk. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profBuf.canWriteTwoRecords",
                    "documentation": {
                      "identifier": "profBuf.canWriteTwoRecords",
                      "newPage": false,
                      "searchKey": "runtime.profBuf.canWriteTwoRecords",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *profBuf) canWriteTwoRecords(nstk1, nstk2 int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *profBuf) canWriteTwoRecords(nstk1, nstk2 int) bool\n```\n\ncanWriteTwoRecords reports whether the buffer has room for two records with stack lengths nstk1, nstk2, in that order. Each record must be contiguous on its own, but the two records need not be contiguous (one can be at the end of the buffer and the other can wrap around and start at the beginning of the buffer). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profBuf.write",
                    "documentation": {
                      "identifier": "profBuf.write",
                      "newPage": false,
                      "searchKey": "runtime.profBuf.write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *profBuf) write(tagPtr *unsafe.Pointer, now int64, hdr []uint64, stk []uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *profBuf) write(tagPtr *unsafe.Pointer, now int64, hdr []uint64, stk []uintptr)\n```\n\nwrite writes an entry to the profiling buffer b. The entry begins with a fixed hdr, which must have length b.hdrsize, followed by a variable-sized stack and a single tag pointer *tagPtr (or nil if tagPtr is nil). No write barriers allowed because this might be called from a signal handler. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profBuf.close",
                    "documentation": {
                      "identifier": "profBuf.close",
                      "newPage": false,
                      "searchKey": "runtime.profBuf.close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *profBuf) close()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *profBuf) close()\n```\n\nclose signals that there will be no more writes on the buffer. Once all the data has been read from the buffer, reads will return eof=true. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profBuf.wakeupExtra",
                    "documentation": {
                      "identifier": "profBuf.wakeupExtra",
                      "newPage": false,
                      "searchKey": "runtime.profBuf.wakeupExtra",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *profBuf) wakeupExtra()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *profBuf) wakeupExtra()\n```\n\nwakeupExtra must be called after setting one of the \"extra\" atomic fields b.overflow or b.eof. It records the change in b.w and wakes up the reader if needed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profBuf.read",
                    "documentation": {
                      "identifier": "profBuf.read",
                      "newPage": false,
                      "searchKey": "runtime.profBuf.read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *profBuf) read(mode profBufReadMode) (data []uint64, tags []unsafe.Pointer, eof bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *profBuf) read(mode profBufReadMode) (data []uint64, tags []unsafe.Pointer, eof bool)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#profAtomic",
              "documentation": {
                "identifier": "profAtomic",
                "newPage": false,
                "searchKey": "runtime.profAtomic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type profAtomic uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype profAtomic uint64\n```\n\nA profAtomic is the atomically-accessed word holding a profIndex. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#profAtomic.load",
                    "documentation": {
                      "identifier": "profAtomic.load",
                      "newPage": false,
                      "searchKey": "runtime.profAtomic.load",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *profAtomic) load() profIndex"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *profAtomic) load() profIndex\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profAtomic.store",
                    "documentation": {
                      "identifier": "profAtomic.store",
                      "newPage": false,
                      "searchKey": "runtime.profAtomic.store",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *profAtomic) store(new profIndex)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *profAtomic) store(new profIndex)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profAtomic.cas",
                    "documentation": {
                      "identifier": "profAtomic.cas",
                      "newPage": false,
                      "searchKey": "runtime.profAtomic.cas",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *profAtomic) cas(old, new profIndex) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *profAtomic) cas(old, new profIndex) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#profIndex",
              "documentation": {
                "identifier": "profIndex",
                "newPage": false,
                "searchKey": "runtime.profIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type profIndex uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype profIndex uint64\n```\n\nA profIndex is the packet tag and data counts and flags bits, described above. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#profIndex.dataCount",
                    "documentation": {
                      "identifier": "profIndex.dataCount",
                      "newPage": false,
                      "searchKey": "runtime.profIndex.dataCount",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x profIndex) dataCount() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x profIndex) dataCount() uint32\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profIndex.tagCount",
                    "documentation": {
                      "identifier": "profIndex.tagCount",
                      "newPage": false,
                      "searchKey": "runtime.profIndex.tagCount",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x profIndex) tagCount() uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x profIndex) tagCount() uint32\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#profIndex.addCountsAndClearFlags",
                    "documentation": {
                      "identifier": "profIndex.addCountsAndClearFlags",
                      "newPage": false,
                      "searchKey": "runtime.profIndex.addCountsAndClearFlags",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x profIndex) addCountsAndClearFlags(data, tag int) profIndex"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x profIndex) addCountsAndClearFlags(data, tag int) profIndex\n```\n\naddCountsAndClearFlags returns the packed form of \"x + (data, tag) - all flags\". \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#profBufReadMode",
              "documentation": {
                "identifier": "profBufReadMode",
                "newPage": false,
                "searchKey": "runtime.profBufReadMode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type profBufReadMode int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype profBufReadMode int\n```\n\nprofBufReadMode specifies whether to block when no data is available to read. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dbgVar",
              "documentation": {
                "identifier": "dbgVar",
                "newPage": false,
                "searchKey": "runtime.dbgVar",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type dbgVar struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype dbgVar struct {\n\tname  string\n\tvalue *int32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mutex",
              "documentation": {
                "identifier": "mutex",
                "newPage": false,
                "searchKey": "runtime.mutex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type mutex struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype mutex struct {\n\t// Empty struct if lock ranking is disabled, otherwise includes the lock rank\n\tlockRankStruct\n\t// Futex-based impl treats it as uint32 key,\n\t// while sema-based impl as M* waitm.\n\t// Used to be a union, but unions break precise GC.\n\tkey uintptr\n}\n```\n\nMutual exclusion locks.  In the uncontended case, as fast as spin locks (just a few user-level instructions), but on the contention path they sleep in the kernel. A zeroed Mutex is unlocked (no need to initialize each lock). Initialization is helpful for static lock ranking, but not required. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#note",
              "documentation": {
                "identifier": "note",
                "newPage": false,
                "searchKey": "runtime.note",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type note struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype note struct {\n\t// Futex-based impl treats it as uint32 key,\n\t// while sema-based impl as M* waitm.\n\t// Used to be a union, but unions break precise GC.\n\tkey uintptr\n}\n```\n\nsleep and wakeup on one-time events. before any calls to notesleep or notewakeup, must call noteclear to initialize the Note. then, exactly one thread can call notesleep and exactly one thread can call notewakeup (once). once notewakeup has been called, the notesleep will return.  future notesleep will return immediately. subsequent noteclear must be called only after previous notesleep has returned, e.g. it's disallowed to call noteclear straight after notewakeup. \n\nnotetsleep is like notesleep but wakes up after a given number of nanoseconds even if the event has not yet happened.  if a goroutine uses notetsleep to wake up early, it must wait to call noteclear until it can be sure that no other goroutine is calling notewakeup. \n\nnotesleep/notetsleep are generally called on g0, notetsleepg is similar to notetsleep but is called on user g. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcval",
              "documentation": {
                "identifier": "funcval",
                "newPage": false,
                "searchKey": "runtime.funcval",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcval struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcval struct {\n\tfn uintptr\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#iface",
              "documentation": {
                "identifier": "iface",
                "newPage": false,
                "searchKey": "runtime.iface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type iface struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype iface struct {\n\ttab  *itab\n\tdata unsafe.Pointer\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#convT2I",
                    "documentation": {
                      "identifier": "convT2I",
                      "newPage": false,
                      "searchKey": "runtime.convT2I",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func convT2I(tab *itab, elem unsafe.Pointer) (i iface)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc convT2I(tab *itab, elem unsafe.Pointer) (i iface)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#convT2Inoptr",
                    "documentation": {
                      "identifier": "convT2Inoptr",
                      "newPage": false,
                      "searchKey": "runtime.convT2Inoptr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func convT2Inoptr(tab *itab, elem unsafe.Pointer) (i iface)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc convT2Inoptr(tab *itab, elem unsafe.Pointer) (i iface)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#convI2I",
                    "documentation": {
                      "identifier": "convI2I",
                      "newPage": false,
                      "searchKey": "runtime.convI2I",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func convI2I(inter *interfacetype, i iface) (r iface)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc convI2I(inter *interfacetype, i iface) (r iface)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#assertI2I2",
                    "documentation": {
                      "identifier": "assertI2I2",
                      "newPage": false,
                      "searchKey": "runtime.assertI2I2",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func assertI2I2(inter *interfacetype, i iface) (r iface)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc assertI2I2(inter *interfacetype, i iface) (r iface)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#assertE2I2",
                    "documentation": {
                      "identifier": "assertE2I2",
                      "newPage": false,
                      "searchKey": "runtime.assertE2I2",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func assertE2I2(inter *interfacetype, e eface) (r iface)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc assertE2I2(inter *interfacetype, e eface) (r iface)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#eface",
              "documentation": {
                "identifier": "eface",
                "newPage": false,
                "searchKey": "runtime.eface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type eface struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype eface struct {\n\t_type *_type\n\tdata  unsafe.Pointer\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#convT2E",
                    "documentation": {
                      "identifier": "convT2E",
                      "newPage": false,
                      "searchKey": "runtime.convT2E",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func convT2E(t *_type, elem unsafe.Pointer) (e eface)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc convT2E(t *_type, elem unsafe.Pointer) (e eface)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#convT2Enoptr",
                    "documentation": {
                      "identifier": "convT2Enoptr",
                      "newPage": false,
                      "searchKey": "runtime.convT2Enoptr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func convT2Enoptr(t *_type, elem unsafe.Pointer) (e eface)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc convT2Enoptr(t *_type, elem unsafe.Pointer) (e eface)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#efaceOf",
                    "documentation": {
                      "identifier": "efaceOf",
                      "newPage": false,
                      "searchKey": "runtime.efaceOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func efaceOf(ep *interface{}) *eface"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc efaceOf(ep *interface{}) *eface\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#guintptr",
              "documentation": {
                "identifier": "guintptr",
                "newPage": false,
                "searchKey": "runtime.guintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type guintptr uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype guintptr uintptr\n```\n\nA guintptr holds a goroutine pointer, but typed as a uintptr to bypass write barriers. It is used in the Gobuf goroutine state and in scheduling lists that are manipulated without a P. \n\nThe Gobuf.g goroutine pointer is almost always updated by assembly code. In one of the few places it is updated by Go code - func save - it must be treated as a uintptr to avoid a write barrier being emitted at a bad time. Instead of figuring out how to emit the write barriers missing in the assembly manipulation, we change the type of the field to uintptr, so that it does not require write barriers at all. \n\nGoroutine structs are published in the allg list and never freed. That will keep the goroutine structs from being collected. There is never a time that Gobuf.g's contain the only references to a goroutine: the publishing of the goroutine in allg comes first. Goroutine pointers are also kept in non-GC-visible places like TLS, so I can't see them ever moving. If we did want to start moving data in the GC, we'd need to allocate the goroutine structs from an alternate arena. Using guintptr doesn't make that problem any worse. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#guintptr.ptr",
                    "documentation": {
                      "identifier": "guintptr.ptr",
                      "newPage": false,
                      "searchKey": "runtime.guintptr.ptr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (gp guintptr) ptr() *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (gp guintptr) ptr() *g\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#guintptr.set",
                    "documentation": {
                      "identifier": "guintptr.set",
                      "newPage": false,
                      "searchKey": "runtime.guintptr.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (gp *guintptr) set(g *g)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (gp *guintptr) set(g *g)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#guintptr.cas",
                    "documentation": {
                      "identifier": "guintptr.cas",
                      "newPage": false,
                      "searchKey": "runtime.guintptr.cas",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (gp *guintptr) cas(old, new guintptr) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (gp *guintptr) cas(old, new guintptr) bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#puintptr",
              "documentation": {
                "identifier": "puintptr",
                "newPage": false,
                "searchKey": "runtime.puintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type puintptr uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype puintptr uintptr\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#puintptr.ptr",
                    "documentation": {
                      "identifier": "puintptr.ptr",
                      "newPage": false,
                      "searchKey": "runtime.puintptr.ptr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pp puintptr) ptr() *p"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pp puintptr) ptr() *p\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#puintptr.set",
                    "documentation": {
                      "identifier": "puintptr.set",
                      "newPage": false,
                      "searchKey": "runtime.puintptr.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pp *puintptr) set(p *p)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pp *puintptr) set(p *p)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#muintptr",
              "documentation": {
                "identifier": "muintptr",
                "newPage": false,
                "searchKey": "runtime.muintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type muintptr uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype muintptr uintptr\n```\n\nmuintptr is a *m that is not tracked by the garbage collector. \n\nBecause we do free Ms, there are some additional constrains on muintptrs: \n\n1. Never hold an muintptr locally across a safe point. \n\n2. Any muintptr in the heap must be owned by the M itself so it can \n\n```\nensure it is not in use when the last true *m is released.\n\n```\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#muintptr.ptr",
                    "documentation": {
                      "identifier": "muintptr.ptr",
                      "newPage": false,
                      "searchKey": "runtime.muintptr.ptr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mp muintptr) ptr() *m"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mp muintptr) ptr() *m\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#muintptr.set",
                    "documentation": {
                      "identifier": "muintptr.set",
                      "newPage": false,
                      "searchKey": "runtime.muintptr.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mp *muintptr) set(m *m)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mp *muintptr) set(m *m)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gobuf",
              "documentation": {
                "identifier": "gobuf",
                "newPage": false,
                "searchKey": "runtime.gobuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gobuf struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gobuf struct {\n\t// The offsets of sp, pc, and g are known to (hard-coded in) libmach.\n\t//\n\t// ctxt is unusual with respect to GC: it may be a\n\t// heap-allocated funcval, so GC needs to track it, but it\n\t// needs to be set and cleared from assembly, where it's\n\t// difficult to have write barriers. However, ctxt is really a\n\t// saved, live register, and we only ever exchange it between\n\t// the real register and the gobuf. Hence, we treat it as a\n\t// root during stack scanning, which means assembly that saves\n\t// and restores it doesn't need write barriers. It's still\n\t// typed as a pointer so that any other writes from Go get\n\t// write barriers.\n\tsp   uintptr\n\tpc   uintptr\n\tg    guintptr\n\tctxt unsafe.Pointer\n\tret  uintptr\n\tlr   uintptr\n\tbp   uintptr // for framepointer-enabled architectures\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sudog",
              "documentation": {
                "identifier": "sudog",
                "newPage": false,
                "searchKey": "runtime.sudog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sudog struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sudog struct {\n\tg *g\n\n\tnext *sudog\n\tprev *sudog\n\telem unsafe.Pointer // data element (may point to stack)\n\n\tacquiretime int64\n\treleasetime int64\n\tticket      uint32\n\n\t// isSelect indicates g is participating in a select, so\n\t// g.selectDone must be CAS'd to win the wake-up race.\n\tisSelect bool\n\n\t// success indicates whether communication over channel c\n\t// succeeded. It is true if the goroutine was awoken because a\n\t// value was delivered over channel c, and false if awoken\n\t// because c was closed.\n\tsuccess bool\n\n\tparent   *sudog // semaRoot binary tree\n\twaitlink *sudog // g.waiting list or semaRoot\n\twaittail *sudog // semaRoot\n\tc        *hchan // channel\n}\n```\n\nsudog represents a g in a wait list, such as for sending/receiving on a channel. \n\nsudog is necessary because the g ↔ synchronization object relation is many-to-many. A g can be on many wait lists, so there may be many sudogs for one g; and many gs may be waiting on the same synchronization object, so there may be many sudogs for one object. \n\nsudogs are allocated from a special pool. Use acquireSudog and releaseSudog to allocate and free them. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#acquireSudog",
                    "documentation": {
                      "identifier": "acquireSudog",
                      "newPage": false,
                      "searchKey": "runtime.acquireSudog",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func acquireSudog() *sudog"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc acquireSudog() *sudog\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#libcall",
              "documentation": {
                "identifier": "libcall",
                "newPage": false,
                "searchKey": "runtime.libcall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type libcall struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype libcall struct {\n\tfn   uintptr\n\tn    uintptr // number of parameters\n\targs uintptr // parameters\n\tr1   uintptr // return values\n\tr2   uintptr\n\terr  uintptr // error number\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stack",
              "documentation": {
                "identifier": "stack",
                "newPage": false,
                "searchKey": "runtime.stack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stack struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stack struct {\n\tlo uintptr\n\thi uintptr\n}\n```\n\nStack describes a Go execution stack. The bounds of the stack are exactly [lo, hi), with no implicit data structures on either side. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#stackalloc",
                    "documentation": {
                      "identifier": "stackalloc",
                      "newPage": false,
                      "searchKey": "runtime.stackalloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func stackalloc(n uint32) stack"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc stackalloc(n uint32) stack\n```\n\nstackalloc allocates an n byte stack. \n\nstackalloc must run on the system stack because it uses per-P resources and must not split the stack. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heldLockInfo",
              "documentation": {
                "identifier": "heldLockInfo",
                "newPage": false,
                "searchKey": "runtime.heldLockInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type heldLockInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype heldLockInfo struct {\n\tlockAddr uintptr\n\trank     lockRank\n}\n```\n\nheldLockInfo gives info on a held lock and the rank of that lock \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#g",
              "documentation": {
                "identifier": "g",
                "newPage": false,
                "searchKey": "runtime.g",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type g struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype g struct {\n\t// Stack parameters.\n\t// stack describes the actual stack memory: [stack.lo, stack.hi).\n\t// stackguard0 is the stack pointer compared in the Go stack growth prologue.\n\t// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.\n\t// stackguard1 is the stack pointer compared in the C stack growth prologue.\n\t// It is stack.lo+StackGuard on g0 and gsignal stacks.\n\t// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).\n\tstack       stack   // offset known to runtime/cgo\n\tstackguard0 uintptr // offset known to liblink\n\tstackguard1 uintptr // offset known to liblink\n\n\t_panic    *_panic // innermost panic - offset known to liblink\n\t_defer    *_defer // innermost defer\n\tm         *m      // current m; offset known to arm liblink\n\tsched     gobuf\n\tsyscallsp uintptr // if status==Gsyscall, syscallsp = sched.sp to use during gc\n\tsyscallpc uintptr // if status==Gsyscall, syscallpc = sched.pc to use during gc\n\tstktopsp  uintptr // expected sp at top of stack, to check in traceback\n\t// param is a generic pointer parameter field used to pass\n\t// values in particular contexts where other storage for the\n\t// parameter would be difficult to find. It is currently used\n\t// in three ways:\n\t// 1. When a channel operation wakes up a blocked goroutine, it sets param to\n\t//    point to the sudog of the completed blocking operation.\n\t// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed\n\t//    the GC cycle. It is unsafe to do so in any other way, because the goroutine's\n\t//    stack may have moved in the meantime.\n\t// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a\n\t//    closure in the runtime is forbidden.\n\tparam        unsafe.Pointer\n\tatomicstatus uint32\n\tstackLock    uint32 // sigprof/scang lock; TODO: fold in to atomicstatus\n\tgoid         int64\n\tschedlink    guintptr\n\twaitsince    int64      // approx time when the g become blocked\n\twaitreason   waitReason // if status==Gwaiting\n\n\tpreempt       bool // preemption signal, duplicates stackguard0 = stackpreempt\n\tpreemptStop   bool // transition to _Gpreempted on preemption; otherwise, just deschedule\n\tpreemptShrink bool // shrink stack at synchronous safe point\n\n\t// asyncSafePoint is set if g is stopped at an asynchronous\n\t// safe point. This means there are frames on the stack\n\t// without precise pointer information.\n\tasyncSafePoint bool\n\n\tpaniconfault bool // panic (instead of crash) on unexpected fault address\n\tgcscandone   bool // g has scanned stack; protected by _Gscan bit in status\n\tthrowsplit   bool // must not split stack\n\t// activeStackChans indicates that there are unlocked channels\n\t// pointing into this goroutine's stack. If true, stack\n\t// copying needs to acquire channel locks to protect these\n\t// areas of the stack.\n\tactiveStackChans bool\n\t// parkingOnChan indicates that the goroutine is about to\n\t// park on a chansend or chanrecv. Used to signal an unsafe point\n\t// for stack shrinking. It's a boolean value, but is updated atomically.\n\tparkingOnChan uint8\n\n\traceignore     int8     // ignore race detection events\n\tsysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine\n\ttracking       bool     // whether we're tracking this G for sched latency statistics\n\ttrackingSeq    uint8    // used to decide whether to track this G\n\trunnableStamp  int64    // timestamp of when the G last became runnable, only used when tracking\n\trunnableTime   int64    // the amount of time spent runnable, cleared when running, only used when tracking\n\tsysexitticks   int64    // cputicks when syscall has returned (for tracing)\n\ttraceseq       uint64   // trace event sequencer\n\ttracelastp     puintptr // last P emitted an event for this goroutine\n\tlockedm        muintptr\n\tsig            uint32\n\twritebuf       []byte\n\tsigcode0       uintptr\n\tsigcode1       uintptr\n\tsigpc          uintptr\n\tgopc           uintptr         // pc of go statement that created this goroutine\n\tancestors      *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)\n\tstartpc        uintptr         // pc of goroutine function\n\tracectx        uintptr\n\twaiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order\n\tcgoCtxt        []uintptr      // cgo traceback context\n\tlabels         unsafe.Pointer // profiler labels\n\ttimer          *timer         // cached timer for time.Sleep\n\tselectDone     uint32         // are we participating in a select and did someone win the race?\n\n\t// gcAssistBytes is this G's GC assist credit in terms of\n\t// bytes allocated. If this is positive, then the G has credit\n\t// to allocate gcAssistBytes bytes without assisting. If this\n\t// is negative, then the G must correct this by performing\n\t// scan work. We track this in bytes to make it fast to update\n\t// and check for debt in the malloc hot path. The assist ratio\n\t// determines how this corresponds to scan work debt.\n\tgcAssistBytes int64\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#beforeIdle",
                    "documentation": {
                      "identifier": "beforeIdle",
                      "newPage": false,
                      "searchKey": "runtime.beforeIdle",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func beforeIdle(int64, int64) (*g, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc beforeIdle(int64, int64) (*g, bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#wakefing",
                    "documentation": {
                      "identifier": "wakefing",
                      "newPage": false,
                      "searchKey": "runtime.wakefing",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func wakefing() *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc wakefing() *g\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#netpollunblock",
                    "documentation": {
                      "identifier": "netpollunblock",
                      "newPage": false,
                      "searchKey": "runtime.netpollunblock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc netpollunblock(pd *pollDesc, mode int32, ioready bool) *g\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#atomicAllG",
                    "documentation": {
                      "identifier": "atomicAllG",
                      "newPage": false,
                      "searchKey": "runtime.atomicAllG",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func atomicAllG() (**g, uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc atomicAllG() (**g, uintptr)\n```\n\natomicAllG returns &allgs[0] and len(allgs) for use with atomicAllGIndex. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#atomicAllGIndex",
                    "documentation": {
                      "identifier": "atomicAllGIndex",
                      "newPage": false,
                      "searchKey": "runtime.atomicAllGIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func atomicAllGIndex(ptr **g, i uintptr) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc atomicAllGIndex(ptr **g, i uintptr) *g\n```\n\natomicAllGIndex returns ptr[i] with the allgptr returned from atomicAllG. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#findrunnable",
                    "documentation": {
                      "identifier": "findrunnable",
                      "newPage": false,
                      "searchKey": "runtime.findrunnable",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func findrunnable() (gp *g, inheritTime bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc findrunnable() (gp *g, inheritTime bool)\n```\n\nFinds a runnable goroutine to execute. Tries to steal from other P's, get g from local or global queue, poll network. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#stealWork",
                    "documentation": {
                      "identifier": "stealWork",
                      "newPage": false,
                      "searchKey": "runtime.stealWork",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func stealWork(now int64) (gp *g, inheritTime bool, rnow, pollUntil int64, newWork bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc stealWork(now int64) (gp *g, inheritTime bool, rnow, pollUntil int64, newWork bool)\n```\n\nstealWork attempts to steal a runnable goroutine or timer from any P. \n\nIf newWork is true, new work may have been readied. \n\nIf now is not 0 it is the current time. stealWork returns the passed time or the current time if now was passed as 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#checkIdleGCNoP",
                    "documentation": {
                      "identifier": "checkIdleGCNoP",
                      "newPage": false,
                      "searchKey": "runtime.checkIdleGCNoP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func checkIdleGCNoP() (*p, *g)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc checkIdleGCNoP() (*p, *g)\n```\n\nCheck for idle-priority GC, without a P on entry. \n\nIf some GC work, a P, and a worker G are all available, the P and G will be returned. The returned P has not been wired yet. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#malg",
                    "documentation": {
                      "identifier": "malg",
                      "newPage": false,
                      "searchKey": "runtime.malg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func malg(stacksize int32) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc malg(stacksize int32) *g\n```\n\nAllocate a new g, with a stack big enough for stacksize bytes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#newproc1",
                    "documentation": {
                      "identifier": "newproc1",
                      "newPage": false,
                      "searchKey": "runtime.newproc1",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g\n```\n\nCreate a new g in state _Grunnable, starting at fn, with narg bytes of arguments starting at argp. callerpc is the address of the go statement that created this. The caller is responsible for adding the new g to the scheduler. \n\nThis must run on the system stack because it's the continuation of newproc, which cannot split the stack. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gfget",
                    "documentation": {
                      "identifier": "gfget",
                      "newPage": false,
                      "searchKey": "runtime.gfget",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func gfget(_p_ *p) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc gfget(_p_ *p) *g\n```\n\nGet from gfree list. If local list is empty, grab a batch from global list. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#globrunqget",
                    "documentation": {
                      "identifier": "globrunqget",
                      "newPage": false,
                      "searchKey": "runtime.globrunqget",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func globrunqget(_p_ *p, max int32) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc globrunqget(_p_ *p, max int32) *g\n```\n\nTry get a batch of G's from the global runnable queue. sched.lock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#runqget",
                    "documentation": {
                      "identifier": "runqget",
                      "newPage": false,
                      "searchKey": "runtime.runqget",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func runqget(_p_ *p) (gp *g, inheritTime bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc runqget(_p_ *p) (gp *g, inheritTime bool)\n```\n\nGet g from local runnable queue. If inheritTime is true, gp should inherit the remaining time in the current time slice. Otherwise, it should start a new time slice. Executed only by the owner P. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#runqsteal",
                    "documentation": {
                      "identifier": "runqsteal",
                      "newPage": false,
                      "searchKey": "runtime.runqsteal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func runqsteal(_p_, p2 *p, stealRunNextG bool) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc runqsteal(_p_, p2 *p, stealRunNextG bool) *g\n```\n\nSteal half of elements from local runnable queue of p2 and put onto local runnable queue of p. Returns one of the stolen elements (or nil if failed). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigFetchG",
                    "documentation": {
                      "identifier": "sigFetchG",
                      "newPage": false,
                      "searchKey": "runtime.sigFetchG",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func sigFetchG(c *sigctxt) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc sigFetchG(c *sigctxt) *g\n```\n\nsigFetchG fetches the value of G safely when running in a signal handler. On some architectures, the g value may be clobbered when running in a VDSO. See issue #32912. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#getg",
                    "documentation": {
                      "identifier": "getg",
                      "newPage": false,
                      "searchKey": "runtime.getg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func getg() *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc getg() *g\n```\n\ngetg returns the pointer to the current g. The compiler rewrites calls to this function into instructions that fetch the g directly (from TLS or from the dedicated register). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceReader",
                    "documentation": {
                      "identifier": "traceReader",
                      "newPage": false,
                      "searchKey": "runtime.traceReader",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func traceReader() *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc traceReader() *g\n```\n\ntraceReader returns the trace reader that should be woken up, if any. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#Getg",
                    "documentation": {
                      "identifier": "Getg",
                      "newPage": false,
                      "searchKey": "runtime.Getg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Getg() *G"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Getg() *G\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#m",
              "documentation": {
                "identifier": "m",
                "newPage": false,
                "searchKey": "runtime.m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type m struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype m struct {\n\tg0      *g     // goroutine with scheduling stack\n\tmorebuf gobuf  // gobuf arg to morestack\n\tdivmod  uint32 // div/mod denominator for arm - known to liblink\n\n\t// Fields not known to debuggers.\n\tprocid        uint64            // for debuggers, but offset not hard-coded\n\tgsignal       *g                // signal-handling g\n\tgoSigStack    gsignalStack      // Go-allocated signal handling stack\n\tsigmask       sigset            // storage for saved signal mask\n\ttls           [tlsSlots]uintptr // thread-local storage (for x86 extern register)\n\tmstartfn      func()\n\tcurg          *g       // current running goroutine\n\tcaughtsig     guintptr // goroutine running during fatal signal\n\tp             puintptr // attached p for executing go code (nil if not executing go code)\n\tnextp         puintptr\n\toldp          puintptr // the p that was attached before executing a syscall\n\tid            int64\n\tmallocing     int32\n\tthrowing      int32\n\tpreemptoff    string // if != \"\", keep curg running on this m\n\tlocks         int32\n\tdying         int32\n\tprofilehz     int32\n\tspinning      bool // m is out of work and is actively looking for work\n\tblocked       bool // m is blocked on a note\n\tnewSigstack   bool // minit on C thread called sigaltstack\n\tprintlock     int8\n\tincgo         bool   // m is executing a cgo call\n\tfreeWait      uint32 // if == 0, safe to free g0 and delete m (atomic)\n\tfastrand      [2]uint32\n\tneedextram    bool\n\ttraceback     uint8\n\tncgocall      uint64      // number of cgo calls in total\n\tncgo          int32       // number of cgo calls currently in progress\n\tcgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily\n\tcgoCallers    *cgoCallers // cgo traceback if crashing in cgo call\n\tdoesPark      bool        // non-P running threads: sysmon and newmHandoff never use .park\n\tpark          note\n\talllink       *m // on allm\n\tschedlink     muintptr\n\tlockedg       guintptr\n\tcreatestack   [32]uintptr // stack that created this thread.\n\tlockedExt     uint32      // tracking for external LockOSThread\n\tlockedInt     uint32      // tracking for internal lockOSThread\n\tnextwaitm     muintptr    // next m waiting for lock\n\twaitunlockf   func(*g, unsafe.Pointer) bool\n\twaitlock      unsafe.Pointer\n\twaittraceev   byte\n\twaittraceskip int\n\tstartingtrace bool\n\tsyscalltick   uint32\n\tfreelink      *m // on sched.freem\n\n\t// mFixup is used to synchronize OS related m state\n\t// (credentials etc) use mutex to access. To avoid deadlocks\n\t// an atomic.Load() of used being zero in mDoFixupFn()\n\t// guarantees fn is nil.\n\tmFixup struct {\n\t\tlock mutex\n\t\tused uint32\n\t\tfn   func(bool) bool\n\t}\n\n\t// these are here because they are too large to be on the stack\n\t// of low-level NOSPLIT functions.\n\tlibcall   libcall\n\tlibcallpc uintptr // for cpu profiler\n\tlibcallsp uintptr\n\tlibcallg  guintptr\n\tsyscall   libcall // stores syscall parameters on windows\n\n\tvdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call)\n\tvdsoPC uintptr // PC for traceback while in VDSO call\n\n\t// preemptGen counts the number of completed preemption\n\t// signals. This is used to detect when a preemption is\n\t// requested, but fails. Accessed atomically.\n\tpreemptGen uint32\n\n\t// Whether this is a pending preemption signal on this M.\n\t// Accessed atomically.\n\tsignalPending uint32\n\n\tdlogPerM\n\n\tmOS\n\n\t// Up to 10 locks held by this m, maintained by the lock ranking code.\n\tlocksHeldLen int\n\tlocksHeld    [10]heldLockInfo\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#allocm",
                    "documentation": {
                      "identifier": "allocm",
                      "newPage": false,
                      "searchKey": "runtime.allocm",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func allocm(_p_ *p, fn func(), id int64) *m"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc allocm(_p_ *p, fn func(), id int64) *m\n```\n\nAllocate a new m unassociated with any thread. Can use p for allocation context if needed. fn is recorded as the new m's m.mstartfn. id is optional pre-allocated m ID. Omit by passing -1. \n\nThis function is allowed to have write barriers even if the caller isn't because it borrows _p_. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#lockextra",
                    "documentation": {
                      "identifier": "lockextra",
                      "newPage": false,
                      "searchKey": "runtime.lockextra",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func lockextra(nilokay bool) *m"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc lockextra(nilokay bool) *m\n```\n\nlockextra locks the extra list and returns the list head. The caller must unlock the list by storing a new list head to extram. If nilokay is true, then lockextra will return a nil list head if that's what it finds. If nilokay is false, lockextra will keep waiting until the list head is no longer nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mget",
                    "documentation": {
                      "identifier": "mget",
                      "newPage": false,
                      "searchKey": "runtime.mget",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mget() *m"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mget() *m\n```\n\nTry to get an m from midle list. sched.lock must be held. May run during STW, so write barriers are not allowed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#acquirem",
                    "documentation": {
                      "identifier": "acquirem",
                      "newPage": false,
                      "searchKey": "runtime.acquirem",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func acquirem() *m"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc acquirem() *m\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceAcquireBuffer",
                    "documentation": {
                      "identifier": "traceAcquireBuffer",
                      "newPage": false,
                      "searchKey": "runtime.traceAcquireBuffer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func traceAcquireBuffer() (mp *m, pid int32, bufp *traceBufPtr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc traceAcquireBuffer() (mp *m, pid int32, bufp *traceBufPtr)\n```\n\ntraceAcquireBuffer returns trace buffer to use and, if necessary, locks it. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#p",
              "documentation": {
                "identifier": "p",
                "newPage": false,
                "searchKey": "runtime.p",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type p struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype p struct {\n\tid          int32\n\tstatus      uint32 // one of pidle/prunning/...\n\tlink        puintptr\n\tschedtick   uint32     // incremented on every scheduler call\n\tsyscalltick uint32     // incremented on every system call\n\tsysmontick  sysmontick // last tick observed by sysmon\n\tm           muintptr   // back-link to associated m (nil if idle)\n\tmcache      *mcache\n\tpcache      pageCache\n\traceprocctx uintptr\n\n\tdeferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)\n\tdeferpoolbuf [5][32]*_defer\n\n\t// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.\n\tgoidcache    uint64\n\tgoidcacheend uint64\n\n\t// Queue of runnable goroutines. Accessed without lock.\n\trunqhead uint32\n\trunqtail uint32\n\trunq     [256]guintptr\n\t// runnext, if non-nil, is a runnable G that was ready'd by\n\t// the current G and should be run next instead of what's in\n\t// runq if there's time remaining in the running G's time\n\t// slice. It will inherit the time left in the current time\n\t// slice. If a set of goroutines is locked in a\n\t// communicate-and-wait pattern, this schedules that set as a\n\t// unit and eliminates the (potentially large) scheduling\n\t// latency that otherwise arises from adding the ready'd\n\t// goroutines to the end of the run queue.\n\t//\n\t// Note that while other P's may atomically CAS this to zero,\n\t// only the owner P can CAS it to a valid G.\n\trunnext guintptr\n\n\t// Available G's (status == Gdead)\n\tgFree struct {\n\t\tgList\n\t\tn int32\n\t}\n\n\tsudogcache []*sudog\n\tsudogbuf   [128]*sudog\n\n\t// Cache of mspan objects from the heap.\n\tmspancache struct {\n\t\t// We need an explicit length here because this field is used\n\t\t// in allocation codepaths where write barriers are not allowed,\n\t\t// and eliminating the write barrier/keeping it eliminated from\n\t\t// slice updates is tricky, moreso than just managing the length\n\t\t// ourselves.\n\t\tlen int\n\t\tbuf [128]*mspan\n\t}\n\n\ttracebuf traceBufPtr\n\n\t// traceSweep indicates the sweep events should be traced.\n\t// This is used to defer the sweep start event until a span\n\t// has actually been swept.\n\ttraceSweep bool\n\t// traceSwept and traceReclaimed track the number of bytes\n\t// swept and reclaimed by sweeping in the current sweep loop.\n\ttraceSwept, traceReclaimed uintptr\n\n\tpalloc persistentAlloc // per-P to avoid mutex\n\n\t_ uint32 // Alignment for atomic fields below\n\n\t// The when field of the first entry on the timer heap.\n\t// This is updated using atomic functions.\n\t// This is 0 if the timer heap is empty.\n\ttimer0When uint64\n\n\t// The earliest known nextwhen field of a timer with\n\t// timerModifiedEarlier status. Because the timer may have been\n\t// modified again, there need not be any timer with this value.\n\t// This is updated using atomic functions.\n\t// This is 0 if the value is unknown.\n\ttimerModifiedEarliest uint64\n\n\t// Per-P GC state\n\tgcAssistTime         int64 // Nanoseconds in assistAlloc\n\tgcFractionalMarkTime int64 // Nanoseconds in fractional mark worker (atomic)\n\n\t// gcMarkWorkerMode is the mode for the next mark worker to run in.\n\t// That is, this is used to communicate with the worker goroutine\n\t// selected for immediate execution by\n\t// gcController.findRunnableGCWorker. When scheduling other goroutines,\n\t// this field must be set to gcMarkWorkerNotWorker.\n\tgcMarkWorkerMode gcMarkWorkerMode\n\t// gcMarkWorkerStartTime is the nanotime() at which the most recent\n\t// mark worker started.\n\tgcMarkWorkerStartTime int64\n\n\t// gcw is this P's GC work buffer cache. The work buffer is\n\t// filled by write barriers, drained by mutator assists, and\n\t// disposed on certain GC state transitions.\n\tgcw gcWork\n\n\t// wbBuf is this P's GC write barrier buffer.\n\t//\n\t// TODO: Consider caching this in the running G.\n\twbBuf wbBuf\n\n\trunSafePointFn uint32 // if 1, run sched.safePointFn at next safe point\n\n\t// statsSeq is a counter indicating whether this P is currently\n\t// writing any stats. Its value is even when not, odd when it is.\n\tstatsSeq uint32\n\n\t// Lock for timers. We normally access the timers while running\n\t// on this P, but the scheduler can also do it from a different P.\n\ttimersLock mutex\n\n\t// Actions to take at some time. This is used to implement the\n\t// standard library's time package.\n\t// Must hold timersLock to access.\n\ttimers []*timer\n\n\t// Number of timers in P's heap.\n\t// Modified using atomic instructions.\n\tnumTimers uint32\n\n\t// Number of timerModifiedEarlier timers on P's heap.\n\t// This should only be modified while holding timersLock,\n\t// or while the timer status is in a transient state\n\t// such as timerModifying.\n\tadjustTimers uint32\n\n\t// Number of timerDeleted timers in P's heap.\n\t// Modified using atomic instructions.\n\tdeletedTimers uint32\n\n\t// Race context used while executing timer functions.\n\ttimerRaceCtx uintptr\n\n\t// preempt is set to indicate that this P should be enter the\n\t// scheduler ASAP (regardless of what G is running on it).\n\tpreempt bool\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#checkRunqsNoP",
                    "documentation": {
                      "identifier": "checkRunqsNoP",
                      "newPage": false,
                      "searchKey": "runtime.checkRunqsNoP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func checkRunqsNoP(allpSnapshot []*p, idlepMaskSnapshot pMask) *p"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc checkRunqsNoP(allpSnapshot []*p, idlepMaskSnapshot pMask) *p\n```\n\nCheck all Ps for a runnable G to steal. \n\nOn entry we have no P. If a G is available to steal and a P is available, the P is returned which the caller should acquire and attempt to steal the work to. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#checkIdleGCNoP",
                    "documentation": {
                      "identifier": "checkIdleGCNoP",
                      "newPage": false,
                      "searchKey": "runtime.checkIdleGCNoP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func checkIdleGCNoP() (*p, *g)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc checkIdleGCNoP() (*p, *g)\n```\n\nCheck for idle-priority GC, without a P on entry. \n\nIf some GC work, a P, and a worker G are all available, the P and G will be returned. The returned P has not been wired yet. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#procresize",
                    "documentation": {
                      "identifier": "procresize",
                      "newPage": false,
                      "searchKey": "runtime.procresize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func procresize(nprocs int32) *p"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc procresize(nprocs int32) *p\n```\n\nChange number of processors. \n\nsched.lock must be held, and the world must be stopped. \n\ngcworkbufs must not be being modified by either the GC or the write barrier code, so the GC must not be running if the number of Ps actually changes. \n\nReturns list of Ps with local work, they need to be scheduled by the caller. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#releasep",
                    "documentation": {
                      "identifier": "releasep",
                      "newPage": false,
                      "searchKey": "runtime.releasep",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func releasep() *p"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc releasep() *p\n```\n\nDisassociate p and the current m. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#pidleget",
                    "documentation": {
                      "identifier": "pidleget",
                      "newPage": false,
                      "searchKey": "runtime.pidleget",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func pidleget() *p"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc pidleget() *p\n```\n\npidleget tries to get a p from the _Pidle list, acquiring ownership. \n\nsched.lock must be held. \n\nMay run during STW, so write barriers are not allowed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#timeSleepUntil",
                    "documentation": {
                      "identifier": "timeSleepUntil",
                      "newPage": false,
                      "searchKey": "runtime.timeSleepUntil",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func timeSleepUntil() (int64, *p)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc timeSleepUntil() (int64, *p)\n```\n\ntimeSleepUntil returns the time when the next timer should fire, and the P that holds the timer heap that that timer is on. This is only called by sysmon and checkdead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#p.init",
                    "documentation": {
                      "identifier": "p.init",
                      "newPage": false,
                      "searchKey": "runtime.p.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pp *p) init(id int32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pp *p) init(id int32)\n```\n\ninit initializes pp, which may be a freshly allocated p or a previously destroyed p, and transitions it to status _Pgcstop. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#p.destroy",
                    "documentation": {
                      "identifier": "p.destroy",
                      "newPage": false,
                      "searchKey": "runtime.p.destroy",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (pp *p) destroy()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (pp *p) destroy()\n```\n\ndestroy releases all of the resources associated with pp and transitions it to status _Pdead. \n\nsched.lock must be held and the world must be stopped. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#schedt",
              "documentation": {
                "identifier": "schedt",
                "newPage": false,
                "searchKey": "runtime.schedt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type schedt struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype schedt struct {\n\t// accessed atomically. keep at top to ensure alignment on 32-bit systems.\n\tgoidgen   uint64\n\tlastpoll  uint64 // time of last network poll, 0 if currently polling\n\tpollUntil uint64 // time to which current poll is sleeping\n\n\tlock mutex\n\n\tmidle        muintptr // idle m's waiting for work\n\tnmidle       int32    // number of idle m's waiting for work\n\tnmidlelocked int32    // number of locked m's waiting for work\n\tmnext        int64    // number of m's that have been created and next M ID\n\tmaxmcount    int32    // maximum number of m's allowed (or die)\n\tnmsys        int32    // number of system m's not counted for deadlock\n\tnmfreed      int64    // cumulative number of freed m's\n\n\tngsys uint32 // number of system goroutines; updated atomically\n\n\tpidle      puintptr // idle p's\n\tnpidle     uint32\n\tnmspinning uint32 // See \"Worker thread parking/unparking\" comment in proc.go.\n\n\t// Global runnable queue.\n\trunq     gQueue\n\trunqsize int32\n\n\t// disable controls selective disabling of the scheduler.\n\t//\n\t// Use schedEnableUser to control this.\n\t//\n\t// disable is protected by sched.lock.\n\tdisable struct {\n\t\t// user disables scheduling of user goroutines.\n\t\tuser     bool\n\t\trunnable gQueue // pending runnable Gs\n\t\tn        int32  // length of runnable\n\t}\n\n\t// Global cache of dead G's.\n\tgFree struct {\n\t\tlock    mutex\n\t\tstack   gList // Gs with stacks\n\t\tnoStack gList // Gs without stacks\n\t\tn       int32\n\t}\n\n\t// Central cache of sudog structs.\n\tsudoglock  mutex\n\tsudogcache *sudog\n\n\t// Central pool of available defer structs of different sizes.\n\tdeferlock mutex\n\tdeferpool [5]*_defer\n\n\t// freem is the list of m's waiting to be freed when their\n\t// m.exited is set. Linked through m.freelink.\n\tfreem *m\n\n\tgcwaiting  uint32 // gc is waiting to run\n\tstopwait   int32\n\tstopnote   note\n\tsysmonwait uint32\n\tsysmonnote note\n\n\t// While true, sysmon not ready for mFixup calls.\n\t// Accessed atomically.\n\tsysmonStarting uint32\n\n\t// safepointFn should be called on each P at the next GC\n\t// safepoint if p.runSafePointFn is set.\n\tsafePointFn   func(*p)\n\tsafePointWait int32\n\tsafePointNote note\n\n\tprofilehz int32 // cpu profiling rate\n\n\tprocresizetime int64 // nanotime() of last change to gomaxprocs\n\ttotaltime      int64 // ∫gomaxprocs dt up to procresizetime\n\n\t// sysmonlock protects sysmon's actions on the runtime.\n\t//\n\t// Acquire and hold this mutex to block sysmon from interacting\n\t// with the rest of the runtime.\n\tsysmonlock mutex\n\n\t_ uint32 // ensure timeToRun has 8-byte alignment\n\n\t// timeToRun is a distribution of scheduling latencies, defined\n\t// as the sum of time a G spends in the _Grunnable state before\n\t// it transitions to _Grunning.\n\t//\n\t// timeToRun is protected by sched.lock.\n\ttimeToRun timeHistogram\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_func",
              "documentation": {
                "identifier": "_func",
                "newPage": false,
                "searchKey": "runtime._func",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type _func struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype _func struct {\n\tentry   uintptr // start pc\n\tnameoff int32   // function name\n\n\targs        int32  // in/out args size\n\tdeferreturn uint32 // offset of start of a deferreturn call instruction from entry, if any.\n\n\tpcsp      uint32\n\tpcfile    uint32\n\tpcln      uint32\n\tnpcdata   uint32\n\tcuOffset  uint32 // runtime.cutab offset of this function's CU\n\tfuncID    funcID // set for certain special runtime functions\n\tflag      funcFlag\n\t_         [1]byte // pad\n\tnfuncdata uint8   // must be last, must end on a uint32-aligned boundary\n}\n```\n\nLayout of in-memory per-function information prepared by linker See [https://golang.org/s/go12symtab](https://golang.org/s/go12symtab). Keep in sync with linker (../cmd/link/internal/ld/pcln.go:/pclntab) and with package debug/gosym and with symtab.go in package runtime. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcinl",
              "documentation": {
                "identifier": "funcinl",
                "newPage": false,
                "searchKey": "runtime.funcinl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcinl struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcinl struct {\n\tzero  uintptr // set to 0 to distinguish from _func\n\tentry uintptr // entry of the real (the \"outermost\") frame.\n\tname  string\n\tfile  string\n\tline  int\n}\n```\n\nPseudo-Func that is returned for PCs that occur in inlined code. A *Func can be either a *_func or a *funcinl, and they are distinguished by the first uintptr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itab",
              "documentation": {
                "identifier": "itab",
                "newPage": false,
                "searchKey": "runtime.itab",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type itab struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype itab struct {\n\tinter *interfacetype\n\t_type *_type\n\thash  uint32 // copy of _type.hash. Used for type switches.\n\t_     [4]byte\n\tfun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.\n}\n```\n\nlayout of Itab known to compilers allocated in non-garbage-collected memory Needs to be in sync with ../cmd/compile/internal/gc/reflect.go:/^func.WriteTabs. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#getitab",
                    "documentation": {
                      "identifier": "getitab",
                      "newPage": false,
                      "searchKey": "runtime.getitab",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func getitab(inter *interfacetype, typ *_type, canfail bool) *itab"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc getitab(inter *interfacetype, typ *_type, canfail bool) *itab\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#assertI2I",
                    "documentation": {
                      "identifier": "assertI2I",
                      "newPage": false,
                      "searchKey": "runtime.assertI2I",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func assertI2I(inter *interfacetype, tab *itab) *itab"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc assertI2I(inter *interfacetype, tab *itab) *itab\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#assertE2I",
                    "documentation": {
                      "identifier": "assertE2I",
                      "newPage": false,
                      "searchKey": "runtime.assertE2I",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func assertE2I(inter *interfacetype, t *_type) *itab"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc assertE2I(inter *interfacetype, t *_type) *itab\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#itab.init",
                    "documentation": {
                      "identifier": "itab.init",
                      "newPage": false,
                      "searchKey": "runtime.itab.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m *itab) init() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m *itab) init() string\n```\n\ninit fills in the m.fun array with all the code pointers for the m.inter/m._type pair. If the type does not implement the interface, it sets m.fun[0] to 0 and returns the name of an interface function that is missing. It is ok to call this multiple times on the same m, even concurrently. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lfnode",
              "documentation": {
                "identifier": "lfnode",
                "newPage": false,
                "searchKey": "runtime.lfnode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type lfnode struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype lfnode struct {\n\tnext    uint64\n\tpushcnt uintptr\n}\n```\n\nLock-free stack node. Also known to export_test.go. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#lfstackUnpack",
                    "documentation": {
                      "identifier": "lfstackUnpack",
                      "newPage": false,
                      "searchKey": "runtime.lfstackUnpack",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func lfstackUnpack(val uint64) *lfnode"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc lfstackUnpack(val uint64) *lfnode\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#forcegcstate",
              "documentation": {
                "identifier": "forcegcstate",
                "newPage": false,
                "searchKey": "runtime.forcegcstate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type forcegcstate struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype forcegcstate struct {\n\tlock mutex\n\tg    *g\n\tidle uint32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_defer",
              "documentation": {
                "identifier": "_defer",
                "newPage": false,
                "searchKey": "runtime._defer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type _defer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype _defer struct {\n\tsiz     int32 // includes both arguments and results\n\tstarted bool\n\theap    bool\n\t// openDefer indicates that this _defer is for a frame with open-coded\n\t// defers. We have only one defer record for the entire frame (which may\n\t// currently have 0, 1, or more defers active).\n\topenDefer bool\n\tsp        uintptr  // sp at time of defer\n\tpc        uintptr  // pc at time of defer\n\tfn        *funcval // can be nil for open-coded defers\n\t_panic    *_panic  // panic that is running defer\n\tlink      *_defer\n\n\t// If openDefer is true, the fields below record values about the stack\n\t// frame and associated function that has the open-coded defer(s). sp\n\t// above will be the sp for the frame, and pc will be address of the\n\t// deferreturn call in the function.\n\tfd   unsafe.Pointer // funcdata for the function associated with the frame\n\tvarp uintptr        // value of varp for the stack frame\n\t// framepc is the current pc associated with the stack frame. Together,\n\t// with sp above (which is the sp associated with the stack frame),\n\t// framepc/sp can be used as pc/sp pair to continue a stack trace via\n\t// gentraceback().\n\tframepc uintptr\n}\n```\n\nA _defer holds an entry on the list of deferred calls. If you add a field here, add code to clear it in freedefer and deferProcStack This struct must match the code in cmd/compile/internal/gc/reflect.go:deferstruct and cmd/compile/internal/gc/ssa.go:(*state).call. Some defers will be allocated on the stack and some on the heap. All defers are logically part of the stack, so write barriers to initialize them are not required. All defers must be manually scanned, and for heap defers, marked. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#newdefer",
                    "documentation": {
                      "identifier": "newdefer",
                      "newPage": false,
                      "searchKey": "runtime.newdefer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newdefer(siz int32) *_defer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newdefer(siz int32) *_defer\n```\n\nAllocate a Defer, usually using per-P pool. Each defer must be released with freedefer.  The defer is not added to any defer chain yet. \n\nThis must not grow the stack because there may be a frame without stack map information when this is called. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_panic",
              "documentation": {
                "identifier": "_panic",
                "newPage": false,
                "searchKey": "runtime._panic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type _panic struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype _panic struct {\n\targp      unsafe.Pointer // pointer to arguments of deferred call run during panic; cannot move - known to liblink\n\targ       interface{}    // argument to panic\n\tlink      *_panic        // link to earlier panic\n\tpc        uintptr        // where to return to in runtime if this panic is bypassed\n\tsp        unsafe.Pointer // where to return to in runtime if this panic is bypassed\n\trecovered bool           // whether this panic is over\n\taborted   bool           // the panic was aborted\n\tgoexit    bool\n}\n```\n\nA _panic holds information about an active panic. \n\nA _panic value must only ever live on the stack. \n\nThe argp and link fields are stack pointers, but don't need special handling during stack growth: because they are pointer-typed and _panic values only live on the stack, regular stack pointer adjustment takes care of them. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stkframe",
              "documentation": {
                "identifier": "stkframe",
                "newPage": false,
                "searchKey": "runtime.stkframe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stkframe struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stkframe struct {\n\tfn       funcInfo   // function being run\n\tpc       uintptr    // program counter within fn\n\tcontinpc uintptr    // program counter where execution can continue, or 0 if not\n\tlr       uintptr    // program counter at caller aka link register\n\tsp       uintptr    // stack pointer at pc\n\tfp       uintptr    // stack pointer at caller aka frame pointer\n\tvarp     uintptr    // top of local variables\n\targp     uintptr    // pointer to function arguments\n\targlen   uintptr    // number of bytes at argp\n\targmap   *bitvector // force use of this argmap\n}\n```\n\nstack traces \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ancestorInfo",
              "documentation": {
                "identifier": "ancestorInfo",
                "newPage": false,
                "searchKey": "runtime.ancestorInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ancestorInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ancestorInfo struct {\n\tpcs  []uintptr // pcs from the stack of this goroutine\n\tgoid int64     // goroutine id of this goroutine; original goroutine possibly dead\n\tgopc uintptr   // pc of go statement that created this goroutine\n}\n```\n\nancestorInfo records details of where a goroutine was started. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitReason",
              "documentation": {
                "identifier": "waitReason",
                "newPage": false,
                "searchKey": "runtime.waitReason",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type waitReason uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype waitReason uint8\n```\n\nA waitReason explains why a goroutine has been stopped. See gopark. Do not re-use waitReasons, add new ones. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#waitReason.String",
                    "documentation": {
                      "identifier": "waitReason.String",
                      "newPage": false,
                      "searchKey": "runtime.waitReason.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (w waitReason) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (w waitReason) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#rwmutex",
              "documentation": {
                "identifier": "rwmutex",
                "newPage": false,
                "searchKey": "runtime.rwmutex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type rwmutex struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype rwmutex struct {\n\trLock      mutex    // protects readers, readerPass, writer\n\treaders    muintptr // list of pending readers\n\treaderPass uint32   // number of pending readers to skip readers list\n\n\twLock  mutex    // serializes writers\n\twriter muintptr // pending writer waiting for completing readers\n\n\treaderCount uint32 // number of pending readers\n\treaderWait  uint32 // number of departing readers\n}\n```\n\nA rwmutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer. This is a variant of sync.RWMutex, for the runtime package. Like mutex, rwmutex blocks the calling M. It does not interact with the goroutine scheduler. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#rwmutex.rlock",
                    "documentation": {
                      "identifier": "rwmutex.rlock",
                      "newPage": false,
                      "searchKey": "runtime.rwmutex.rlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rw *rwmutex) rlock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rw *rwmutex) rlock()\n```\n\nrlock locks rw for reading. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#rwmutex.runlock",
                    "documentation": {
                      "identifier": "rwmutex.runlock",
                      "newPage": false,
                      "searchKey": "runtime.rwmutex.runlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rw *rwmutex) runlock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rw *rwmutex) runlock()\n```\n\nrunlock undoes a single rlock call on rw. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#rwmutex.lock",
                    "documentation": {
                      "identifier": "rwmutex.lock",
                      "newPage": false,
                      "searchKey": "runtime.rwmutex.lock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rw *rwmutex) lock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rw *rwmutex) lock()\n```\n\nlock locks rw for writing. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#rwmutex.unlock",
                    "documentation": {
                      "identifier": "rwmutex.unlock",
                      "newPage": false,
                      "searchKey": "runtime.rwmutex.unlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rw *rwmutex) unlock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rw *rwmutex) unlock()\n```\n\nunlock unlocks rw for writing. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#scase",
              "documentation": {
                "identifier": "scase",
                "newPage": false,
                "searchKey": "runtime.scase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type scase struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype scase struct {\n\tc    *hchan         // chan\n\telem unsafe.Pointer // data element\n}\n```\n\nSelect case descriptor. Known to compiler. Changes here must also be made in src/cmd/internal/gc/select.go's scasetype. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtimeSelect",
              "documentation": {
                "identifier": "runtimeSelect",
                "newPage": false,
                "searchKey": "runtime.runtimeSelect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type runtimeSelect struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype runtimeSelect struct {\n\tdir selectDir\n\ttyp unsafe.Pointer // channel type (not used here)\n\tch  *hchan         // channel\n\tval unsafe.Pointer // ptr to data (SendDir) or ptr to receive buffer (RecvDir)\n}\n```\n\nA runtimeSelect is a single case passed to rselect. This must match ../reflect/value.go:/runtimeSelect \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#selectDir",
              "documentation": {
                "identifier": "selectDir",
                "newPage": false,
                "searchKey": "runtime.selectDir",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type selectDir int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype selectDir int\n```\n\nThese values must match ../reflect/value.go:/SelectDir. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semaRoot",
              "documentation": {
                "identifier": "semaRoot",
                "newPage": false,
                "searchKey": "runtime.semaRoot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type semaRoot struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype semaRoot struct {\n\tlock  mutex\n\ttreap *sudog // root of balanced tree of unique waiters.\n\tnwait uint32 // Number of waiters. Read w/o the lock.\n}\n```\n\nA semaRoot holds a balanced tree of sudog with distinct addresses (s.elem). Each of those sudog may in turn point (through s.waitlink) to a list of other sudogs waiting on the same address. The operations on the inner lists of sudogs with the same address are all O(1). The scanning of the top-level semaRoot list is O(log n), where n is the number of distinct addresses with goroutines blocked on them that hash to the given semaRoot. See golang.org/issue/17953 for a program that worked badly before we introduced the second level of list, and test/locklinear.go for a test that exercises this. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#semroot",
                    "documentation": {
                      "identifier": "semroot",
                      "newPage": false,
                      "searchKey": "runtime.semroot",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func semroot(addr *uint32) *semaRoot"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc semroot(addr *uint32) *semaRoot\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#semaRoot.queue",
                    "documentation": {
                      "identifier": "semaRoot.queue",
                      "newPage": false,
                      "searchKey": "runtime.semaRoot.queue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool)\n```\n\nqueue adds s to the blocked goroutines in semaRoot. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#semaRoot.dequeue",
                    "documentation": {
                      "identifier": "semaRoot.dequeue",
                      "newPage": false,
                      "searchKey": "runtime.semaRoot.dequeue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (root *semaRoot) dequeue(addr *uint32) (found *sudog, now int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (root *semaRoot) dequeue(addr *uint32) (found *sudog, now int64)\n```\n\ndequeue searches for and finds the first goroutine in semaRoot blocked on addr. If the sudog was being profiled, dequeue returns the time at which it was woken up as now. Otherwise now is 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#semaRoot.rotateLeft",
                    "documentation": {
                      "identifier": "semaRoot.rotateLeft",
                      "newPage": false,
                      "searchKey": "runtime.semaRoot.rotateLeft",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (root *semaRoot) rotateLeft(x *sudog)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (root *semaRoot) rotateLeft(x *sudog)\n```\n\nrotateLeft rotates the tree rooted at node x. turning (x a (y b c)) into (y (x a b) c). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#semaRoot.rotateRight",
                    "documentation": {
                      "identifier": "semaRoot.rotateRight",
                      "newPage": false,
                      "searchKey": "runtime.semaRoot.rotateRight",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (root *semaRoot) rotateRight(y *sudog)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (root *semaRoot) rotateRight(y *sudog)\n```\n\nrotateRight rotates the tree rooted at node y. turning (y (x a b) c) into (x a (y b c)). \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semaProfileFlags",
              "documentation": {
                "identifier": "semaProfileFlags",
                "newPage": false,
                "searchKey": "runtime.semaProfileFlags",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type semaProfileFlags int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype semaProfileFlags int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notifyList",
              "documentation": {
                "identifier": "notifyList",
                "newPage": false,
                "searchKey": "runtime.notifyList",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type notifyList struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype notifyList struct {\n\t// wait is the ticket number of the next waiter. It is atomically\n\t// incremented outside the lock.\n\twait uint32\n\n\t// notify is the ticket number of the next waiter to be notified. It can\n\t// be read outside the lock, but is only written to with lock held.\n\t//\n\t// Both wait & notify can wrap around, and such cases will be correctly\n\t// handled as long as their \"unwrapped\" difference is bounded by 2^31.\n\t// For this not to be the case, we'd need to have 2^31+ goroutines\n\t// blocked on the same condvar, which is currently not possible.\n\tnotify uint32\n\n\t// List of parked waiters.\n\tlock mutex\n\thead *sudog\n\ttail *sudog\n}\n```\n\nnotifyList is a ticket-based notification list used to implement sync.Cond. \n\nIt must be kept in sync with the sync package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigctxt",
              "documentation": {
                "identifier": "sigctxt",
                "newPage": false,
                "searchKey": "runtime.sigctxt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sigctxt struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sigctxt struct {\n\tinfo *siginfo\n\tctxt unsafe.Pointer\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.sigpc",
                    "documentation": {
                      "identifier": "sigctxt.sigpc",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.sigpc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) sigpc() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) sigpc() uintptr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.sigsp",
                    "documentation": {
                      "identifier": "sigctxt.sigsp",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.sigsp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) sigsp() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) sigsp() uintptr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.siglr",
                    "documentation": {
                      "identifier": "sigctxt.siglr",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.siglr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) siglr() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) siglr() uintptr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.fault",
                    "documentation": {
                      "identifier": "sigctxt.fault",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.fault",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) fault() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) fault() uintptr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.preparePanic",
                    "documentation": {
                      "identifier": "sigctxt.preparePanic",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.preparePanic",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) preparePanic(sig uint32, gp *g)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) preparePanic(sig uint32, gp *g)\n```\n\npreparePanic sets up the stack to look like a call to sigpanic. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.pushCall",
                    "documentation": {
                      "identifier": "sigctxt.pushCall",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.pushCall",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) pushCall(targetPC, resumePC uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) pushCall(targetPC, resumePC uintptr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.regs",
                    "documentation": {
                      "identifier": "sigctxt.regs",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.regs",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) regs() *regs64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) regs() *regs64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.rax",
                    "documentation": {
                      "identifier": "sigctxt.rax",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.rax",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) rax() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) rax() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.rbx",
                    "documentation": {
                      "identifier": "sigctxt.rbx",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.rbx",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) rbx() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) rbx() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.rcx",
                    "documentation": {
                      "identifier": "sigctxt.rcx",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.rcx",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) rcx() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) rcx() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.rdx",
                    "documentation": {
                      "identifier": "sigctxt.rdx",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.rdx",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) rdx() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) rdx() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.rdi",
                    "documentation": {
                      "identifier": "sigctxt.rdi",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.rdi",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) rdi() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) rdi() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.rsi",
                    "documentation": {
                      "identifier": "sigctxt.rsi",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.rsi",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) rsi() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) rsi() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.rbp",
                    "documentation": {
                      "identifier": "sigctxt.rbp",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.rbp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) rbp() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) rbp() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.rsp",
                    "documentation": {
                      "identifier": "sigctxt.rsp",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.rsp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) rsp() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) rsp() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.r8",
                    "documentation": {
                      "identifier": "sigctxt.r8",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.r8",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) r8() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) r8() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.r9",
                    "documentation": {
                      "identifier": "sigctxt.r9",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.r9",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) r9() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) r9() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.r10",
                    "documentation": {
                      "identifier": "sigctxt.r10",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.r10",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) r10() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) r10() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.r11",
                    "documentation": {
                      "identifier": "sigctxt.r11",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.r11",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) r11() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) r11() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.r12",
                    "documentation": {
                      "identifier": "sigctxt.r12",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.r12",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) r12() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) r12() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.r13",
                    "documentation": {
                      "identifier": "sigctxt.r13",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.r13",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) r13() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) r13() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.r14",
                    "documentation": {
                      "identifier": "sigctxt.r14",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.r14",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) r14() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) r14() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.r15",
                    "documentation": {
                      "identifier": "sigctxt.r15",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.r15",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) r15() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) r15() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.rip",
                    "documentation": {
                      "identifier": "sigctxt.rip",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.rip",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) rip() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) rip() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.rflags",
                    "documentation": {
                      "identifier": "sigctxt.rflags",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.rflags",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) rflags() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) rflags() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.cs",
                    "documentation": {
                      "identifier": "sigctxt.cs",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.cs",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) cs() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) cs() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.fs",
                    "documentation": {
                      "identifier": "sigctxt.fs",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.fs",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) fs() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) fs() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.gs",
                    "documentation": {
                      "identifier": "sigctxt.gs",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.gs",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) gs() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) gs() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.sigcode",
                    "documentation": {
                      "identifier": "sigctxt.sigcode",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.sigcode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) sigcode() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) sigcode() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.sigaddr",
                    "documentation": {
                      "identifier": "sigctxt.sigaddr",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.sigaddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) sigaddr() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) sigaddr() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.set_rip",
                    "documentation": {
                      "identifier": "sigctxt.set_rip",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.set_rip",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) set_rip(x uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) set_rip(x uint64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.set_rsp",
                    "documentation": {
                      "identifier": "sigctxt.set_rsp",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.set_rsp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) set_rsp(x uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) set_rsp(x uint64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.set_sigcode",
                    "documentation": {
                      "identifier": "sigctxt.set_sigcode",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.set_sigcode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) set_sigcode(x uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) set_sigcode(x uint64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.set_sigaddr",
                    "documentation": {
                      "identifier": "sigctxt.set_sigaddr",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.set_sigaddr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) set_sigaddr(x uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) set_sigaddr(x uint64)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigctxt.fixsigcode",
                    "documentation": {
                      "identifier": "sigctxt.fixsigcode",
                      "newPage": false,
                      "searchKey": "runtime.sigctxt.fixsigcode",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *sigctxt) fixsigcode(sig uint32)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *sigctxt) fixsigcode(sig uint32)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigTabT",
              "documentation": {
                "identifier": "sigTabT",
                "newPage": false,
                "searchKey": "runtime.sigTabT",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type sigTabT struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype sigTabT struct {\n\tflags int32\n\tname  string\n}\n```\n\nsigTabT is the type of an entry in the global sigtable array. sigtable is inherently system dependent, and appears in OS-specific files, but sigTabT is the same for all Unixy systems. The sigtable array is indexed by a system signal number to get the flags and printable name of each signal. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gsignalStack",
              "documentation": {
                "identifier": "gsignalStack",
                "newPage": false,
                "searchKey": "runtime.gsignalStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type gsignalStack struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype gsignalStack struct {\n\tstack       stack\n\tstackguard0 uintptr\n\tstackguard1 uintptr\n\tstktopsp    uintptr\n}\n```\n\ngsignalStack saves the fields of the gsignal stack changed by setGsignalStack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#slice",
              "documentation": {
                "identifier": "slice",
                "newPage": false,
                "searchKey": "runtime.slice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type slice struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype slice struct {\n\tarray unsafe.Pointer\n\tlen   int\n\tcap   int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#growslice",
                    "documentation": {
                      "identifier": "growslice",
                      "newPage": false,
                      "searchKey": "runtime.growslice",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func growslice(et *_type, old slice, cap int) slice"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc growslice(et *_type, old slice, cap int) slice\n```\n\ngrowslice handles slice growth during append. It is passed the slice element type, the old slice, and the desired new minimum capacity, and it returns a new slice with at least that capacity, with the old data copied into it. The new slice's length is set to the old slice's length, NOT to the new requested capacity. This is for codegen convenience. The old slice's length is used immediately to calculate where to write new values during an append. TODO: When the old backend is gone, reconsider this decision. The SSA backend might prefer the new length or to return only ptr/cap and save stack space. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notInHeapSlice",
              "documentation": {
                "identifier": "notInHeapSlice",
                "newPage": false,
                "searchKey": "runtime.notInHeapSlice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type notInHeapSlice struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype notInHeapSlice struct {\n\tarray *notInHeap\n\tlen   int\n\tcap   int\n}\n```\n\nA notInHeapSlice is a slice backed by go:notinheap memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackpoolItem",
              "documentation": {
                "identifier": "stackpoolItem",
                "newPage": false,
                "searchKey": "runtime.stackpoolItem",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stackpoolItem struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stackpoolItem struct {\n\tmu   mutex\n\tspan mSpanList\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#adjustinfo",
              "documentation": {
                "identifier": "adjustinfo",
                "newPage": false,
                "searchKey": "runtime.adjustinfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type adjustinfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype adjustinfo struct {\n\told   stack\n\tdelta uintptr // ptr distance from old to new stack (newbase - oldbase)\n\tcache pcvalueCache\n\n\t// sghi is the highest sudog.elem on the stack.\n\tsghi uintptr\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bitvector",
              "documentation": {
                "identifier": "bitvector",
                "newPage": false,
                "searchKey": "runtime.bitvector",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type bitvector struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bitvector struct {\n\tn        int32 // # of bits\n\tbytedata *uint8\n}\n```\n\nInformation from the compiler about the layout of stack frames. Note: this type must agree with reflect.bitVector. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#makeheapobjbv",
                    "documentation": {
                      "identifier": "makeheapobjbv",
                      "newPage": false,
                      "searchKey": "runtime.makeheapobjbv",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeheapobjbv(p uintptr, size uintptr) bitvector"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeheapobjbv(p uintptr, size uintptr) bitvector\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#progToPointerMask",
                    "documentation": {
                      "identifier": "progToPointerMask",
                      "newPage": false,
                      "searchKey": "runtime.progToPointerMask",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func progToPointerMask(prog *byte, size uintptr) bitvector"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc progToPointerMask(prog *byte, size uintptr) bitvector\n```\n\nprogToPointerMask returns the 1-bit pointer mask output by the GC program prog. size the size of the region described by prog, in bytes. The resulting bitvector will have no more than size/sys.PtrSize bits. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#getStackMap",
                    "documentation": {
                      "identifier": "getStackMap",
                      "newPage": false,
                      "searchKey": "runtime.getStackMap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func getStackMap(frame *stkframe, cache *pcvalueCache, debug bool) (locals, args bitvector, objs []stackObjectRecord)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc getStackMap(frame *stkframe, cache *pcvalueCache, debug bool) (locals, args bitvector, objs []stackObjectRecord)\n```\n\ngetStackMap returns the locals and arguments live pointer maps, and stack object list for frame. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#stackmapdata",
                    "documentation": {
                      "identifier": "stackmapdata",
                      "newPage": false,
                      "searchKey": "runtime.stackmapdata",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func stackmapdata(stkmap *stackmap, n int32) bitvector"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc stackmapdata(stkmap *stackmap, n int32) bitvector\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#getArgInfoFast",
                    "documentation": {
                      "identifier": "getArgInfoFast",
                      "newPage": false,
                      "searchKey": "runtime.getArgInfoFast",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func getArgInfoFast(f funcInfo, needArgMap bool) (arglen uintptr, argmap *bitvector, ok bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc getArgInfoFast(f funcInfo, needArgMap bool) (arglen uintptr, argmap *bitvector, ok bool)\n```\n\ngetArgInfoFast returns the argument frame information for a call to f. It is short and inlineable. However, it does not handle all functions. If ok reports false, you must call getArgInfo instead. TODO(josharian): once we do mid-stack inlining, call getArgInfo directly from getArgInfoFast and stop returning an ok bool. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#getArgInfo",
                    "documentation": {
                      "identifier": "getArgInfo",
                      "newPage": false,
                      "searchKey": "runtime.getArgInfo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func getArgInfo(frame *stkframe, f funcInfo, needArgMap bool, ctxt *funcval) (arglen uintptr, argmap *bitvector)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc getArgInfo(frame *stkframe, f funcInfo, needArgMap bool, ctxt *funcval) (arglen uintptr, argmap *bitvector)\n```\n\ngetArgInfo returns the argument frame information for a call to f with call frame frame. \n\nThis is used for both actual calls with active stack frames and for deferred calls or goroutines that are not yet executing. If this is an actual call, ctxt must be nil (getArgInfo will retrieve what it needs from the active stack frame). If this is a deferred call or unstarted goroutine, ctxt must be the function object that was deferred or go'd. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#bitvector.ptrbit",
                    "documentation": {
                      "identifier": "bitvector.ptrbit",
                      "newPage": false,
                      "searchKey": "runtime.bitvector.ptrbit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (bv *bitvector) ptrbit(i uintptr) uint8"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (bv *bitvector) ptrbit(i uintptr) uint8\n```\n\nptrbit returns the i'th bit in bv. ptrbit is less efficient than iterating directly over bitvector bits, and should only be used in non-performance-critical code. See adjustpointers for an example of a high-efficiency walk of a bitvector. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackObjectRecord",
              "documentation": {
                "identifier": "stackObjectRecord",
                "newPage": false,
                "searchKey": "runtime.stackObjectRecord",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stackObjectRecord struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stackObjectRecord struct {\n\t// offset in frame\n\t// if negative, offset from varp\n\t// if non-negative, offset from argp\n\toff      int32\n\tsize     int32\n\t_ptrdata int32 // ptrdata, or -ptrdata is GC prog is used\n\tgcdata   *byte // pointer map or GC prog of the type\n}\n```\n\nA stackObjectRecord is generated by the compiler for each stack object in a stack frame. This record must match the generator code in cmd/compile/internal/liveness/plive.go:emitStackObjects. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#stackObjectRecord.useGCProg",
                    "documentation": {
                      "identifier": "stackObjectRecord.useGCProg",
                      "newPage": false,
                      "searchKey": "runtime.stackObjectRecord.useGCProg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *stackObjectRecord) useGCProg() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *stackObjectRecord) useGCProg() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#stackObjectRecord.ptrdata",
                    "documentation": {
                      "identifier": "stackObjectRecord.ptrdata",
                      "newPage": false,
                      "searchKey": "runtime.stackObjectRecord.ptrdata",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r *stackObjectRecord) ptrdata() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r *stackObjectRecord) ptrdata() uintptr\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tmpBuf",
              "documentation": {
                "identifier": "tmpBuf",
                "newPage": false,
                "searchKey": "runtime.tmpBuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type tmpBuf [32]byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype tmpBuf [tmpStringBufSize]byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stringStruct",
              "documentation": {
                "identifier": "stringStruct",
                "newPage": false,
                "searchKey": "runtime.stringStruct",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stringStruct struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stringStruct struct {\n\tstr unsafe.Pointer\n\tlen int\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#stringStructOf",
                    "documentation": {
                      "identifier": "stringStructOf",
                      "newPage": false,
                      "searchKey": "runtime.stringStructOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func stringStructOf(sp *string) *stringStruct"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc stringStructOf(sp *string) *stringStruct\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stringStructDWARF",
              "documentation": {
                "identifier": "stringStructDWARF",
                "newPage": false,
                "searchKey": "runtime.stringStructDWARF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stringStructDWARF struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stringStructDWARF struct {\n\tstr *byte\n\tlen int\n}\n```\n\nVariant with *byte pointer type for DWARF debugging. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#neverCallThisFunction",
              "documentation": {
                "identifier": "neverCallThisFunction",
                "newPage": false,
                "searchKey": "runtime.neverCallThisFunction",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type neverCallThisFunction struct{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype neverCallThisFunction struct{}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Frames",
              "documentation": {
                "identifier": "Frames",
                "newPage": false,
                "searchKey": "runtime.Frames",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Frames struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Frames struct {\n\t// callers is a slice of PCs that have not yet been expanded to frames.\n\tcallers []uintptr\n\n\t// frames is a slice of Frames that have yet to be returned.\n\tframes     []Frame\n\tframeStore [2]Frame\n}\n```\n\nFrames may be used to get function/file/line information for a slice of PC values returned by Callers. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#CallersFrames",
                    "documentation": {
                      "identifier": "CallersFrames",
                      "newPage": false,
                      "searchKey": "runtime.CallersFrames",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func CallersFrames(callers []uintptr) *Frames"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc CallersFrames(callers []uintptr) *Frames\n```\n\nCallersFrames takes a slice of PC values returned by Callers and prepares to return function/file/line information. Do not change the slice until you are done with the Frames. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#Frames.Next",
                    "documentation": {
                      "identifier": "Frames.Next",
                      "newPage": false,
                      "searchKey": "runtime.Frames.Next",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ci *Frames) Next() (frame Frame, more bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ci *Frames) Next() (frame Frame, more bool)\n```\n\nNext returns a Frame representing the next call frame in the slice of PC values. If it has already returned all call frames, Next returns a zero Frame. \n\nThe more result indicates whether the next call to Next will return a valid Frame. It does not necessarily indicate whether this call returned one. \n\nSee the Frames example for idiomatic usage. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Frame",
              "documentation": {
                "identifier": "Frame",
                "newPage": false,
                "searchKey": "runtime.Frame",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Frame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Frame struct {\n\t// PC is the program counter for the location in this frame.\n\t// For a frame that calls another frame, this will be the\n\t// program counter of a call instruction. Because of inlining,\n\t// multiple frames may have the same PC value, but different\n\t// symbolic information.\n\tPC uintptr\n\n\t// Func is the Func value of this call frame. This may be nil\n\t// for non-Go code or fully inlined functions.\n\tFunc *Func\n\n\t// Function is the package path-qualified function name of\n\t// this call frame. If non-empty, this string uniquely\n\t// identifies a single function in the program.\n\t// This may be the empty string if not known.\n\t// If Func is not nil then Function == Func.Name().\n\tFunction string\n\n\t// File and Line are the file name and line number of the\n\t// location in this frame. For non-leaf frames, this will be\n\t// the location of a call. These may be the empty string and\n\t// zero, respectively, if not known.\n\tFile string\n\tLine int\n\n\t// Entry point program counter for the function; may be zero\n\t// if not known. If Func is not nil then Entry ==\n\t// Func.Entry().\n\tEntry uintptr\n\n\t// The runtime's internal view of the function. This field\n\t// is set (funcInfo.valid() returns true) only for Go functions,\n\t// not for C functions.\n\tfuncInfo funcInfo\n}\n```\n\nFrame is the information returned by Frames for each call frame. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Func",
              "documentation": {
                "identifier": "Func",
                "newPage": false,
                "searchKey": "runtime.Func",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Func struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Func struct {\n\topaque struct{} // unexported field to disallow conversions\n}\n```\n\nA Func represents a Go function in the running binary. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#FuncForPC",
                    "documentation": {
                      "identifier": "FuncForPC",
                      "newPage": false,
                      "searchKey": "runtime.FuncForPC",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func FuncForPC(pc uintptr) *Func"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc FuncForPC(pc uintptr) *Func\n```\n\nFuncForPC returns a *Func describing the function that contains the given program counter address, or else nil. \n\nIf pc represents multiple functions because of inlining, it returns the *Func describing the innermost function, but with an entry of the outermost function. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#Func.raw",
                    "documentation": {
                      "identifier": "Func.raw",
                      "newPage": false,
                      "searchKey": "runtime.Func.raw",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *Func) raw() *_func"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *Func) raw() *_func\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#Func.funcInfo",
                    "documentation": {
                      "identifier": "Func.funcInfo",
                      "newPage": false,
                      "searchKey": "runtime.Func.funcInfo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *Func) funcInfo() funcInfo"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *Func) funcInfo() funcInfo\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#Func.Name",
                    "documentation": {
                      "identifier": "Func.Name",
                      "newPage": false,
                      "searchKey": "runtime.Func.Name",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *Func) Name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *Func) Name() string\n```\n\nName returns the name of the function. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#Func.Entry",
                    "documentation": {
                      "identifier": "Func.Entry",
                      "newPage": false,
                      "searchKey": "runtime.Func.Entry",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *Func) Entry() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *Func) Entry() uintptr\n```\n\nEntry returns the entry address of the function. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#Func.FileLine",
                    "documentation": {
                      "identifier": "Func.FileLine",
                      "newPage": false,
                      "searchKey": "runtime.Func.FileLine",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *Func) FileLine(pc uintptr) (file string, line int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *Func) FileLine(pc uintptr) (file string, line int)\n```\n\nFileLine returns the file name and line number of the source code corresponding to the program counter pc. The result will not be accurate if pc is not a program counter within f. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcID",
              "documentation": {
                "identifier": "funcID",
                "newPage": false,
                "searchKey": "runtime.funcID",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcID uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcID uint8\n```\n\nA FuncID identifies particular functions that need to be treated specially by the runtime. Note that in some situations involving plugins, there may be multiple copies of a particular special runtime function. Note: this list must match the list in cmd/internal/objabi/funcid.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcFlag",
              "documentation": {
                "identifier": "funcFlag",
                "newPage": false,
                "searchKey": "runtime.funcFlag",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcFlag uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcFlag uint8\n```\n\nA FuncFlag holds bits about a function. This list must match the list in cmd/internal/objabi/funcid.go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pcHeader",
              "documentation": {
                "identifier": "pcHeader",
                "newPage": false,
                "searchKey": "runtime.pcHeader",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pcHeader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pcHeader struct {\n\tmagic          uint32  // 0xFFFFFFFA\n\tpad1, pad2     uint8   // 0,0\n\tminLC          uint8   // min instruction size\n\tptrSize        uint8   // size of a ptr in bytes\n\tnfunc          int     // number of functions in the module\n\tnfiles         uint    // number of entries in the file tab.\n\tfuncnameOffset uintptr // offset to the funcnametab variable from pcHeader\n\tcuOffset       uintptr // offset to the cutab variable from pcHeader\n\tfiletabOffset  uintptr // offset to the filetab variable from pcHeader\n\tpctabOffset    uintptr // offset to the pctab varible from pcHeader\n\tpclnOffset     uintptr // offset to the pclntab variable from pcHeader\n}\n```\n\npcHeader holds data used by the pclntab lookups. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#moduledata",
              "documentation": {
                "identifier": "moduledata",
                "newPage": false,
                "searchKey": "runtime.moduledata",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type moduledata struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype moduledata struct {\n\tpcHeader     *pcHeader\n\tfuncnametab  []byte\n\tcutab        []uint32\n\tfiletab      []byte\n\tpctab        []byte\n\tpclntable    []byte\n\tftab         []functab\n\tfindfunctab  uintptr\n\tminpc, maxpc uintptr\n\n\ttext, etext           uintptr\n\tnoptrdata, enoptrdata uintptr\n\tdata, edata           uintptr\n\tbss, ebss             uintptr\n\tnoptrbss, enoptrbss   uintptr\n\tend, gcdata, gcbss    uintptr\n\ttypes, etypes         uintptr\n\n\ttextsectmap []textsect\n\ttypelinks   []int32 // offsets from types\n\titablinks   []*itab\n\n\tptab []ptabEntry\n\n\tpluginpath string\n\tpkghashes  []modulehash\n\n\tmodulename   string\n\tmodulehashes []modulehash\n\n\thasmain uint8 // 1 if module contains the main function, 0 otherwise\n\n\tgcdatamask, gcbssmask bitvector\n\n\ttypemap map[typeOff]*_type // offset to *_rtype in previous module\n\n\tbad bool // module failed to load and should be ignored\n\n\tnext *moduledata\n}\n```\n\nmoduledata records information about the layout of the executable image. It is written by the linker. Any changes here must be matched changes to the code in cmd/internal/ld/symtab.go:symtab. moduledata is stored in statically allocated non-pointer memory; none of the pointers here are visible to the garbage collector. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#findmoduledatap",
                    "documentation": {
                      "identifier": "findmoduledatap",
                      "newPage": false,
                      "searchKey": "runtime.findmoduledatap",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func findmoduledatap(pc uintptr) *moduledata"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc findmoduledatap(pc uintptr) *moduledata\n```\n\nfindmoduledatap looks up the moduledata for a PC. \n\nIt is nosplit because it's part of the isgoexception implementation. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#modulehash",
              "documentation": {
                "identifier": "modulehash",
                "newPage": false,
                "searchKey": "runtime.modulehash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type modulehash struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype modulehash struct {\n\tmodulename   string\n\tlinktimehash string\n\truntimehash  *string\n}\n```\n\nA modulehash is used to compare the ABI of a new module or a package in a new module with the loaded program. \n\nFor each shared library a module links against, the linker creates an entry in the moduledata.modulehashes slice containing the name of the module, the abi hash seen at link time and a pointer to the runtime abi hash. These are checked in moduledataverify1 below. \n\nFor each loaded plugin, the pkghashes slice has a modulehash of the newly loaded package that can be used to check the plugin's version of a package against any previously loaded version of the package. This is done in plugin.lastmoduleinit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#functab",
              "documentation": {
                "identifier": "functab",
                "newPage": false,
                "searchKey": "runtime.functab",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type functab struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype functab struct {\n\tentry   uintptr\n\tfuncoff uintptr\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#textsect",
              "documentation": {
                "identifier": "textsect",
                "newPage": false,
                "searchKey": "runtime.textsect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type textsect struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype textsect struct {\n\tvaddr    uintptr // prelinked section vaddr\n\tlength   uintptr // section length\n\tbaseaddr uintptr // relocated section address\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#findfuncbucket",
              "documentation": {
                "identifier": "findfuncbucket",
                "newPage": false,
                "searchKey": "runtime.findfuncbucket",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type findfuncbucket struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype findfuncbucket struct {\n\tidx        uint32\n\tsubbuckets [16]byte\n}\n```\n\nfindfunctab is an array of these structures. Each bucket represents 4096 bytes of the text segment. Each subbucket represents 256 bytes of the text segment. To find a function given a pc, locate the bucket and subbucket for that pc. Add together the idx and subbucket value to obtain a function index. Then scan the functab array starting at that index to find the target function. This table uses 20 bytes for every 4096 bytes of code, or ~0.5% overhead. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcInfo",
              "documentation": {
                "identifier": "funcInfo",
                "newPage": false,
                "searchKey": "runtime.funcInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funcInfo struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funcInfo struct {\n\t*_func\n\tdatap *moduledata\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#findfunc",
                    "documentation": {
                      "identifier": "findfunc",
                      "newPage": false,
                      "searchKey": "runtime.findfunc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func findfunc(pc uintptr) funcInfo"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc findfunc(pc uintptr) funcInfo\n```\n\nfindfunc looks up function metadata for a PC. \n\nIt is nosplit because it's part of the isgoexception implementation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#funcInfo.valid",
                    "documentation": {
                      "identifier": "funcInfo.valid",
                      "newPage": false,
                      "searchKey": "runtime.funcInfo.valid",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f funcInfo) valid() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f funcInfo) valid() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#funcInfo._Func",
                    "documentation": {
                      "identifier": "funcInfo._Func",
                      "newPage": false,
                      "searchKey": "runtime.funcInfo._Func",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f funcInfo) _Func() *Func"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f funcInfo) _Func() *Func\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pcvalueCache",
              "documentation": {
                "identifier": "pcvalueCache",
                "newPage": false,
                "searchKey": "runtime.pcvalueCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pcvalueCache struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pcvalueCache struct {\n\tentries [2][8]pcvalueCacheEnt\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pcvalueCacheEnt",
              "documentation": {
                "identifier": "pcvalueCacheEnt",
                "newPage": false,
                "searchKey": "runtime.pcvalueCacheEnt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type pcvalueCacheEnt struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype pcvalueCacheEnt struct {\n\t// targetpc and off together are the key of this cache entry.\n\ttargetpc uintptr\n\toff      uint32\n\t// val is the value of this cached pcvalue entry.\n\tval int32\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackmap",
              "documentation": {
                "identifier": "stackmap",
                "newPage": false,
                "searchKey": "runtime.stackmap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type stackmap struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype stackmap struct {\n\tn        int32   // number of bitmaps\n\tnbit     int32   // number of bits in each bitmap\n\tbytedata [1]byte // bitmaps, each starting on a byte boundary\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inlinedCall",
              "documentation": {
                "identifier": "inlinedCall",
                "newPage": false,
                "searchKey": "runtime.inlinedCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type inlinedCall struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype inlinedCall struct {\n\tparent   int16  // index of parent in the inltree, or < 0\n\tfuncID   funcID // type of the called function\n\t_        byte\n\tfile     int32 // perCU file index for inlined call. See cmd/link:pcln.go\n\tline     int32 // line number of the call site\n\tfunc_    int32 // offset into pclntab for name of called function\n\tparentPc int32 // position of an instruction whose source position is the call site (offset from entry)\n}\n```\n\ninlinedCall is the encoding of entries in the FUNCDATA_InlTree table. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timer",
              "documentation": {
                "identifier": "timer",
                "newPage": false,
                "searchKey": "runtime.timer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type timer struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype timer struct {\n\t// If this timer is on a heap, which P's heap it is on.\n\t// puintptr rather than *p to match uintptr in the versions\n\t// of this struct defined in other packages.\n\tpp puintptr\n\n\t// Timer wakes up at when, and then at when+period, ... (period > 0 only)\n\t// each time calling f(arg, now) in the timer goroutine, so f must be\n\t// a well-behaved function and not block.\n\t//\n\t// when must be positive on an active timer.\n\twhen   int64\n\tperiod int64\n\tf      func(interface{}, uintptr)\n\targ    interface{}\n\tseq    uintptr\n\n\t// What to set the when field to in timerModifiedXX status.\n\tnextwhen int64\n\n\t// The status field holds one of the values below.\n\tstatus uint32\n}\n```\n\nPackage time knows the layout of this structure. If this struct changes, adjust ../time/sleep.go:/runtimeTimer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceBufHeader",
              "documentation": {
                "identifier": "traceBufHeader",
                "newPage": false,
                "searchKey": "runtime.traceBufHeader",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type traceBufHeader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype traceBufHeader struct {\n\tlink      traceBufPtr             // in trace.empty/full\n\tlastTicks uint64                  // when we wrote the last event\n\tpos       int                     // next write offset in arr\n\tstk       [traceStackSize]uintptr // scratch buffer for traceback\n}\n```\n\ntraceBufHeader is per-P tracing buffer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceBuf",
              "documentation": {
                "identifier": "traceBuf",
                "newPage": false,
                "searchKey": "runtime.traceBuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type traceBuf struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype traceBuf struct {\n\ttraceBufHeader\n\tarr [64<<10 - unsafe.Sizeof(traceBufHeader{})]byte // underlying buffer for traceBufHeader.buf\n}\n```\n\ntraceBuf is per-P tracing buffer. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#traceBuf.varint",
                    "documentation": {
                      "identifier": "traceBuf.varint",
                      "newPage": false,
                      "searchKey": "runtime.traceBuf.varint",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (buf *traceBuf) varint(v uint64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (buf *traceBuf) varint(v uint64)\n```\n\nvarint appends v to buf in little-endian-base-128 encoding. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceBuf.byte",
                    "documentation": {
                      "identifier": "traceBuf.byte",
                      "newPage": false,
                      "searchKey": "runtime.traceBuf.byte",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (buf *traceBuf) byte(v byte)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (buf *traceBuf) byte(v byte)\n```\n\nbyte appends v to buf. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceBufPtr",
              "documentation": {
                "identifier": "traceBufPtr",
                "newPage": false,
                "searchKey": "runtime.traceBufPtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type traceBufPtr uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype traceBufPtr uintptr\n```\n\ntraceBufPtr is a *traceBuf that is not traced by the garbage collector and doesn't have write barriers. traceBufs are not allocated from the GC'd heap, so this is safe, and are often manipulated in contexts where write barriers are not allowed, so this is necessary. \n\nTODO: Since traceBuf is now go:notinheap, this isn't necessary. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#traceBufPtrOf",
                    "documentation": {
                      "identifier": "traceBufPtrOf",
                      "newPage": false,
                      "searchKey": "runtime.traceBufPtrOf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func traceBufPtrOf(b *traceBuf) traceBufPtr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc traceBufPtrOf(b *traceBuf) traceBufPtr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceFullDequeue",
                    "documentation": {
                      "identifier": "traceFullDequeue",
                      "newPage": false,
                      "searchKey": "runtime.traceFullDequeue",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func traceFullDequeue() traceBufPtr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc traceFullDequeue() traceBufPtr\n```\n\ntraceFullDequeue dequeues from queue of full buffers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceAcquireBuffer",
                    "documentation": {
                      "identifier": "traceAcquireBuffer",
                      "newPage": false,
                      "searchKey": "runtime.traceAcquireBuffer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func traceAcquireBuffer() (mp *m, pid int32, bufp *traceBufPtr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc traceAcquireBuffer() (mp *m, pid int32, bufp *traceBufPtr)\n```\n\ntraceAcquireBuffer returns trace buffer to use and, if necessary, locks it. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceFlush",
                    "documentation": {
                      "identifier": "traceFlush",
                      "newPage": false,
                      "searchKey": "runtime.traceFlush",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func traceFlush(buf traceBufPtr, pid int32) traceBufPtr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc traceFlush(buf traceBufPtr, pid int32) traceBufPtr\n```\n\ntraceFlush puts buf onto stack of full buffers and returns an empty buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceString",
                    "documentation": {
                      "identifier": "traceString",
                      "newPage": false,
                      "searchKey": "runtime.traceString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func traceString(bufp *traceBufPtr, pid int32, s string) (uint64, *traceBufPtr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc traceString(bufp *traceBufPtr, pid int32, s string) (uint64, *traceBufPtr)\n```\n\ntraceString adds a string to the trace.strings and returns the id. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceFrameForPC",
                    "documentation": {
                      "identifier": "traceFrameForPC",
                      "newPage": false,
                      "searchKey": "runtime.traceFrameForPC",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func traceFrameForPC(buf traceBufPtr, pid int32, f Frame) (traceFrame, traceBufPtr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc traceFrameForPC(buf traceBufPtr, pid int32, f Frame) (traceFrame, traceBufPtr)\n```\n\ntraceFrameForPC records the frame information. It may allocate memory. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceBufPtr.ptr",
                    "documentation": {
                      "identifier": "traceBufPtr.ptr",
                      "newPage": false,
                      "searchKey": "runtime.traceBufPtr.ptr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tp traceBufPtr) ptr() *traceBuf"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tp traceBufPtr) ptr() *traceBuf\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceBufPtr.set",
                    "documentation": {
                      "identifier": "traceBufPtr.set",
                      "newPage": false,
                      "searchKey": "runtime.traceBufPtr.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tp *traceBufPtr) set(b *traceBuf)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tp *traceBufPtr) set(b *traceBuf)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceStackTable",
              "documentation": {
                "identifier": "traceStackTable",
                "newPage": false,
                "searchKey": "runtime.traceStackTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type traceStackTable struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype traceStackTable struct {\n\tlock mutex\n\tseq  uint32\n\tmem  traceAlloc\n\ttab  [1 << 13]traceStackPtr\n}\n```\n\ntraceStackTable maps stack traces (arrays of PC's) to unique uint32 ids. It is lock-free for reading. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#traceStackTable.put",
                    "documentation": {
                      "identifier": "traceStackTable.put",
                      "newPage": false,
                      "searchKey": "runtime.traceStackTable.put",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tab *traceStackTable) put(pcs []uintptr) uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tab *traceStackTable) put(pcs []uintptr) uint32\n```\n\nput returns a unique id for the stack trace pcs and caches it in the table, if it sees the trace for the first time. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceStackTable.find",
                    "documentation": {
                      "identifier": "traceStackTable.find",
                      "newPage": false,
                      "searchKey": "runtime.traceStackTable.find",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tab *traceStackTable) find(pcs []uintptr, hash uintptr) uint32"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tab *traceStackTable) find(pcs []uintptr, hash uintptr) uint32\n```\n\nfind checks if the stack trace pcs is already present in the table. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceStackTable.newStack",
                    "documentation": {
                      "identifier": "traceStackTable.newStack",
                      "newPage": false,
                      "searchKey": "runtime.traceStackTable.newStack",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tab *traceStackTable) newStack(n int) *traceStack"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tab *traceStackTable) newStack(n int) *traceStack\n```\n\nnewStack allocates a new stack of size n. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceStackTable.dump",
                    "documentation": {
                      "identifier": "traceStackTable.dump",
                      "newPage": false,
                      "searchKey": "runtime.traceStackTable.dump",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tab *traceStackTable) dump()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tab *traceStackTable) dump()\n```\n\ndump writes all previously cached stacks to trace buffers, releases all memory and resets state. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceStack",
              "documentation": {
                "identifier": "traceStack",
                "newPage": false,
                "searchKey": "runtime.traceStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type traceStack struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype traceStack struct {\n\tlink traceStackPtr\n\thash uintptr\n\tid   uint32\n\tn    int\n\tstk  [0]uintptr // real type [n]uintptr\n}\n```\n\ntraceStack is a single stack in traceStackTable. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#traceStack.stack",
                    "documentation": {
                      "identifier": "traceStack.stack",
                      "newPage": false,
                      "searchKey": "runtime.traceStack.stack",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (ts *traceStack) stack() []uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (ts *traceStack) stack() []uintptr\n```\n\nstack returns slice of PCs. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceStackPtr",
              "documentation": {
                "identifier": "traceStackPtr",
                "newPage": false,
                "searchKey": "runtime.traceStackPtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type traceStackPtr uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype traceStackPtr uintptr\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#traceStackPtr.ptr",
                    "documentation": {
                      "identifier": "traceStackPtr.ptr",
                      "newPage": false,
                      "searchKey": "runtime.traceStackPtr.ptr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (tp traceStackPtr) ptr() *traceStack"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (tp traceStackPtr) ptr() *traceStack\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceFrame",
              "documentation": {
                "identifier": "traceFrame",
                "newPage": false,
                "searchKey": "runtime.traceFrame",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type traceFrame struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype traceFrame struct {\n\tfuncID uint64\n\tfileID uint64\n\tline   uint64\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#traceFrameForPC",
                    "documentation": {
                      "identifier": "traceFrameForPC",
                      "newPage": false,
                      "searchKey": "runtime.traceFrameForPC",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func traceFrameForPC(buf traceBufPtr, pid int32, f Frame) (traceFrame, traceBufPtr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc traceFrameForPC(buf traceBufPtr, pid int32, f Frame) (traceFrame, traceBufPtr)\n```\n\ntraceFrameForPC records the frame information. It may allocate memory. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceAlloc",
              "documentation": {
                "identifier": "traceAlloc",
                "newPage": false,
                "searchKey": "runtime.traceAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type traceAlloc struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype traceAlloc struct {\n\thead traceAllocBlockPtr\n\toff  uintptr\n}\n```\n\ntraceAlloc is a non-thread-safe region allocator. It holds a linked list of traceAllocBlock. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#traceAlloc.alloc",
                    "documentation": {
                      "identifier": "traceAlloc.alloc",
                      "newPage": false,
                      "searchKey": "runtime.traceAlloc.alloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *traceAlloc) alloc(n uintptr) unsafe.Pointer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *traceAlloc) alloc(n uintptr) unsafe.Pointer\n```\n\nalloc allocates n-byte block. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceAlloc.drop",
                    "documentation": {
                      "identifier": "traceAlloc.drop",
                      "newPage": false,
                      "searchKey": "runtime.traceAlloc.drop",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *traceAlloc) drop()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *traceAlloc) drop()\n```\n\ndrop frees all previously allocated memory and resets the allocator. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceAllocBlock",
              "documentation": {
                "identifier": "traceAllocBlock",
                "newPage": false,
                "searchKey": "runtime.traceAllocBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type traceAllocBlock struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype traceAllocBlock struct {\n\tnext traceAllocBlockPtr\n\tdata [64<<10 - sys.PtrSize]byte\n}\n```\n\ntraceAllocBlock is a block in traceAlloc. \n\ntraceAllocBlock is allocated from non-GC'd memory, so it must not contain heap pointers. Writes to pointers to traceAllocBlocks do not need write barriers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceAllocBlockPtr",
              "documentation": {
                "identifier": "traceAllocBlockPtr",
                "newPage": false,
                "searchKey": "runtime.traceAllocBlockPtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type traceAllocBlockPtr uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype traceAllocBlockPtr uintptr\n```\n\nTODO: Since traceAllocBlock is now go:notinheap, this isn't necessary. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#traceAllocBlockPtr.ptr",
                    "documentation": {
                      "identifier": "traceAllocBlockPtr.ptr",
                      "newPage": false,
                      "searchKey": "runtime.traceAllocBlockPtr.ptr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p traceAllocBlockPtr) ptr() *traceAllocBlock"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p traceAllocBlockPtr) ptr() *traceAllocBlock\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceAllocBlockPtr.set",
                    "documentation": {
                      "identifier": "traceAllocBlockPtr.set",
                      "newPage": false,
                      "searchKey": "runtime.traceAllocBlockPtr.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *traceAllocBlockPtr) set(x *traceAllocBlock)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *traceAllocBlockPtr) set(x *traceAllocBlock)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectMethodValue",
              "documentation": {
                "identifier": "reflectMethodValue",
                "newPage": false,
                "searchKey": "runtime.reflectMethodValue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type reflectMethodValue struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype reflectMethodValue struct {\n\tfn     uintptr\n\tstack  *bitvector // ptrmap for both args and results\n\targLen uintptr    // just args\n}\n```\n\nreflectMethodValue is a partial duplicate of reflect.makeFuncImpl and reflect.methodValue. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoTracebackArg",
              "documentation": {
                "identifier": "cgoTracebackArg",
                "newPage": false,
                "searchKey": "runtime.cgoTracebackArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cgoTracebackArg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cgoTracebackArg struct {\n\tcontext    uintptr\n\tsigContext uintptr\n\tbuf        *uintptr\n\tmax        uintptr\n}\n```\n\ncgoTracebackArg is the type passed to cgoTraceback. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoContextArg",
              "documentation": {
                "identifier": "cgoContextArg",
                "newPage": false,
                "searchKey": "runtime.cgoContextArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cgoContextArg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cgoContextArg struct {\n\tcontext uintptr\n}\n```\n\ncgoContextArg is the type passed to the context function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoSymbolizerArg",
              "documentation": {
                "identifier": "cgoSymbolizerArg",
                "newPage": false,
                "searchKey": "runtime.cgoSymbolizerArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type cgoSymbolizerArg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype cgoSymbolizerArg struct {\n\tpc       uintptr\n\tfile     *byte\n\tlineno   uintptr\n\tfuncName *byte\n\tentry    uintptr\n\tmore     uintptr\n\tdata     uintptr\n}\n```\n\ncgoSymbolizerArg is the type passed to cgoSymbolizer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tflag",
              "documentation": {
                "identifier": "tflag",
                "newPage": false,
                "searchKey": "runtime.tflag",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type tflag uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype tflag uint8\n```\n\ntflag is documented in reflect/type.go. \n\ntflag values must be kept in sync with copies in: \n\n```\n\tcmd/compile/internal/gc/reflect.go\n\tcmd/link/internal/ld/decodesym.go\n\treflect/type.go\n     internal/reflectlite/type.go\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_type",
              "documentation": {
                "identifier": "_type",
                "newPage": false,
                "searchKey": "runtime._type",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type _type struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype _type struct {\n\tsize       uintptr\n\tptrdata    uintptr // size of memory prefix holding all pointers\n\thash       uint32\n\ttflag      tflag\n\talign      uint8\n\tfieldAlign uint8\n\tkind       uint8\n\t// function for comparing objects of this type\n\t// (ptr to object A, ptr to object B) -> ==?\n\tequal func(unsafe.Pointer, unsafe.Pointer) bool\n\t// gcdata stores the GC type data for the garbage collector.\n\t// If the KindGCProg bit is set in kind, gcdata is a GC program.\n\t// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.\n\tgcdata    *byte\n\tstr       nameOff\n\tptrToThis typeOff\n}\n```\n\nNeeds to be in sync with ../cmd/link/internal/ld/decodesym.go:/^func.commonsize, ../cmd/compile/internal/gc/reflect.go:/^func.dcommontype and ../reflect/type.go:/^type.rtype. ../internal/reflectlite/type.go:/^type.rtype. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#resolveTypeOff",
                    "documentation": {
                      "identifier": "resolveTypeOff",
                      "newPage": false,
                      "searchKey": "runtime.resolveTypeOff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func resolveTypeOff(ptrInModule unsafe.Pointer, off typeOff) *_type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc resolveTypeOff(ptrInModule unsafe.Pointer, off typeOff) *_type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#_type.string",
                    "documentation": {
                      "identifier": "_type.string",
                      "newPage": false,
                      "searchKey": "runtime._type.string",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_type) string() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_type) string() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#_type.uncommon",
                    "documentation": {
                      "identifier": "_type.uncommon",
                      "newPage": false,
                      "searchKey": "runtime._type.uncommon",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_type) uncommon() *uncommontype"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_type) uncommon() *uncommontype\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#_type.name",
                    "documentation": {
                      "identifier": "_type.name",
                      "newPage": false,
                      "searchKey": "runtime._type.name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_type) name() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_type) name() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#_type.pkgpath",
                    "documentation": {
                      "identifier": "_type.pkgpath",
                      "newPage": false,
                      "searchKey": "runtime._type.pkgpath",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_type) pkgpath() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_type) pkgpath() string\n```\n\npkgpath returns the path of the package where t was defined, if available. This is not the same as the reflect package's PkgPath method, in that it returns the package path for struct and interface types, not just named types. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#_type.nameOff",
                    "documentation": {
                      "identifier": "_type.nameOff",
                      "newPage": false,
                      "searchKey": "runtime._type.nameOff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_type) nameOff(off nameOff) name"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_type) nameOff(off nameOff) name\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#_type.typeOff",
                    "documentation": {
                      "identifier": "_type.typeOff",
                      "newPage": false,
                      "searchKey": "runtime._type.typeOff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_type) typeOff(off typeOff) *_type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_type) typeOff(off typeOff) *_type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#_type.textOff",
                    "documentation": {
                      "identifier": "_type.textOff",
                      "newPage": false,
                      "searchKey": "runtime._type.textOff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *_type) textOff(off textOff) unsafe.Pointer"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *_type) textOff(off textOff) unsafe.Pointer\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nameOff",
              "documentation": {
                "identifier": "nameOff",
                "newPage": false,
                "searchKey": "runtime.nameOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type nameOff int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nameOff int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typeOff",
              "documentation": {
                "identifier": "typeOff",
                "newPage": false,
                "searchKey": "runtime.typeOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type typeOff int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype typeOff int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#textOff",
              "documentation": {
                "identifier": "textOff",
                "newPage": false,
                "searchKey": "runtime.textOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type textOff int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype textOff int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#method",
              "documentation": {
                "identifier": "method",
                "newPage": false,
                "searchKey": "runtime.method",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type method struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype method struct {\n\tname nameOff\n\tmtyp typeOff\n\tifn  textOff\n\ttfn  textOff\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#uncommontype",
              "documentation": {
                "identifier": "uncommontype",
                "newPage": false,
                "searchKey": "runtime.uncommontype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type uncommontype struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype uncommontype struct {\n\tpkgpath nameOff\n\tmcount  uint16 // number of methods\n\txcount  uint16 // number of exported methods\n\tmoff    uint32 // offset from this uncommontype to [mcount]method\n\t_       uint32 // unused\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#imethod",
              "documentation": {
                "identifier": "imethod",
                "newPage": false,
                "searchKey": "runtime.imethod",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type imethod struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype imethod struct {\n\tname nameOff\n\tityp typeOff\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#interfacetype",
              "documentation": {
                "identifier": "interfacetype",
                "newPage": false,
                "searchKey": "runtime.interfacetype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type interfacetype struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype interfacetype struct {\n\ttyp     _type\n\tpkgpath name\n\tmhdr    []imethod\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#maptype",
              "documentation": {
                "identifier": "maptype",
                "newPage": false,
                "searchKey": "runtime.maptype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type maptype struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype maptype struct {\n\ttyp    _type\n\tkey    *_type\n\telem   *_type\n\tbucket *_type // internal type representing a hash bucket\n\t// function for hashing keys (ptr to key, seed) -> hash\n\thasher     func(unsafe.Pointer, uintptr) uintptr\n\tkeysize    uint8  // size of key slot\n\telemsize   uint8  // size of elem slot\n\tbucketsize uint16 // size of bucket\n\tflags      uint32\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#maptype.indirectkey",
                    "documentation": {
                      "identifier": "maptype.indirectkey",
                      "newPage": false,
                      "searchKey": "runtime.maptype.indirectkey",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mt *maptype) indirectkey() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mt *maptype) indirectkey() bool\n```\n\nNote: flag values must match those used in the TMAP case in ../cmd/compile/internal/gc/reflect.go:writeType. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#maptype.indirectelem",
                    "documentation": {
                      "identifier": "maptype.indirectelem",
                      "newPage": false,
                      "searchKey": "runtime.maptype.indirectelem",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mt *maptype) indirectelem() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mt *maptype) indirectelem() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#maptype.reflexivekey",
                    "documentation": {
                      "identifier": "maptype.reflexivekey",
                      "newPage": false,
                      "searchKey": "runtime.maptype.reflexivekey",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mt *maptype) reflexivekey() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mt *maptype) reflexivekey() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#maptype.needkeyupdate",
                    "documentation": {
                      "identifier": "maptype.needkeyupdate",
                      "newPage": false,
                      "searchKey": "runtime.maptype.needkeyupdate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mt *maptype) needkeyupdate() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mt *maptype) needkeyupdate() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#maptype.hashMightPanic",
                    "documentation": {
                      "identifier": "maptype.hashMightPanic",
                      "newPage": false,
                      "searchKey": "runtime.maptype.hashMightPanic",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (mt *maptype) hashMightPanic() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (mt *maptype) hashMightPanic() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#arraytype",
              "documentation": {
                "identifier": "arraytype",
                "newPage": false,
                "searchKey": "runtime.arraytype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type arraytype struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype arraytype struct {\n\ttyp   _type\n\telem  *_type\n\tslice *_type\n\tlen   uintptr\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chantype",
              "documentation": {
                "identifier": "chantype",
                "newPage": false,
                "searchKey": "runtime.chantype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type chantype struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype chantype struct {\n\ttyp  _type\n\telem *_type\n\tdir  uintptr\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#slicetype",
              "documentation": {
                "identifier": "slicetype",
                "newPage": false,
                "searchKey": "runtime.slicetype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type slicetype struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype slicetype struct {\n\ttyp  _type\n\telem *_type\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#functype",
              "documentation": {
                "identifier": "functype",
                "newPage": false,
                "searchKey": "runtime.functype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type functype struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype functype struct {\n\ttyp      _type\n\tinCount  uint16\n\toutCount uint16\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#functype.in",
                    "documentation": {
                      "identifier": "functype.in",
                      "newPage": false,
                      "searchKey": "runtime.functype.in",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *functype) in() []*_type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *functype) in() []*_type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#functype.out",
                    "documentation": {
                      "identifier": "functype.out",
                      "newPage": false,
                      "searchKey": "runtime.functype.out",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *functype) out() []*_type"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *functype) out() []*_type\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#functype.dotdotdot",
                    "documentation": {
                      "identifier": "functype.dotdotdot",
                      "newPage": false,
                      "searchKey": "runtime.functype.dotdotdot",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (t *functype) dotdotdot() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (t *functype) dotdotdot() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ptrtype",
              "documentation": {
                "identifier": "ptrtype",
                "newPage": false,
                "searchKey": "runtime.ptrtype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ptrtype struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ptrtype struct {\n\ttyp  _type\n\telem *_type\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#structfield",
              "documentation": {
                "identifier": "structfield",
                "newPage": false,
                "searchKey": "runtime.structfield",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type structfield struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype structfield struct {\n\tname       name\n\ttyp        *_type\n\toffsetAnon uintptr\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#structfield.offset",
                    "documentation": {
                      "identifier": "structfield.offset",
                      "newPage": false,
                      "searchKey": "runtime.structfield.offset",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (f *structfield) offset() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (f *structfield) offset() uintptr\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#structtype",
              "documentation": {
                "identifier": "structtype",
                "newPage": false,
                "searchKey": "runtime.structtype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type structtype struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype structtype struct {\n\ttyp     _type\n\tpkgPath name\n\tfields  []structfield\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#name",
              "documentation": {
                "identifier": "name",
                "newPage": false,
                "searchKey": "runtime.name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type name struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype name struct {\n\tbytes *byte\n}\n```\n\nname is an encoded type name with optional extra data. See reflect/type.go for details. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#resolveNameOff",
                    "documentation": {
                      "identifier": "resolveNameOff",
                      "newPage": false,
                      "searchKey": "runtime.resolveNameOff",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc resolveNameOff(ptrInModule unsafe.Pointer, off nameOff) name\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#name.data",
                    "documentation": {
                      "identifier": "name.data",
                      "newPage": false,
                      "searchKey": "runtime.name.data",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) data(off int) *byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) data(off int) *byte\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#name.isExported",
                    "documentation": {
                      "identifier": "name.isExported",
                      "newPage": false,
                      "searchKey": "runtime.name.isExported",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) isExported() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) isExported() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#name.readvarint",
                    "documentation": {
                      "identifier": "name.readvarint",
                      "newPage": false,
                      "searchKey": "runtime.name.readvarint",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) readvarint(off int) (int, int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) readvarint(off int) (int, int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#name.name",
                    "documentation": {
                      "identifier": "name.name",
                      "newPage": false,
                      "searchKey": "runtime.name.name",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) name() (s string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) name() (s string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#name.tag",
                    "documentation": {
                      "identifier": "name.tag",
                      "newPage": false,
                      "searchKey": "runtime.name.tag",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) tag() (s string)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) tag() (s string)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#name.pkgPath",
                    "documentation": {
                      "identifier": "name.pkgPath",
                      "newPage": false,
                      "searchKey": "runtime.name.pkgPath",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) pkgPath() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) pkgPath() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#name.isBlank",
                    "documentation": {
                      "identifier": "name.isBlank",
                      "newPage": false,
                      "searchKey": "runtime.name.isBlank",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n name) isBlank() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n name) isBlank() bool\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_typePair",
              "documentation": {
                "identifier": "_typePair",
                "newPage": false,
                "searchKey": "runtime._typePair",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type _typePair struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype _typePair struct {\n\tt1 *_type\n\tt2 *_type\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#LockRank",
              "documentation": {
                "identifier": "LockRank",
                "newPage": false,
                "searchKey": "runtime.LockRank",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type LockRank runtime.lockRank"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype LockRank lockRank\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#LockRank.String",
                    "documentation": {
                      "identifier": "LockRank.String",
                      "newPage": false,
                      "searchKey": "runtime.LockRank.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (l LockRank) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (l LockRank) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#LFNode",
              "documentation": {
                "identifier": "LFNode",
                "newPage": false,
                "searchKey": "runtime.LFNode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type LFNode struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype LFNode struct {\n\tNext    uint64\n\tPushcnt uintptr\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#LFStackPop",
                    "documentation": {
                      "identifier": "LFStackPop",
                      "newPage": false,
                      "searchKey": "runtime.LFStackPop",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func LFStackPop(head *uint64) *LFNode"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc LFStackPop(head *uint64) *LFNode\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ProfBuf",
              "documentation": {
                "identifier": "ProfBuf",
                "newPage": false,
                "searchKey": "runtime.ProfBuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ProfBuf runtime.profBuf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ProfBuf profBuf\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#NewProfBuf",
                    "documentation": {
                      "identifier": "NewProfBuf",
                      "newPage": false,
                      "searchKey": "runtime.NewProfBuf",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewProfBuf(hdrsize, bufwords, tags int) *ProfBuf"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewProfBuf(hdrsize, bufwords, tags int) *ProfBuf\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#ProfBuf.Write",
                    "documentation": {
                      "identifier": "ProfBuf.Write",
                      "newPage": false,
                      "searchKey": "runtime.ProfBuf.Write",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProfBuf) Write(tag *unsafe.Pointer, now int64, hdr []uint64, stk []uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProfBuf) Write(tag *unsafe.Pointer, now int64, hdr []uint64, stk []uintptr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#ProfBuf.Read",
                    "documentation": {
                      "identifier": "ProfBuf.Read",
                      "newPage": false,
                      "searchKey": "runtime.ProfBuf.Read",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProfBuf) Read(mode profBufReadMode) ([]uint64, []unsafe.Pointer, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProfBuf) Read(mode profBufReadMode) ([]uint64, []unsafe.Pointer, bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#ProfBuf.Close",
                    "documentation": {
                      "identifier": "ProfBuf.Close",
                      "newPage": false,
                      "searchKey": "runtime.ProfBuf.Close",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *ProfBuf) Close()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *ProfBuf) Close()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#RWMutex",
              "documentation": {
                "identifier": "RWMutex",
                "newPage": false,
                "searchKey": "runtime.RWMutex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type RWMutex struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RWMutex struct {\n\trw rwmutex\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#RWMutex.RLock",
                    "documentation": {
                      "identifier": "RWMutex.RLock",
                      "newPage": false,
                      "searchKey": "runtime.RWMutex.RLock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rw *RWMutex) RLock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rw *RWMutex) RLock()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#RWMutex.RUnlock",
                    "documentation": {
                      "identifier": "RWMutex.RUnlock",
                      "newPage": false,
                      "searchKey": "runtime.RWMutex.RUnlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rw *RWMutex) RUnlock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rw *RWMutex) RUnlock()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#RWMutex.Lock",
                    "documentation": {
                      "identifier": "RWMutex.Lock",
                      "newPage": false,
                      "searchKey": "runtime.RWMutex.Lock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rw *RWMutex) Lock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rw *RWMutex) Lock()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#RWMutex.Unlock",
                    "documentation": {
                      "identifier": "RWMutex.Unlock",
                      "newPage": false,
                      "searchKey": "runtime.RWMutex.Unlock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (rw *RWMutex) Unlock()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (rw *RWMutex) Unlock()\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#G",
              "documentation": {
                "identifier": "G",
                "newPage": false,
                "searchKey": "runtime.G",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type G runtime.g"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype G = g\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#beforeIdle",
                    "documentation": {
                      "identifier": "beforeIdle",
                      "newPage": false,
                      "searchKey": "runtime.beforeIdle",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func beforeIdle(int64, int64) (*g, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc beforeIdle(int64, int64) (*g, bool)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#wakefing",
                    "documentation": {
                      "identifier": "wakefing",
                      "newPage": false,
                      "searchKey": "runtime.wakefing",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func wakefing() *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc wakefing() *g\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#netpollunblock",
                    "documentation": {
                      "identifier": "netpollunblock",
                      "newPage": false,
                      "searchKey": "runtime.netpollunblock",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc netpollunblock(pd *pollDesc, mode int32, ioready bool) *g\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#atomicAllG",
                    "documentation": {
                      "identifier": "atomicAllG",
                      "newPage": false,
                      "searchKey": "runtime.atomicAllG",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func atomicAllG() (**g, uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc atomicAllG() (**g, uintptr)\n```\n\natomicAllG returns &allgs[0] and len(allgs) for use with atomicAllGIndex. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#atomicAllGIndex",
                    "documentation": {
                      "identifier": "atomicAllGIndex",
                      "newPage": false,
                      "searchKey": "runtime.atomicAllGIndex",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func atomicAllGIndex(ptr **g, i uintptr) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc atomicAllGIndex(ptr **g, i uintptr) *g\n```\n\natomicAllGIndex returns ptr[i] with the allgptr returned from atomicAllG. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#findrunnable",
                    "documentation": {
                      "identifier": "findrunnable",
                      "newPage": false,
                      "searchKey": "runtime.findrunnable",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func findrunnable() (gp *g, inheritTime bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc findrunnable() (gp *g, inheritTime bool)\n```\n\nFinds a runnable goroutine to execute. Tries to steal from other P's, get g from local or global queue, poll network. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#stealWork",
                    "documentation": {
                      "identifier": "stealWork",
                      "newPage": false,
                      "searchKey": "runtime.stealWork",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func stealWork(now int64) (gp *g, inheritTime bool, rnow, pollUntil int64, newWork bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc stealWork(now int64) (gp *g, inheritTime bool, rnow, pollUntil int64, newWork bool)\n```\n\nstealWork attempts to steal a runnable goroutine or timer from any P. \n\nIf newWork is true, new work may have been readied. \n\nIf now is not 0 it is the current time. stealWork returns the passed time or the current time if now was passed as 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#checkIdleGCNoP",
                    "documentation": {
                      "identifier": "checkIdleGCNoP",
                      "newPage": false,
                      "searchKey": "runtime.checkIdleGCNoP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func checkIdleGCNoP() (*p, *g)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc checkIdleGCNoP() (*p, *g)\n```\n\nCheck for idle-priority GC, without a P on entry. \n\nIf some GC work, a P, and a worker G are all available, the P and G will be returned. The returned P has not been wired yet. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#malg",
                    "documentation": {
                      "identifier": "malg",
                      "newPage": false,
                      "searchKey": "runtime.malg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func malg(stacksize int32) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc malg(stacksize int32) *g\n```\n\nAllocate a new g, with a stack big enough for stacksize bytes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#newproc1",
                    "documentation": {
                      "identifier": "newproc1",
                      "newPage": false,
                      "searchKey": "runtime.newproc1",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g\n```\n\nCreate a new g in state _Grunnable, starting at fn, with narg bytes of arguments starting at argp. callerpc is the address of the go statement that created this. The caller is responsible for adding the new g to the scheduler. \n\nThis must run on the system stack because it's the continuation of newproc, which cannot split the stack. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#gfget",
                    "documentation": {
                      "identifier": "gfget",
                      "newPage": false,
                      "searchKey": "runtime.gfget",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func gfget(_p_ *p) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc gfget(_p_ *p) *g\n```\n\nGet from gfree list. If local list is empty, grab a batch from global list. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#globrunqget",
                    "documentation": {
                      "identifier": "globrunqget",
                      "newPage": false,
                      "searchKey": "runtime.globrunqget",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func globrunqget(_p_ *p, max int32) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc globrunqget(_p_ *p, max int32) *g\n```\n\nTry get a batch of G's from the global runnable queue. sched.lock must be held. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#runqget",
                    "documentation": {
                      "identifier": "runqget",
                      "newPage": false,
                      "searchKey": "runtime.runqget",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func runqget(_p_ *p) (gp *g, inheritTime bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc runqget(_p_ *p) (gp *g, inheritTime bool)\n```\n\nGet g from local runnable queue. If inheritTime is true, gp should inherit the remaining time in the current time slice. Otherwise, it should start a new time slice. Executed only by the owner P. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#runqsteal",
                    "documentation": {
                      "identifier": "runqsteal",
                      "newPage": false,
                      "searchKey": "runtime.runqsteal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func runqsteal(_p_, p2 *p, stealRunNextG bool) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc runqsteal(_p_, p2 *p, stealRunNextG bool) *g\n```\n\nSteal half of elements from local runnable queue of p2 and put onto local runnable queue of p. Returns one of the stolen elements (or nil if failed). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#sigFetchG",
                    "documentation": {
                      "identifier": "sigFetchG",
                      "newPage": false,
                      "searchKey": "runtime.sigFetchG",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func sigFetchG(c *sigctxt) *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc sigFetchG(c *sigctxt) *g\n```\n\nsigFetchG fetches the value of G safely when running in a signal handler. On some architectures, the g value may be clobbered when running in a VDSO. See issue #32912. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#getg",
                    "documentation": {
                      "identifier": "getg",
                      "newPage": false,
                      "searchKey": "runtime.getg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func getg() *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc getg() *g\n```\n\ngetg returns the pointer to the current g. The compiler rewrites calls to this function into instructions that fetch the g directly (from TLS or from the dedicated register). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceReader",
                    "documentation": {
                      "identifier": "traceReader",
                      "newPage": false,
                      "searchKey": "runtime.traceReader",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func traceReader() *g"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc traceReader() *g\n```\n\ntraceReader returns the trace reader that should be woken up, if any. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#Getg",
                    "documentation": {
                      "identifier": "Getg",
                      "newPage": false,
                      "searchKey": "runtime.Getg",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func Getg() *G"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc Getg() *G\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Sudog",
              "documentation": {
                "identifier": "Sudog",
                "newPage": false,
                "searchKey": "runtime.Sudog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Sudog runtime.sudog"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Sudog = sudog\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#acquireSudog",
                    "documentation": {
                      "identifier": "acquireSudog",
                      "newPage": false,
                      "searchKey": "runtime.acquireSudog",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func acquireSudog() *sudog"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc acquireSudog() *sudog\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PallocSum",
              "documentation": {
                "identifier": "PallocSum",
                "newPage": false,
                "searchKey": "runtime.PallocSum",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type PallocSum runtime.pallocSum"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PallocSum pallocSum\n```\n\nExpose pallocSum for testing. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#PackPallocSum",
                    "documentation": {
                      "identifier": "PackPallocSum",
                      "newPage": false,
                      "searchKey": "runtime.PackPallocSum",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func PackPallocSum(start, max, end uint) PallocSum"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc PackPallocSum(start, max, end uint) PallocSum\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#SummarizeSlow",
                    "documentation": {
                      "identifier": "SummarizeSlow",
                      "newPage": false,
                      "searchKey": "runtime.SummarizeSlow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func SummarizeSlow(b *PallocBits) PallocSum"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc SummarizeSlow(b *PallocBits) PallocSum\n```\n\nSummarizeSlow is a slow but more obviously correct implementation of (*pallocBits).summarize. Used for testing. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PallocSum.Start",
                    "documentation": {
                      "identifier": "PallocSum.Start",
                      "newPage": false,
                      "searchKey": "runtime.PallocSum.Start",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m PallocSum) Start() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m PallocSum) Start() uint\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PallocSum.Max",
                    "documentation": {
                      "identifier": "PallocSum.Max",
                      "newPage": false,
                      "searchKey": "runtime.PallocSum.Max",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m PallocSum) Max() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m PallocSum) Max() uint\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PallocSum.End",
                    "documentation": {
                      "identifier": "PallocSum.End",
                      "newPage": false,
                      "searchKey": "runtime.PallocSum.End",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (m PallocSum) End() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (m PallocSum) End() uint\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PallocBits",
              "documentation": {
                "identifier": "PallocBits",
                "newPage": false,
                "searchKey": "runtime.PallocBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type PallocBits runtime.pallocBits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PallocBits pallocBits\n```\n\nExpose pallocBits for testing. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#PallocBits.Find",
                    "documentation": {
                      "identifier": "PallocBits.Find",
                      "newPage": false,
                      "searchKey": "runtime.PallocBits.Find",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *PallocBits) Find(npages uintptr, searchIdx uint) (uint, uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *PallocBits) Find(npages uintptr, searchIdx uint) (uint, uint)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PallocBits.AllocRange",
                    "documentation": {
                      "identifier": "PallocBits.AllocRange",
                      "newPage": false,
                      "searchKey": "runtime.PallocBits.AllocRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *PallocBits) AllocRange(i, n uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *PallocBits) AllocRange(i, n uint)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PallocBits.Free",
                    "documentation": {
                      "identifier": "PallocBits.Free",
                      "newPage": false,
                      "searchKey": "runtime.PallocBits.Free",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *PallocBits) Free(i, n uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *PallocBits) Free(i, n uint)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PallocBits.Summarize",
                    "documentation": {
                      "identifier": "PallocBits.Summarize",
                      "newPage": false,
                      "searchKey": "runtime.PallocBits.Summarize",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *PallocBits) Summarize() PallocSum"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *PallocBits) Summarize() PallocSum\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PallocBits.PopcntRange",
                    "documentation": {
                      "identifier": "PallocBits.PopcntRange",
                      "newPage": false,
                      "searchKey": "runtime.PallocBits.PopcntRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (b *PallocBits) PopcntRange(i, n uint) uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (b *PallocBits) PopcntRange(i, n uint) uint\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PallocData",
              "documentation": {
                "identifier": "PallocData",
                "newPage": false,
                "searchKey": "runtime.PallocData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type PallocData runtime.pallocData"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PallocData pallocData\n```\n\nExpose pallocData for testing. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#PallocData.FindScavengeCandidate",
                    "documentation": {
                      "identifier": "PallocData.FindScavengeCandidate",
                      "newPage": false,
                      "searchKey": "runtime.PallocData.FindScavengeCandidate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *PallocData) FindScavengeCandidate(searchIdx uint, min, max uintptr) (uint, uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *PallocData) FindScavengeCandidate(searchIdx uint, min, max uintptr) (uint, uint)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PallocData.AllocRange",
                    "documentation": {
                      "identifier": "PallocData.AllocRange",
                      "newPage": false,
                      "searchKey": "runtime.PallocData.AllocRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *PallocData) AllocRange(i, n uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *PallocData) AllocRange(i, n uint)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PallocData.ScavengedSetRange",
                    "documentation": {
                      "identifier": "PallocData.ScavengedSetRange",
                      "newPage": false,
                      "searchKey": "runtime.PallocData.ScavengedSetRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *PallocData) ScavengedSetRange(i, n uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *PallocData) ScavengedSetRange(i, n uint)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PallocData.PallocBits",
                    "documentation": {
                      "identifier": "PallocData.PallocBits",
                      "newPage": false,
                      "searchKey": "runtime.PallocData.PallocBits",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *PallocData) PallocBits() *PallocBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *PallocData) PallocBits() *PallocBits\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PallocData.Scavenged",
                    "documentation": {
                      "identifier": "PallocData.Scavenged",
                      "newPage": false,
                      "searchKey": "runtime.PallocData.Scavenged",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *PallocData) Scavenged() *PallocBits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *PallocData) Scavenged() *PallocBits\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PageCache",
              "documentation": {
                "identifier": "PageCache",
                "newPage": false,
                "searchKey": "runtime.PageCache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type PageCache runtime.pageCache"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PageCache pageCache\n```\n\nExpose pageCache for testing. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#NewPageCache",
                    "documentation": {
                      "identifier": "NewPageCache",
                      "newPage": false,
                      "searchKey": "runtime.NewPageCache",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewPageCache(base uintptr, cache, scav uint64) PageCache"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewPageCache(base uintptr, cache, scav uint64) PageCache\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageCache.Empty",
                    "documentation": {
                      "identifier": "PageCache.Empty",
                      "newPage": false,
                      "searchKey": "runtime.PageCache.Empty",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *PageCache) Empty() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *PageCache) Empty() bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageCache.Base",
                    "documentation": {
                      "identifier": "PageCache.Base",
                      "newPage": false,
                      "searchKey": "runtime.PageCache.Base",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *PageCache) Base() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *PageCache) Base() uintptr\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageCache.Cache",
                    "documentation": {
                      "identifier": "PageCache.Cache",
                      "newPage": false,
                      "searchKey": "runtime.PageCache.Cache",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *PageCache) Cache() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *PageCache) Cache() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageCache.Scav",
                    "documentation": {
                      "identifier": "PageCache.Scav",
                      "newPage": false,
                      "searchKey": "runtime.PageCache.Scav",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *PageCache) Scav() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *PageCache) Scav() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageCache.Alloc",
                    "documentation": {
                      "identifier": "PageCache.Alloc",
                      "newPage": false,
                      "searchKey": "runtime.PageCache.Alloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *PageCache) Alloc(npages uintptr) (uintptr, uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *PageCache) Alloc(npages uintptr) (uintptr, uintptr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageCache.Flush",
                    "documentation": {
                      "identifier": "PageCache.Flush",
                      "newPage": false,
                      "searchKey": "runtime.PageCache.Flush",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (c *PageCache) Flush(s *PageAlloc)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (c *PageCache) Flush(s *PageAlloc)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ChunkIdx",
              "documentation": {
                "identifier": "ChunkIdx",
                "newPage": false,
                "searchKey": "runtime.ChunkIdx",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ChunkIdx runtime.chunkIdx"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ChunkIdx chunkIdx\n```\n\nExpose chunk index type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PageAlloc",
              "documentation": {
                "identifier": "PageAlloc",
                "newPage": false,
                "searchKey": "runtime.PageAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type PageAlloc runtime.pageAlloc"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype PageAlloc pageAlloc\n```\n\nExpose pageAlloc for testing. Note that because pageAlloc is not in the heap, so is PageAlloc. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#NewPageAlloc",
                    "documentation": {
                      "identifier": "NewPageAlloc",
                      "newPage": false,
                      "searchKey": "runtime.NewPageAlloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewPageAlloc(chunks, scav map[ChunkIdx][]BitRange) *PageAlloc"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewPageAlloc(chunks, scav map[ChunkIdx][]BitRange) *PageAlloc\n```\n\nNewPageAlloc creates a new page allocator for testing and initializes it with the scav and chunks maps. Each key in these maps represents a chunk index and each value is a series of bit ranges to set within each bitmap's chunk. \n\nThe initialization of the pageAlloc preserves the invariant that if a scavenged bit is set the alloc bit is necessarily unset, so some of the bits described by scav may be cleared in the final bitmap if ranges in chunks overlap with them. \n\nscav is optional, and if nil, the scavenged bitmap will be cleared (as opposed to all 1s, which it usually is). Furthermore, every chunk index in scav must appear in chunks; ones that do not are ignored. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageAlloc.Alloc",
                    "documentation": {
                      "identifier": "PageAlloc.Alloc",
                      "newPage": false,
                      "searchKey": "runtime.PageAlloc.Alloc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *PageAlloc) Alloc(npages uintptr) (uintptr, uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *PageAlloc) Alloc(npages uintptr) (uintptr, uintptr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageAlloc.AllocToCache",
                    "documentation": {
                      "identifier": "PageAlloc.AllocToCache",
                      "newPage": false,
                      "searchKey": "runtime.PageAlloc.AllocToCache",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *PageAlloc) AllocToCache() PageCache"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *PageAlloc) AllocToCache() PageCache\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageAlloc.Free",
                    "documentation": {
                      "identifier": "PageAlloc.Free",
                      "newPage": false,
                      "searchKey": "runtime.PageAlloc.Free",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *PageAlloc) Free(base, npages uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *PageAlloc) Free(base, npages uintptr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageAlloc.Bounds",
                    "documentation": {
                      "identifier": "PageAlloc.Bounds",
                      "newPage": false,
                      "searchKey": "runtime.PageAlloc.Bounds",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *PageAlloc) Bounds() (ChunkIdx, ChunkIdx)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *PageAlloc) Bounds() (ChunkIdx, ChunkIdx)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageAlloc.Scavenge",
                    "documentation": {
                      "identifier": "PageAlloc.Scavenge",
                      "newPage": false,
                      "searchKey": "runtime.PageAlloc.Scavenge",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *PageAlloc) Scavenge(nbytes uintptr, mayUnlock bool) (r uintptr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *PageAlloc) Scavenge(nbytes uintptr, mayUnlock bool) (r uintptr)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageAlloc.InUse",
                    "documentation": {
                      "identifier": "PageAlloc.InUse",
                      "newPage": false,
                      "searchKey": "runtime.PageAlloc.InUse",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *PageAlloc) InUse() []AddrRange"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *PageAlloc) InUse() []AddrRange\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#PageAlloc.PallocData",
                    "documentation": {
                      "identifier": "PageAlloc.PallocData",
                      "newPage": false,
                      "searchKey": "runtime.PageAlloc.PallocData",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (p *PageAlloc) PallocData(i ChunkIdx) *PallocData"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (p *PageAlloc) PallocData(i ChunkIdx) *PallocData\n```\n\nReturns nil if the PallocData's L2 is missing. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#AddrRange",
              "documentation": {
                "identifier": "AddrRange",
                "newPage": false,
                "searchKey": "runtime.AddrRange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type AddrRange struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype AddrRange struct {\n\taddrRange\n}\n```\n\nAddrRange is a wrapper around addrRange for testing. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#MakeAddrRange",
                    "documentation": {
                      "identifier": "MakeAddrRange",
                      "newPage": false,
                      "searchKey": "runtime.MakeAddrRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MakeAddrRange(base, limit uintptr) AddrRange"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MakeAddrRange(base, limit uintptr) AddrRange\n```\n\nMakeAddrRange creates a new address range. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#AddrRange.Base",
                    "documentation": {
                      "identifier": "AddrRange.Base",
                      "newPage": false,
                      "searchKey": "runtime.AddrRange.Base",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a AddrRange) Base() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a AddrRange) Base() uintptr\n```\n\nBase returns the virtual base address of the address range. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#AddrRange.Limit",
                    "documentation": {
                      "identifier": "AddrRange.Limit",
                      "newPage": false,
                      "searchKey": "runtime.AddrRange.Limit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a AddrRange) Limit() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a AddrRange) Limit() uintptr\n```\n\nBase returns the virtual address of the limit of the address range. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#AddrRange.Equals",
                    "documentation": {
                      "identifier": "AddrRange.Equals",
                      "newPage": false,
                      "searchKey": "runtime.AddrRange.Equals",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a AddrRange) Equals(b AddrRange) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a AddrRange) Equals(b AddrRange) bool\n```\n\nEquals returns true if the two address ranges are exactly equal. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#AddrRange.Size",
                    "documentation": {
                      "identifier": "AddrRange.Size",
                      "newPage": false,
                      "searchKey": "runtime.AddrRange.Size",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a AddrRange) Size() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a AddrRange) Size() uintptr\n```\n\nSize returns the size in bytes of the address range. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#AddrRanges",
              "documentation": {
                "identifier": "AddrRanges",
                "newPage": false,
                "searchKey": "runtime.AddrRanges",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type AddrRanges struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype AddrRanges struct {\n\taddrRanges\n\tmutable bool\n}\n```\n\nAddrRanges is a wrapper around addrRanges for testing. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#NewAddrRanges",
                    "documentation": {
                      "identifier": "NewAddrRanges",
                      "newPage": false,
                      "searchKey": "runtime.NewAddrRanges",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewAddrRanges() AddrRanges"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewAddrRanges() AddrRanges\n```\n\nNewAddrRanges creates a new empty addrRanges. \n\nNote that this initializes addrRanges just like in the runtime, so its memory is persistentalloc'd. Call this function sparingly since the memory it allocates is leaked. \n\nThis AddrRanges is mutable, so we can test methods like Add. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#MakeAddrRanges",
                    "documentation": {
                      "identifier": "MakeAddrRanges",
                      "newPage": false,
                      "searchKey": "runtime.MakeAddrRanges",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func MakeAddrRanges(a ...AddrRange) AddrRanges"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc MakeAddrRanges(a ...AddrRange) AddrRanges\n```\n\nMakeAddrRanges creates a new addrRanges populated with the ranges in a. \n\nThe returned AddrRanges is immutable, so methods like Add will fail. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#AddrRanges.Ranges",
                    "documentation": {
                      "identifier": "AddrRanges.Ranges",
                      "newPage": false,
                      "searchKey": "runtime.AddrRanges.Ranges",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *AddrRanges) Ranges() []AddrRange"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *AddrRanges) Ranges() []AddrRange\n```\n\nRanges returns a copy of the ranges described by the addrRanges. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#AddrRanges.FindSucc",
                    "documentation": {
                      "identifier": "AddrRanges.FindSucc",
                      "newPage": false,
                      "searchKey": "runtime.AddrRanges.FindSucc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *AddrRanges) FindSucc(base uintptr) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *AddrRanges) FindSucc(base uintptr) int\n```\n\nFindSucc returns the successor to base. See addrRanges.findSucc for more details. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#AddrRanges.Add",
                    "documentation": {
                      "identifier": "AddrRanges.Add",
                      "newPage": false,
                      "searchKey": "runtime.AddrRanges.Add",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *AddrRanges) Add(r AddrRange)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *AddrRanges) Add(r AddrRange)\n```\n\nAdd adds a new AddrRange to the AddrRanges. \n\nThe AddrRange must be mutable (i.e. created by NewAddrRanges), otherwise this method will throw. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#AddrRanges.TotalBytes",
                    "documentation": {
                      "identifier": "AddrRanges.TotalBytes",
                      "newPage": false,
                      "searchKey": "runtime.AddrRanges.TotalBytes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *AddrRanges) TotalBytes() uintptr"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *AddrRanges) TotalBytes() uintptr\n```\n\nTotalBytes returns the totalBytes field of the addrRanges. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#BitRange",
              "documentation": {
                "identifier": "BitRange",
                "newPage": false,
                "searchKey": "runtime.BitRange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type BitRange struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype BitRange struct {\n\tI, N uint // bit index and length in bits\n}\n```\n\nBitRange represents a range over a bitmap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#BitsMismatch",
              "documentation": {
                "identifier": "BitsMismatch",
                "newPage": false,
                "searchKey": "runtime.BitsMismatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type BitsMismatch struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype BitsMismatch struct {\n\tBase      uintptr\n\tGot, Want uint64\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MSpan",
              "documentation": {
                "identifier": "MSpan",
                "newPage": false,
                "searchKey": "runtime.MSpan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type MSpan runtime.mspan"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype MSpan mspan\n```\n\nmspan wrapper for testing. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#AllocMSpan",
                    "documentation": {
                      "identifier": "AllocMSpan",
                      "newPage": false,
                      "searchKey": "runtime.AllocMSpan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func AllocMSpan() *MSpan"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc AllocMSpan() *MSpan\n```\n\nAllocate an mspan for testing. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#TimeHistogram",
              "documentation": {
                "identifier": "TimeHistogram",
                "newPage": false,
                "searchKey": "runtime.TimeHistogram",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type TimeHistogram runtime.timeHistogram"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype TimeHistogram timeHistogram\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#TimeHistogram.Count",
                    "documentation": {
                      "identifier": "TimeHistogram.Count",
                      "newPage": false,
                      "searchKey": "runtime.TimeHistogram.Count",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (th *TimeHistogram) Count(bucket, subBucket uint) (uint64, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (th *TimeHistogram) Count(bucket, subBucket uint) (uint64, bool)\n```\n\nCounts returns the counts for the given bucket, subBucket indices. Returns true if the bucket was valid, otherwise returns the counts for the underflow bucket and false. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#TimeHistogram.Record",
                    "documentation": {
                      "identifier": "TimeHistogram.Record",
                      "newPage": false,
                      "searchKey": "runtime.TimeHistogram.Record",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (th *TimeHistogram) Record(duration int64)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (th *TimeHistogram) Record(duration int64)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#M",
              "documentation": {
                "identifier": "M",
                "newPage": false,
                "searchKey": "runtime.M",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type M runtime.m"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype M = m\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/runtime#allocm",
                    "documentation": {
                      "identifier": "allocm",
                      "newPage": false,
                      "searchKey": "runtime.allocm",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func allocm(_p_ *p, fn func(), id int64) *m"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc allocm(_p_ *p, fn func(), id int64) *m\n```\n\nAllocate a new m unassociated with any thread. Can use p for allocation context if needed. fn is recorded as the new m's m.mstartfn. id is optional pre-allocated m ID. Omit by passing -1. \n\nThis function is allowed to have write barriers even if the caller isn't because it borrows _p_. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#lockextra",
                    "documentation": {
                      "identifier": "lockextra",
                      "newPage": false,
                      "searchKey": "runtime.lockextra",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func lockextra(nilokay bool) *m"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc lockextra(nilokay bool) *m\n```\n\nlockextra locks the extra list and returns the list head. The caller must unlock the list by storing a new list head to extram. If nilokay is true, then lockextra will return a nil list head if that's what it finds. If nilokay is false, lockextra will keep waiting until the list head is no longer nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#mget",
                    "documentation": {
                      "identifier": "mget",
                      "newPage": false,
                      "searchKey": "runtime.mget",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mget() *m"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mget() *m\n```\n\nTry to get an m from midle list. sched.lock must be held. May run during STW, so write barriers are not allowed. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#acquirem",
                    "documentation": {
                      "identifier": "acquirem",
                      "newPage": false,
                      "searchKey": "runtime.acquirem",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func acquirem() *m"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc acquirem() *m\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/runtime#traceAcquireBuffer",
                    "documentation": {
                      "identifier": "traceAcquireBuffer",
                      "newPage": false,
                      "searchKey": "runtime.traceAcquireBuffer",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func traceAcquireBuffer() (mp *m, pid int32, bufp *traceBufPtr)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc traceAcquireBuffer() (mp *m, pid int32, bufp *traceBufPtr)\n```\n\ntraceAcquireBuffer returns trace buffer to use and, if necessary, locks it. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/runtime#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/runtime#memhash0",
              "documentation": {
                "identifier": "memhash0",
                "newPage": false,
                "searchKey": "runtime.memhash0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memhash0(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memhash0(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memhash8",
              "documentation": {
                "identifier": "memhash8",
                "newPage": false,
                "searchKey": "runtime.memhash8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memhash8(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memhash8(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memhash16",
              "documentation": {
                "identifier": "memhash16",
                "newPage": false,
                "searchKey": "runtime.memhash16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memhash16(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memhash16(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memhash128",
              "documentation": {
                "identifier": "memhash128",
                "newPage": false,
                "searchKey": "runtime.memhash128",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memhash128(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memhash128(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memhash_varlen",
              "documentation": {
                "identifier": "memhash_varlen",
                "newPage": false,
                "searchKey": "runtime.memhash_varlen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memhash_varlen(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memhash_varlen(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memhash",
              "documentation": {
                "identifier": "memhash",
                "newPage": false,
                "searchKey": "runtime.memhash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memhash(p unsafe.Pointer, h, s uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memhash(p unsafe.Pointer, h, s uintptr) uintptr\n```\n\nin asm_*.s \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memhash32",
              "documentation": {
                "identifier": "memhash32",
                "newPage": false,
                "searchKey": "runtime.memhash32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memhash32(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memhash32(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memhash64",
              "documentation": {
                "identifier": "memhash64",
                "newPage": false,
                "searchKey": "runtime.memhash64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memhash64(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memhash64(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#strhash",
              "documentation": {
                "identifier": "strhash",
                "newPage": false,
                "searchKey": "runtime.strhash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func strhash(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc strhash(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#strhashFallback",
              "documentation": {
                "identifier": "strhashFallback",
                "newPage": false,
                "searchKey": "runtime.strhashFallback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func strhashFallback(a unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc strhashFallback(a unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f32hash",
              "documentation": {
                "identifier": "f32hash",
                "newPage": false,
                "searchKey": "runtime.f32hash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f32hash(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f32hash(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f64hash",
              "documentation": {
                "identifier": "f64hash",
                "newPage": false,
                "searchKey": "runtime.f64hash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f64hash(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f64hash(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#c64hash",
              "documentation": {
                "identifier": "c64hash",
                "newPage": false,
                "searchKey": "runtime.c64hash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func c64hash(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc c64hash(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#c128hash",
              "documentation": {
                "identifier": "c128hash",
                "newPage": false,
                "searchKey": "runtime.c128hash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func c128hash(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc c128hash(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#interhash",
              "documentation": {
                "identifier": "interhash",
                "newPage": false,
                "searchKey": "runtime.interhash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func interhash(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc interhash(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nilinterhash",
              "documentation": {
                "identifier": "nilinterhash",
                "newPage": false,
                "searchKey": "runtime.nilinterhash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nilinterhash(p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nilinterhash(p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typehash",
              "documentation": {
                "identifier": "typehash",
                "newPage": false,
                "searchKey": "runtime.typehash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typehash(t *_type, p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typehash(t *_type, p unsafe.Pointer, h uintptr) uintptr\n```\n\ntypehash computes the hash of the object of type t at address p. h is the seed. This function is seldom used. Most maps use for hashing either fixed functions (e.g. f32hash) or compiler-generated functions (e.g. for a type like struct { x, y string }). This implementation is slower but more general and is used for hashing interface types (called from interhash or nilinterhash, above) or for hashing in maps generated by reflect.MapOf (reflect_typehash, below). Note: this function must match the compiler generated functions exactly. See issue 37716. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_typehash",
              "documentation": {
                "identifier": "reflect_typehash",
                "newPage": false,
                "searchKey": "runtime.reflect_typehash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_typehash(t *_type, p unsafe.Pointer, h uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_typehash(t *_type, p unsafe.Pointer, h uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memequal0",
              "documentation": {
                "identifier": "memequal0",
                "newPage": false,
                "searchKey": "runtime.memequal0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memequal0(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memequal0(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memequal8",
              "documentation": {
                "identifier": "memequal8",
                "newPage": false,
                "searchKey": "runtime.memequal8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memequal8(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memequal8(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memequal16",
              "documentation": {
                "identifier": "memequal16",
                "newPage": false,
                "searchKey": "runtime.memequal16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memequal16(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memequal16(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memequal32",
              "documentation": {
                "identifier": "memequal32",
                "newPage": false,
                "searchKey": "runtime.memequal32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memequal32(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memequal32(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memequal64",
              "documentation": {
                "identifier": "memequal64",
                "newPage": false,
                "searchKey": "runtime.memequal64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memequal64(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memequal64(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memequal128",
              "documentation": {
                "identifier": "memequal128",
                "newPage": false,
                "searchKey": "runtime.memequal128",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memequal128(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memequal128(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f32equal",
              "documentation": {
                "identifier": "f32equal",
                "newPage": false,
                "searchKey": "runtime.f32equal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f32equal(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f32equal(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f64equal",
              "documentation": {
                "identifier": "f64equal",
                "newPage": false,
                "searchKey": "runtime.f64equal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f64equal(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f64equal(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#c64equal",
              "documentation": {
                "identifier": "c64equal",
                "newPage": false,
                "searchKey": "runtime.c64equal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func c64equal(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc c64equal(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#c128equal",
              "documentation": {
                "identifier": "c128equal",
                "newPage": false,
                "searchKey": "runtime.c128equal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func c128equal(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc c128equal(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#strequal",
              "documentation": {
                "identifier": "strequal",
                "newPage": false,
                "searchKey": "runtime.strequal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func strequal(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc strequal(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#interequal",
              "documentation": {
                "identifier": "interequal",
                "newPage": false,
                "searchKey": "runtime.interequal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func interequal(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc interequal(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nilinterequal",
              "documentation": {
                "identifier": "nilinterequal",
                "newPage": false,
                "searchKey": "runtime.nilinterequal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nilinterequal(p, q unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nilinterequal(p, q unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#efaceeq",
              "documentation": {
                "identifier": "efaceeq",
                "newPage": false,
                "searchKey": "runtime.efaceeq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func efaceeq(t *_type, x, y unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc efaceeq(t *_type, x, y unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ifaceeq",
              "documentation": {
                "identifier": "ifaceeq",
                "newPage": false,
                "searchKey": "runtime.ifaceeq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ifaceeq(tab *itab, x, y unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ifaceeq(tab *itab, x, y unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stringHash",
              "documentation": {
                "identifier": "stringHash",
                "newPage": false,
                "searchKey": "runtime.stringHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringHash(s string, seed uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringHash(s string, seed uintptr) uintptr\n```\n\nTesting adapters for hash quality tests (see hash_test.go) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bytesHash",
              "documentation": {
                "identifier": "bytesHash",
                "newPage": false,
                "searchKey": "runtime.bytesHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bytesHash(b []byte, seed uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bytesHash(b []byte, seed uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#int32Hash",
              "documentation": {
                "identifier": "int32Hash",
                "newPage": false,
                "searchKey": "runtime.int32Hash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func int32Hash(i uint32, seed uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc int32Hash(i uint32, seed uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#int64Hash",
              "documentation": {
                "identifier": "int64Hash",
                "newPage": false,
                "searchKey": "runtime.int64Hash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func int64Hash(i uint64, seed uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc int64Hash(i uint64, seed uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#efaceHash",
              "documentation": {
                "identifier": "efaceHash",
                "newPage": false,
                "searchKey": "runtime.efaceHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func efaceHash(i interface{}, seed uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc efaceHash(i interface{}, seed uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ifaceHash",
              "documentation": {
                "identifier": "ifaceHash",
                "newPage": false,
                "searchKey": "runtime.ifaceHash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ifaceHash(i interface {..."
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ifaceHash(i interface {\n\tF()\n}, seed uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#alginit",
              "documentation": {
                "identifier": "alginit",
                "newPage": false,
                "searchKey": "runtime.alginit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func alginit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc alginit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#initAlgAES",
              "documentation": {
                "identifier": "initAlgAES",
                "newPage": false,
                "searchKey": "runtime.initAlgAES",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func initAlgAES()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc initAlgAES()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readUnaligned32",
              "documentation": {
                "identifier": "readUnaligned32",
                "newPage": false,
                "searchKey": "runtime.readUnaligned32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readUnaligned32(p unsafe.Pointer) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readUnaligned32(p unsafe.Pointer) uint32\n```\n\nNote: These routines perform the read with a native endianness. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readUnaligned64",
              "documentation": {
                "identifier": "readUnaligned64",
                "newPage": false,
                "searchKey": "runtime.readUnaligned64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readUnaligned64(p unsafe.Pointer) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readUnaligned64(p unsafe.Pointer) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#atomicwb",
              "documentation": {
                "identifier": "atomicwb",
                "newPage": false,
                "searchKey": "runtime.atomicwb",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func atomicwb(ptr *unsafe.Pointer, new unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc atomicwb(ptr *unsafe.Pointer, new unsafe.Pointer)\n```\n\natomicwb performs a write barrier before an atomic pointer write. The caller should guard the call with \"if writeBarrier.enabled\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#atomicstorep",
              "documentation": {
                "identifier": "atomicstorep",
                "newPage": false,
                "searchKey": "runtime.atomicstorep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer)\n```\n\natomicstorep performs *ptr = new atomically and invokes a write barrier. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_atomic_StoreUintptr",
              "documentation": {
                "identifier": "sync_atomic_StoreUintptr",
                "newPage": false,
                "searchKey": "runtime.sync_atomic_StoreUintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_atomic_StoreUintptr(ptr *uintptr, new uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_atomic_StoreUintptr(ptr *uintptr, new uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_atomic_StorePointer",
              "documentation": {
                "identifier": "sync_atomic_StorePointer",
                "newPage": false,
                "searchKey": "runtime.sync_atomic_StorePointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_atomic_StorePointer(ptr *unsafe.Pointer, new unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_atomic_StorePointer(ptr *unsafe.Pointer, new unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_atomic_SwapUintptr",
              "documentation": {
                "identifier": "sync_atomic_SwapUintptr",
                "newPage": false,
                "searchKey": "runtime.sync_atomic_SwapUintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_atomic_SwapUintptr(ptr *uintptr, new uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_atomic_SwapUintptr(ptr *uintptr, new uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_atomic_SwapPointer",
              "documentation": {
                "identifier": "sync_atomic_SwapPointer",
                "newPage": false,
                "searchKey": "runtime.sync_atomic_SwapPointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_atomic_SwapPointer(ptr *unsafe.Pointer, new unsafe.Pointer) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_atomic_SwapPointer(ptr *unsafe.Pointer, new unsafe.Pointer) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_atomic_CompareAndSwapUintptr",
              "documentation": {
                "identifier": "sync_atomic_CompareAndSwapUintptr",
                "newPage": false,
                "searchKey": "runtime.sync_atomic_CompareAndSwapUintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_atomic_CompareAndSwapUintptr(ptr *uintptr, old, new uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_atomic_CompareAndSwapUintptr(ptr *uintptr, old, new uintptr) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_atomic_CompareAndSwapPointer",
              "documentation": {
                "identifier": "sync_atomic_CompareAndSwapPointer",
                "newPage": false,
                "searchKey": "runtime.sync_atomic_CompareAndSwapPointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_atomic_CompareAndSwapPointer(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_atomic_CompareAndSwapPointer(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoUse",
              "documentation": {
                "identifier": "cgoUse",
                "newPage": false,
                "searchKey": "runtime.cgoUse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoUse(interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoUse(interface{})\n```\n\ncgoUse is called by cgo-generated code (using go:linkname to get at an unexported name). The calls serve two purposes: 1) they are opaque to escape analysis, so the argument is considered to escape to the heap. 2) they keep the argument alive until the call site; the call is emitted after the end of the (presumed) use of the argument by C. cgoUse should not actually be called (see cgoAlwaysFalse). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_cgocaller",
              "documentation": {
                "identifier": "syscall_cgocaller",
                "newPage": false,
                "searchKey": "runtime.syscall_cgocaller",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_cgocaller(fn unsafe.Pointer, args ...uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_cgocaller(fn unsafe.Pointer, args ...uintptr) uintptr\n```\n\nwrapper for syscall package to call cgocall for libc (cgo) calls. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgocall",
              "documentation": {
                "identifier": "cgocall",
                "newPage": false,
                "searchKey": "runtime.cgocall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgocall(fn, arg unsafe.Pointer) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgocall(fn, arg unsafe.Pointer) int32\n```\n\nCall from Go to C. \n\nThis must be nosplit because it's used for syscalls on some platforms. Syscalls may have untyped arguments on the stack, so it's not safe to grow or scan the stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgocallbackg",
              "documentation": {
                "identifier": "cgocallbackg",
                "newPage": false,
                "searchKey": "runtime.cgocallbackg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgocallbackg(fn, frame unsafe.Pointer, ctxt uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgocallbackg(fn, frame unsafe.Pointer, ctxt uintptr)\n```\n\nCall from C back to Go. fn must point to an ABIInternal Go entry-point. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgocallbackg1",
              "documentation": {
                "identifier": "cgocallbackg1",
                "newPage": false,
                "searchKey": "runtime.cgocallbackg1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgocallbackg1(fn, frame unsafe.Pointer, ctxt uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgocallbackg1(fn, frame unsafe.Pointer, ctxt uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unwindm",
              "documentation": {
                "identifier": "unwindm",
                "newPage": false,
                "searchKey": "runtime.unwindm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unwindm(restore *bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unwindm(restore *bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badcgocallback",
              "documentation": {
                "identifier": "badcgocallback",
                "newPage": false,
                "searchKey": "runtime.badcgocallback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badcgocallback()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badcgocallback()\n```\n\ncalled from assembly \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgounimpl",
              "documentation": {
                "identifier": "cgounimpl",
                "newPage": false,
                "searchKey": "runtime.cgounimpl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgounimpl()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgounimpl()\n```\n\ncalled from (incomplete) assembly \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoCheckPointer",
              "documentation": {
                "identifier": "cgoCheckPointer",
                "newPage": false,
                "searchKey": "runtime.cgoCheckPointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoCheckPointer(ptr interface{}, arg interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoCheckPointer(ptr interface{}, arg interface{})\n```\n\ncgoCheckPointer checks if the argument contains a Go pointer that points to a Go pointer, and panics if it does. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoCheckArg",
              "documentation": {
                "identifier": "cgoCheckArg",
                "newPage": false,
                "searchKey": "runtime.cgoCheckArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoCheckArg(t *_type, p unsafe.Pointer, indir, top bool, msg string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoCheckArg(t *_type, p unsafe.Pointer, indir, top bool, msg string)\n```\n\ncgoCheckArg is the real work of cgoCheckPointer. The argument p is either a pointer to the value (of type t), or the value itself, depending on indir. The top parameter is whether we are at the top level, where Go pointers are allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoCheckUnknownPointer",
              "documentation": {
                "identifier": "cgoCheckUnknownPointer",
                "newPage": false,
                "searchKey": "runtime.cgoCheckUnknownPointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoCheckUnknownPointer(p unsafe.Pointer, msg string) (base, i uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoCheckUnknownPointer(p unsafe.Pointer, msg string) (base, i uintptr)\n```\n\ncgoCheckUnknownPointer is called for an arbitrary pointer into Go memory. It checks whether that Go memory contains any other pointer into Go memory. If it does, we panic. The return values are unused but useful to see in panic tracebacks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoIsGoPointer",
              "documentation": {
                "identifier": "cgoIsGoPointer",
                "newPage": false,
                "searchKey": "runtime.cgoIsGoPointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoIsGoPointer(p unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoIsGoPointer(p unsafe.Pointer) bool\n```\n\ncgoIsGoPointer reports whether the pointer is a Go pointer--a pointer to Go memory. We only care about Go memory that might contain pointers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoInRange",
              "documentation": {
                "identifier": "cgoInRange",
                "newPage": false,
                "searchKey": "runtime.cgoInRange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoInRange(p unsafe.Pointer, start, end uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoInRange(p unsafe.Pointer, start, end uintptr) bool\n```\n\ncgoInRange reports whether p is between start and end. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoCheckResult",
              "documentation": {
                "identifier": "cgoCheckResult",
                "newPage": false,
                "searchKey": "runtime.cgoCheckResult",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoCheckResult(val interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoCheckResult(val interface{})\n```\n\ncgoCheckResult is called to check the result parameter of an exported Go function. It panics if the result is or contains a Go pointer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_cgo_panic_internal",
              "documentation": {
                "identifier": "_cgo_panic_internal",
                "newPage": false,
                "searchKey": "runtime._cgo_panic_internal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func _cgo_panic_internal(p *byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc _cgo_panic_internal(p *byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoCheckWriteBarrier",
              "documentation": {
                "identifier": "cgoCheckWriteBarrier",
                "newPage": false,
                "searchKey": "runtime.cgoCheckWriteBarrier",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoCheckWriteBarrier(dst *uintptr, src uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoCheckWriteBarrier(dst *uintptr, src uintptr)\n```\n\ncgoCheckWriteBarrier is called whenever a pointer is stored into memory. It throws if the program is storing a Go pointer into non-Go memory. \n\nThis is called from the write barrier, so its entire call tree must be nosplit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoCheckMemmove",
              "documentation": {
                "identifier": "cgoCheckMemmove",
                "newPage": false,
                "searchKey": "runtime.cgoCheckMemmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoCheckMemmove(typ *_type, dst, src unsafe.Pointer, off, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoCheckMemmove(typ *_type, dst, src unsafe.Pointer, off, size uintptr)\n```\n\ncgoCheckMemmove is called when moving a block of memory. dst and src point off bytes into the value to copy. size is the number of bytes to copy. It throws if the program is copying a block that contains a Go pointer into non-Go memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoCheckSliceCopy",
              "documentation": {
                "identifier": "cgoCheckSliceCopy",
                "newPage": false,
                "searchKey": "runtime.cgoCheckSliceCopy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoCheckSliceCopy(typ *_type, dst, src unsafe.Pointer, n int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoCheckSliceCopy(typ *_type, dst, src unsafe.Pointer, n int)\n```\n\ncgoCheckSliceCopy is called when copying n elements of a slice. src and dst are pointers to the first element of the slice. typ is the element type of the slice. It throws if the program is copying slice elements that contain Go pointers into non-Go memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoCheckTypedBlock",
              "documentation": {
                "identifier": "cgoCheckTypedBlock",
                "newPage": false,
                "searchKey": "runtime.cgoCheckTypedBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoCheckTypedBlock(typ *_type, src unsafe.Pointer, off, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoCheckTypedBlock(typ *_type, src unsafe.Pointer, off, size uintptr)\n```\n\ncgoCheckTypedBlock checks the block of memory at src, for up to size bytes, and throws if it finds a Go pointer. The type of the memory is typ, and src is off bytes into that type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoCheckBits",
              "documentation": {
                "identifier": "cgoCheckBits",
                "newPage": false,
                "searchKey": "runtime.cgoCheckBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoCheckBits(src unsafe.Pointer, gcbits *byte, off, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoCheckBits(src unsafe.Pointer, gcbits *byte, off, size uintptr)\n```\n\ncgoCheckBits checks the block of memory at src, for up to size bytes, and throws if it finds a Go pointer. The gcbits mark each pointer value. The src pointer is off bytes into the gcbits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoCheckUsingType",
              "documentation": {
                "identifier": "cgoCheckUsingType",
                "newPage": false,
                "searchKey": "runtime.cgoCheckUsingType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoCheckUsingType(typ *_type, src unsafe.Pointer, off, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoCheckUsingType(typ *_type, src unsafe.Pointer, off, size uintptr)\n```\n\ncgoCheckUsingType is like cgoCheckTypedBlock, but is a last ditch fall back to look for pointers in src using the type information. We only use this when looking at a value on the stack when the type uses a GC program, because otherwise it's more efficient to use the GC bits. This is called on the system stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chanbuf",
              "documentation": {
                "identifier": "chanbuf",
                "newPage": false,
                "searchKey": "runtime.chanbuf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chanbuf(c *hchan, i uint) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chanbuf(c *hchan, i uint) unsafe.Pointer\n```\n\nchanbuf(c, i) is pointer to the i'th slot in the buffer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#full",
              "documentation": {
                "identifier": "full",
                "newPage": false,
                "searchKey": "runtime.full",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func full(c *hchan) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc full(c *hchan) bool\n```\n\nfull reports whether a send on c would block (that is, the channel is full). It uses a single word-sized read of mutable state, so although the answer is instantaneously true, the correct answer may have changed by the time the calling function receives the return value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chansend1",
              "documentation": {
                "identifier": "chansend1",
                "newPage": false,
                "searchKey": "runtime.chansend1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chansend1(c *hchan, elem unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chansend1(c *hchan, elem unsafe.Pointer)\n```\n\nentry point for c <- x from compiled code \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chansend",
              "documentation": {
                "identifier": "chansend",
                "newPage": false,
                "searchKey": "runtime.chansend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool\n```\n\n* generic single channel send/recv * If block is not nil, * then the protocol will not * sleep but return if it could * not complete. * * sleep can wake up with g.param == nil * when a channel involved in the sleep has * been closed.  it is easiest to loop and re-run * the operation; we'll see that it's now closed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#send",
              "documentation": {
                "identifier": "send",
                "newPage": false,
                "searchKey": "runtime.send",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int)\n```\n\nsend processes a send operation on an empty channel c. The value ep sent by the sender is copied to the receiver sg. The receiver is then woken up to go on its merry way. Channel c must be empty and locked.  send unlocks c with unlockf. sg must already be dequeued from c. ep must be non-nil and point to the heap or the caller's stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sendDirect",
              "documentation": {
                "identifier": "sendDirect",
                "newPage": false,
                "searchKey": "runtime.sendDirect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sendDirect(t *_type, sg *sudog, src unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sendDirect(t *_type, sg *sudog, src unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#recvDirect",
              "documentation": {
                "identifier": "recvDirect",
                "newPage": false,
                "searchKey": "runtime.recvDirect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc recvDirect(t *_type, sg *sudog, dst unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#closechan",
              "documentation": {
                "identifier": "closechan",
                "newPage": false,
                "searchKey": "runtime.closechan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func closechan(c *hchan)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc closechan(c *hchan)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#empty",
              "documentation": {
                "identifier": "empty",
                "newPage": false,
                "searchKey": "runtime.empty",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func empty(c *hchan) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc empty(c *hchan) bool\n```\n\nempty reports whether a read from c would block (that is, the channel is empty).  It uses a single atomic read of mutable state. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chanrecv1",
              "documentation": {
                "identifier": "chanrecv1",
                "newPage": false,
                "searchKey": "runtime.chanrecv1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chanrecv1(c *hchan, elem unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chanrecv1(c *hchan, elem unsafe.Pointer)\n```\n\nentry points for <- c from compiled code \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chanrecv2",
              "documentation": {
                "identifier": "chanrecv2",
                "newPage": false,
                "searchKey": "runtime.chanrecv2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chanrecv2(c *hchan, elem unsafe.Pointer) (received bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chanrecv",
              "documentation": {
                "identifier": "chanrecv",
                "newPage": false,
                "searchKey": "runtime.chanrecv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)\n```\n\nchanrecv receives on channel c and writes the received data to ep. ep may be nil, in which case received data is ignored. If block == false and no elements are available, returns (false, false). Otherwise, if c is closed, zeros *ep and returns (true, false). Otherwise, fills in *ep with an element and returns (true, true). A non-nil ep must point to the heap or the caller's stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#recv",
              "documentation": {
                "identifier": "recv",
                "newPage": false,
                "searchKey": "runtime.recv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int)\n```\n\nrecv processes a receive operation on a full channel c. There are 2 parts: 1) The value sent by the sender sg is put into the channel \n\n```\nand the sender is woken up to go on its merry way.\n\n```\n2) The value received by the receiver (the current G) is \n\n```\nwritten to ep.\n\n```\nFor synchronous channels, both values are the same. For asynchronous channels, the receiver gets its data from the channel buffer and the sender's data is put in the channel buffer. Channel c must be full and locked. recv unlocks c with unlockf. sg must already be dequeued from c. A non-nil ep must point to the heap or the caller's stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chanparkcommit",
              "documentation": {
                "identifier": "chanparkcommit",
                "newPage": false,
                "searchKey": "runtime.chanparkcommit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chanparkcommit(gp *g, chanLock unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chanparkcommit(gp *g, chanLock unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#selectnbsend",
              "documentation": {
                "identifier": "selectnbsend",
                "newPage": false,
                "searchKey": "runtime.selectnbsend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool)\n```\n\ncompiler implements \n\n```\nselect {\ncase c <- v:\n\t... foo\ndefault:\n\t... bar\n}\n\n```\nas \n\n```\nif selectnbsend(c, v) {\n\t... foo\n} else {\n\t... bar\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#selectnbrecv",
              "documentation": {
                "identifier": "selectnbrecv",
                "newPage": false,
                "searchKey": "runtime.selectnbrecv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected, received bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc selectnbrecv(elem unsafe.Pointer, c *hchan) (selected, received bool)\n```\n\ncompiler implements \n\n```\nselect {\ncase v, ok = <-c:\n\t... foo\ndefault:\n\t... bar\n}\n\n```\nas \n\n```\nif selected, ok = selectnbrecv(&v, c); selected {\n\t... foo\n} else {\n\t... bar\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_chansend",
              "documentation": {
                "identifier": "reflect_chansend",
                "newPage": false,
                "searchKey": "runtime.reflect_chansend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_chansend(c *hchan, elem unsafe.Pointer, nb bool) (selected bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_chansend(c *hchan, elem unsafe.Pointer, nb bool) (selected bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_chanrecv",
              "documentation": {
                "identifier": "reflect_chanrecv",
                "newPage": false,
                "searchKey": "runtime.reflect_chanrecv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_chanrecv(c *hchan, nb bool, elem unsafe.Pointer) (selected bool, received bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_chanrecv(c *hchan, nb bool, elem unsafe.Pointer) (selected bool, received bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_chanlen",
              "documentation": {
                "identifier": "reflect_chanlen",
                "newPage": false,
                "searchKey": "runtime.reflect_chanlen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_chanlen(c *hchan) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_chanlen(c *hchan) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectlite_chanlen",
              "documentation": {
                "identifier": "reflectlite_chanlen",
                "newPage": false,
                "searchKey": "runtime.reflectlite_chanlen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectlite_chanlen(c *hchan) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectlite_chanlen(c *hchan) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_chancap",
              "documentation": {
                "identifier": "reflect_chancap",
                "newPage": false,
                "searchKey": "runtime.reflect_chancap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_chancap(c *hchan) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_chancap(c *hchan) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_chanclose",
              "documentation": {
                "identifier": "reflect_chanclose",
                "newPage": false,
                "searchKey": "runtime.reflect_chanclose",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_chanclose(c *hchan)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_chanclose(c *hchan)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racesync",
              "documentation": {
                "identifier": "racesync",
                "newPage": false,
                "searchKey": "runtime.racesync",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racesync(c *hchan, sg *sudog)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racesync(c *hchan, sg *sudog)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racenotify",
              "documentation": {
                "identifier": "racenotify",
                "newPage": false,
                "searchKey": "runtime.racenotify",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racenotify(c *hchan, idx uint, sg *sudog)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racenotify(c *hchan, idx uint, sg *sudog)\n```\n\nNotify the race detector of a send or receive involving buffer entry idx and a channel c or its communicating partner sg. This function handles the special case of c.elemsize==0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#checkptrAlignment",
              "documentation": {
                "identifier": "checkptrAlignment",
                "newPage": false,
                "searchKey": "runtime.checkptrAlignment",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkptrAlignment(p unsafe.Pointer, elem *_type, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkptrAlignment(p unsafe.Pointer, elem *_type, n uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#checkptrArithmetic",
              "documentation": {
                "identifier": "checkptrArithmetic",
                "newPage": false,
                "searchKey": "runtime.checkptrArithmetic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkptrArithmetic(p unsafe.Pointer, originals []unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkptrArithmetic(p unsafe.Pointer, originals []unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#checkptrBase",
              "documentation": {
                "identifier": "checkptrBase",
                "newPage": false,
                "searchKey": "runtime.checkptrBase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkptrBase(p unsafe.Pointer) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkptrBase(p unsafe.Pointer) uintptr\n```\n\ncheckptrBase returns the base address for the allocation containing the address p. \n\nImportantly, if p1 and p2 point into the same variable, then checkptrBase(p1) == checkptrBase(p2). However, the converse/inverse is not necessarily true as allocations can have trailing padding, and multiple variables may be packed into a single allocation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inf2one",
              "documentation": {
                "identifier": "inf2one",
                "newPage": false,
                "searchKey": "runtime.inf2one",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func inf2one(f float64) float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc inf2one(f float64) float64\n```\n\ninf2one returns a signed 1 if f is an infinity and a signed 0 otherwise. The sign of the result is the sign of f. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#complex128div",
              "documentation": {
                "identifier": "complex128div",
                "newPage": false,
                "searchKey": "runtime.complex128div",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func complex128div(n complex128, m complex128) complex128"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc complex128div(n complex128, m complex128) complex128\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "runtime.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#SetCPUProfileRate",
              "documentation": {
                "identifier": "SetCPUProfileRate",
                "newPage": false,
                "searchKey": "runtime.SetCPUProfileRate",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetCPUProfileRate(hz int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetCPUProfileRate(hz int)\n```\n\nSetCPUProfileRate sets the CPU profiling rate to hz samples per second. If hz <= 0, SetCPUProfileRate turns off profiling. If the profiler is on, the rate cannot be changed without first turning it off. \n\nMost clients should use the runtime/pprof package or the testing package's -test.cpuprofile flag instead of calling SetCPUProfileRate directly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#CPUProfile",
              "documentation": {
                "identifier": "CPUProfile",
                "newPage": false,
                "searchKey": "runtime.CPUProfile",
                "tags": [
                  "exported",
                  "deprecated"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func CPUProfile() []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc CPUProfile() []byte\n```\n\nCPUProfile panics. It formerly provided raw access to chunks of a pprof-format profile generated by the runtime. The details of generating that format have changed, so this functionality has been removed. \n\nDeprecated: Use the runtime/pprof package, or the handlers in the net/http/pprof package, or the testing package's -test.cpuprofile flag instead. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtime_pprof_runtime_cyclesPerSecond",
              "documentation": {
                "identifier": "runtime_pprof_runtime_cyclesPerSecond",
                "newPage": false,
                "searchKey": "runtime.runtime_pprof_runtime_cyclesPerSecond",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtime_pprof_runtime_cyclesPerSecond() int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtime_pprof_runtime_cyclesPerSecond() int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtime_pprof_readProfile",
              "documentation": {
                "identifier": "runtime_pprof_readProfile",
                "newPage": false,
                "searchKey": "runtime.runtime_pprof_readProfile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtime_pprof_readProfile() ([]uint64, []unsafe.Pointer, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtime_pprof_readProfile() ([]uint64, []unsafe.Pointer, bool)\n```\n\nreadProfile, provided to runtime/pprof, returns the next chunk of binary CPU profiling stack trace data, blocking until data is available. If profiling is turned off and all the profile data accumulated while it was on has been returned, readProfile returns eof=true. The caller must save the returned data and tags before calling readProfile again. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cputicks",
              "documentation": {
                "identifier": "cputicks",
                "newPage": false,
                "searchKey": "runtime.cputicks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cputicks() int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cputicks() int64\n```\n\ncareful: cputicks is not guaranteed to be monotonic! In particular, we have noticed drift between cpus on certain os/arch combinations. See issue 8976. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GOMAXPROCS",
              "documentation": {
                "identifier": "GOMAXPROCS",
                "newPage": false,
                "searchKey": "runtime.GOMAXPROCS",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func GOMAXPROCS(n int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc GOMAXPROCS(n int) int\n```\n\nGOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. It defaults to the value of runtime.NumCPU. If n < 1, it does not change the current setting. This call will go away when the scheduler improves. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#NumCPU",
              "documentation": {
                "identifier": "NumCPU",
                "newPage": false,
                "searchKey": "runtime.NumCPU",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func NumCPU() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc NumCPU() int\n```\n\nNumCPU returns the number of logical CPUs usable by the current process. \n\nThe set of available CPUs is checked by querying the operating system at process startup. Changes to operating system CPU allocation after process startup are not reflected. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#NumCgoCall",
              "documentation": {
                "identifier": "NumCgoCall",
                "newPage": false,
                "searchKey": "runtime.NumCgoCall",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func NumCgoCall() int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc NumCgoCall() int64\n```\n\nNumCgoCall returns the number of cgo calls made by the current process. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#NumGoroutine",
              "documentation": {
                "identifier": "NumGoroutine",
                "newPage": false,
                "searchKey": "runtime.NumGoroutine",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func NumGoroutine() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc NumGoroutine() int\n```\n\nNumGoroutine returns the number of goroutines that currently exist. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debug_modinfo",
              "documentation": {
                "identifier": "debug_modinfo",
                "newPage": false,
                "searchKey": "runtime.debug_modinfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func debug_modinfo() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc debug_modinfo() string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCallV2",
              "documentation": {
                "identifier": "debugCallV2",
                "newPage": false,
                "searchKey": "runtime.debugCallV2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func debugCallV2()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc debugCallV2()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCallPanicked",
              "documentation": {
                "identifier": "debugCallPanicked",
                "newPage": false,
                "searchKey": "runtime.debugCallPanicked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func debugCallPanicked(val interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc debugCallPanicked(val interface{})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCallCheck",
              "documentation": {
                "identifier": "debugCallCheck",
                "newPage": false,
                "searchKey": "runtime.debugCallCheck",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func debugCallCheck(pc uintptr) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc debugCallCheck(pc uintptr) string\n```\n\ndebugCallCheck checks whether it is safe to inject a debugger function call with return PC pc. If not, it returns a string explaining why. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCallWrap",
              "documentation": {
                "identifier": "debugCallWrap",
                "newPage": false,
                "searchKey": "runtime.debugCallWrap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func debugCallWrap(dispatch uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc debugCallWrap(dispatch uintptr)\n```\n\ndebugCallWrap starts a new goroutine to run a debug call and blocks the calling goroutine. On the goroutine, it prepares to recover panics from the debug call, and then calls the call dispatching function at PC dispatch. \n\nThis must be deeply nosplit because there are untyped values on the stack from debugCallV2. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCallWrap1",
              "documentation": {
                "identifier": "debugCallWrap1",
                "newPage": false,
                "searchKey": "runtime.debugCallWrap1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func debugCallWrap1()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc debugCallWrap1()\n```\n\ndebugCallWrap1 is the continuation of debugCallWrap on the callee goroutine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#debugCallWrap2",
              "documentation": {
                "identifier": "debugCallWrap2",
                "newPage": false,
                "searchKey": "runtime.debugCallWrap2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func debugCallWrap2(dispatch uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc debugCallWrap2(dispatch uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printDebugLog",
              "documentation": {
                "identifier": "printDebugLog",
                "newPage": false,
                "searchKey": "runtime.printDebugLog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printDebugLog()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printDebugLog()\n```\n\nprintDebugLog prints the debug log. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printDebugLogPC",
              "documentation": {
                "identifier": "printDebugLogPC",
                "newPage": false,
                "searchKey": "runtime.printDebugLogPC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printDebugLogPC(pc uintptr, returnPC bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printDebugLogPC(pc uintptr, returnPC bool)\n```\n\nprintDebugLogPC prints a single symbolized PC. If returnPC is true, pc is a return PC that must first be converted to a call PC. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#putCachedDlogger",
              "documentation": {
                "identifier": "putCachedDlogger",
                "newPage": false,
                "searchKey": "runtime.putCachedDlogger",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func putCachedDlogger(l *dlogger) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc putCachedDlogger(l *dlogger) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gogetenv",
              "documentation": {
                "identifier": "gogetenv",
                "newPage": false,
                "searchKey": "runtime.gogetenv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gogetenv(key string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gogetenv(key string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#envKeyEqual",
              "documentation": {
                "identifier": "envKeyEqual",
                "newPage": false,
                "searchKey": "runtime.envKeyEqual",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func envKeyEqual(a, b string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc envKeyEqual(a, b string) bool\n```\n\nenvKeyEqual reports whether a == b, with ASCII-only case insensitivity on Windows. The two strings must have the same length. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lowerASCII",
              "documentation": {
                "identifier": "lowerASCII",
                "newPage": false,
                "searchKey": "runtime.lowerASCII",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lowerASCII(c byte) byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lowerASCII(c byte) byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_setenv_c",
              "documentation": {
                "identifier": "syscall_setenv_c",
                "newPage": false,
                "searchKey": "runtime.syscall_setenv_c",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_setenv_c(k string, v string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_setenv_c(k string, v string)\n```\n\nUpdate the C environment if cgo is loaded. Called from syscall.Setenv. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_unsetenv_c",
              "documentation": {
                "identifier": "syscall_unsetenv_c",
                "newPage": false,
                "searchKey": "runtime.syscall_unsetenv_c",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_unsetenv_c(k string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_unsetenv_c(k string)\n```\n\nUpdate the C environment if cgo is loaded. Called from syscall.unsetenv. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cstring",
              "documentation": {
                "identifier": "cstring",
                "newPage": false,
                "searchKey": "runtime.cstring",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cstring(s string) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cstring(s string) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itoa",
              "documentation": {
                "identifier": "itoa",
                "newPage": false,
                "searchKey": "runtime.itoa",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func itoa(buf []byte, val uint64) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc itoa(buf []byte, val uint64) []byte\n```\n\nitoa converts val to a decimal representation. The result is written somewhere within buf and the location of the result is returned. buf must be at least 20 bytes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#appendIntStr",
              "documentation": {
                "identifier": "appendIntStr",
                "newPage": false,
                "searchKey": "runtime.appendIntStr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendIntStr(b []byte, v int64, signed bool) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendIntStr(b []byte, v int64, signed bool) []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printany",
              "documentation": {
                "identifier": "printany",
                "newPage": false,
                "searchKey": "runtime.printany",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printany(i interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printany(i interface{})\n```\n\nprintany prints an argument passed to panic. If panic is called with a value that has a String or Error method, it has already been converted into a string by preprintpanics. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printanycustomtype",
              "documentation": {
                "identifier": "printanycustomtype",
                "newPage": false,
                "searchKey": "runtime.printanycustomtype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printanycustomtype(i interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printanycustomtype(i interface{})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicwrap",
              "documentation": {
                "identifier": "panicwrap",
                "newPage": false,
                "searchKey": "runtime.panicwrap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicwrap()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicwrap()\n```\n\npanicwrap generates a panic for a call to a wrapped value method with a nil pointer receiver. \n\nIt is called from the generated wrapper code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Caller",
              "documentation": {
                "identifier": "Caller",
                "newPage": false,
                "searchKey": "runtime.Caller",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Caller(skip int) (pc uintptr, file string, line int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Caller(skip int) (pc uintptr, file string, line int, ok bool)\n```\n\nCaller reports file and line number information about function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to ascend, with 0 identifying the caller of Caller.  (For historical reasons the meaning of skip differs between Caller and Callers.) The return values report the program counter, file name, and line number within the file of the corresponding call. The boolean ok is false if it was not possible to recover the information. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Callers",
              "documentation": {
                "identifier": "Callers",
                "newPage": false,
                "searchKey": "runtime.Callers",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Callers(skip int, pc []uintptr) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Callers(skip int, pc []uintptr) int\n```\n\nCallers fills the slice pc with the return program counters of function invocations on the calling goroutine's stack. The argument skip is the number of stack frames to skip before recording in pc, with 0 identifying the frame for Callers itself and 1 identifying the caller of Callers. It returns the number of entries written to pc. \n\nTo translate these PCs into symbolic information such as function names and line numbers, use CallersFrames. CallersFrames accounts for inlined functions and adjusts the return program counters into call program counters. Iterating over the returned slice of PCs directly is discouraged, as is using FuncForPC on any of the returned PCs, since these cannot account for inlining or return program counter adjustment. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GOROOT",
              "documentation": {
                "identifier": "GOROOT",
                "newPage": false,
                "searchKey": "runtime.GOROOT",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func GOROOT() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc GOROOT() string\n```\n\nGOROOT returns the root of the Go tree. It uses the GOROOT environment variable, if set at process start, or else the root used during the Go build. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Version",
              "documentation": {
                "identifier": "Version",
                "newPage": false,
                "searchKey": "runtime.Version",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Version() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Version() string\n```\n\nVersion returns the Go tree's version string. It is either the commit hash and date at the time of the build or, when possible, a release tag like \"go1.3\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fastlog2",
              "documentation": {
                "identifier": "fastlog2",
                "newPage": false,
                "searchKey": "runtime.fastlog2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fastlog2(x float64) float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fastlog2(x float64) float64\n```\n\nfastlog2 implements a fast approximation to the base 2 log of a float64. This is used to compute a geometric distribution for heap sampling, without introducing dependencies into package math. This uses a very rough approximation using the float64 exponent and the first 25 bits of the mantissa. The top 5 bits of the mantissa are used to load limits from a table of constants and the rest are used to scale linearly between them. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isNaN",
              "documentation": {
                "identifier": "isNaN",
                "newPage": false,
                "searchKey": "runtime.isNaN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isNaN(f float64) (is bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isNaN(f float64) (is bool)\n```\n\nisNaN reports whether f is an IEEE 754 `not-a-number' value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isFinite",
              "documentation": {
                "identifier": "isFinite",
                "newPage": false,
                "searchKey": "runtime.isFinite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isFinite(f float64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isFinite(f float64) bool\n```\n\nisFinite reports whether f is neither NaN nor an infinity. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isInf",
              "documentation": {
                "identifier": "isInf",
                "newPage": false,
                "searchKey": "runtime.isInf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isInf(f float64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isInf(f float64) bool\n```\n\nisInf reports whether f is an infinity. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#abs",
              "documentation": {
                "identifier": "abs",
                "newPage": false,
                "searchKey": "runtime.abs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func abs(x float64) float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc abs(x float64) float64\n```\n\nAbs returns the absolute value of x. \n\nSpecial cases are: \n\n```\nAbs(±Inf) = +Inf\nAbs(NaN) = NaN\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#copysign",
              "documentation": {
                "identifier": "copysign",
                "newPage": false,
                "searchKey": "runtime.copysign",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func copysign(x, y float64) float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc copysign(x, y float64) float64\n```\n\ncopysign returns a value with the magnitude of x and the sign of y. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#float64bits",
              "documentation": {
                "identifier": "float64bits",
                "newPage": false,
                "searchKey": "runtime.float64bits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func float64bits(f float64) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc float64bits(f float64) uint64\n```\n\nFloat64bits returns the IEEE 754 binary representation of f. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#float64frombits",
              "documentation": {
                "identifier": "float64frombits",
                "newPage": false,
                "searchKey": "runtime.float64frombits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func float64frombits(b uint64) float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc float64frombits(b uint64) float64\n```\n\nFloat64frombits returns the floating point number corresponding the IEEE 754 binary representation b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memhashFallback",
              "documentation": {
                "identifier": "memhashFallback",
                "newPage": false,
                "searchKey": "runtime.memhashFallback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memhashFallback(p unsafe.Pointer, seed, s uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memhashFallback(p unsafe.Pointer, seed, s uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memhash32Fallback",
              "documentation": {
                "identifier": "memhash32Fallback",
                "newPage": false,
                "searchKey": "runtime.memhash32Fallback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memhash32Fallback(p unsafe.Pointer, seed uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memhash32Fallback(p unsafe.Pointer, seed uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memhash64Fallback",
              "documentation": {
                "identifier": "memhash64Fallback",
                "newPage": false,
                "searchKey": "runtime.memhash64Fallback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memhash64Fallback(p unsafe.Pointer, seed uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memhash64Fallback(p unsafe.Pointer, seed uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mix",
              "documentation": {
                "identifier": "mix",
                "newPage": false,
                "searchKey": "runtime.mix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mix(a, b uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mix(a, b uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#r4",
              "documentation": {
                "identifier": "r4",
                "newPage": false,
                "searchKey": "runtime.r4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func r4(p unsafe.Pointer) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc r4(p unsafe.Pointer) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#r8",
              "documentation": {
                "identifier": "r8",
                "newPage": false,
                "searchKey": "runtime.r8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func r8(p unsafe.Pointer) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc r8(p unsafe.Pointer) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtime_debug_WriteHeapDump",
              "documentation": {
                "identifier": "runtime_debug_WriteHeapDump",
                "newPage": false,
                "searchKey": "runtime.runtime_debug_WriteHeapDump",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtime_debug_WriteHeapDump(fd uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtime_debug_WriteHeapDump(fd uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dwrite",
              "documentation": {
                "identifier": "dwrite",
                "newPage": false,
                "searchKey": "runtime.dwrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dwrite(data unsafe.Pointer, len uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dwrite(data unsafe.Pointer, len uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dwritebyte",
              "documentation": {
                "identifier": "dwritebyte",
                "newPage": false,
                "searchKey": "runtime.dwritebyte",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dwritebyte(b byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dwritebyte(b byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#flush",
              "documentation": {
                "identifier": "flush",
                "newPage": false,
                "searchKey": "runtime.flush",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func flush()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc flush()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpint",
              "documentation": {
                "identifier": "dumpint",
                "newPage": false,
                "searchKey": "runtime.dumpint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpint(v uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpint(v uint64)\n```\n\ndump a uint64 in a varint format parseable by encoding/binary \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpbool",
              "documentation": {
                "identifier": "dumpbool",
                "newPage": false,
                "searchKey": "runtime.dumpbool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpbool(b bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpbool(b bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpmemrange",
              "documentation": {
                "identifier": "dumpmemrange",
                "newPage": false,
                "searchKey": "runtime.dumpmemrange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpmemrange(data unsafe.Pointer, len uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpmemrange(data unsafe.Pointer, len uintptr)\n```\n\ndump varint uint64 length followed by memory contents \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpslice",
              "documentation": {
                "identifier": "dumpslice",
                "newPage": false,
                "searchKey": "runtime.dumpslice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpslice(b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpslice(b []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpstr",
              "documentation": {
                "identifier": "dumpstr",
                "newPage": false,
                "searchKey": "runtime.dumpstr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpstr(s string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpstr(s string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumptype",
              "documentation": {
                "identifier": "dumptype",
                "newPage": false,
                "searchKey": "runtime.dumptype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumptype(t *_type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumptype(t *_type)\n```\n\ndump information for a type \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpobj",
              "documentation": {
                "identifier": "dumpobj",
                "newPage": false,
                "searchKey": "runtime.dumpobj",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpobj(obj unsafe.Pointer, size uintptr, bv bitvector)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpobj(obj unsafe.Pointer, size uintptr, bv bitvector)\n```\n\ndump an object \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpotherroot",
              "documentation": {
                "identifier": "dumpotherroot",
                "newPage": false,
                "searchKey": "runtime.dumpotherroot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpotherroot(description string, to unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpotherroot(description string, to unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpfinalizer",
              "documentation": {
                "identifier": "dumpfinalizer",
                "newPage": false,
                "searchKey": "runtime.dumpfinalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpfinalizer(obj unsafe.Pointer, fn *funcval, fint *_type, ot *ptrtype)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpfinalizer(obj unsafe.Pointer, fn *funcval, fint *_type, ot *ptrtype)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpbv",
              "documentation": {
                "identifier": "dumpbv",
                "newPage": false,
                "searchKey": "runtime.dumpbv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpbv(cbv *bitvector, offset uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpbv(cbv *bitvector, offset uintptr)\n```\n\ndump kinds & offsets of interesting fields in bv \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpframe",
              "documentation": {
                "identifier": "dumpframe",
                "newPage": false,
                "searchKey": "runtime.dumpframe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpframe(s *stkframe, arg unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpframe(s *stkframe, arg unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpgoroutine",
              "documentation": {
                "identifier": "dumpgoroutine",
                "newPage": false,
                "searchKey": "runtime.dumpgoroutine",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpgoroutine(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpgoroutine(gp *g)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpgs",
              "documentation": {
                "identifier": "dumpgs",
                "newPage": false,
                "searchKey": "runtime.dumpgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpgs()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpgs()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#finq_callback",
              "documentation": {
                "identifier": "finq_callback",
                "newPage": false,
                "searchKey": "runtime.finq_callback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func finq_callback(fn *funcval, obj unsafe.Pointer, nret uintptr, fint *_type, ot *ptrtype)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc finq_callback(fn *funcval, obj unsafe.Pointer, nret uintptr, fint *_type, ot *ptrtype)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumproots",
              "documentation": {
                "identifier": "dumproots",
                "newPage": false,
                "searchKey": "runtime.dumproots",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumproots()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumproots()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpobjs",
              "documentation": {
                "identifier": "dumpobjs",
                "newPage": false,
                "searchKey": "runtime.dumpobjs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpobjs()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpobjs()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpparams",
              "documentation": {
                "identifier": "dumpparams",
                "newPage": false,
                "searchKey": "runtime.dumpparams",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpparams()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpparams()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itab_callback",
              "documentation": {
                "identifier": "itab_callback",
                "newPage": false,
                "searchKey": "runtime.itab_callback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func itab_callback(tab *itab)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc itab_callback(tab *itab)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpitabs",
              "documentation": {
                "identifier": "dumpitabs",
                "newPage": false,
                "searchKey": "runtime.dumpitabs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpitabs()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpitabs()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpms",
              "documentation": {
                "identifier": "dumpms",
                "newPage": false,
                "searchKey": "runtime.dumpms",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpms()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpms()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpmemstats",
              "documentation": {
                "identifier": "dumpmemstats",
                "newPage": false,
                "searchKey": "runtime.dumpmemstats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpmemstats(m *MemStats)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpmemstats(m *MemStats)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpmemprof_callback",
              "documentation": {
                "identifier": "dumpmemprof_callback",
                "newPage": false,
                "searchKey": "runtime.dumpmemprof_callback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpmemprof_callback(b *bucket, nstk uintptr, pstk *uintptr, size, allocs, frees uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpmemprof_callback(b *bucket, nstk uintptr, pstk *uintptr, size, allocs, frees uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpmemprof",
              "documentation": {
                "identifier": "dumpmemprof",
                "newPage": false,
                "searchKey": "runtime.dumpmemprof",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpmemprof()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpmemprof()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mdump",
              "documentation": {
                "identifier": "mdump",
                "newPage": false,
                "searchKey": "runtime.mdump",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mdump(m *MemStats)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mdump(m *MemStats)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#writeheapdump_m",
              "documentation": {
                "identifier": "writeheapdump_m",
                "newPage": false,
                "searchKey": "runtime.writeheapdump_m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeheapdump_m(fd uintptr, m *MemStats)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeheapdump_m(fd uintptr, m *MemStats)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpfields",
              "documentation": {
                "identifier": "dumpfields",
                "newPage": false,
                "searchKey": "runtime.dumpfields",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpfields(bv bitvector)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpfields(bv bitvector)\n```\n\ndumpint() the kind & offset of each field in an object. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#float64Inf",
              "documentation": {
                "identifier": "float64Inf",
                "newPage": false,
                "searchKey": "runtime.float64Inf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func float64Inf() float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc float64Inf() float64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#float64NegInf",
              "documentation": {
                "identifier": "float64NegInf",
                "newPage": false,
                "searchKey": "runtime.float64NegInf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func float64NegInf() float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc float64NegInf() float64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timeHistogramMetricsBuckets",
              "documentation": {
                "identifier": "timeHistogramMetricsBuckets",
                "newPage": false,
                "searchKey": "runtime.timeHistogramMetricsBuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func timeHistogramMetricsBuckets() []float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc timeHistogramMetricsBuckets() []float64\n```\n\ntimeHistogramMetricsBuckets generates a slice of boundaries for the timeHistogram. These boundaries are represented in seconds, not nanoseconds like the timeHistogram represents durations. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itabHashFunc",
              "documentation": {
                "identifier": "itabHashFunc",
                "newPage": false,
                "searchKey": "runtime.itabHashFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func itabHashFunc(inter *interfacetype, typ *_type) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc itabHashFunc(inter *interfacetype, typ *_type) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itabAdd",
              "documentation": {
                "identifier": "itabAdd",
                "newPage": false,
                "searchKey": "runtime.itabAdd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func itabAdd(m *itab)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc itabAdd(m *itab)\n```\n\nitabAdd adds the given itab to the itab hash table. itabLock must be held. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itabsinit",
              "documentation": {
                "identifier": "itabsinit",
                "newPage": false,
                "searchKey": "runtime.itabsinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func itabsinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc itabsinit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicdottypeE",
              "documentation": {
                "identifier": "panicdottypeE",
                "newPage": false,
                "searchKey": "runtime.panicdottypeE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicdottypeE(have, want, iface *_type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicdottypeE(have, want, iface *_type)\n```\n\npanicdottypeE is called when doing an e.(T) conversion and the conversion fails. have = the dynamic type we have. want = the static type we're trying to convert to. iface = the static type we're converting from. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicdottypeI",
              "documentation": {
                "identifier": "panicdottypeI",
                "newPage": false,
                "searchKey": "runtime.panicdottypeI",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicdottypeI(have *itab, want, iface *_type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicdottypeI(have *itab, want, iface *_type)\n```\n\npanicdottypeI is called when doing an i.(T) conversion and the conversion fails. Same args as panicdottypeE, but \"have\" is the dynamic itab we have. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicnildottype",
              "documentation": {
                "identifier": "panicnildottype",
                "newPage": false,
                "searchKey": "runtime.panicnildottype",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicnildottype(want *_type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicnildottype(want *_type)\n```\n\npanicnildottype is called when doing a i.(T) conversion and the interface i is nil. want = the static type we're trying to convert to. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#convT16",
              "documentation": {
                "identifier": "convT16",
                "newPage": false,
                "searchKey": "runtime.convT16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func convT16(val uint16) (x unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc convT16(val uint16) (x unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#convT32",
              "documentation": {
                "identifier": "convT32",
                "newPage": false,
                "searchKey": "runtime.convT32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func convT32(val uint32) (x unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc convT32(val uint32) (x unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#convT64",
              "documentation": {
                "identifier": "convT64",
                "newPage": false,
                "searchKey": "runtime.convT64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func convT64(val uint64) (x unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc convT64(val uint64) (x unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#convTstring",
              "documentation": {
                "identifier": "convTstring",
                "newPage": false,
                "searchKey": "runtime.convTstring",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func convTstring(val string) (x unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc convTstring(val string) (x unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#convTslice",
              "documentation": {
                "identifier": "convTslice",
                "newPage": false,
                "searchKey": "runtime.convTslice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func convTslice(val []byte) (x unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc convTslice(val []byte) (x unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_ifaceE2I",
              "documentation": {
                "identifier": "reflect_ifaceE2I",
                "newPage": false,
                "searchKey": "runtime.reflect_ifaceE2I",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_ifaceE2I(inter *interfacetype, e eface, dst *iface)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_ifaceE2I(inter *interfacetype, e eface, dst *iface)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectlite_ifaceE2I",
              "documentation": {
                "identifier": "reflectlite_ifaceE2I",
                "newPage": false,
                "searchKey": "runtime.reflectlite_ifaceE2I",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectlite_ifaceE2I(inter *interfacetype, e eface, dst *iface)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectlite_ifaceE2I(inter *interfacetype, e eface, dst *iface)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#iterate_itabs",
              "documentation": {
                "identifier": "iterate_itabs",
                "newPage": false,
                "searchKey": "runtime.iterate_itabs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func iterate_itabs(fn func(*itab))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc iterate_itabs(fn func(*itab))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unreachableMethod",
              "documentation": {
                "identifier": "unreachableMethod",
                "newPage": false,
                "searchKey": "runtime.unreachableMethod",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unreachableMethod()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unreachableMethod()\n```\n\nThe linker redirects a reference of a method that it determined unreachable to a reference to this function, so it will throw if ever called. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lfnodeValidate",
              "documentation": {
                "identifier": "lfnodeValidate",
                "newPage": false,
                "searchKey": "runtime.lfnodeValidate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lfnodeValidate(node *lfnode)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lfnodeValidate(node *lfnode)\n```\n\nlfnodeValidate panics if node is not a valid address for use with lfstack.push. This only needs to be called when node is allocated. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lfstackPack",
              "documentation": {
                "identifier": "lfstackPack",
                "newPage": false,
                "searchKey": "runtime.lfstackPack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lfstackPack(node *lfnode, cnt uintptr) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lfstackPack(node *lfnode, cnt uintptr) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lock",
              "documentation": {
                "identifier": "lock",
                "newPage": false,
                "searchKey": "runtime.lock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lock(l *mutex)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lock(l *mutex)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lock2",
              "documentation": {
                "identifier": "lock2",
                "newPage": false,
                "searchKey": "runtime.lock2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lock2(l *mutex)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lock2(l *mutex)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unlock",
              "documentation": {
                "identifier": "unlock",
                "newPage": false,
                "searchKey": "runtime.unlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unlock(l *mutex)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unlock(l *mutex)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unlock2",
              "documentation": {
                "identifier": "unlock2",
                "newPage": false,
                "searchKey": "runtime.unlock2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unlock2(l *mutex)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unlock2(l *mutex)\n```\n\nWe might not be holding a p in this code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#noteclear",
              "documentation": {
                "identifier": "noteclear",
                "newPage": false,
                "searchKey": "runtime.noteclear",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func noteclear(n *note)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc noteclear(n *note)\n```\n\nOne-time notifications. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notewakeup",
              "documentation": {
                "identifier": "notewakeup",
                "newPage": false,
                "searchKey": "runtime.notewakeup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func notewakeup(n *note)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notewakeup(n *note)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notesleep",
              "documentation": {
                "identifier": "notesleep",
                "newPage": false,
                "searchKey": "runtime.notesleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func notesleep(n *note)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notesleep(n *note)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notetsleep_internal",
              "documentation": {
                "identifier": "notetsleep_internal",
                "newPage": false,
                "searchKey": "runtime.notetsleep_internal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func notetsleep_internal(n *note, ns int64, gp *g, deadline int64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notetsleep_internal(n *note, ns int64, gp *g, deadline int64) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notetsleep",
              "documentation": {
                "identifier": "notetsleep",
                "newPage": false,
                "searchKey": "runtime.notetsleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func notetsleep(n *note, ns int64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notetsleep(n *note, ns int64) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notetsleepg",
              "documentation": {
                "identifier": "notetsleepg",
                "newPage": false,
                "searchKey": "runtime.notetsleepg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func notetsleepg(n *note, ns int64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notetsleepg(n *note, ns int64) bool\n```\n\nsame as runtime·notetsleep, but called on user g (not g0) calls only nosplit functions between entersyscallblock/exitsyscall \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#checkTimeouts",
              "documentation": {
                "identifier": "checkTimeouts",
                "newPage": false,
                "searchKey": "runtime.checkTimeouts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkTimeouts()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkTimeouts()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockInit",
              "documentation": {
                "identifier": "lockInit",
                "newPage": false,
                "searchKey": "runtime.lockInit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lockInit(l *mutex, rank lockRank)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lockInit(l *mutex, rank lockRank)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockWithRank",
              "documentation": {
                "identifier": "lockWithRank",
                "newPage": false,
                "searchKey": "runtime.lockWithRank",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lockWithRank(l *mutex, rank lockRank)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lockWithRank(l *mutex, rank lockRank)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#acquireLockRank",
              "documentation": {
                "identifier": "acquireLockRank",
                "newPage": false,
                "searchKey": "runtime.acquireLockRank",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func acquireLockRank(rank lockRank)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc acquireLockRank(rank lockRank)\n```\n\nThis function may be called in nosplit context and thus must be nosplit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unlockWithRank",
              "documentation": {
                "identifier": "unlockWithRank",
                "newPage": false,
                "searchKey": "runtime.unlockWithRank",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unlockWithRank(l *mutex)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unlockWithRank(l *mutex)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#releaseLockRank",
              "documentation": {
                "identifier": "releaseLockRank",
                "newPage": false,
                "searchKey": "runtime.releaseLockRank",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func releaseLockRank(rank lockRank)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc releaseLockRank(rank lockRank)\n```\n\nThis function may be called in nosplit context and thus must be nosplit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockWithRankMayAcquire",
              "documentation": {
                "identifier": "lockWithRankMayAcquire",
                "newPage": false,
                "searchKey": "runtime.lockWithRankMayAcquire",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lockWithRankMayAcquire(l *mutex, rank lockRank)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lockWithRankMayAcquire(l *mutex, rank lockRank)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#assertLockHeld",
              "documentation": {
                "identifier": "assertLockHeld",
                "newPage": false,
                "searchKey": "runtime.assertLockHeld",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func assertLockHeld(l *mutex)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc assertLockHeld(l *mutex)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#assertRankHeld",
              "documentation": {
                "identifier": "assertRankHeld",
                "newPage": false,
                "searchKey": "runtime.assertRankHeld",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func assertRankHeld(r lockRank)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc assertRankHeld(r lockRank)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#worldStopped",
              "documentation": {
                "identifier": "worldStopped",
                "newPage": false,
                "searchKey": "runtime.worldStopped",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func worldStopped()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc worldStopped()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#worldStarted",
              "documentation": {
                "identifier": "worldStarted",
                "newPage": false,
                "searchKey": "runtime.worldStarted",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func worldStarted()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc worldStarted()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#assertWorldStopped",
              "documentation": {
                "identifier": "assertWorldStopped",
                "newPage": false,
                "searchKey": "runtime.assertWorldStopped",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func assertWorldStopped()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc assertWorldStopped()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#assertWorldStoppedOrLockHeld",
              "documentation": {
                "identifier": "assertWorldStoppedOrLockHeld",
                "newPage": false,
                "searchKey": "runtime.assertWorldStoppedOrLockHeld",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func assertWorldStoppedOrLockHeld(l *mutex)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc assertWorldStoppedOrLockHeld(l *mutex)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mallocinit",
              "documentation": {
                "identifier": "mallocinit",
                "newPage": false,
                "searchKey": "runtime.mallocinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mallocinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mallocinit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysReserveAligned",
              "documentation": {
                "identifier": "sysReserveAligned",
                "newPage": false,
                "searchKey": "runtime.sysReserveAligned",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysReserveAligned(v unsafe.Pointer, size, align uintptr) (unsafe.Pointer, uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysReserveAligned(v unsafe.Pointer, size, align uintptr) (unsafe.Pointer, uintptr)\n```\n\nsysReserveAligned is like sysReserve, but the returned pointer is aligned to align bytes. It may reserve either n or n+align bytes, so it returns the size that was reserved. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mallocgc",
              "documentation": {
                "identifier": "mallocgc",
                "newPage": false,
                "searchKey": "runtime.mallocgc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer\n```\n\nAllocate an object of size bytes. Small objects are allocated from the per-P cache's free lists. Large objects (> 32 kB) are allocated straight from the heap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memclrNoHeapPointersChunked",
              "documentation": {
                "identifier": "memclrNoHeapPointersChunked",
                "newPage": false,
                "searchKey": "runtime.memclrNoHeapPointersChunked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memclrNoHeapPointersChunked(size uintptr, x unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memclrNoHeapPointersChunked(size uintptr, x unsafe.Pointer)\n```\n\nmemclrNoHeapPointersChunked repeatedly calls memclrNoHeapPointers on chunks of the buffer to be zeroed, with opportunities for preemption along the way.  memclrNoHeapPointers contains no safepoints and also cannot be preemptively scheduled, so this provides a still-efficient block copy that can also be preempted on a reasonable granularity. \n\nUse this with care; if the data being cleared is tagged to contain pointers, this allows the GC to run before it is all cleared. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#newobject",
              "documentation": {
                "identifier": "newobject",
                "newPage": false,
                "searchKey": "runtime.newobject",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newobject(typ *_type) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newobject(typ *_type) unsafe.Pointer\n```\n\nimplementation of new builtin compiler (both frontend and SSA backend) knows the signature of this function \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_unsafe_New",
              "documentation": {
                "identifier": "reflect_unsafe_New",
                "newPage": false,
                "searchKey": "runtime.reflect_unsafe_New",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_unsafe_New(typ *_type) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_unsafe_New(typ *_type) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectlite_unsafe_New",
              "documentation": {
                "identifier": "reflectlite_unsafe_New",
                "newPage": false,
                "searchKey": "runtime.reflectlite_unsafe_New",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectlite_unsafe_New(typ *_type) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectlite_unsafe_New(typ *_type) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#newarray",
              "documentation": {
                "identifier": "newarray",
                "newPage": false,
                "searchKey": "runtime.newarray",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newarray(typ *_type, n int) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newarray(typ *_type, n int) unsafe.Pointer\n```\n\nnewarray allocates an array of n elements of type typ. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_unsafe_NewArray",
              "documentation": {
                "identifier": "reflect_unsafe_NewArray",
                "newPage": false,
                "searchKey": "runtime.reflect_unsafe_NewArray",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_unsafe_NewArray(typ *_type, n int) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_unsafe_NewArray(typ *_type, n int) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#profilealloc",
              "documentation": {
                "identifier": "profilealloc",
                "newPage": false,
                "searchKey": "runtime.profilealloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func profilealloc(mp *m, x unsafe.Pointer, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc profilealloc(mp *m, x unsafe.Pointer, size uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nextSample",
              "documentation": {
                "identifier": "nextSample",
                "newPage": false,
                "searchKey": "runtime.nextSample",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nextSample() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nextSample() uintptr\n```\n\nnextSample returns the next sampling point for heap profiling. The goal is to sample allocations on average every MemProfileRate bytes, but with a completely random distribution over the allocation timeline; this corresponds to a Poisson process with parameter MemProfileRate. In Poisson processes, the distance between two samples follows the exponential distribution (exp(MemProfileRate)), so the best return value is a random number taken from an exponential distribution whose mean is MemProfileRate. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fastexprand",
              "documentation": {
                "identifier": "fastexprand",
                "newPage": false,
                "searchKey": "runtime.fastexprand",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fastexprand(mean int) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fastexprand(mean int) int32\n```\n\nfastexprand returns a random number from an exponential distribution with the specified mean. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nextSampleNoFP",
              "documentation": {
                "identifier": "nextSampleNoFP",
                "newPage": false,
                "searchKey": "runtime.nextSampleNoFP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nextSampleNoFP() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nextSampleNoFP() uintptr\n```\n\nnextSampleNoFP is similar to nextSample, but uses older, simpler code to avoid floating point. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#persistentalloc",
              "documentation": {
                "identifier": "persistentalloc",
                "newPage": false,
                "searchKey": "runtime.persistentalloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func persistentalloc(size, align uintptr, sysStat *sysMemStat) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc persistentalloc(size, align uintptr, sysStat *sysMemStat) unsafe.Pointer\n```\n\nWrapper around sysAlloc that can allocate small chunks. There is no associated free operation. Intended for things like function/type/debug-related persistent data. If align is 0, uses default align (currently 8). The returned memory will be zeroed. \n\nConsider marking persistentalloc'd types go:notinheap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inPersistentAlloc",
              "documentation": {
                "identifier": "inPersistentAlloc",
                "newPage": false,
                "searchKey": "runtime.inPersistentAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func inPersistentAlloc(p uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc inPersistentAlloc(p uintptr) bool\n```\n\ninPersistentAlloc reports whether p points to memory allocated by persistentalloc. This must be nosplit because it is called by the cgo checker code, which is called by the write barrier code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isEmpty",
              "documentation": {
                "identifier": "isEmpty",
                "newPage": false,
                "searchKey": "runtime.isEmpty",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isEmpty(x uint8) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isEmpty(x uint8) bool\n```\n\nisEmpty reports whether the given tophash array entry represents an empty bucket entry. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bucketShift",
              "documentation": {
                "identifier": "bucketShift",
                "newPage": false,
                "searchKey": "runtime.bucketShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bucketShift(b uint8) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bucketShift(b uint8) uintptr\n```\n\nbucketShift returns 1<<b, optimized for code generation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bucketMask",
              "documentation": {
                "identifier": "bucketMask",
                "newPage": false,
                "searchKey": "runtime.bucketMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bucketMask(b uint8) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bucketMask(b uint8) uintptr\n```\n\nbucketMask returns 1<<b - 1, optimized for code generation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tophash",
              "documentation": {
                "identifier": "tophash",
                "newPage": false,
                "searchKey": "runtime.tophash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tophash(hash uintptr) uint8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tophash(hash uintptr) uint8\n```\n\ntophash calculates the tophash value for hash. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#evacuated",
              "documentation": {
                "identifier": "evacuated",
                "newPage": false,
                "searchKey": "runtime.evacuated",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func evacuated(b *bmap) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc evacuated(b *bmap) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapaccess1",
              "documentation": {
                "identifier": "mapaccess1",
                "newPage": false,
                "searchKey": "runtime.mapaccess1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\n```\n\nmapaccess1 returns a pointer to h[key].  Never returns nil, instead it will return a reference to the zero object for the elem type if the key is not in the map. NOTE: The returned pointer may keep the whole map live, so don't hold onto it for very long. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapaccess2",
              "documentation": {
                "identifier": "mapaccess2",
                "newPage": false,
                "searchKey": "runtime.mapaccess2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapaccessK",
              "documentation": {
                "identifier": "mapaccessK",
                "newPage": false,
                "searchKey": "runtime.mapaccessK",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer)\n```\n\nreturns both key and elem. Used by map iterator \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapaccess1_fat",
              "documentation": {
                "identifier": "mapaccess1_fat",
                "newPage": false,
                "searchKey": "runtime.mapaccess1_fat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccess1_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccess1_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapaccess2_fat",
              "documentation": {
                "identifier": "mapaccess2_fat",
                "newPage": false,
                "searchKey": "runtime.mapaccess2_fat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccess2_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) (unsafe.Pointer, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccess2_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) (unsafe.Pointer, bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapassign",
              "documentation": {
                "identifier": "mapassign",
                "newPage": false,
                "searchKey": "runtime.mapassign",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\n```\n\nLike mapaccess, but allocates a slot for the key if it is not present in the map. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapdelete",
              "documentation": {
                "identifier": "mapdelete",
                "newPage": false,
                "searchKey": "runtime.mapdelete",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapdelete(t *maptype, h *hmap, key unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapdelete(t *maptype, h *hmap, key unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapiterinit",
              "documentation": {
                "identifier": "mapiterinit",
                "newPage": false,
                "searchKey": "runtime.mapiterinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapiterinit(t *maptype, h *hmap, it *hiter)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapiterinit(t *maptype, h *hmap, it *hiter)\n```\n\nmapiterinit initializes the hiter struct used for ranging over maps. The hiter struct pointed to by 'it' is allocated on the stack by the compilers order pass or on the heap by reflect_mapiterinit. Both need to have zeroed hiter since the struct contains pointers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapiternext",
              "documentation": {
                "identifier": "mapiternext",
                "newPage": false,
                "searchKey": "runtime.mapiternext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapiternext(it *hiter)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapiternext(it *hiter)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapclear",
              "documentation": {
                "identifier": "mapclear",
                "newPage": false,
                "searchKey": "runtime.mapclear",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapclear(t *maptype, h *hmap)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapclear(t *maptype, h *hmap)\n```\n\nmapclear deletes all keys from a map. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hashGrow",
              "documentation": {
                "identifier": "hashGrow",
                "newPage": false,
                "searchKey": "runtime.hashGrow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hashGrow(t *maptype, h *hmap)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hashGrow(t *maptype, h *hmap)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#overLoadFactor",
              "documentation": {
                "identifier": "overLoadFactor",
                "newPage": false,
                "searchKey": "runtime.overLoadFactor",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func overLoadFactor(count int, B uint8) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc overLoadFactor(count int, B uint8) bool\n```\n\noverLoadFactor reports whether count items placed in 1<<B buckets is over loadFactor. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tooManyOverflowBuckets",
              "documentation": {
                "identifier": "tooManyOverflowBuckets",
                "newPage": false,
                "searchKey": "runtime.tooManyOverflowBuckets",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tooManyOverflowBuckets(noverflow uint16, B uint8) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tooManyOverflowBuckets(noverflow uint16, B uint8) bool\n```\n\ntooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1<<B buckets. Note that most of these overflow buckets must be in sparse use; if use was dense, then we'd have already triggered regular map growth. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#growWork",
              "documentation": {
                "identifier": "growWork",
                "newPage": false,
                "searchKey": "runtime.growWork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func growWork(t *maptype, h *hmap, bucket uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc growWork(t *maptype, h *hmap, bucket uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bucketEvacuated",
              "documentation": {
                "identifier": "bucketEvacuated",
                "newPage": false,
                "searchKey": "runtime.bucketEvacuated",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bucketEvacuated(t *maptype, h *hmap, bucket uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bucketEvacuated(t *maptype, h *hmap, bucket uintptr) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#evacuate",
              "documentation": {
                "identifier": "evacuate",
                "newPage": false,
                "searchKey": "runtime.evacuate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func evacuate(t *maptype, h *hmap, oldbucket uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc evacuate(t *maptype, h *hmap, oldbucket uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#advanceEvacuationMark",
              "documentation": {
                "identifier": "advanceEvacuationMark",
                "newPage": false,
                "searchKey": "runtime.advanceEvacuationMark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_mapaccess",
              "documentation": {
                "identifier": "reflect_mapaccess",
                "newPage": false,
                "searchKey": "runtime.reflect_mapaccess",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_mapaccess(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_mapaccess(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_mapassign",
              "documentation": {
                "identifier": "reflect_mapassign",
                "newPage": false,
                "searchKey": "runtime.reflect_mapassign",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_mapassign(t *maptype, h *hmap, key unsafe.Pointer, elem unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_mapassign(t *maptype, h *hmap, key unsafe.Pointer, elem unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_mapdelete",
              "documentation": {
                "identifier": "reflect_mapdelete",
                "newPage": false,
                "searchKey": "runtime.reflect_mapdelete",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_mapdelete(t *maptype, h *hmap, key unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_mapdelete(t *maptype, h *hmap, key unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_mapiternext",
              "documentation": {
                "identifier": "reflect_mapiternext",
                "newPage": false,
                "searchKey": "runtime.reflect_mapiternext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_mapiternext(it *hiter)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_mapiternext(it *hiter)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_mapiterkey",
              "documentation": {
                "identifier": "reflect_mapiterkey",
                "newPage": false,
                "searchKey": "runtime.reflect_mapiterkey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_mapiterkey(it *hiter) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_mapiterkey(it *hiter) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_mapiterelem",
              "documentation": {
                "identifier": "reflect_mapiterelem",
                "newPage": false,
                "searchKey": "runtime.reflect_mapiterelem",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_mapiterelem(it *hiter) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_mapiterelem(it *hiter) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_maplen",
              "documentation": {
                "identifier": "reflect_maplen",
                "newPage": false,
                "searchKey": "runtime.reflect_maplen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_maplen(h *hmap) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_maplen(h *hmap) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectlite_maplen",
              "documentation": {
                "identifier": "reflectlite_maplen",
                "newPage": false,
                "searchKey": "runtime.reflectlite_maplen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectlite_maplen(h *hmap) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectlite_maplen(h *hmap) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapaccess1_fast32",
              "documentation": {
                "identifier": "mapaccess1_fast32",
                "newPage": false,
                "searchKey": "runtime.mapaccess1_fast32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapaccess2_fast32",
              "documentation": {
                "identifier": "mapaccess2_fast32",
                "newPage": false,
                "searchKey": "runtime.mapaccess2_fast32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapassign_fast32",
              "documentation": {
                "identifier": "mapassign_fast32",
                "newPage": false,
                "searchKey": "runtime.mapassign_fast32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapassign_fast32ptr",
              "documentation": {
                "identifier": "mapassign_fast32ptr",
                "newPage": false,
                "searchKey": "runtime.mapassign_fast32ptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapassign_fast32ptr(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapassign_fast32ptr(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapdelete_fast32",
              "documentation": {
                "identifier": "mapdelete_fast32",
                "newPage": false,
                "searchKey": "runtime.mapdelete_fast32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapdelete_fast32(t *maptype, h *hmap, key uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapdelete_fast32(t *maptype, h *hmap, key uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#growWork_fast32",
              "documentation": {
                "identifier": "growWork_fast32",
                "newPage": false,
                "searchKey": "runtime.growWork_fast32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func growWork_fast32(t *maptype, h *hmap, bucket uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc growWork_fast32(t *maptype, h *hmap, bucket uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#evacuate_fast32",
              "documentation": {
                "identifier": "evacuate_fast32",
                "newPage": false,
                "searchKey": "runtime.evacuate_fast32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func evacuate_fast32(t *maptype, h *hmap, oldbucket uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc evacuate_fast32(t *maptype, h *hmap, oldbucket uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapaccess1_fast64",
              "documentation": {
                "identifier": "mapaccess1_fast64",
                "newPage": false,
                "searchKey": "runtime.mapaccess1_fast64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapaccess2_fast64",
              "documentation": {
                "identifier": "mapaccess2_fast64",
                "newPage": false,
                "searchKey": "runtime.mapaccess2_fast64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapassign_fast64",
              "documentation": {
                "identifier": "mapassign_fast64",
                "newPage": false,
                "searchKey": "runtime.mapassign_fast64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapassign_fast64ptr",
              "documentation": {
                "identifier": "mapassign_fast64ptr",
                "newPage": false,
                "searchKey": "runtime.mapassign_fast64ptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapassign_fast64ptr(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapassign_fast64ptr(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapdelete_fast64",
              "documentation": {
                "identifier": "mapdelete_fast64",
                "newPage": false,
                "searchKey": "runtime.mapdelete_fast64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapdelete_fast64(t *maptype, h *hmap, key uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapdelete_fast64(t *maptype, h *hmap, key uint64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#growWork_fast64",
              "documentation": {
                "identifier": "growWork_fast64",
                "newPage": false,
                "searchKey": "runtime.growWork_fast64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func growWork_fast64(t *maptype, h *hmap, bucket uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc growWork_fast64(t *maptype, h *hmap, bucket uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#evacuate_fast64",
              "documentation": {
                "identifier": "evacuate_fast64",
                "newPage": false,
                "searchKey": "runtime.evacuate_fast64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func evacuate_fast64(t *maptype, h *hmap, oldbucket uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc evacuate_fast64(t *maptype, h *hmap, oldbucket uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapaccess1_faststr",
              "documentation": {
                "identifier": "mapaccess1_faststr",
                "newPage": false,
                "searchKey": "runtime.mapaccess1_faststr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapaccess2_faststr",
              "documentation": {
                "identifier": "mapaccess2_faststr",
                "newPage": false,
                "searchKey": "runtime.mapaccess2_faststr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapassign_faststr",
              "documentation": {
                "identifier": "mapassign_faststr",
                "newPage": false,
                "searchKey": "runtime.mapassign_faststr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapassign_faststr(t *maptype, h *hmap, s string) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapassign_faststr(t *maptype, h *hmap, s string) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mapdelete_faststr",
              "documentation": {
                "identifier": "mapdelete_faststr",
                "newPage": false,
                "searchKey": "runtime.mapdelete_faststr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mapdelete_faststr(t *maptype, h *hmap, ky string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mapdelete_faststr(t *maptype, h *hmap, ky string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#growWork_faststr",
              "documentation": {
                "identifier": "growWork_faststr",
                "newPage": false,
                "searchKey": "runtime.growWork_faststr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func growWork_faststr(t *maptype, h *hmap, bucket uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc growWork_faststr(t *maptype, h *hmap, bucket uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#evacuate_faststr",
              "documentation": {
                "identifier": "evacuate_faststr",
                "newPage": false,
                "searchKey": "runtime.evacuate_faststr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func evacuate_faststr(t *maptype, h *hmap, oldbucket uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc evacuate_faststr(t *maptype, h *hmap, oldbucket uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typedmemmove",
              "documentation": {
                "identifier": "typedmemmove",
                "newPage": false,
                "searchKey": "runtime.typedmemmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typedmemmove(typ *_type, dst, src unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typedmemmove(typ *_type, dst, src unsafe.Pointer)\n```\n\ntypedmemmove copies a value of type t to dst from src. Must be nosplit, see #16026. \n\nTODO: Perfect for go:nosplitrec since we can't have a safe point anywhere in the bulk barrier or memmove. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_typedmemmove",
              "documentation": {
                "identifier": "reflect_typedmemmove",
                "newPage": false,
                "searchKey": "runtime.reflect_typedmemmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_typedmemmove(typ *_type, dst, src unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_typedmemmove(typ *_type, dst, src unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectlite_typedmemmove",
              "documentation": {
                "identifier": "reflectlite_typedmemmove",
                "newPage": false,
                "searchKey": "runtime.reflectlite_typedmemmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectlite_typedmemmove(typ *_type, dst, src unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectlite_typedmemmove(typ *_type, dst, src unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_typedmemmovepartial",
              "documentation": {
                "identifier": "reflect_typedmemmovepartial",
                "newPage": false,
                "searchKey": "runtime.reflect_typedmemmovepartial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_typedmemmovepartial(typ *_type, dst, src unsafe.Pointer, off, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_typedmemmovepartial(typ *_type, dst, src unsafe.Pointer, off, size uintptr)\n```\n\ntypedmemmovepartial is like typedmemmove but assumes that dst and src point off bytes into the value and only copies size bytes. off must be a multiple of sys.PtrSize. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectcallmove",
              "documentation": {
                "identifier": "reflectcallmove",
                "newPage": false,
                "searchKey": "runtime.reflectcallmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectcallmove(typ *_type, dst, src unsafe.Pointer, size uintptr, regs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectcallmove(typ *_type, dst, src unsafe.Pointer, size uintptr, regs *abi.RegArgs)\n```\n\nreflectcallmove is invoked by reflectcall to copy the return values out of the stack and into the heap, invoking the necessary write barriers. dst, src, and size describe the return value area to copy. typ describes the entire frame (not just the return values). typ may be nil, which indicates write barriers are not needed. \n\nIt must be nosplit and must only call nosplit functions because the stack map of reflectcall is wrong. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typedslicecopy",
              "documentation": {
                "identifier": "typedslicecopy",
                "newPage": false,
                "searchKey": "runtime.typedslicecopy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typedslicecopy(typ *_type, dstPtr unsafe.Pointer, dstLen int, srcPtr unsafe.Pointer, srcLen int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typedslicecopy(typ *_type, dstPtr unsafe.Pointer, dstLen int, srcPtr unsafe.Pointer, srcLen int) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_typedslicecopy",
              "documentation": {
                "identifier": "reflect_typedslicecopy",
                "newPage": false,
                "searchKey": "runtime.reflect_typedslicecopy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_typedslicecopy(elemType *_type, dst, src slice) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_typedslicecopy(elemType *_type, dst, src slice) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typedmemclr",
              "documentation": {
                "identifier": "typedmemclr",
                "newPage": false,
                "searchKey": "runtime.typedmemclr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typedmemclr(typ *_type, ptr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typedmemclr(typ *_type, ptr unsafe.Pointer)\n```\n\ntypedmemclr clears the typed memory at ptr with type typ. The memory at ptr must already be initialized (and hence in type-safe state). If the memory is being initialized for the first time, see memclrNoHeapPointers. \n\nIf the caller knows that typ has pointers, it can alternatively call memclrHasPointers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_typedmemclr",
              "documentation": {
                "identifier": "reflect_typedmemclr",
                "newPage": false,
                "searchKey": "runtime.reflect_typedmemclr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_typedmemclr(typ *_type, ptr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_typedmemclr(typ *_type, ptr unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_typedmemclrpartial",
              "documentation": {
                "identifier": "reflect_typedmemclrpartial",
                "newPage": false,
                "searchKey": "runtime.reflect_typedmemclrpartial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_typedmemclrpartial(typ *_type, ptr unsafe.Pointer, off, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_typedmemclrpartial(typ *_type, ptr unsafe.Pointer, off, size uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memclrHasPointers",
              "documentation": {
                "identifier": "memclrHasPointers",
                "newPage": false,
                "searchKey": "runtime.memclrHasPointers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memclrHasPointers(ptr unsafe.Pointer, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memclrHasPointers(ptr unsafe.Pointer, n uintptr)\n```\n\nmemclrHasPointers clears n bytes of typed memory starting at ptr. The caller must ensure that the type of the object at ptr has pointers, usually by checking typ.ptrdata. However, ptr does not have to point to the start of the allocation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#addb",
              "documentation": {
                "identifier": "addb",
                "newPage": false,
                "searchKey": "runtime.addb",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addb(p *byte, n uintptr) *byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addb(p *byte, n uintptr) *byte\n```\n\naddb returns the byte pointer p+n. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#subtractb",
              "documentation": {
                "identifier": "subtractb",
                "newPage": false,
                "searchKey": "runtime.subtractb",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func subtractb(p *byte, n uintptr) *byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc subtractb(p *byte, n uintptr) *byte\n```\n\nsubtractb returns the byte pointer p-n. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#add1",
              "documentation": {
                "identifier": "add1",
                "newPage": false,
                "searchKey": "runtime.add1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func add1(p *byte) *byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc add1(p *byte) *byte\n```\n\nadd1 returns the byte pointer p+1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#subtract1",
              "documentation": {
                "identifier": "subtract1",
                "newPage": false,
                "searchKey": "runtime.subtract1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func subtract1(p *byte) *byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc subtract1(p *byte) *byte\n```\n\nsubtract1 returns the byte pointer p-1. \n\nnosplit because it is used during write barriers and must not be preempted. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badPointer",
              "documentation": {
                "identifier": "badPointer",
                "newPage": false,
                "searchKey": "runtime.badPointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badPointer(s *mspan, p, refBase, refOff uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badPointer(s *mspan, p, refBase, refOff uintptr)\n```\n\nbadPointer throws bad pointer in heap panic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bulkBarrierPreWrite",
              "documentation": {
                "identifier": "bulkBarrierPreWrite",
                "newPage": false,
                "searchKey": "runtime.bulkBarrierPreWrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bulkBarrierPreWrite(dst, src, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bulkBarrierPreWrite(dst, src, size uintptr)\n```\n\nbulkBarrierPreWrite executes a write barrier for every pointer slot in the memory range [src, src+size), using pointer/scalar information from [dst, dst+size). This executes the write barriers necessary before a memmove. src, dst, and size must be pointer-aligned. The range [dst, dst+size) must lie within a single object. It does not perform the actual writes. \n\nAs a special case, src == 0 indicates that this is being used for a memclr. bulkBarrierPreWrite will pass 0 for the src of each write barrier. \n\nCallers should call bulkBarrierPreWrite immediately before calling memmove(dst, src, size). This function is marked nosplit to avoid being preempted; the GC must not stop the goroutine between the memmove and the execution of the barriers. The caller is also responsible for cgo pointer checks if this may be writing Go pointers into non-Go memory. \n\nThe pointer bitmap is not maintained for allocations containing no pointers at all; any caller of bulkBarrierPreWrite must first make sure the underlying allocation contains pointers, usually by checking typ.ptrdata. \n\nCallers must perform cgo checks if writeBarrier.cgo. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bulkBarrierPreWriteSrcOnly",
              "documentation": {
                "identifier": "bulkBarrierPreWriteSrcOnly",
                "newPage": false,
                "searchKey": "runtime.bulkBarrierPreWriteSrcOnly",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bulkBarrierPreWriteSrcOnly(dst, src, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bulkBarrierPreWriteSrcOnly(dst, src, size uintptr)\n```\n\nbulkBarrierPreWriteSrcOnly is like bulkBarrierPreWrite but does not execute write barriers for [dst, dst+size). \n\nIn addition to the requirements of bulkBarrierPreWrite callers need to ensure [dst, dst+size) is zeroed. \n\nThis is used for special cases where e.g. dst was just created and zeroed with malloc. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bulkBarrierBitmap",
              "documentation": {
                "identifier": "bulkBarrierBitmap",
                "newPage": false,
                "searchKey": "runtime.bulkBarrierBitmap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bulkBarrierBitmap(dst, src, size, maskOffset uintptr, bits *uint8)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bulkBarrierBitmap(dst, src, size, maskOffset uintptr, bits *uint8)\n```\n\nbulkBarrierBitmap executes write barriers for copying from [src, src+size) to [dst, dst+size) using a 1-bit pointer bitmap. src is assumed to start maskOffset bytes into the data covered by the bitmap in bits (which may not be a multiple of 8). \n\nThis is used by bulkBarrierPreWrite for writes to data and BSS. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typeBitsBulkBarrier",
              "documentation": {
                "identifier": "typeBitsBulkBarrier",
                "newPage": false,
                "searchKey": "runtime.typeBitsBulkBarrier",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typeBitsBulkBarrier(typ *_type, dst, src, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typeBitsBulkBarrier(typ *_type, dst, src, size uintptr)\n```\n\ntypeBitsBulkBarrier executes a write barrier for every pointer that would be copied from [src, src+size) to [dst, dst+size) by a memmove using the type bitmap to locate those pointer slots. \n\nThe type typ must correspond exactly to [src, src+size) and [dst, dst+size). dst, src, and size must be pointer-aligned. The type typ must have a plain bitmap, not a GC program. The only use of this function is in channel sends, and the 64 kB channel element limit takes care of this for us. \n\nMust not be preempted because it typically runs right before memmove, and the GC must observe them as an atomic action. \n\nCallers must perform cgo checks if writeBarrier.cgo. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapBitsSetType",
              "documentation": {
                "identifier": "heapBitsSetType",
                "newPage": false,
                "searchKey": "runtime.heapBitsSetType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func heapBitsSetType(x, size, dataSize uintptr, typ *_type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc heapBitsSetType(x, size, dataSize uintptr, typ *_type)\n```\n\nheapBitsSetType records that the new allocation [x, x+size) holds in [x, x+dataSize) one or more values of type typ. (The number of values is given by dataSize / typ.size.) If dataSize < size, the fragment [x+dataSize, x+size) is recorded as non-pointer data. It is known that the type has pointers somewhere; malloc does not call heapBitsSetType when there are no pointers, because all free objects are marked as noscan during heapBitsSweepSpan. \n\nThere can only be one allocation from a given span active at a time, and the bitmap for a span always falls on byte boundaries, so there are no write-write races for access to the heap bitmap. Hence, heapBitsSetType can access the bitmap without atomics. \n\nThere can be read-write races between heapBitsSetType and things that read the heap bitmap like scanobject. However, since heapBitsSetType is only used for objects that have not yet been made reachable, readers will ignore bits being modified by this function. This does mean this function cannot transiently modify bits that belong to neighboring objects. Also, on weakly-ordered machines, callers must execute a store/store (publication) barrier between calling this function and making the object reachable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapBitsSetTypeGCProg",
              "documentation": {
                "identifier": "heapBitsSetTypeGCProg",
                "newPage": false,
                "searchKey": "runtime.heapBitsSetTypeGCProg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func heapBitsSetTypeGCProg(h heapBits, progSize, elemSize, dataSize, allocSize uintptr, prog *byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc heapBitsSetTypeGCProg(h heapBits, progSize, elemSize, dataSize, allocSize uintptr, prog *byte)\n```\n\nheapBitsSetTypeGCProg implements heapBitsSetType using a GC program. progSize is the size of the memory described by the program. elemSize is the size of the element that the GC program describes (a prefix of). dataSize is the total size of the intended data, a multiple of elemSize. allocSize is the total size of the allocated memory. \n\nGC programs are only used for large allocations. heapBitsSetType requires that allocSize is a multiple of 4 words, so that the relevant bitmap bytes are not shared with surrounding objects. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runGCProg",
              "documentation": {
                "identifier": "runGCProg",
                "newPage": false,
                "searchKey": "runtime.runGCProg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runGCProg(prog, trailer, dst *byte, size int) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runGCProg(prog, trailer, dst *byte, size int) uintptr\n```\n\nrunGCProg executes the GC program prog, and then trailer if non-nil, writing to dst with entries of the given size. If size == 1, dst is a 1-bit pointer mask laid out moving forward from dst. If size == 2, dst is the 2-bit heap bitmap, and writes move backward starting at dst (because the heap bitmap does). In this case, the caller guarantees that only whole bytes in dst need to be written. \n\nrunGCProg returns the number of 1- or 2-bit entries written to memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dematerializeGCProg",
              "documentation": {
                "identifier": "dematerializeGCProg",
                "newPage": false,
                "searchKey": "runtime.dematerializeGCProg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dematerializeGCProg(s *mspan)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dematerializeGCProg(s *mspan)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpGCProg",
              "documentation": {
                "identifier": "dumpGCProg",
                "newPage": false,
                "searchKey": "runtime.dumpGCProg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpGCProg(p *byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpGCProg(p *byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#getgcmaskcb",
              "documentation": {
                "identifier": "getgcmaskcb",
                "newPage": false,
                "searchKey": "runtime.getgcmaskcb",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getgcmaskcb(frame *stkframe, ctxt unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getgcmaskcb(frame *stkframe, ctxt unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_gcbits",
              "documentation": {
                "identifier": "reflect_gcbits",
                "newPage": false,
                "searchKey": "runtime.reflect_gcbits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_gcbits(x interface{}) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_gcbits(x interface{}) []byte\n```\n\ngcbits returns the GC type info for x, for testing. The result is the bitmap entries (0 or 1), one entry per byte. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#getgcmask",
              "documentation": {
                "identifier": "getgcmask",
                "newPage": false,
                "searchKey": "runtime.getgcmask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getgcmask(ep interface{}) (mask []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getgcmask(ep interface{}) (mask []byte)\n```\n\nReturns GC type info for the pointer stored in ep for testing. If ep points to the stack, only static live information will be returned (i.e. not for objects which are only dynamically live stack objects). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freemcache",
              "documentation": {
                "identifier": "freemcache",
                "newPage": false,
                "searchKey": "runtime.freemcache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func freemcache(c *mcache)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc freemcache(c *mcache)\n```\n\nfreemcache releases resources associated with this mcache and puts the object onto a free list. \n\nIn some cases there is no way to simply release resources, such as statistics, so donate them to a different mcache (the recipient). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#startCheckmarks",
              "documentation": {
                "identifier": "startCheckmarks",
                "newPage": false,
                "searchKey": "runtime.startCheckmarks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func startCheckmarks()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc startCheckmarks()\n```\n\nstartCheckmarks prepares for the checkmarks phase. \n\nThe world must be stopped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#endCheckmarks",
              "documentation": {
                "identifier": "endCheckmarks",
                "newPage": false,
                "searchKey": "runtime.endCheckmarks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func endCheckmarks()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc endCheckmarks()\n```\n\nendCheckmarks ends the checkmarks phase. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setCheckmark",
              "documentation": {
                "identifier": "setCheckmark",
                "newPage": false,
                "searchKey": "runtime.setCheckmark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setCheckmark(obj, base, off uintptr, mbits markBits) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setCheckmark(obj, base, off uintptr, mbits markBits) bool\n```\n\nsetCheckmark throws if marking object is a checkmarks violation, and otherwise sets obj's checkmark. It returns true if obj was already checkmarked. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysAlloc",
              "documentation": {
                "identifier": "sysAlloc",
                "newPage": false,
                "searchKey": "runtime.sysAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysAlloc(n uintptr, sysStat *sysMemStat) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysAlloc(n uintptr, sysStat *sysMemStat) unsafe.Pointer\n```\n\nDon't split the stack as this function may be invoked without a valid G, which prevents us from allocating more stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysUnused",
              "documentation": {
                "identifier": "sysUnused",
                "newPage": false,
                "searchKey": "runtime.sysUnused",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysUnused(v unsafe.Pointer, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysUnused(v unsafe.Pointer, n uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysUsed",
              "documentation": {
                "identifier": "sysUsed",
                "newPage": false,
                "searchKey": "runtime.sysUsed",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysUsed(v unsafe.Pointer, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysUsed(v unsafe.Pointer, n uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysHugePage",
              "documentation": {
                "identifier": "sysHugePage",
                "newPage": false,
                "searchKey": "runtime.sysHugePage",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysHugePage(v unsafe.Pointer, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysHugePage(v unsafe.Pointer, n uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysFree",
              "documentation": {
                "identifier": "sysFree",
                "newPage": false,
                "searchKey": "runtime.sysFree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysFree(v unsafe.Pointer, n uintptr, sysStat *sysMemStat)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysFree(v unsafe.Pointer, n uintptr, sysStat *sysMemStat)\n```\n\nDon't split the stack as this function may be invoked without a valid G, which prevents us from allocating more stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysFault",
              "documentation": {
                "identifier": "sysFault",
                "newPage": false,
                "searchKey": "runtime.sysFault",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysFault(v unsafe.Pointer, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysFault(v unsafe.Pointer, n uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysReserve",
              "documentation": {
                "identifier": "sysReserve",
                "newPage": false,
                "searchKey": "runtime.sysReserve",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysReserve(v unsafe.Pointer, n uintptr) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysReserve(v unsafe.Pointer, n uintptr) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysMap",
              "documentation": {
                "identifier": "sysMap",
                "newPage": false,
                "searchKey": "runtime.sysMap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysMap(v unsafe.Pointer, n uintptr, sysStat *sysMemStat)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysMap(v unsafe.Pointer, n uintptr, sysStat *sysMemStat)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#initMetrics",
              "documentation": {
                "identifier": "initMetrics",
                "newPage": false,
                "searchKey": "runtime.initMetrics",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func initMetrics()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc initMetrics()\n```\n\ninitMetrics initializes the metrics map if it hasn't been yet. \n\nmetricsSema must be held. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readMetrics",
              "documentation": {
                "identifier": "readMetrics",
                "newPage": false,
                "searchKey": "runtime.readMetrics",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readMetrics(samplesp unsafe.Pointer, len int, cap int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readMetrics(samplesp unsafe.Pointer, len int, cap int)\n```\n\nreadMetrics is the implementation of runtime/metrics.Read. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#queuefinalizer",
              "documentation": {
                "identifier": "queuefinalizer",
                "newPage": false,
                "searchKey": "runtime.queuefinalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func queuefinalizer(p unsafe.Pointer, fn *funcval, nret uintptr, fint *_type, ot *ptrtype)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc queuefinalizer(p unsafe.Pointer, fn *funcval, nret uintptr, fint *_type, ot *ptrtype)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#iterate_finq",
              "documentation": {
                "identifier": "iterate_finq",
                "newPage": false,
                "searchKey": "runtime.iterate_finq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func iterate_finq(callback func(*funcval, unsafe.Pointer, uintptr, *_type, *ptrtype))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc iterate_finq(callback func(*funcval, unsafe.Pointer, uintptr, *_type, *ptrtype))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#createfing",
              "documentation": {
                "identifier": "createfing",
                "newPage": false,
                "searchKey": "runtime.createfing",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func createfing()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc createfing()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runfinq",
              "documentation": {
                "identifier": "runfinq",
                "newPage": false,
                "searchKey": "runtime.runfinq",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runfinq()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runfinq()\n```\n\nThis is the goroutine that runs all of the finalizers \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#SetFinalizer",
              "documentation": {
                "identifier": "SetFinalizer",
                "newPage": false,
                "searchKey": "runtime.SetFinalizer",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetFinalizer(obj interface{}, finalizer interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetFinalizer(obj interface{}, finalizer interface{})\n```\n\nSetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with an associated finalizer, it clears the association and runs finalizer(obj) in a separate goroutine. This makes obj reachable again, but now without an associated finalizer. Assuming that SetFinalizer is not called again, the next time the garbage collector sees that obj is unreachable, it will free obj. \n\nSetFinalizer(obj, nil) clears any finalizer associated with obj. \n\nThe argument obj must be a pointer to an object allocated by calling new, by taking the address of a composite literal, or by taking the address of a local variable. The argument finalizer must be a function that takes a single argument to which obj's type can be assigned, and can have arbitrary ignored return values. If either of these is not true, SetFinalizer may abort the program. \n\nFinalizers are run in dependency order: if A points at B, both have finalizers, and they are otherwise unreachable, only the finalizer for A runs; once A is freed, the finalizer for B can run. If a cyclic structure includes a block with a finalizer, that cycle is not guaranteed to be garbage collected and the finalizer is not guaranteed to run, because there is no ordering that respects the dependencies. \n\nThe finalizer is scheduled to run at some arbitrary time after the program can no longer reach the object to which obj points. There is no guarantee that finalizers will run before a program exits, so typically they are useful only for releasing non-memory resources associated with an object during a long-running program. For example, an os.File object could use a finalizer to close the associated operating system file descriptor when a program discards an os.File without calling Close, but it would be a mistake to depend on a finalizer to flush an in-memory I/O buffer such as a bufio.Writer, because the buffer would not be flushed at program exit. \n\nIt is not guaranteed that a finalizer will run if the size of *obj is zero bytes. \n\nIt is not guaranteed that a finalizer will run for objects allocated in initializers for package-level variables. Such objects may be linker-allocated, not heap-allocated. \n\nA finalizer may run as soon as an object becomes unreachable. In order to use finalizers correctly, the program must ensure that the object is reachable until it is no longer required. Objects stored in global variables, or that can be found by tracing pointers from a global variable, are reachable. For other objects, pass the object to a call of the KeepAlive function to mark the last point in the function where the object must be reachable. \n\nFor example, if p points to a struct, such as os.File, that contains a file descriptor d, and p has a finalizer that closes that file descriptor, and if the last use of p in a function is a call to syscall.Write(p.d, buf, size), then p may be unreachable as soon as the program enters syscall.Write. The finalizer may run at that moment, closing p.d, causing syscall.Write to fail because it is writing to a closed file descriptor (or, worse, to an entirely different file descriptor opened by a different goroutine). To avoid this problem, call runtime.KeepAlive(p) after the call to syscall.Write. \n\nA single goroutine runs all finalizers for a program, sequentially. If a finalizer must run for a long time, it should do so by starting a new goroutine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#KeepAlive",
              "documentation": {
                "identifier": "KeepAlive",
                "newPage": false,
                "searchKey": "runtime.KeepAlive",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func KeepAlive(x interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc KeepAlive(x interface{})\n```\n\nKeepAlive marks its argument as currently reachable. This ensures that the object is not freed, and its finalizer is not run, before the point in the program where KeepAlive is called. \n\nA very simplified example showing where KeepAlive is required: \n\n```\ntype File struct { d int }\nd, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n// ... do something if err != nil ...\np := &File{d}\nruntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\nvar buf [10]byte\nn, err := syscall.Read(p.d, buf[:])\n// Ensure p is not finalized until Read returns.\nruntime.KeepAlive(p)\n// No more uses of p after this point.\n\n```\nWithout the KeepAlive call, the finalizer could run at the start of syscall.Read, closing the file descriptor before syscall.Read makes the actual system call. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcinit",
              "documentation": {
                "identifier": "gcinit",
                "newPage": false,
                "searchKey": "runtime.gcinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcinit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcenable",
              "documentation": {
                "identifier": "gcenable",
                "newPage": false,
                "searchKey": "runtime.gcenable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcenable()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcenable()\n```\n\ngcenable is called after the bulk of the runtime initialization, just before we're about to start letting user code run. It kicks off the background sweeper goroutine, the background scavenger goroutine, and enables GC. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setGCPhase",
              "documentation": {
                "identifier": "setGCPhase",
                "newPage": false,
                "searchKey": "runtime.setGCPhase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setGCPhase(x uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setGCPhase(x uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pollFractionalWorkerExit",
              "documentation": {
                "identifier": "pollFractionalWorkerExit",
                "newPage": false,
                "searchKey": "runtime.pollFractionalWorkerExit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pollFractionalWorkerExit() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pollFractionalWorkerExit() bool\n```\n\npollFractionalWorkerExit reports whether a fractional mark worker should self-preempt. It assumes it is called from the fractional worker. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GC",
              "documentation": {
                "identifier": "GC",
                "newPage": false,
                "searchKey": "runtime.GC",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func GC()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc GC()\n```\n\nGC runs a garbage collection and blocks the caller until the garbage collection is complete. It may also block the entire program. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcWaitOnMark",
              "documentation": {
                "identifier": "gcWaitOnMark",
                "newPage": false,
                "searchKey": "runtime.gcWaitOnMark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcWaitOnMark(n uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcWaitOnMark(n uint32)\n```\n\ngcWaitOnMark blocks until GC finishes the Nth mark phase. If GC has already completed this mark phase, it returns immediately. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcStart",
              "documentation": {
                "identifier": "gcStart",
                "newPage": false,
                "searchKey": "runtime.gcStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcStart(trigger gcTrigger)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcStart(trigger gcTrigger)\n```\n\ngcStart starts the GC. It transitions from _GCoff to _GCmark (if debug.gcstoptheworld == 0) or performs all of GC (if debug.gcstoptheworld != 0). \n\nThis may return without performing this transition in some cases, such as when called on a system stack or with locks held. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkDone",
              "documentation": {
                "identifier": "gcMarkDone",
                "newPage": false,
                "searchKey": "runtime.gcMarkDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcMarkDone()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcMarkDone()\n```\n\ngcMarkDone transitions the GC from mark to mark termination if all reachable objects have been marked (that is, there are no grey objects and can be no more in the future). Otherwise, it flushes all local work to the global queues where it can be discovered by other workers. \n\nThis should be called when all local mark work has been drained and there are no remaining workers. Specifically, when \n\n```\nwork.nwait == work.nproc && !gcMarkWorkAvailable(p)\n\n```\nThe calling context must be preemptible. \n\nFlushing local work is important because idle Ps may have local work queued. This is the only way to make that work visible and drive GC to completion. \n\nIt is explicitly okay to have write barriers in this function. If it does transition to mark termination, then all reachable objects have been marked, so the write barrier cannot shade any more objects. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkTermination",
              "documentation": {
                "identifier": "gcMarkTermination",
                "newPage": false,
                "searchKey": "runtime.gcMarkTermination",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcMarkTermination(nextTriggerRatio float64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcMarkTermination(nextTriggerRatio float64)\n```\n\nWorld must be stopped and mark assists and background workers must be disabled. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBgMarkStartWorkers",
              "documentation": {
                "identifier": "gcBgMarkStartWorkers",
                "newPage": false,
                "searchKey": "runtime.gcBgMarkStartWorkers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcBgMarkStartWorkers()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcBgMarkStartWorkers()\n```\n\ngcBgMarkStartWorkers prepares background mark worker goroutines. These goroutines will not run until the mark phase, but they must be started while the work is not stopped and from a regular G stack. The caller must hold worldsema. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBgMarkPrepare",
              "documentation": {
                "identifier": "gcBgMarkPrepare",
                "newPage": false,
                "searchKey": "runtime.gcBgMarkPrepare",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcBgMarkPrepare()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcBgMarkPrepare()\n```\n\ngcBgMarkPrepare sets up state for background marking. Mutator assists must not yet be enabled. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcBgMarkWorker",
              "documentation": {
                "identifier": "gcBgMarkWorker",
                "newPage": false,
                "searchKey": "runtime.gcBgMarkWorker",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcBgMarkWorker()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcBgMarkWorker()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkWorkAvailable",
              "documentation": {
                "identifier": "gcMarkWorkAvailable",
                "newPage": false,
                "searchKey": "runtime.gcMarkWorkAvailable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcMarkWorkAvailable(p *p) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcMarkWorkAvailable(p *p) bool\n```\n\ngcMarkWorkAvailable reports whether executing a mark worker on p is potentially useful. p may be nil, in which case it only checks the global sources of work. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMark",
              "documentation": {
                "identifier": "gcMark",
                "newPage": false,
                "searchKey": "runtime.gcMark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcMark(startTime int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcMark(startTime int64)\n```\n\ngcMark runs the mark (or, for concurrent GC, mark termination) All gcWork caches must be empty. STW is in effect at this point. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcSweep",
              "documentation": {
                "identifier": "gcSweep",
                "newPage": false,
                "searchKey": "runtime.gcSweep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcSweep(mode gcMode)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcSweep(mode gcMode)\n```\n\ngcSweep must be called on the system stack because it acquires the heap lock. See mheap for details. \n\nThe world must be stopped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcResetMarkState",
              "documentation": {
                "identifier": "gcResetMarkState",
                "newPage": false,
                "searchKey": "runtime.gcResetMarkState",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcResetMarkState()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcResetMarkState()\n```\n\ngcResetMarkState resets global state prior to marking (concurrent or STW) and resets the stack scan state of all Gs. \n\nThis is safe to do without the world stopped because any Gs created during or after this will start out in the reset state. \n\ngcResetMarkState must be called on the system stack because it acquires the heap lock. See mheap for details. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_runtime_registerPoolCleanup",
              "documentation": {
                "identifier": "sync_runtime_registerPoolCleanup",
                "newPage": false,
                "searchKey": "runtime.sync_runtime_registerPoolCleanup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_runtime_registerPoolCleanup(f func())"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_runtime_registerPoolCleanup(f func())\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#clearpools",
              "documentation": {
                "identifier": "clearpools",
                "newPage": false,
                "searchKey": "runtime.clearpools",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func clearpools()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc clearpools()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#itoaDiv",
              "documentation": {
                "identifier": "itoaDiv",
                "newPage": false,
                "searchKey": "runtime.itoaDiv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func itoaDiv(buf []byte, val uint64, dec int) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc itoaDiv(buf []byte, val uint64, dec int) []byte\n```\n\nitoaDiv formats val/(10**dec) into buf. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fmtNSAsMS",
              "documentation": {
                "identifier": "fmtNSAsMS",
                "newPage": false,
                "searchKey": "runtime.fmtNSAsMS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fmtNSAsMS(buf []byte, ns uint64) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fmtNSAsMS(buf []byte, ns uint64) []byte\n```\n\nfmtNSAsMS nicely formats ns nanoseconds as milliseconds. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcTestMoveStackOnNextCall",
              "documentation": {
                "identifier": "gcTestMoveStackOnNextCall",
                "newPage": false,
                "searchKey": "runtime.gcTestMoveStackOnNextCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcTestMoveStackOnNextCall()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcTestMoveStackOnNextCall()\n```\n\ngcTestMoveStackOnNextCall causes the stack to be moved on a call immediately following the call to this. It may not work correctly if any other work appears after this call (such as returning). Typically the following call should be marked go:noinline so it performs a stack check. \n\nIn rare cases this may not cause the stack to move, specifically if there's a preemption between this call and the next. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcTestIsReachable",
              "documentation": {
                "identifier": "gcTestIsReachable",
                "newPage": false,
                "searchKey": "runtime.gcTestIsReachable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcTestIsReachable(ptrs ...unsafe.Pointer) (mask uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcTestIsReachable(ptrs ...unsafe.Pointer) (mask uint64)\n```\n\ngcTestIsReachable performs a GC and returns a bit set where bit i is set if ptrs[i] is reachable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcTestPointerClass",
              "documentation": {
                "identifier": "gcTestPointerClass",
                "newPage": false,
                "searchKey": "runtime.gcTestPointerClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcTestPointerClass(p unsafe.Pointer) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcTestPointerClass(p unsafe.Pointer) string\n```\n\ngcTestPointerClass returns the category of what p points to, one of: \"heap\", \"stack\", \"data\", \"bss\", \"other\". This is useful for checking that a test is doing what it's intended to do. \n\nThis is nosplit simply to avoid extra pointer shuffling that may complicate a test. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkRootPrepare",
              "documentation": {
                "identifier": "gcMarkRootPrepare",
                "newPage": false,
                "searchKey": "runtime.gcMarkRootPrepare",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcMarkRootPrepare()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcMarkRootPrepare()\n```\n\ngcMarkRootPrepare queues root scanning jobs (stacks, globals, and some miscellany) and initializes scanning-related state. \n\nThe world must be stopped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkRootCheck",
              "documentation": {
                "identifier": "gcMarkRootCheck",
                "newPage": false,
                "searchKey": "runtime.gcMarkRootCheck",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcMarkRootCheck()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcMarkRootCheck()\n```\n\ngcMarkRootCheck checks that all roots have been scanned. It is purely for debugging. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#markroot",
              "documentation": {
                "identifier": "markroot",
                "newPage": false,
                "searchKey": "runtime.markroot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func markroot(gcw *gcWork, i uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc markroot(gcw *gcWork, i uint32)\n```\n\nmarkroot scans the i'th root. \n\nPreemption must be disabled (because this uses a gcWork). \n\nnowritebarrier is only advisory here. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#markrootBlock",
              "documentation": {
                "identifier": "markrootBlock",
                "newPage": false,
                "searchKey": "runtime.markrootBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func markrootBlock(b0, n0 uintptr, ptrmask0 *uint8, gcw *gcWork, shard int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc markrootBlock(b0, n0 uintptr, ptrmask0 *uint8, gcw *gcWork, shard int)\n```\n\nmarkrootBlock scans the shard'th shard of the block of memory [b0, b0+n0), with the given pointer mask. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#markrootFreeGStacks",
              "documentation": {
                "identifier": "markrootFreeGStacks",
                "newPage": false,
                "searchKey": "runtime.markrootFreeGStacks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func markrootFreeGStacks()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc markrootFreeGStacks()\n```\n\nmarkrootFreeGStacks frees stacks of dead Gs. \n\nThis does not free stacks of dead Gs cached on Ps, but having a few cached stacks around isn't a problem. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#markrootSpans",
              "documentation": {
                "identifier": "markrootSpans",
                "newPage": false,
                "searchKey": "runtime.markrootSpans",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func markrootSpans(gcw *gcWork, shard int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc markrootSpans(gcw *gcWork, shard int)\n```\n\nmarkrootSpans marks roots for one shard of markArenas. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcAssistAlloc",
              "documentation": {
                "identifier": "gcAssistAlloc",
                "newPage": false,
                "searchKey": "runtime.gcAssistAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcAssistAlloc(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcAssistAlloc(gp *g)\n```\n\ngcAssistAlloc performs GC work to make gp's assist debt positive. gp must be the calling user gorountine. \n\nThis must be called with preemption enabled. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcAssistAlloc1",
              "documentation": {
                "identifier": "gcAssistAlloc1",
                "newPage": false,
                "searchKey": "runtime.gcAssistAlloc1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcAssistAlloc1(gp *g, scanWork int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcAssistAlloc1(gp *g, scanWork int64)\n```\n\ngcAssistAlloc1 is the part of gcAssistAlloc that runs on the system stack. This is a separate function to make it easier to see that we're not capturing anything from the user stack, since the user stack may move while we're in this function. \n\ngcAssistAlloc1 indicates whether this assist completed the mark phase by setting gp.param to non-nil. This can't be communicated on the stack since it may move. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcWakeAllAssists",
              "documentation": {
                "identifier": "gcWakeAllAssists",
                "newPage": false,
                "searchKey": "runtime.gcWakeAllAssists",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcWakeAllAssists()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcWakeAllAssists()\n```\n\ngcWakeAllAssists wakes all currently blocked assists. This is used at the end of a GC cycle. gcBlackenEnabled must be false to prevent new assists from going to sleep after this point. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcParkAssist",
              "documentation": {
                "identifier": "gcParkAssist",
                "newPage": false,
                "searchKey": "runtime.gcParkAssist",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcParkAssist() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcParkAssist() bool\n```\n\ngcParkAssist puts the current goroutine on the assist queue and parks. \n\ngcParkAssist reports whether the assist is now satisfied. If it returns false, the caller must retry the assist. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcFlushBgCredit",
              "documentation": {
                "identifier": "gcFlushBgCredit",
                "newPage": false,
                "searchKey": "runtime.gcFlushBgCredit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcFlushBgCredit(scanWork int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcFlushBgCredit(scanWork int64)\n```\n\ngcFlushBgCredit flushes scanWork units of background scan work credit. This first satisfies blocked assists on the work.assistQueue and then flushes any remaining credit to gcController.bgScanCredit. \n\nWrite barriers are disallowed because this is used by gcDrain after it has ensured that all work is drained and this must preserve that condition. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#scanstack",
              "documentation": {
                "identifier": "scanstack",
                "newPage": false,
                "searchKey": "runtime.scanstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func scanstack(gp *g, gcw *gcWork)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc scanstack(gp *g, gcw *gcWork)\n```\n\nscanstack scans gp's stack, greying all pointers found on the stack. \n\nscanstack will also shrink the stack if it is safe to do so. If it is not, it schedules a stack shrink for the next synchronous safe point. \n\nscanstack is marked go:systemstack because it must not be preempted while using a workbuf. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#scanframeworker",
              "documentation": {
                "identifier": "scanframeworker",
                "newPage": false,
                "searchKey": "runtime.scanframeworker",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func scanframeworker(frame *stkframe, state *stackScanState, gcw *gcWork)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc scanframeworker(frame *stkframe, state *stackScanState, gcw *gcWork)\n```\n\nScan a stack frame: local variables and function arguments/results. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcDrain",
              "documentation": {
                "identifier": "gcDrain",
                "newPage": false,
                "searchKey": "runtime.gcDrain",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcDrain(gcw *gcWork, flags gcDrainFlags)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcDrain(gcw *gcWork, flags gcDrainFlags)\n```\n\ngcDrain scans roots and objects in work buffers, blackening grey objects until it is unable to get more work. It may return before GC is done; it's the caller's responsibility to balance work from other Ps. \n\nIf flags&gcDrainUntilPreempt != 0, gcDrain returns when g.preempt is set. \n\nIf flags&gcDrainIdle != 0, gcDrain returns when there is other work to do. \n\nIf flags&gcDrainFractional != 0, gcDrain self-preempts when pollFractionalWorkerExit() returns true. This implies gcDrainNoBlock. \n\nIf flags&gcDrainFlushBgCredit != 0, gcDrain flushes scan work credit to gcController.bgScanCredit every gcCreditSlack units of scan work. \n\ngcDrain will always return if there is a pending STW. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcDrainN",
              "documentation": {
                "identifier": "gcDrainN",
                "newPage": false,
                "searchKey": "runtime.gcDrainN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcDrainN(gcw *gcWork, scanWork int64) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcDrainN(gcw *gcWork, scanWork int64) int64\n```\n\ngcDrainN blackens grey objects until it has performed roughly scanWork units of scan work or the G is preempted. This is best-effort, so it may perform less work if it fails to get a work buffer. Otherwise, it will perform at least n units of work, but may perform more because scanning is always done in whole object increments. It returns the amount of scan work performed. \n\nThe caller goroutine must be in a preemptible state (e.g., _Gwaiting) to prevent deadlocks during stack scanning. As a consequence, this must be called on the system stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#scanblock",
              "documentation": {
                "identifier": "scanblock",
                "newPage": false,
                "searchKey": "runtime.scanblock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func scanblock(b0, n0 uintptr, ptrmask *uint8, gcw *gcWork, stk *stackScanState)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc scanblock(b0, n0 uintptr, ptrmask *uint8, gcw *gcWork, stk *stackScanState)\n```\n\nscanblock scans b as scanobject would, but using an explicit pointer bitmap instead of the heap bitmap. \n\nThis is used to scan non-heap roots, so it does not update gcw.bytesMarked or gcw.scanWork. \n\nIf stk != nil, possible stack pointers are also reported to stk.putPtr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#scanobject",
              "documentation": {
                "identifier": "scanobject",
                "newPage": false,
                "searchKey": "runtime.scanobject",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func scanobject(b uintptr, gcw *gcWork)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc scanobject(b uintptr, gcw *gcWork)\n```\n\nscanobject scans the object starting at b, adding pointers to gcw. b must point to the beginning of a heap object or an oblet. scanobject consults the GC bitmap for the pointer mask and the spans for the size of the object. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#scanConservative",
              "documentation": {
                "identifier": "scanConservative",
                "newPage": false,
                "searchKey": "runtime.scanConservative",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func scanConservative(b, n uintptr, ptrmask *uint8, gcw *gcWork, state *stackScanState)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc scanConservative(b, n uintptr, ptrmask *uint8, gcw *gcWork, state *stackScanState)\n```\n\nscanConservative scans block [b, b+n) conservatively, treating any pointer-like value in the block as a pointer. \n\nIf ptrmask != nil, only words that are marked in ptrmask are considered as potential pointers. \n\nIf state != nil, it's assumed that [b, b+n) is a block in the stack and may contain pointers to stack objects. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#shade",
              "documentation": {
                "identifier": "shade",
                "newPage": false,
                "searchKey": "runtime.shade",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func shade(b uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc shade(b uintptr)\n```\n\nShade the object if it isn't already. The object is not nil and known to be in the heap. Preemption must be disabled. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#greyobject",
              "documentation": {
                "identifier": "greyobject",
                "newPage": false,
                "searchKey": "runtime.greyobject",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func greyobject(obj, base, off uintptr, span *mspan, gcw *gcWork, objIndex uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc greyobject(obj, base, off uintptr, span *mspan, gcw *gcWork, objIndex uintptr)\n```\n\nobj is the start of an object with mark mbits. If it isn't already marked, mark it and enqueue into gcw. base and off are for debugging only and could be removed. \n\nSee also wbBufFlush1, which partially duplicates this logic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcDumpObject",
              "documentation": {
                "identifier": "gcDumpObject",
                "newPage": false,
                "searchKey": "runtime.gcDumpObject",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcDumpObject(label string, obj, off uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcDumpObject(label string, obj, off uintptr)\n```\n\ngcDumpObject dumps the contents of obj for debugging and marks the field at byte offset off in obj. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcmarknewobject",
              "documentation": {
                "identifier": "gcmarknewobject",
                "newPage": false,
                "searchKey": "runtime.gcmarknewobject",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcmarknewobject(span *mspan, obj, size, scanSize uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcmarknewobject(span *mspan, obj, size, scanSize uintptr)\n```\n\ngcmarknewobject marks a newly allocated object black. obj must not contain any non-nil pointers. \n\nThis is nosplit so it can manipulate a gcWork without preemption. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcMarkTinyAllocs",
              "documentation": {
                "identifier": "gcMarkTinyAllocs",
                "newPage": false,
                "searchKey": "runtime.gcMarkTinyAllocs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcMarkTinyAllocs()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcMarkTinyAllocs()\n```\n\ngcMarkTinyAllocs greys all active tiny alloc blocks. \n\nThe world must be stopped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "runtime.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setGCPercent",
              "documentation": {
                "identifier": "setGCPercent",
                "newPage": false,
                "searchKey": "runtime.setGCPercent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setGCPercent(in int32) (out int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setGCPercent(in int32) (out int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readGOGC",
              "documentation": {
                "identifier": "readGOGC",
                "newPage": false,
                "searchKey": "runtime.readGOGC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readGOGC() int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readGOGC() int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#heapRetained",
              "documentation": {
                "identifier": "heapRetained",
                "newPage": false,
                "searchKey": "runtime.heapRetained",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func heapRetained() uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc heapRetained() uint64\n```\n\nheapRetained returns an estimate of the current heap RSS. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcPaceScavenger",
              "documentation": {
                "identifier": "gcPaceScavenger",
                "newPage": false,
                "searchKey": "runtime.gcPaceScavenger",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcPaceScavenger()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcPaceScavenger()\n```\n\ngcPaceScavenger updates the scavenger's pacing, particularly its rate and RSS goal. \n\nThe RSS goal is based on the current heap goal with a small overhead to accommodate non-determinism in the allocator. \n\nThe pacing is based on scavengePageRate, which applies to both regular and huge pages. See that constant for more information. \n\nmheap_.lock must be held or the world must be stopped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readyForScavenger",
              "documentation": {
                "identifier": "readyForScavenger",
                "newPage": false,
                "searchKey": "runtime.readyForScavenger",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readyForScavenger()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readyForScavenger()\n```\n\nreadyForScavenger signals sysmon to wake the scavenger because there may be new work to do. \n\nThere may be a significant delay between when this function runs and when the scavenger is kicked awake, but it may be safely invoked in contexts where wakeScavenger is unsafe to call directly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#wakeScavenger",
              "documentation": {
                "identifier": "wakeScavenger",
                "newPage": false,
                "searchKey": "runtime.wakeScavenger",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func wakeScavenger()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc wakeScavenger()\n```\n\nwakeScavenger immediately unparks the scavenger if necessary. \n\nMay run without a P, but it may allocate, so it must not be called on any allocation path. \n\nmheap_.lock, scavenge.lock, and sched.lock must not be held. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#scavengeSleep",
              "documentation": {
                "identifier": "scavengeSleep",
                "newPage": false,
                "searchKey": "runtime.scavengeSleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func scavengeSleep(ns int64) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc scavengeSleep(ns int64) int64\n```\n\nscavengeSleep attempts to put the scavenger to sleep for ns. \n\nNote that this function should only be called by the scavenger. \n\nThe scavenger may be woken up earlier by a pacing change, and it may not go to sleep at all if there's a pending pacing change. \n\nReturns the amount of time actually slept. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bgscavenge",
              "documentation": {
                "identifier": "bgscavenge",
                "newPage": false,
                "searchKey": "runtime.bgscavenge",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bgscavenge()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bgscavenge()\n```\n\nBackground scavenger. \n\nThe background scavenger maintains the RSS of the application below the line described by the proportional scavenging statistics in the mheap struct. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printScavTrace",
              "documentation": {
                "identifier": "printScavTrace",
                "newPage": false,
                "searchKey": "runtime.printScavTrace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printScavTrace(gen uint32, released uintptr, forced bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printScavTrace(gen uint32, released uintptr, forced bool)\n```\n\nprintScavTrace prints a scavenge trace line to standard error. \n\nreleased should be the amount of memory released since the last time this was called, and forced indicates whether the scavenge was forced by the application. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fillAligned",
              "documentation": {
                "identifier": "fillAligned",
                "newPage": false,
                "searchKey": "runtime.fillAligned",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fillAligned(x uint64, m uint) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fillAligned(x uint64, m uint) uint64\n```\n\nfillAligned returns x but with all zeroes in m-aligned groups of m bits set to 1 if any bit in the group is non-zero. \n\nFor example, fillAligned(0x0100a3, 8) == 0xff00ff. \n\nNote that if m == 1, this is a no-op. \n\nm must be a power of 2 <= maxPagesPerPhysPage. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "runtime.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#finishsweep_m",
              "documentation": {
                "identifier": "finishsweep_m",
                "newPage": false,
                "searchKey": "runtime.finishsweep_m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func finishsweep_m()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc finishsweep_m()\n```\n\nfinishsweep_m ensures that all spans are swept. \n\nThe world must be stopped. This ensures there are no sweeps in progress. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bgsweep",
              "documentation": {
                "identifier": "bgsweep",
                "newPage": false,
                "searchKey": "runtime.bgsweep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bgsweep()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bgsweep()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sweepone",
              "documentation": {
                "identifier": "sweepone",
                "newPage": false,
                "searchKey": "runtime.sweepone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sweepone() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sweepone() uintptr\n```\n\nsweepone sweeps some unswept heap span and returns the number of pages returned to the heap, or ^uintptr(0) if there was nothing to sweep. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isSweepDone",
              "documentation": {
                "identifier": "isSweepDone",
                "newPage": false,
                "searchKey": "runtime.isSweepDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isSweepDone() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isSweepDone() bool\n```\n\nisSweepDone reports whether all spans are swept. \n\nNote that this condition may transition from false to true at any time as the sweeper runs. It may transition from true to false if a GC runs; to prevent that the caller must be non-preemptible or must somehow block GC progress. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deductSweepCredit",
              "documentation": {
                "identifier": "deductSweepCredit",
                "newPage": false,
                "searchKey": "runtime.deductSweepCredit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func deductSweepCredit(spanBytes uintptr, callerSweepPages uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc deductSweepCredit(spanBytes uintptr, callerSweepPages uintptr)\n```\n\ndeductSweepCredit deducts sweep credit for allocating a span of size spanBytes. This must be performed *before* the span is allocated to ensure the system has enough credit. If necessary, it performs sweeping to prevent going in to debt. If the caller will also sweep pages (e.g., for a large allocation), it can pass a non-zero callerSweepPages to leave that many pages unswept. \n\ndeductSweepCredit makes a worst-case assumption that all spanBytes bytes of the ultimately allocated span will be available for object allocation. \n\ndeductSweepCredit is the core of the \"proportional sweep\" system. It uses statistics gathered by the garbage collector to perform enough sweeping so that all pages are swept during the concurrent sweep phase between GC cycles. \n\nmheap_ must NOT be locked. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#clobberfree",
              "documentation": {
                "identifier": "clobberfree",
                "newPage": false,
                "searchKey": "runtime.clobberfree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func clobberfree(x unsafe.Pointer, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc clobberfree(x unsafe.Pointer, size uintptr)\n```\n\nclobberfree sets the memory content at x to bad content, for debugging purposes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "runtime.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#putempty",
              "documentation": {
                "identifier": "putempty",
                "newPage": false,
                "searchKey": "runtime.putempty",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func putempty(b *workbuf)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc putempty(b *workbuf)\n```\n\nputempty puts a workbuf onto the work.empty list. Upon entry this goroutine owns b. The lfstack.push relinquishes ownership. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#putfull",
              "documentation": {
                "identifier": "putfull",
                "newPage": false,
                "searchKey": "runtime.putfull",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func putfull(b *workbuf)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc putfull(b *workbuf)\n```\n\nputfull puts the workbuf on the work.full list for the GC. putfull accepts partially full buffers so the GC can avoid competing with the mutators for ownership of partially full buffers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#prepareFreeWorkbufs",
              "documentation": {
                "identifier": "prepareFreeWorkbufs",
                "newPage": false,
                "searchKey": "runtime.prepareFreeWorkbufs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func prepareFreeWorkbufs()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc prepareFreeWorkbufs()\n```\n\nprepareFreeWorkbufs moves busy workbuf spans to free list so they can be freed to the heap. This must only be called when all workbufs are on the empty list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freeSomeWbufs",
              "documentation": {
                "identifier": "freeSomeWbufs",
                "newPage": false,
                "searchKey": "runtime.freeSomeWbufs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func freeSomeWbufs(preemptible bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc freeSomeWbufs(preemptible bool) bool\n```\n\nfreeSomeWbufs frees some workbufs back to the heap and returns true if it should be called again to free more. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#recordspan",
              "documentation": {
                "identifier": "recordspan",
                "newPage": false,
                "searchKey": "runtime.recordspan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func recordspan(vh unsafe.Pointer, p unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc recordspan(vh unsafe.Pointer, p unsafe.Pointer)\n```\n\nrecordspan adds a newly allocated span to h.allspans. \n\nThis only happens the first time a span is allocated from mheap.spanalloc (it is not called when a span is reused). \n\nWrite barriers are disallowed here because it can be called from gcWork when allocating new workbufs. However, because it's an indirect call from the fixalloc initializer, the compiler can't see this. \n\nThe heap lock must be held. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#arenaBase",
              "documentation": {
                "identifier": "arenaBase",
                "newPage": false,
                "searchKey": "runtime.arenaBase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func arenaBase(i arenaIdx) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc arenaBase(i arenaIdx) uintptr\n```\n\narenaBase returns the low address of the region covered by heap arena i. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inheap",
              "documentation": {
                "identifier": "inheap",
                "newPage": false,
                "searchKey": "runtime.inheap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func inheap(b uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc inheap(b uintptr) bool\n```\n\ninheap reports whether b is a pointer into a (potentially dead) heap object. It returns false for pointers into mSpanManual spans. Non-preemptible because it is used by write barriers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inHeapOrStack",
              "documentation": {
                "identifier": "inHeapOrStack",
                "newPage": false,
                "searchKey": "runtime.inHeapOrStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func inHeapOrStack(b uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc inHeapOrStack(b uintptr) bool\n```\n\ninHeapOrStack is a variant of inheap that returns true for pointers into any allocated heap span. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtime_debug_freeOSMemory",
              "documentation": {
                "identifier": "runtime_debug_freeOSMemory",
                "newPage": false,
                "searchKey": "runtime.runtime_debug_freeOSMemory",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtime_debug_freeOSMemory()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtime_debug_freeOSMemory()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanHasSpecials",
              "documentation": {
                "identifier": "spanHasSpecials",
                "newPage": false,
                "searchKey": "runtime.spanHasSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func spanHasSpecials(s *mspan)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc spanHasSpecials(s *mspan)\n```\n\nspanHasSpecials marks a span as having specials in the arena bitmap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spanHasNoSpecials",
              "documentation": {
                "identifier": "spanHasNoSpecials",
                "newPage": false,
                "searchKey": "runtime.spanHasNoSpecials",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func spanHasNoSpecials(s *mspan)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc spanHasNoSpecials(s *mspan)\n```\n\nspanHasNoSpecials marks a span as having no specials in the arena bitmap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#addspecial",
              "documentation": {
                "identifier": "addspecial",
                "newPage": false,
                "searchKey": "runtime.addspecial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addspecial(p unsafe.Pointer, s *special) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addspecial(p unsafe.Pointer, s *special) bool\n```\n\nAdds the special record s to the list of special records for the object p. All fields of s should be filled in except for offset & next, which this routine will fill in. Returns true if the special was successfully added, false otherwise. (The add will fail only if a record with the same p and s->kind \n\n```\nalready exists.)\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#addfinalizer",
              "documentation": {
                "identifier": "addfinalizer",
                "newPage": false,
                "searchKey": "runtime.addfinalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addfinalizer(p unsafe.Pointer, f *funcval, nret uintptr, fint *_type, ot *ptrtype) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addfinalizer(p unsafe.Pointer, f *funcval, nret uintptr, fint *_type, ot *ptrtype) bool\n```\n\nAdds a finalizer to the object p. Returns true if it succeeded. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#removefinalizer",
              "documentation": {
                "identifier": "removefinalizer",
                "newPage": false,
                "searchKey": "runtime.removefinalizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func removefinalizer(p unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc removefinalizer(p unsafe.Pointer)\n```\n\nRemoves the finalizer (if any) from the object p. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setprofilebucket",
              "documentation": {
                "identifier": "setprofilebucket",
                "newPage": false,
                "searchKey": "runtime.setprofilebucket",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setprofilebucket(p unsafe.Pointer, b *bucket)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setprofilebucket(p unsafe.Pointer, b *bucket)\n```\n\nSet the heap profile bucket associated with addr to b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freeSpecial",
              "documentation": {
                "identifier": "freeSpecial",
                "newPage": false,
                "searchKey": "runtime.freeSpecial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func freeSpecial(s *special, p unsafe.Pointer, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc freeSpecial(s *special, p unsafe.Pointer, size uintptr)\n```\n\nfreeSpecial performs any cleanup on special s and deallocates it. s must already be unlinked from the specials list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nextMarkBitArenaEpoch",
              "documentation": {
                "identifier": "nextMarkBitArenaEpoch",
                "newPage": false,
                "searchKey": "runtime.nextMarkBitArenaEpoch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nextMarkBitArenaEpoch()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nextMarkBitArenaEpoch()\n```\n\nnextMarkBitArenaEpoch establishes a new epoch for the arenas holding the mark bits. The arenas are named relative to the current GC cycle which is demarcated by the call to finishweep_m. \n\nAll current spans have been swept. During that sweep each span allocated room for its gcmarkBits in gcBitsArenas.next block. gcBitsArenas.next becomes the gcBitsArenas.current where the GC will mark objects and after each span is swept these bits will be used to allocate objects. gcBitsArenas.current becomes gcBitsArenas.previous where the span's gcAllocBits live until all the spans have been swept during this GC cycle. The span's sweep extinguishes all the references to gcBitsArenas.previous by pointing gcAllocBits into the gcBitsArenas.current. The gcBitsArenas.previous is released to the gcBitsArenas.free list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chunkBase",
              "documentation": {
                "identifier": "chunkBase",
                "newPage": false,
                "searchKey": "runtime.chunkBase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chunkBase(ci chunkIdx) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chunkBase(ci chunkIdx) uintptr\n```\n\nchunkIndex returns the base address of the palloc chunk at index ci. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#chunkPageIndex",
              "documentation": {
                "identifier": "chunkPageIndex",
                "newPage": false,
                "searchKey": "runtime.chunkPageIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func chunkPageIndex(p uintptr) uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc chunkPageIndex(p uintptr) uint\n```\n\nchunkPageIndex computes the index of the page that contains p, relative to the chunk which contains p. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#offAddrToLevelIndex",
              "documentation": {
                "identifier": "offAddrToLevelIndex",
                "newPage": false,
                "searchKey": "runtime.offAddrToLevelIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func offAddrToLevelIndex(level int, addr offAddr) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc offAddrToLevelIndex(level int, addr offAddr) int\n```\n\noffAddrToLevelIndex converts an address in the offset address space to the index into summary[level] containing addr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#addrsToSummaryRange",
              "documentation": {
                "identifier": "addrsToSummaryRange",
                "newPage": false,
                "searchKey": "runtime.addrsToSummaryRange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addrsToSummaryRange(level int, base, limit uintptr) (lo int, hi int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addrsToSummaryRange(level int, base, limit uintptr) (lo int, hi int)\n```\n\naddrsToSummaryRange converts base and limit pointers into a range of entries for the given summary level. \n\nThe returned range is inclusive on the lower bound and exclusive on the upper bound. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#blockAlignSummaryRange",
              "documentation": {
                "identifier": "blockAlignSummaryRange",
                "newPage": false,
                "searchKey": "runtime.blockAlignSummaryRange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func blockAlignSummaryRange(level int, lo, hi int) (int, int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc blockAlignSummaryRange(level int, lo, hi int) (int, int)\n```\n\nblockAlignSummaryRange aligns indices into the given level to that level's block width (1 << levelBits[level]). It assumes lo is inclusive and hi is exclusive, and so aligns them down and up respectively. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#findBitRange64",
              "documentation": {
                "identifier": "findBitRange64",
                "newPage": false,
                "searchKey": "runtime.findBitRange64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func findBitRange64(c uint64, n uint) uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc findBitRange64(c uint64, n uint) uint\n```\n\nfindBitRange64 returns the bit index of the first set of n consecutive 1 bits. If no consecutive set of 1 bits of size n may be found in c, then it returns an integer >= 64. n must be > 0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#eqslice",
              "documentation": {
                "identifier": "eqslice",
                "newPage": false,
                "searchKey": "runtime.eqslice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func eqslice(x, y []uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc eqslice(x, y []uintptr) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mProf_NextCycle",
              "documentation": {
                "identifier": "mProf_NextCycle",
                "newPage": false,
                "searchKey": "runtime.mProf_NextCycle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mProf_NextCycle()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mProf_NextCycle()\n```\n\nmProf_NextCycle publishes the next heap profile cycle and creates a fresh heap profile cycle. This operation is fast and can be done during STW. The caller must call mProf_Flush before calling mProf_NextCycle again. \n\nThis is called by mark termination during STW so allocations and frees after the world is started again count towards a new heap profiling cycle. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mProf_Flush",
              "documentation": {
                "identifier": "mProf_Flush",
                "newPage": false,
                "searchKey": "runtime.mProf_Flush",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mProf_Flush()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mProf_Flush()\n```\n\nmProf_Flush flushes the events from the current heap profiling cycle into the active profile. After this it is safe to start a new heap profiling cycle with mProf_NextCycle. \n\nThis is called by GC after mark termination starts the world. In contrast with mProf_NextCycle, this is somewhat expensive, but safe to do concurrently. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mProf_FlushLocked",
              "documentation": {
                "identifier": "mProf_FlushLocked",
                "newPage": false,
                "searchKey": "runtime.mProf_FlushLocked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mProf_FlushLocked()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mProf_FlushLocked()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mProf_PostSweep",
              "documentation": {
                "identifier": "mProf_PostSweep",
                "newPage": false,
                "searchKey": "runtime.mProf_PostSweep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mProf_PostSweep()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mProf_PostSweep()\n```\n\nmProf_PostSweep records that all sweep frees for this GC cycle have completed. This has the effect of publishing the heap profile snapshot as of the last mark termination without advancing the heap profile cycle. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mProf_Malloc",
              "documentation": {
                "identifier": "mProf_Malloc",
                "newPage": false,
                "searchKey": "runtime.mProf_Malloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mProf_Malloc(p unsafe.Pointer, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mProf_Malloc(p unsafe.Pointer, size uintptr)\n```\n\nCalled by malloc to record a profiled block. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mProf_Free",
              "documentation": {
                "identifier": "mProf_Free",
                "newPage": false,
                "searchKey": "runtime.mProf_Free",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mProf_Free(b *bucket, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mProf_Free(b *bucket, size uintptr)\n```\n\nCalled when freeing a profiled block. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#SetBlockProfileRate",
              "documentation": {
                "identifier": "SetBlockProfileRate",
                "newPage": false,
                "searchKey": "runtime.SetBlockProfileRate",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetBlockProfileRate(rate int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetBlockProfileRate(rate int)\n```\n\nSetBlockProfileRate controls the fraction of goroutine blocking events that are reported in the blocking profile. The profiler aims to sample an average of one blocking event per rate nanoseconds spent blocked. \n\nTo include every blocking event in the profile, pass rate = 1. To turn off profiling entirely, pass rate <= 0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#blockevent",
              "documentation": {
                "identifier": "blockevent",
                "newPage": false,
                "searchKey": "runtime.blockevent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func blockevent(cycles int64, skip int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc blockevent(cycles int64, skip int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#blocksampled",
              "documentation": {
                "identifier": "blocksampled",
                "newPage": false,
                "searchKey": "runtime.blocksampled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func blocksampled(cycles, rate int64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc blocksampled(cycles, rate int64) bool\n```\n\nblocksampled returns true for all events where cycles >= rate. Shorter events have a cycles/rate random chance of returning true. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#saveblockevent",
              "documentation": {
                "identifier": "saveblockevent",
                "newPage": false,
                "searchKey": "runtime.saveblockevent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func saveblockevent(cycles, rate int64, skip int, which bucketType)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc saveblockevent(cycles, rate int64, skip int, which bucketType)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#SetMutexProfileFraction",
              "documentation": {
                "identifier": "SetMutexProfileFraction",
                "newPage": false,
                "searchKey": "runtime.SetMutexProfileFraction",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetMutexProfileFraction(rate int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetMutexProfileFraction(rate int) int\n```\n\nSetMutexProfileFraction controls the fraction of mutex contention events that are reported in the mutex profile. On average 1/rate events are reported. The previous rate is returned. \n\nTo turn off profiling entirely, pass rate 0. To just read the current rate, pass rate < 0. (For n>1 the details of sampling may change.) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mutexevent",
              "documentation": {
                "identifier": "mutexevent",
                "newPage": false,
                "searchKey": "runtime.mutexevent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mutexevent(cycles int64, skip int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mutexevent(cycles int64, skip int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#defaultMemProfileRate",
              "documentation": {
                "identifier": "defaultMemProfileRate",
                "newPage": false,
                "searchKey": "runtime.defaultMemProfileRate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func defaultMemProfileRate(v int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc defaultMemProfileRate(v int) int\n```\n\ndefaultMemProfileRate returns 0 if disableMemoryProfiling is set. It exists primarily for the godoc rendering of MemProfileRate above. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MemProfile",
              "documentation": {
                "identifier": "MemProfile",
                "newPage": false,
                "searchKey": "runtime.MemProfile",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)\n```\n\nMemProfile returns a profile of memory allocated and freed per allocation site. \n\nMemProfile returns n, the number of records in the current memory profile. If len(p) >= n, MemProfile copies the profile into p and returns n, true. If len(p) < n, MemProfile does not change p and returns n, false. \n\nIf inuseZero is true, the profile includes allocation records where r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes. These are sites where memory was allocated, but it has all been released back to the runtime. \n\nThe returned profile may be up to two garbage collection cycles old. This is to avoid skewing the profile toward allocations; because allocations happen in real time but frees are delayed until the garbage collector performs sweeping, the profile only accounts for allocations that have had a chance to be freed by the garbage collector. \n\nMost clients should use the runtime/pprof package or the testing package's -test.memprofile flag instead of calling MemProfile directly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#record",
              "documentation": {
                "identifier": "record",
                "newPage": false,
                "searchKey": "runtime.record",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func record(r *MemProfileRecord, b *bucket)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc record(r *MemProfileRecord, b *bucket)\n```\n\nWrite b's data to r. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#iterate_memprof",
              "documentation": {
                "identifier": "iterate_memprof",
                "newPage": false,
                "searchKey": "runtime.iterate_memprof",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func iterate_memprof(fn func(*bucket, uintptr, *uintptr, uintptr, uintptr, uintptr))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc iterate_memprof(fn func(*bucket, uintptr, *uintptr, uintptr, uintptr, uintptr))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#BlockProfile",
              "documentation": {
                "identifier": "BlockProfile",
                "newPage": false,
                "searchKey": "runtime.BlockProfile",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func BlockProfile(p []BlockProfileRecord) (n int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BlockProfile(p []BlockProfileRecord) (n int, ok bool)\n```\n\nBlockProfile returns n, the number of records in the current blocking profile. If len(p) >= n, BlockProfile copies the profile into p and returns n, true. If len(p) < n, BlockProfile does not change p and returns n, false. \n\nMost clients should use the runtime/pprof package or the testing package's -test.blockprofile flag instead of calling BlockProfile directly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MutexProfile",
              "documentation": {
                "identifier": "MutexProfile",
                "newPage": false,
                "searchKey": "runtime.MutexProfile",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func MutexProfile(p []BlockProfileRecord) (n int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MutexProfile(p []BlockProfileRecord) (n int, ok bool)\n```\n\nMutexProfile returns n, the number of records in the current mutex profile. If len(p) >= n, MutexProfile copies the profile into p and returns n, true. Otherwise, MutexProfile does not change p, and returns n, false. \n\nMost clients should use the runtime/pprof package instead of calling MutexProfile directly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ThreadCreateProfile",
              "documentation": {
                "identifier": "ThreadCreateProfile",
                "newPage": false,
                "searchKey": "runtime.ThreadCreateProfile",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ThreadCreateProfile(p []StackRecord) (n int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ThreadCreateProfile(p []StackRecord) (n int, ok bool)\n```\n\nThreadCreateProfile returns n, the number of records in the thread creation profile. If len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true. If len(p) < n, ThreadCreateProfile does not change p and returns n, false. \n\nMost clients should use the runtime/pprof package instead of calling ThreadCreateProfile directly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtime_goroutineProfileWithLabels",
              "documentation": {
                "identifier": "runtime_goroutineProfileWithLabels",
                "newPage": false,
                "searchKey": "runtime.runtime_goroutineProfileWithLabels",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtime_goroutineProfileWithLabels(p []StackRecord, labels []unsafe.Pointer) (n int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtime_goroutineProfileWithLabels(p []StackRecord, labels []unsafe.Pointer) (n int, ok bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goroutineProfileWithLabels",
              "documentation": {
                "identifier": "goroutineProfileWithLabels",
                "newPage": false,
                "searchKey": "runtime.goroutineProfileWithLabels",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goroutineProfileWithLabels(p []StackRecord, labels []unsafe.Pointer) (n int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goroutineProfileWithLabels(p []StackRecord, labels []unsafe.Pointer) (n int, ok bool)\n```\n\nlabels may be nil. If labels is non-nil, it must have the same length as p. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GoroutineProfile",
              "documentation": {
                "identifier": "GoroutineProfile",
                "newPage": false,
                "searchKey": "runtime.GoroutineProfile",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func GoroutineProfile(p []StackRecord) (n int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc GoroutineProfile(p []StackRecord) (n int, ok bool)\n```\n\nGoroutineProfile returns n, the number of records in the active goroutine stack profile. If len(p) >= n, GoroutineProfile copies the profile into p and returns n, true. If len(p) < n, GoroutineProfile does not change p and returns n, false. \n\nMost clients should use the runtime/pprof package instead of calling GoroutineProfile directly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#saveg",
              "documentation": {
                "identifier": "saveg",
                "newPage": false,
                "searchKey": "runtime.saveg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func saveg(pc, sp uintptr, gp *g, r *StackRecord)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc saveg(pc, sp uintptr, gp *g, r *StackRecord)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Stack",
              "documentation": {
                "identifier": "Stack",
                "newPage": false,
                "searchKey": "runtime.Stack",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Stack(buf []byte, all bool) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Stack(buf []byte, all bool) int\n```\n\nStack formats a stack trace of the calling goroutine into buf and returns the number of bytes written to buf. If all is true, Stack formats stack traces of all other goroutines into buf after the trace for the current goroutine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracealloc",
              "documentation": {
                "identifier": "tracealloc",
                "newPage": false,
                "searchKey": "runtime.tracealloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tracealloc(p unsafe.Pointer, size uintptr, typ *_type)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tracealloc(p unsafe.Pointer, size uintptr, typ *_type)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracefree",
              "documentation": {
                "identifier": "tracefree",
                "newPage": false,
                "searchKey": "runtime.tracefree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tracefree(p unsafe.Pointer, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tracefree(p unsafe.Pointer, size uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracegc",
              "documentation": {
                "identifier": "tracegc",
                "newPage": false,
                "searchKey": "runtime.tracegc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tracegc()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tracegc()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#msanread",
              "documentation": {
                "identifier": "msanread",
                "newPage": false,
                "searchKey": "runtime.msanread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func msanread(addr unsafe.Pointer, sz uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc msanread(addr unsafe.Pointer, sz uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#msanwrite",
              "documentation": {
                "identifier": "msanwrite",
                "newPage": false,
                "searchKey": "runtime.msanwrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func msanwrite(addr unsafe.Pointer, sz uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc msanwrite(addr unsafe.Pointer, sz uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#msanmalloc",
              "documentation": {
                "identifier": "msanmalloc",
                "newPage": false,
                "searchKey": "runtime.msanmalloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func msanmalloc(addr unsafe.Pointer, sz uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc msanmalloc(addr unsafe.Pointer, sz uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#msanfree",
              "documentation": {
                "identifier": "msanfree",
                "newPage": false,
                "searchKey": "runtime.msanfree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func msanfree(addr unsafe.Pointer, sz uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc msanfree(addr unsafe.Pointer, sz uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#msanmove",
              "documentation": {
                "identifier": "msanmove",
                "newPage": false,
                "searchKey": "runtime.msanmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func msanmove(dst, src unsafe.Pointer, sz uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc msanmove(dst, src unsafe.Pointer, sz uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#roundupsize",
              "documentation": {
                "identifier": "roundupsize",
                "newPage": false,
                "searchKey": "runtime.roundupsize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func roundupsize(size uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc roundupsize(size uintptr) uintptr\n```\n\nReturns size of the memory block that mallocgc will allocate if you ask for the size. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "runtime.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ReadMemStats",
              "documentation": {
                "identifier": "ReadMemStats",
                "newPage": false,
                "searchKey": "runtime.ReadMemStats",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ReadMemStats(m *MemStats)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ReadMemStats(m *MemStats)\n```\n\nReadMemStats populates m with memory allocator statistics. \n\nThe returned memory allocator statistics are up to date as of the call to ReadMemStats. This is in contrast with a heap profile, which is a snapshot as of the most recently completed garbage collection cycle. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readmemstats_m",
              "documentation": {
                "identifier": "readmemstats_m",
                "newPage": false,
                "searchKey": "runtime.readmemstats_m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readmemstats_m(stats *MemStats)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readmemstats_m(stats *MemStats)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readGCStats",
              "documentation": {
                "identifier": "readGCStats",
                "newPage": false,
                "searchKey": "runtime.readGCStats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readGCStats(pauses *[]uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readGCStats(pauses *[]uint64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readGCStats_m",
              "documentation": {
                "identifier": "readGCStats_m",
                "newPage": false,
                "searchKey": "runtime.readGCStats_m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readGCStats_m(pauses *[]uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readGCStats_m(pauses *[]uint64)\n```\n\nreadGCStats_m must be called on the system stack because it acquires the heap lock. See mheap for details. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#updatememstats",
              "documentation": {
                "identifier": "updatememstats",
                "newPage": false,
                "searchKey": "runtime.updatememstats",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func updatememstats()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc updatememstats()\n```\n\nUpdates the memstats structure. \n\nThe world must be stopped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#flushmcache",
              "documentation": {
                "identifier": "flushmcache",
                "newPage": false,
                "searchKey": "runtime.flushmcache",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func flushmcache(i int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc flushmcache(i int)\n```\n\nflushmcache flushes the mcache of allp[i]. \n\nThe world must be stopped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#flushallmcaches",
              "documentation": {
                "identifier": "flushallmcaches",
                "newPage": false,
                "searchKey": "runtime.flushallmcaches",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func flushallmcaches()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc flushallmcaches()\n```\n\nflushallmcaches flushes the mcaches of all Ps. \n\nThe world must be stopped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#wbBufFlush",
              "documentation": {
                "identifier": "wbBufFlush",
                "newPage": false,
                "searchKey": "runtime.wbBufFlush",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func wbBufFlush(dst *uintptr, src uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc wbBufFlush(dst *uintptr, src uintptr)\n```\n\nwbBufFlush flushes the current P's write barrier buffer to the GC workbufs. It is passed the slot and value of the write barrier that caused the flush so that it can implement cgocheck. \n\nThis must not have write barriers because it is part of the write barrier implementation. \n\nThis and everything it calls must be nosplit because 1) the stack contains untyped slots from gcWriteBarrier and 2) there must not be a GC safe point between the write barrier test in the caller and flushing the buffer. \n\nTODO: A \"go:nosplitrec\" annotation would be perfect for this. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#wbBufFlush1",
              "documentation": {
                "identifier": "wbBufFlush1",
                "newPage": false,
                "searchKey": "runtime.wbBufFlush1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func wbBufFlush1(_p_ *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc wbBufFlush1(_p_ *p)\n```\n\nwbBufFlush1 flushes p's write barrier buffer to the GC work queue. \n\nThis must not have write barriers because it is part of the write barrier implementation, so this may lead to infinite loops or buffer corruption. \n\nThis must be non-preemptible because it uses the P's workbuf. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nonblockingPipe",
              "documentation": {
                "identifier": "nonblockingPipe",
                "newPage": false,
                "searchKey": "runtime.nonblockingPipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nonblockingPipe() (r, w int32, errno int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nonblockingPipe() (r, w int32, errno int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#poll_runtime_pollServerInit",
              "documentation": {
                "identifier": "poll_runtime_pollServerInit",
                "newPage": false,
                "searchKey": "runtime.poll_runtime_pollServerInit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func poll_runtime_pollServerInit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc poll_runtime_pollServerInit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollGenericInit",
              "documentation": {
                "identifier": "netpollGenericInit",
                "newPage": false,
                "searchKey": "runtime.netpollGenericInit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollGenericInit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollGenericInit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollinited",
              "documentation": {
                "identifier": "netpollinited",
                "newPage": false,
                "searchKey": "runtime.netpollinited",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollinited() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollinited() bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#poll_runtime_isPollServerDescriptor",
              "documentation": {
                "identifier": "poll_runtime_isPollServerDescriptor",
                "newPage": false,
                "searchKey": "runtime.poll_runtime_isPollServerDescriptor",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func poll_runtime_isPollServerDescriptor(fd uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc poll_runtime_isPollServerDescriptor(fd uintptr) bool\n```\n\npoll_runtime_isPollServerDescriptor reports whether fd is a descriptor being used by netpoll. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#poll_runtime_pollClose",
              "documentation": {
                "identifier": "poll_runtime_pollClose",
                "newPage": false,
                "searchKey": "runtime.poll_runtime_pollClose",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func poll_runtime_pollClose(pd *pollDesc)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc poll_runtime_pollClose(pd *pollDesc)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#poll_runtime_pollReset",
              "documentation": {
                "identifier": "poll_runtime_pollReset",
                "newPage": false,
                "searchKey": "runtime.poll_runtime_pollReset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func poll_runtime_pollReset(pd *pollDesc, mode int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc poll_runtime_pollReset(pd *pollDesc, mode int) int\n```\n\npoll_runtime_pollReset, which is internal/poll.runtime_pollReset, prepares a descriptor for polling in mode, which is 'r' or 'w'. This returns an error code; the codes are defined above. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#poll_runtime_pollWait",
              "documentation": {
                "identifier": "poll_runtime_pollWait",
                "newPage": false,
                "searchKey": "runtime.poll_runtime_pollWait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func poll_runtime_pollWait(pd *pollDesc, mode int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc poll_runtime_pollWait(pd *pollDesc, mode int) int\n```\n\npoll_runtime_pollWait, which is internal/poll.runtime_pollWait, waits for a descriptor to be ready for reading or writing, according to mode, which is 'r' or 'w'. This returns an error code; the codes are defined above. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#poll_runtime_pollWaitCanceled",
              "documentation": {
                "identifier": "poll_runtime_pollWaitCanceled",
                "newPage": false,
                "searchKey": "runtime.poll_runtime_pollWaitCanceled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func poll_runtime_pollWaitCanceled(pd *pollDesc, mode int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc poll_runtime_pollWaitCanceled(pd *pollDesc, mode int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#poll_runtime_pollSetDeadline",
              "documentation": {
                "identifier": "poll_runtime_pollSetDeadline",
                "newPage": false,
                "searchKey": "runtime.poll_runtime_pollSetDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func poll_runtime_pollSetDeadline(pd *pollDesc, d int64, mode int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc poll_runtime_pollSetDeadline(pd *pollDesc, d int64, mode int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#poll_runtime_pollUnblock",
              "documentation": {
                "identifier": "poll_runtime_pollUnblock",
                "newPage": false,
                "searchKey": "runtime.poll_runtime_pollUnblock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func poll_runtime_pollUnblock(pd *pollDesc)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc poll_runtime_pollUnblock(pd *pollDesc)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollready",
              "documentation": {
                "identifier": "netpollready",
                "newPage": false,
                "searchKey": "runtime.netpollready",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollready(toRun *gList, pd *pollDesc, mode int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollready(toRun *gList, pd *pollDesc, mode int32)\n```\n\nnetpollready is called by the platform-specific netpoll function. It declares that the fd associated with pd is ready for I/O. The toRun argument is used to build a list of goroutines to return from netpoll. The mode argument is 'r', 'w', or 'r'+'w' to indicate whether the fd is ready for reading or writing or both. \n\nThis may run while the world is stopped, so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollcheckerr",
              "documentation": {
                "identifier": "netpollcheckerr",
                "newPage": false,
                "searchKey": "runtime.netpollcheckerr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollcheckerr(pd *pollDesc, mode int32) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollcheckerr(pd *pollDesc, mode int32) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollblockcommit",
              "documentation": {
                "identifier": "netpollblockcommit",
                "newPage": false,
                "searchKey": "runtime.netpollblockcommit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollblockcommit(gp *g, gpp unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollblockcommit(gp *g, gpp unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollgoready",
              "documentation": {
                "identifier": "netpollgoready",
                "newPage": false,
                "searchKey": "runtime.netpollgoready",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollgoready(gp *g, traceskip int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollgoready(gp *g, traceskip int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollblock",
              "documentation": {
                "identifier": "netpollblock",
                "newPage": false,
                "searchKey": "runtime.netpollblock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollblock(pd *pollDesc, mode int32, waitio bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollblock(pd *pollDesc, mode int32, waitio bool) bool\n```\n\nreturns true if IO is ready, or false if timedout or closed waitio - wait only for completed IO, ignore errors \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpolldeadlineimpl",
              "documentation": {
                "identifier": "netpolldeadlineimpl",
                "newPage": false,
                "searchKey": "runtime.netpolldeadlineimpl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpolldeadlineimpl(pd *pollDesc, seq uintptr, read, write bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpolldeadlineimpl(pd *pollDesc, seq uintptr, read, write bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollDeadline",
              "documentation": {
                "identifier": "netpollDeadline",
                "newPage": false,
                "searchKey": "runtime.netpollDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollDeadline(arg interface{}, seq uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollDeadline(arg interface{}, seq uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollReadDeadline",
              "documentation": {
                "identifier": "netpollReadDeadline",
                "newPage": false,
                "searchKey": "runtime.netpollReadDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollReadDeadline(arg interface{}, seq uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollReadDeadline(arg interface{}, seq uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollWriteDeadline",
              "documentation": {
                "identifier": "netpollWriteDeadline",
                "newPage": false,
                "searchKey": "runtime.netpollWriteDeadline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollWriteDeadline(arg interface{}, seq uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollWriteDeadline(arg interface{}, seq uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollinit",
              "documentation": {
                "identifier": "netpollinit",
                "newPage": false,
                "searchKey": "runtime.netpollinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollinit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollIsPollDescriptor",
              "documentation": {
                "identifier": "netpollIsPollDescriptor",
                "newPage": false,
                "searchKey": "runtime.netpollIsPollDescriptor",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollIsPollDescriptor(fd uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollIsPollDescriptor(fd uintptr) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollopen",
              "documentation": {
                "identifier": "netpollopen",
                "newPage": false,
                "searchKey": "runtime.netpollopen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollopen(fd uintptr, pd *pollDesc) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollopen(fd uintptr, pd *pollDesc) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollclose",
              "documentation": {
                "identifier": "netpollclose",
                "newPage": false,
                "searchKey": "runtime.netpollclose",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollclose(fd uintptr) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollclose(fd uintptr) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollarm",
              "documentation": {
                "identifier": "netpollarm",
                "newPage": false,
                "searchKey": "runtime.netpollarm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollarm(pd *pollDesc, mode int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollarm(pd *pollDesc, mode int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#netpollBreak",
              "documentation": {
                "identifier": "netpollBreak",
                "newPage": false,
                "searchKey": "runtime.netpollBreak",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func netpollBreak()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc netpollBreak()\n```\n\nnetpollBreak interrupts a kevent. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unimplemented",
              "documentation": {
                "identifier": "unimplemented",
                "newPage": false,
                "searchKey": "runtime.unimplemented",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unimplemented(name string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unimplemented(name string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semacreate",
              "documentation": {
                "identifier": "semacreate",
                "newPage": false,
                "searchKey": "runtime.semacreate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func semacreate(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc semacreate(mp *m)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semasleep",
              "documentation": {
                "identifier": "semasleep",
                "newPage": false,
                "searchKey": "runtime.semasleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func semasleep(ns int64) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc semasleep(ns int64) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semawakeup",
              "documentation": {
                "identifier": "semawakeup",
                "newPage": false,
                "searchKey": "runtime.semawakeup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func semawakeup(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc semawakeup(mp *m)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigNoteSetup",
              "documentation": {
                "identifier": "sigNoteSetup",
                "newPage": false,
                "searchKey": "runtime.sigNoteSetup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigNoteSetup(*note)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigNoteSetup(*note)\n```\n\nsigNoteSetup initializes an async-signal-safe note. \n\nThe current implementation of notes on Darwin is not async-signal-safe, because the functions pthread_mutex_lock, pthread_cond_signal, and pthread_mutex_unlock, called by semawakeup, are not async-signal-safe. There is only one case where we need to wake up a note from a signal handler: the sigsend function. The signal handler code does not require all the features of notes: it does not need to do a timed wait. This is a separate implementation of notes, based on a pipe, that does not support timed waits but is async-signal-safe. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigNoteWakeup",
              "documentation": {
                "identifier": "sigNoteWakeup",
                "newPage": false,
                "searchKey": "runtime.sigNoteWakeup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigNoteWakeup(*note)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigNoteWakeup(*note)\n```\n\nsigNoteWakeup wakes up a thread sleeping on a note created by sigNoteSetup. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigNoteSleep",
              "documentation": {
                "identifier": "sigNoteSleep",
                "newPage": false,
                "searchKey": "runtime.sigNoteSleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigNoteSleep(*note)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigNoteSleep(*note)\n```\n\nsigNoteSleep waits for a note created by sigNoteSetup to be woken. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#osinit",
              "documentation": {
                "identifier": "osinit",
                "newPage": false,
                "searchKey": "runtime.osinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func osinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc osinit()\n```\n\nBSD interface for threading. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysctlbynameInt32",
              "documentation": {
                "identifier": "sysctlbynameInt32",
                "newPage": false,
                "searchKey": "runtime.sysctlbynameInt32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysctlbynameInt32(name []byte) (int32, int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysctlbynameInt32(name []byte) (int32, int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#internal_cpu_getsysctlbyname",
              "documentation": {
                "identifier": "internal_cpu_getsysctlbyname",
                "newPage": false,
                "searchKey": "runtime.internal_cpu_getsysctlbyname",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func internal_cpu_getsysctlbyname(name []byte) (int32, int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc internal_cpu_getsysctlbyname(name []byte) (int32, int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#getncpu",
              "documentation": {
                "identifier": "getncpu",
                "newPage": false,
                "searchKey": "runtime.getncpu",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getncpu() int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getncpu() int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#getPageSize",
              "documentation": {
                "identifier": "getPageSize",
                "newPage": false,
                "searchKey": "runtime.getPageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getPageSize() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getPageSize() uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#getRandomData",
              "documentation": {
                "identifier": "getRandomData",
                "newPage": false,
                "searchKey": "runtime.getRandomData",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getRandomData(r []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getRandomData(r []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goenvs",
              "documentation": {
                "identifier": "goenvs",
                "newPage": false,
                "searchKey": "runtime.goenvs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goenvs()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goenvs()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#newosproc",
              "documentation": {
                "identifier": "newosproc",
                "newPage": false,
                "searchKey": "runtime.newosproc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newosproc(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newosproc(mp *m)\n```\n\nMay run with m.p==nil, so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mstart_stub",
              "documentation": {
                "identifier": "mstart_stub",
                "newPage": false,
                "searchKey": "runtime.mstart_stub",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mstart_stub()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mstart_stub()\n```\n\nglue code to call mstart from pthread_create. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#newosproc0",
              "documentation": {
                "identifier": "newosproc0",
                "newPage": false,
                "searchKey": "runtime.newosproc0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newosproc0(stacksize uintptr, fn uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newosproc0(stacksize uintptr, fn uintptr)\n```\n\nnewosproc0 is a version of newosproc that can be called before the runtime is initialized. \n\nThis function is not safe to use after initialization as it does not pass an M as fnarg. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#libpreinit",
              "documentation": {
                "identifier": "libpreinit",
                "newPage": false,
                "searchKey": "runtime.libpreinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func libpreinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc libpreinit()\n```\n\nCalled to do synchronous initialization of Go code built with -buildmode=c-archive or -buildmode=c-shared. None of the Go runtime is initialized. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mpreinit",
              "documentation": {
                "identifier": "mpreinit",
                "newPage": false,
                "searchKey": "runtime.mpreinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mpreinit(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mpreinit(mp *m)\n```\n\nCalled to initialize a new m (including the bootstrap m). Called on the parent thread (main thread in case of bootstrap), can allocate memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minit",
              "documentation": {
                "identifier": "minit",
                "newPage": false,
                "searchKey": "runtime.minit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func minit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc minit()\n```\n\nCalled to initialize a new m (including the bootstrap m). Called on the new thread, cannot allocate memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unminit",
              "documentation": {
                "identifier": "unminit",
                "newPage": false,
                "searchKey": "runtime.unminit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unminit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unminit()\n```\n\nCalled from dropm to undo the effect of an minit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mdestroy",
              "documentation": {
                "identifier": "mdestroy",
                "newPage": false,
                "searchKey": "runtime.mdestroy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mdestroy(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mdestroy(mp *m)\n```\n\nCalled from exitm, but not from drop, to undo the effect of thread-owned resources in minit, semacreate, or elsewhere. Do not take locks after calling this. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#osyield_no_g",
              "documentation": {
                "identifier": "osyield_no_g",
                "newPage": false,
                "searchKey": "runtime.osyield_no_g",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func osyield_no_g()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc osyield_no_g()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#osyield",
              "documentation": {
                "identifier": "osyield",
                "newPage": false,
                "searchKey": "runtime.osyield",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func osyield()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc osyield()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setsig",
              "documentation": {
                "identifier": "setsig",
                "newPage": false,
                "searchKey": "runtime.setsig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setsig(i uint32, fn uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setsig(i uint32, fn uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigtramp",
              "documentation": {
                "identifier": "sigtramp",
                "newPage": false,
                "searchKey": "runtime.sigtramp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigtramp()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigtramp()\n```\n\nsigtramp is the callback from libc when a signal is received. It is called with the C calling convention. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoSigtramp",
              "documentation": {
                "identifier": "cgoSigtramp",
                "newPage": false,
                "searchKey": "runtime.cgoSigtramp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoSigtramp()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoSigtramp()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setsigstack",
              "documentation": {
                "identifier": "setsigstack",
                "newPage": false,
                "searchKey": "runtime.setsigstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setsigstack(i uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setsigstack(i uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#getsig",
              "documentation": {
                "identifier": "getsig",
                "newPage": false,
                "searchKey": "runtime.getsig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getsig(i uint32) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getsig(i uint32) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setSignalstackSP",
              "documentation": {
                "identifier": "setSignalstackSP",
                "newPage": false,
                "searchKey": "runtime.setSignalstackSP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setSignalstackSP(s *stackt, sp uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setSignalstackSP(s *stackt, sp uintptr)\n```\n\nsetSignaltstackSP sets the ss_sp field of a stackt. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigaddset",
              "documentation": {
                "identifier": "sigaddset",
                "newPage": false,
                "searchKey": "runtime.sigaddset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigaddset(mask *sigset, i int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigaddset(mask *sigset, i int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigdelset",
              "documentation": {
                "identifier": "sigdelset",
                "newPage": false,
                "searchKey": "runtime.sigdelset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigdelset(mask *sigset, i int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigdelset(mask *sigset, i int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysargs",
              "documentation": {
                "identifier": "sysargs",
                "newPage": false,
                "searchKey": "runtime.sysargs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysargs(argc int32, argv **byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysargs(argc int32, argv **byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#signalM",
              "documentation": {
                "identifier": "signalM",
                "newPage": false,
                "searchKey": "runtime.signalM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signalM(mp *m, sig int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signalM(mp *m, sig int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#osStackAlloc",
              "documentation": {
                "identifier": "osStackAlloc",
                "newPage": false,
                "searchKey": "runtime.osStackAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func osStackAlloc(s *mspan)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc osStackAlloc(s *mspan)\n```\n\nosStackAlloc performs OS-specific initialization before s is used as stack memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#osStackFree",
              "documentation": {
                "identifier": "osStackFree",
                "newPage": false,
                "searchKey": "runtime.osStackFree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func osStackFree(s *mspan)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc osStackFree(s *mspan)\n```\n\nosStackFree undoes the effect of osStackAlloc before s is returned to the heap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicCheck1",
              "documentation": {
                "identifier": "panicCheck1",
                "newPage": false,
                "searchKey": "runtime.panicCheck1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicCheck1(pc uintptr, msg string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicCheck1(pc uintptr, msg string)\n```\n\nCheck to make sure we can really generate a panic. If the panic was generated from the runtime, or from inside malloc, then convert to a throw of msg. pc should be the program counter of the compiler-generated code that triggered this panic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicCheck2",
              "documentation": {
                "identifier": "panicCheck2",
                "newPage": false,
                "searchKey": "runtime.panicCheck2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicCheck2(err string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicCheck2(err string)\n```\n\nSame as above, but calling from the runtime is allowed. \n\nUsing this function is necessary for any panic that may be generated by runtime.sigpanic, since those are always called by the runtime. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicIndex",
              "documentation": {
                "identifier": "goPanicIndex",
                "newPage": false,
                "searchKey": "runtime.goPanicIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicIndex(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicIndex(x int, y int)\n```\n\nfailures in the comparisons for s[x], 0 <= x < y (y == len(s)) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicIndexU",
              "documentation": {
                "identifier": "goPanicIndexU",
                "newPage": false,
                "searchKey": "runtime.goPanicIndexU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicIndexU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicIndexU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSliceAlen",
              "documentation": {
                "identifier": "goPanicSliceAlen",
                "newPage": false,
                "searchKey": "runtime.goPanicSliceAlen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSliceAlen(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSliceAlen(x int, y int)\n```\n\nfailures in the comparisons for s[:x], 0 <= x <= y (y == len(s) or cap(s)) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSliceAlenU",
              "documentation": {
                "identifier": "goPanicSliceAlenU",
                "newPage": false,
                "searchKey": "runtime.goPanicSliceAlenU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSliceAlenU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSliceAlenU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSliceAcap",
              "documentation": {
                "identifier": "goPanicSliceAcap",
                "newPage": false,
                "searchKey": "runtime.goPanicSliceAcap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSliceAcap(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSliceAcap(x int, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSliceAcapU",
              "documentation": {
                "identifier": "goPanicSliceAcapU",
                "newPage": false,
                "searchKey": "runtime.goPanicSliceAcapU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSliceAcapU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSliceAcapU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSliceB",
              "documentation": {
                "identifier": "goPanicSliceB",
                "newPage": false,
                "searchKey": "runtime.goPanicSliceB",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSliceB(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSliceB(x int, y int)\n```\n\nfailures in the comparisons for s[x:y], 0 <= x <= y \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSliceBU",
              "documentation": {
                "identifier": "goPanicSliceBU",
                "newPage": false,
                "searchKey": "runtime.goPanicSliceBU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSliceBU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSliceBU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSlice3Alen",
              "documentation": {
                "identifier": "goPanicSlice3Alen",
                "newPage": false,
                "searchKey": "runtime.goPanicSlice3Alen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSlice3Alen(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSlice3Alen(x int, y int)\n```\n\nfailures in the comparisons for s[::x], 0 <= x <= y (y == len(s) or cap(s)) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSlice3AlenU",
              "documentation": {
                "identifier": "goPanicSlice3AlenU",
                "newPage": false,
                "searchKey": "runtime.goPanicSlice3AlenU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSlice3AlenU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSlice3AlenU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSlice3Acap",
              "documentation": {
                "identifier": "goPanicSlice3Acap",
                "newPage": false,
                "searchKey": "runtime.goPanicSlice3Acap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSlice3Acap(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSlice3Acap(x int, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSlice3AcapU",
              "documentation": {
                "identifier": "goPanicSlice3AcapU",
                "newPage": false,
                "searchKey": "runtime.goPanicSlice3AcapU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSlice3AcapU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSlice3AcapU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSlice3B",
              "documentation": {
                "identifier": "goPanicSlice3B",
                "newPage": false,
                "searchKey": "runtime.goPanicSlice3B",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSlice3B(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSlice3B(x int, y int)\n```\n\nfailures in the comparisons for s[:x:y], 0 <= x <= y \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSlice3BU",
              "documentation": {
                "identifier": "goPanicSlice3BU",
                "newPage": false,
                "searchKey": "runtime.goPanicSlice3BU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSlice3BU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSlice3BU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSlice3C",
              "documentation": {
                "identifier": "goPanicSlice3C",
                "newPage": false,
                "searchKey": "runtime.goPanicSlice3C",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSlice3C(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSlice3C(x int, y int)\n```\n\nfailures in the comparisons for s[x:y:], 0 <= x <= y \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSlice3CU",
              "documentation": {
                "identifier": "goPanicSlice3CU",
                "newPage": false,
                "searchKey": "runtime.goPanicSlice3CU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSlice3CU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSlice3CU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goPanicSliceConvert",
              "documentation": {
                "identifier": "goPanicSliceConvert",
                "newPage": false,
                "searchKey": "runtime.goPanicSliceConvert",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goPanicSliceConvert(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goPanicSliceConvert(x int, y int)\n```\n\nfailures in the conversion (*[x]T)s, 0 <= x <= y, x == cap(s) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicIndex",
              "documentation": {
                "identifier": "panicIndex",
                "newPage": false,
                "searchKey": "runtime.panicIndex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicIndex(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicIndex(x int, y int)\n```\n\nImplemented in assembly, as they take arguments in registers. Declared here to mark them as ABIInternal. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicIndexU",
              "documentation": {
                "identifier": "panicIndexU",
                "newPage": false,
                "searchKey": "runtime.panicIndexU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicIndexU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicIndexU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSliceAlen",
              "documentation": {
                "identifier": "panicSliceAlen",
                "newPage": false,
                "searchKey": "runtime.panicSliceAlen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSliceAlen(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSliceAlen(x int, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSliceAlenU",
              "documentation": {
                "identifier": "panicSliceAlenU",
                "newPage": false,
                "searchKey": "runtime.panicSliceAlenU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSliceAlenU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSliceAlenU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSliceAcap",
              "documentation": {
                "identifier": "panicSliceAcap",
                "newPage": false,
                "searchKey": "runtime.panicSliceAcap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSliceAcap(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSliceAcap(x int, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSliceAcapU",
              "documentation": {
                "identifier": "panicSliceAcapU",
                "newPage": false,
                "searchKey": "runtime.panicSliceAcapU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSliceAcapU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSliceAcapU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSliceB",
              "documentation": {
                "identifier": "panicSliceB",
                "newPage": false,
                "searchKey": "runtime.panicSliceB",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSliceB(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSliceB(x int, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSliceBU",
              "documentation": {
                "identifier": "panicSliceBU",
                "newPage": false,
                "searchKey": "runtime.panicSliceBU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSliceBU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSliceBU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSlice3Alen",
              "documentation": {
                "identifier": "panicSlice3Alen",
                "newPage": false,
                "searchKey": "runtime.panicSlice3Alen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSlice3Alen(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSlice3Alen(x int, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSlice3AlenU",
              "documentation": {
                "identifier": "panicSlice3AlenU",
                "newPage": false,
                "searchKey": "runtime.panicSlice3AlenU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSlice3AlenU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSlice3AlenU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSlice3Acap",
              "documentation": {
                "identifier": "panicSlice3Acap",
                "newPage": false,
                "searchKey": "runtime.panicSlice3Acap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSlice3Acap(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSlice3Acap(x int, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSlice3AcapU",
              "documentation": {
                "identifier": "panicSlice3AcapU",
                "newPage": false,
                "searchKey": "runtime.panicSlice3AcapU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSlice3AcapU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSlice3AcapU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSlice3B",
              "documentation": {
                "identifier": "panicSlice3B",
                "newPage": false,
                "searchKey": "runtime.panicSlice3B",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSlice3B(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSlice3B(x int, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSlice3BU",
              "documentation": {
                "identifier": "panicSlice3BU",
                "newPage": false,
                "searchKey": "runtime.panicSlice3BU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSlice3BU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSlice3BU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSlice3C",
              "documentation": {
                "identifier": "panicSlice3C",
                "newPage": false,
                "searchKey": "runtime.panicSlice3C",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSlice3C(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSlice3C(x int, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSlice3CU",
              "documentation": {
                "identifier": "panicSlice3CU",
                "newPage": false,
                "searchKey": "runtime.panicSlice3CU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSlice3CU(x uint, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSlice3CU(x uint, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicSliceConvert",
              "documentation": {
                "identifier": "panicSliceConvert",
                "newPage": false,
                "searchKey": "runtime.panicSliceConvert",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicSliceConvert(x int, y int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicSliceConvert(x int, y int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicshift",
              "documentation": {
                "identifier": "panicshift",
                "newPage": false,
                "searchKey": "runtime.panicshift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicshift()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicshift()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicdivide",
              "documentation": {
                "identifier": "panicdivide",
                "newPage": false,
                "searchKey": "runtime.panicdivide",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicdivide()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicdivide()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicoverflow",
              "documentation": {
                "identifier": "panicoverflow",
                "newPage": false,
                "searchKey": "runtime.panicoverflow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicoverflow()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicoverflow()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicfloat",
              "documentation": {
                "identifier": "panicfloat",
                "newPage": false,
                "searchKey": "runtime.panicfloat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicfloat()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicfloat()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicmem",
              "documentation": {
                "identifier": "panicmem",
                "newPage": false,
                "searchKey": "runtime.panicmem",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicmem()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicmem()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicmemAddr",
              "documentation": {
                "identifier": "panicmemAddr",
                "newPage": false,
                "searchKey": "runtime.panicmemAddr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicmemAddr(addr uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicmemAddr(addr uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deferproc",
              "documentation": {
                "identifier": "deferproc",
                "newPage": false,
                "searchKey": "runtime.deferproc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func deferproc(siz int32, fn *funcval)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc deferproc(siz int32, fn *funcval)\n```\n\nCreate a new deferred function fn with siz bytes of arguments. The compiler turns a defer statement into a call to this. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deferprocStack",
              "documentation": {
                "identifier": "deferprocStack",
                "newPage": false,
                "searchKey": "runtime.deferprocStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func deferprocStack(d *_defer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc deferprocStack(d *_defer)\n```\n\ndeferprocStack queues a new deferred function with a defer record on the stack. The defer record must have its siz and fn fields initialized. All other fields can contain junk. The defer record must be immediately followed in memory by the arguments of the defer. Nosplit because the arguments on the stack won't be scanned until the defer record is spliced into the gp._defer list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deferclass",
              "documentation": {
                "identifier": "deferclass",
                "newPage": false,
                "searchKey": "runtime.deferclass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func deferclass(siz uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc deferclass(siz uintptr) uintptr\n```\n\ndefer size class for arg size sz \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#totaldefersize",
              "documentation": {
                "identifier": "totaldefersize",
                "newPage": false,
                "searchKey": "runtime.totaldefersize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func totaldefersize(siz uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc totaldefersize(siz uintptr) uintptr\n```\n\ntotal size of memory block for defer with arg size sz \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#testdefersizes",
              "documentation": {
                "identifier": "testdefersizes",
                "newPage": false,
                "searchKey": "runtime.testdefersizes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testdefersizes()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testdefersizes()\n```\n\nEnsure that defer arg sizes that map to the same defer size class also map to the same malloc size class. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deferArgs",
              "documentation": {
                "identifier": "deferArgs",
                "newPage": false,
                "searchKey": "runtime.deferArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func deferArgs(d *_defer) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc deferArgs(d *_defer) unsafe.Pointer\n```\n\nThe arguments associated with a deferred call are stored immediately after the _defer header in memory. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deferFunc",
              "documentation": {
                "identifier": "deferFunc",
                "newPage": false,
                "searchKey": "runtime.deferFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func deferFunc(d *_defer) func()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc deferFunc(d *_defer) func()\n```\n\ndeferFunc returns d's deferred function. This is temporary while we support both modes of GOEXPERIMENT=regabidefer. Once we commit to that experiment, we should change the type of d.fn. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "runtime.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freedefer",
              "documentation": {
                "identifier": "freedefer",
                "newPage": false,
                "searchKey": "runtime.freedefer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func freedefer(d *_defer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc freedefer(d *_defer)\n```\n\nFree the given defer. The defer cannot be used after this call. \n\nThis must not grow the stack because there may be a frame without a stack map when this is called. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freedeferpanic",
              "documentation": {
                "identifier": "freedeferpanic",
                "newPage": false,
                "searchKey": "runtime.freedeferpanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func freedeferpanic()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc freedeferpanic()\n```\n\nSeparate function so that it can split stack. Windows otherwise runs out of stack space. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freedeferfn",
              "documentation": {
                "identifier": "freedeferfn",
                "newPage": false,
                "searchKey": "runtime.freedeferfn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func freedeferfn()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc freedeferfn()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deferreturn",
              "documentation": {
                "identifier": "deferreturn",
                "newPage": false,
                "searchKey": "runtime.deferreturn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func deferreturn()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc deferreturn()\n```\n\nRun a deferred function if there is one. The compiler inserts a call to this at the end of any function which calls defer. If there is a deferred function, this will call runtime·jmpdefer, which will jump to the deferred function such that it appears to have been called by the caller of deferreturn at the point just before deferreturn was called. The effect is that deferreturn is called again and again until there are no more deferred functions. \n\nDeclared as nosplit, because the function should not be preempted once we start modifying the caller's frame in order to reuse the frame to call the deferred function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Goexit",
              "documentation": {
                "identifier": "Goexit",
                "newPage": false,
                "searchKey": "runtime.Goexit",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Goexit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Goexit()\n```\n\nGoexit terminates the goroutine that calls it. No other goroutine is affected. Goexit runs all deferred calls before terminating the goroutine. Because Goexit is not a panic, any recover calls in those deferred functions will return nil. \n\nCalling Goexit from the main goroutine terminates that goroutine without func main returning. Since func main has not returned, the program continues execution of other goroutines. If all other goroutines exit, the program crashes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#preprintpanics",
              "documentation": {
                "identifier": "preprintpanics",
                "newPage": false,
                "searchKey": "runtime.preprintpanics",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func preprintpanics(p *_panic)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc preprintpanics(p *_panic)\n```\n\nCall all Error and String methods before freezing the world. Used when crashing with panicking. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printpanics",
              "documentation": {
                "identifier": "printpanics",
                "newPage": false,
                "searchKey": "runtime.printpanics",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printpanics(p *_panic)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printpanics(p *_panic)\n```\n\nPrint all currently active panics. Used when crashing. Should only be called after preprintpanics. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#addOneOpenDeferFrame",
              "documentation": {
                "identifier": "addOneOpenDeferFrame",
                "newPage": false,
                "searchKey": "runtime.addOneOpenDeferFrame",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addOneOpenDeferFrame(gp *g, pc uintptr, sp unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addOneOpenDeferFrame(gp *g, pc uintptr, sp unsafe.Pointer)\n```\n\naddOneOpenDeferFrame scans the stack for the first frame (if any) with open-coded defers and if it finds one, adds a single record to the defer chain for that frame. If sp is non-nil, it starts the stack scan from the frame specified by sp. If sp is nil, it uses the sp from the current defer record (which has just been finished). Hence, it continues the stack scan from the frame of the defer that just finished. It skips any frame that already has an open-coded _defer record, which would have been created from a previous (unrecovered) panic. \n\nNote: All entries of the defer chain (including this new open-coded entry) have their pointers (including sp) adjusted properly if the stack moves while running deferred functions. Also, it is safe to pass in the sp arg (which is the direct result of calling getcallersp()), because all pointer variables (including arguments) are adjusted as needed during stack copies. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readvarintUnsafe",
              "documentation": {
                "identifier": "readvarintUnsafe",
                "newPage": false,
                "searchKey": "runtime.readvarintUnsafe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readvarintUnsafe(fd unsafe.Pointer) (uint32, unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readvarintUnsafe(fd unsafe.Pointer) (uint32, unsafe.Pointer)\n```\n\nreadvarintUnsafe reads the uint32 in varint format starting at fd, and returns the uint32 and a pointer to the byte following the varint. \n\nThere is a similar function runtime.readvarint, which takes a slice of bytes, rather than an unsafe pointer. These functions are duplicated, because one of the two use cases for the functions would get slower if the functions were combined. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runOpenDeferFrame",
              "documentation": {
                "identifier": "runOpenDeferFrame",
                "newPage": false,
                "searchKey": "runtime.runOpenDeferFrame",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runOpenDeferFrame(gp *g, d *_defer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runOpenDeferFrame(gp *g, d *_defer) bool\n```\n\nrunOpenDeferFrame runs the active open-coded defers in the frame specified by d. It normally processes all active defers in the frame, but stops immediately if a defer does a successful recover. It returns true if there are no remaining defers to run in the frame. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectcallSave",
              "documentation": {
                "identifier": "reflectcallSave",
                "newPage": false,
                "searchKey": "runtime.reflectcallSave",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectcallSave(p *_panic, fn, arg unsafe.Pointer, argsize uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectcallSave(p *_panic, fn, arg unsafe.Pointer, argsize uint32)\n```\n\nreflectcallSave calls reflectcall after saving the caller's pc and sp in the panic record. This allows the runtime to return to the Goexit defer processing loop, in the unusual case where the Goexit may be bypassed by a successful recover. \n\nThis is marked as a wrapper by the compiler so it doesn't appear in tracebacks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deferCallSave",
              "documentation": {
                "identifier": "deferCallSave",
                "newPage": false,
                "searchKey": "runtime.deferCallSave",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func deferCallSave(p *_panic, fn func())"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc deferCallSave(p *_panic, fn func())\n```\n\ndeferCallSave calls fn() after saving the caller's pc and sp in the panic record. This allows the runtime to return to the Goexit defer processing loop, in the unusual case where the Goexit may be bypassed by a successful recover. \n\nThis is marked as a wrapper by the compiler so it doesn't appear in tracebacks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gopanic",
              "documentation": {
                "identifier": "gopanic",
                "newPage": false,
                "searchKey": "runtime.gopanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gopanic(e interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gopanic(e interface{})\n```\n\nThe implementation of the predeclared function panic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#getargp",
              "documentation": {
                "identifier": "getargp",
                "newPage": false,
                "searchKey": "runtime.getargp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getargp() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getargp() uintptr\n```\n\ngetargp returns the location where the caller writes outgoing function call arguments. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gorecover",
              "documentation": {
                "identifier": "gorecover",
                "newPage": false,
                "searchKey": "runtime.gorecover",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gorecover(argp uintptr) interface{}"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gorecover(argp uintptr) interface{}\n```\n\nThe implementation of the predeclared function recover. Cannot split the stack because it needs to reliably find the stack segment of its caller. \n\nTODO(rsc): Once we commit to CopyStackAlways, this doesn't need to be nosplit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_throw",
              "documentation": {
                "identifier": "sync_throw",
                "newPage": false,
                "searchKey": "runtime.sync_throw",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_throw(s string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_throw(s string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#throw",
              "documentation": {
                "identifier": "throw",
                "newPage": false,
                "searchKey": "runtime.throw",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func throw(s string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc throw(s string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#recovery",
              "documentation": {
                "identifier": "recovery",
                "newPage": false,
                "searchKey": "runtime.recovery",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func recovery(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc recovery(gp *g)\n```\n\nUnwind the stack after a deferred function calls recover after a panic. Then arrange to continue running as though the caller of the deferred function returned normally. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fatalthrow",
              "documentation": {
                "identifier": "fatalthrow",
                "newPage": false,
                "searchKey": "runtime.fatalthrow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fatalthrow()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fatalthrow()\n```\n\nfatalthrow implements an unrecoverable runtime throw. It freezes the system, prints stack traces starting from its caller, and terminates the process. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fatalpanic",
              "documentation": {
                "identifier": "fatalpanic",
                "newPage": false,
                "searchKey": "runtime.fatalpanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fatalpanic(msgs *_panic)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fatalpanic(msgs *_panic)\n```\n\nfatalpanic implements an unrecoverable panic. It is like fatalthrow, except that if msgs != nil, fatalpanic also prints panic messages and decrements runningPanicDefers once main is blocked from exiting. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#startpanic_m",
              "documentation": {
                "identifier": "startpanic_m",
                "newPage": false,
                "searchKey": "runtime.startpanic_m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func startpanic_m() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc startpanic_m() bool\n```\n\nstartpanic_m prepares for an unrecoverable panic. \n\nIt returns true if panic messages should be printed, or false if the runtime is in bad shape and should just print stacks. \n\nIt must not have write barriers even though the write barrier explicitly ignores writes once dying > 0. Write barriers still assume that g.m.p != nil, and this function may not have P in some contexts (e.g. a panic in a signal handler for a signal sent to an M with no P). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dopanic_m",
              "documentation": {
                "identifier": "dopanic_m",
                "newPage": false,
                "searchKey": "runtime.dopanic_m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dopanic_m(gp *g, pc, sp uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dopanic_m(gp *g, pc, sp uintptr) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#canpanic",
              "documentation": {
                "identifier": "canpanic",
                "newPage": false,
                "searchKey": "runtime.canpanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func canpanic(gp *g) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc canpanic(gp *g) bool\n```\n\ncanpanic returns false if a signal should throw instead of panicking. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#shouldPushSigpanic",
              "documentation": {
                "identifier": "shouldPushSigpanic",
                "newPage": false,
                "searchKey": "runtime.shouldPushSigpanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func shouldPushSigpanic(gp *g, pc, lr uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc shouldPushSigpanic(gp *g, pc, lr uintptr) bool\n```\n\nshouldPushSigpanic reports whether pc should be used as sigpanic's return PC (pushing a frame for the call). Otherwise, it should be left alone so that LR is used as sigpanic's return PC, effectively replacing the top-most frame with sigpanic. This is used by preparePanic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isAbortPC",
              "documentation": {
                "identifier": "isAbortPC",
                "newPage": false,
                "searchKey": "runtime.isAbortPC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isAbortPC(pc uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isAbortPC(pc uintptr) bool\n```\n\nisAbortPC reports whether pc is the program counter at which runtime.abort raises a signal. \n\nIt is nosplit because it's part of the isgoexception implementation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#plugin_lastmoduleinit",
              "documentation": {
                "identifier": "plugin_lastmoduleinit",
                "newPage": false,
                "searchKey": "runtime.plugin_lastmoduleinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func plugin_lastmoduleinit() (path string, syms map[string]interface{}, errstr string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc plugin_lastmoduleinit() (path string, syms map[string]interface{}, errstr string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pluginftabverify",
              "documentation": {
                "identifier": "pluginftabverify",
                "newPage": false,
                "searchKey": "runtime.pluginftabverify",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pluginftabverify(md *moduledata)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pluginftabverify(md *moduledata)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inRange",
              "documentation": {
                "identifier": "inRange",
                "newPage": false,
                "searchKey": "runtime.inRange",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func inRange(r0, r1, v0, v1 uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc inRange(r0, r1, v0, v1 uintptr) bool\n```\n\ninRange reports whether v0 or v1 are in the range [r0, r1]. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#resumeG",
              "documentation": {
                "identifier": "resumeG",
                "newPage": false,
                "searchKey": "runtime.resumeG",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func resumeG(state suspendGState)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resumeG(state suspendGState)\n```\n\nresumeG undoes the effects of suspendG, allowing the suspended goroutine to continue from its current safe-point. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#canPreemptM",
              "documentation": {
                "identifier": "canPreemptM",
                "newPage": false,
                "searchKey": "runtime.canPreemptM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func canPreemptM(mp *m) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc canPreemptM(mp *m) bool\n```\n\ncanPreemptM reports whether mp is in a state that is safe to preempt. \n\nIt is nosplit because it has nosplit callers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#asyncPreempt",
              "documentation": {
                "identifier": "asyncPreempt",
                "newPage": false,
                "searchKey": "runtime.asyncPreempt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func asyncPreempt()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc asyncPreempt()\n```\n\nasyncPreempt saves all user registers and calls asyncPreempt2. \n\nWhen stack scanning encounters an asyncPreempt frame, it scans that frame and its parent frame conservatively. \n\nasyncPreempt is implemented in assembly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#asyncPreempt2",
              "documentation": {
                "identifier": "asyncPreempt2",
                "newPage": false,
                "searchKey": "runtime.asyncPreempt2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func asyncPreempt2()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc asyncPreempt2()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "runtime.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#wantAsyncPreempt",
              "documentation": {
                "identifier": "wantAsyncPreempt",
                "newPage": false,
                "searchKey": "runtime.wantAsyncPreempt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func wantAsyncPreempt(gp *g) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc wantAsyncPreempt(gp *g) bool\n```\n\nwantAsyncPreempt returns whether an asynchronous preemption is queued for gp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isAsyncSafePoint",
              "documentation": {
                "identifier": "isAsyncSafePoint",
                "newPage": false,
                "searchKey": "runtime.isAsyncSafePoint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isAsyncSafePoint(gp *g, pc, sp, lr uintptr) (bool, uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isAsyncSafePoint(gp *g, pc, sp, lr uintptr) (bool, uintptr)\n```\n\nisAsyncSafePoint reports whether gp at instruction PC is an asynchronous safe point. This indicates that: \n\n1. It's safe to suspend gp and conservatively scan its stack and registers. There are no potentially hidden pointer values and it's not in the middle of an atomic sequence like a write barrier. \n\n2. gp has enough stack space to inject the asyncPreempt call. \n\n3. It's generally safe to interact with the runtime, even if we're in a signal handler stopped here. For example, there are no runtime locks held, so acquiring a runtime lock won't self-deadlock. \n\nIn some cases the PC is safe for asynchronous preemption but it also needs to adjust the resumption PC. The new PC is returned in the second result. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#osPreemptExtEnter",
              "documentation": {
                "identifier": "osPreemptExtEnter",
                "newPage": false,
                "searchKey": "runtime.osPreemptExtEnter",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func osPreemptExtEnter(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc osPreemptExtEnter(mp *m)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#osPreemptExtExit",
              "documentation": {
                "identifier": "osPreemptExtExit",
                "newPage": false,
                "searchKey": "runtime.osPreemptExtExit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func osPreemptExtExit(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc osPreemptExtExit(mp *m)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bytes",
              "documentation": {
                "identifier": "bytes",
                "newPage": false,
                "searchKey": "runtime.bytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bytes(s string) (ret []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bytes(s string) (ret []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#recordForPanic",
              "documentation": {
                "identifier": "recordForPanic",
                "newPage": false,
                "searchKey": "runtime.recordForPanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func recordForPanic(b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc recordForPanic(b []byte)\n```\n\nrecordForPanic maintains a circular buffer of messages written by the runtime leading up to a process crash, allowing the messages to be extracted from a core dump. \n\nThe text written during a process crash (following \"panic\" or \"fatal error\") is not saved, since the goroutine stacks will generally be readable from the runtime datastructures in the core file. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printlock",
              "documentation": {
                "identifier": "printlock",
                "newPage": false,
                "searchKey": "runtime.printlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printlock()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printlock()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printunlock",
              "documentation": {
                "identifier": "printunlock",
                "newPage": false,
                "searchKey": "runtime.printunlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printunlock()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printunlock()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gwrite",
              "documentation": {
                "identifier": "gwrite",
                "newPage": false,
                "searchKey": "runtime.gwrite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gwrite(b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gwrite(b []byte)\n```\n\nwrite to goroutine-local buffer if diverting output, or else standard error. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printsp",
              "documentation": {
                "identifier": "printsp",
                "newPage": false,
                "searchKey": "runtime.printsp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printsp()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printsp()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printnl",
              "documentation": {
                "identifier": "printnl",
                "newPage": false,
                "searchKey": "runtime.printnl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printnl()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printnl()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printbool",
              "documentation": {
                "identifier": "printbool",
                "newPage": false,
                "searchKey": "runtime.printbool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printbool(v bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printbool(v bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printfloat",
              "documentation": {
                "identifier": "printfloat",
                "newPage": false,
                "searchKey": "runtime.printfloat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printfloat(v float64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printfloat(v float64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printcomplex",
              "documentation": {
                "identifier": "printcomplex",
                "newPage": false,
                "searchKey": "runtime.printcomplex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printcomplex(c complex128)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printcomplex(c complex128)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printuint",
              "documentation": {
                "identifier": "printuint",
                "newPage": false,
                "searchKey": "runtime.printuint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printuint(v uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printuint(v uint64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printint",
              "documentation": {
                "identifier": "printint",
                "newPage": false,
                "searchKey": "runtime.printint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printint(v int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printint(v int64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printhex",
              "documentation": {
                "identifier": "printhex",
                "newPage": false,
                "searchKey": "runtime.printhex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printhex(v uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printhex(v uint64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printpointer",
              "documentation": {
                "identifier": "printpointer",
                "newPage": false,
                "searchKey": "runtime.printpointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printpointer(p unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printpointer(p unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printuintptr",
              "documentation": {
                "identifier": "printuintptr",
                "newPage": false,
                "searchKey": "runtime.printuintptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printuintptr(p uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printuintptr(p uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printstring",
              "documentation": {
                "identifier": "printstring",
                "newPage": false,
                "searchKey": "runtime.printstring",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printstring(s string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printstring(s string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printslice",
              "documentation": {
                "identifier": "printslice",
                "newPage": false,
                "searchKey": "runtime.printslice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printslice(s []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printslice(s []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printeface",
              "documentation": {
                "identifier": "printeface",
                "newPage": false,
                "searchKey": "runtime.printeface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printeface(e eface)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printeface(e eface)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printiface",
              "documentation": {
                "identifier": "printiface",
                "newPage": false,
                "searchKey": "runtime.printiface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printiface(i iface)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printiface(i iface)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hexdumpWords",
              "documentation": {
                "identifier": "hexdumpWords",
                "newPage": false,
                "searchKey": "runtime.hexdumpWords",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hexdumpWords(p, end uintptr, mark func(uintptr) byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hexdumpWords(p, end uintptr, mark func(uintptr) byte)\n```\n\nhexdumpWords prints a word-oriented hex dump of [p, end). \n\nIf mark != nil, it will be called with each printed word's address and should return a character mark to appear just before that word's value. It can return 0 to indicate no mark. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#main_main",
              "documentation": {
                "identifier": "main_main",
                "newPage": false,
                "searchKey": "runtime.main_main",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func main_main()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc main_main()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#main",
              "documentation": {
                "identifier": "main",
                "newPage": false,
                "searchKey": "runtime.main",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func main()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc main()\n```\n\nThe main goroutine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#os_beforeExit",
              "documentation": {
                "identifier": "os_beforeExit",
                "newPage": false,
                "searchKey": "runtime.os_beforeExit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func os_beforeExit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc os_beforeExit()\n```\n\nos_beforeExit is called from os.Exit(0). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "runtime.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\nstart forcegc helper goroutine \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#forcegchelper",
              "documentation": {
                "identifier": "forcegchelper",
                "newPage": false,
                "searchKey": "runtime.forcegchelper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func forcegchelper()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc forcegchelper()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Gosched",
              "documentation": {
                "identifier": "Gosched",
                "newPage": false,
                "searchKey": "runtime.Gosched",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Gosched()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Gosched()\n```\n\nGosched yields the processor, allowing other goroutines to run. It does not suspend the current goroutine, so execution resumes automatically. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goschedguarded",
              "documentation": {
                "identifier": "goschedguarded",
                "newPage": false,
                "searchKey": "runtime.goschedguarded",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goschedguarded()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goschedguarded()\n```\n\ngoschedguarded yields the processor like gosched, but also checks for forbidden states and opts out of the yield in those cases. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gopark",
              "documentation": {
                "identifier": "gopark",
                "newPage": false,
                "searchKey": "runtime.gopark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int)\n```\n\nPuts the current goroutine into a waiting state and calls unlockf on the system stack. \n\nIf unlockf returns false, the goroutine is resumed. \n\nunlockf must not access this G's stack, as it may be moved between the call to gopark and the call to unlockf. \n\nNote that because unlockf is called after putting the G into a waiting state, the G may have already been readied by the time unlockf is called unless there is external synchronization preventing the G from being readied. If unlockf returns false, it must guarantee that the G cannot be externally readied. \n\nReason explains why the goroutine has been parked. It is displayed in stack traces and heap dumps. Reasons should be unique and descriptive. Do not re-use reasons, add new ones. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goparkunlock",
              "documentation": {
                "identifier": "goparkunlock",
                "newPage": false,
                "searchKey": "runtime.goparkunlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goparkunlock(lock *mutex, reason waitReason, traceEv byte, traceskip int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goparkunlock(lock *mutex, reason waitReason, traceEv byte, traceskip int)\n```\n\nPuts the current goroutine into a waiting state and unlocks the lock. The goroutine can be made runnable again by calling goready(gp). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goready",
              "documentation": {
                "identifier": "goready",
                "newPage": false,
                "searchKey": "runtime.goready",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goready(gp *g, traceskip int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goready(gp *g, traceskip int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#releaseSudog",
              "documentation": {
                "identifier": "releaseSudog",
                "newPage": false,
                "searchKey": "runtime.releaseSudog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func releaseSudog(s *sudog)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc releaseSudog(s *sudog)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcPC",
              "documentation": {
                "identifier": "funcPC",
                "newPage": false,
                "searchKey": "runtime.funcPC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcPC(f interface{}) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcPC(f interface{}) uintptr\n```\n\nfuncPC returns the entry PC of the function f. It assumes that f is a func value. Otherwise the behavior is undefined. CAREFUL: In programs with plugins, funcPC can return different values for the same function (because there are actually multiple copies of the same function in the address space). To be safe, don't use the results of this function in any == expression. It is only safe to use the result as an address at which to start executing code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badmcall",
              "documentation": {
                "identifier": "badmcall",
                "newPage": false,
                "searchKey": "runtime.badmcall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badmcall(fn func(*g))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badmcall(fn func(*g))\n```\n\ncalled from assembly \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badmcall2",
              "documentation": {
                "identifier": "badmcall2",
                "newPage": false,
                "searchKey": "runtime.badmcall2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badmcall2(fn func(*g))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badmcall2(fn func(*g))\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badreflectcall",
              "documentation": {
                "identifier": "badreflectcall",
                "newPage": false,
                "searchKey": "runtime.badreflectcall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badreflectcall()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badreflectcall()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badmorestackg0",
              "documentation": {
                "identifier": "badmorestackg0",
                "newPage": false,
                "searchKey": "runtime.badmorestackg0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badmorestackg0()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badmorestackg0()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badmorestackgsignal",
              "documentation": {
                "identifier": "badmorestackgsignal",
                "newPage": false,
                "searchKey": "runtime.badmorestackgsignal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badmorestackgsignal()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badmorestackgsignal()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badctxt",
              "documentation": {
                "identifier": "badctxt",
                "newPage": false,
                "searchKey": "runtime.badctxt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badctxt()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badctxt()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockedOSThread",
              "documentation": {
                "identifier": "lockedOSThread",
                "newPage": false,
                "searchKey": "runtime.lockedOSThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lockedOSThread() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lockedOSThread() bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#allgadd",
              "documentation": {
                "identifier": "allgadd",
                "newPage": false,
                "searchKey": "runtime.allgadd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func allgadd(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc allgadd(gp *g)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#forEachG",
              "documentation": {
                "identifier": "forEachG",
                "newPage": false,
                "searchKey": "runtime.forEachG",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func forEachG(fn func(gp *g))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc forEachG(fn func(gp *g))\n```\n\nforEachG calls fn on every G from allgs. \n\nforEachG takes a lock to exclude concurrent addition of new Gs. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#forEachGRace",
              "documentation": {
                "identifier": "forEachGRace",
                "newPage": false,
                "searchKey": "runtime.forEachGRace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func forEachGRace(fn func(gp *g))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc forEachGRace(fn func(gp *g))\n```\n\nforEachGRace calls fn on every G from allgs. \n\nforEachGRace avoids locking, but does not exclude addition of new Gs during execution, which may be missed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cpuinit",
              "documentation": {
                "identifier": "cpuinit",
                "newPage": false,
                "searchKey": "runtime.cpuinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cpuinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cpuinit()\n```\n\ncpuinit extracts the environment variable GODEBUG from the environment on Unix-like operating systems and calls internal/cpu.Initialize. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#schedinit",
              "documentation": {
                "identifier": "schedinit",
                "newPage": false,
                "searchKey": "runtime.schedinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func schedinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc schedinit()\n```\n\nThe bootstrap sequence is: \n\n```\ncall osinit\ncall schedinit\nmake & queue new G\ncall runtime·mstart\n\n```\nThe new G calls runtime·main. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpgstatus",
              "documentation": {
                "identifier": "dumpgstatus",
                "newPage": false,
                "searchKey": "runtime.dumpgstatus",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpgstatus(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpgstatus(gp *g)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#checkmcount",
              "documentation": {
                "identifier": "checkmcount",
                "newPage": false,
                "searchKey": "runtime.checkmcount",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkmcount()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkmcount()\n```\n\nsched.lock must be held. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mReserveID",
              "documentation": {
                "identifier": "mReserveID",
                "newPage": false,
                "searchKey": "runtime.mReserveID",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mReserveID() int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mReserveID() int64\n```\n\nmReserveID returns the next ID to use for a new m. This new m is immediately considered 'running' by checkdead. \n\nsched.lock must be held. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mcommoninit",
              "documentation": {
                "identifier": "mcommoninit",
                "newPage": false,
                "searchKey": "runtime.mcommoninit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mcommoninit(mp *m, id int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mcommoninit(mp *m, id int64)\n```\n\nPre-allocated ID may be passed as 'id', or omitted by passing -1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fastrandinit",
              "documentation": {
                "identifier": "fastrandinit",
                "newPage": false,
                "searchKey": "runtime.fastrandinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fastrandinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fastrandinit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ready",
              "documentation": {
                "identifier": "ready",
                "newPage": false,
                "searchKey": "runtime.ready",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ready(gp *g, traceskip int, next bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ready(gp *g, traceskip int, next bool)\n```\n\nMark gp ready to run. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freezetheworld",
              "documentation": {
                "identifier": "freezetheworld",
                "newPage": false,
                "searchKey": "runtime.freezetheworld",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func freezetheworld()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc freezetheworld()\n```\n\nSimilar to stopTheWorld but best-effort and can be called several times. There is no reverse operation, used during crashing. This function must not lock any mutexes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readgstatus",
              "documentation": {
                "identifier": "readgstatus",
                "newPage": false,
                "searchKey": "runtime.readgstatus",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readgstatus(gp *g) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readgstatus(gp *g) uint32\n```\n\nAll reads and writes of g's status go through readgstatus, casgstatus castogscanstatus, casfrom_Gscanstatus. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#casfrom_Gscanstatus",
              "documentation": {
                "identifier": "casfrom_Gscanstatus",
                "newPage": false,
                "searchKey": "runtime.casfrom_Gscanstatus",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func casfrom_Gscanstatus(gp *g, oldval, newval uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc casfrom_Gscanstatus(gp *g, oldval, newval uint32)\n```\n\nThe Gscanstatuses are acting like locks and this releases them. If it proves to be a performance hit we should be able to make these simple atomic stores but for now we are going to throw if we see an inconsistent state. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#castogscanstatus",
              "documentation": {
                "identifier": "castogscanstatus",
                "newPage": false,
                "searchKey": "runtime.castogscanstatus",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func castogscanstatus(gp *g, oldval, newval uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc castogscanstatus(gp *g, oldval, newval uint32) bool\n```\n\nThis will return false if the gp is not in the expected status and the cas fails. This acts like a lock acquire while the casfromgstatus acts like a lock release. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#casgstatus",
              "documentation": {
                "identifier": "casgstatus",
                "newPage": false,
                "searchKey": "runtime.casgstatus",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func casgstatus(gp *g, oldval, newval uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc casgstatus(gp *g, oldval, newval uint32)\n```\n\nIf asked to move to or from a Gscanstatus this will throw. Use the castogscanstatus and casfrom_Gscanstatus instead. casgstatus will loop if the g->atomicstatus is in a Gscan status until the routine that put it in the Gscan state is finished. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#casgcopystack",
              "documentation": {
                "identifier": "casgcopystack",
                "newPage": false,
                "searchKey": "runtime.casgcopystack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func casgcopystack(gp *g) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc casgcopystack(gp *g) uint32\n```\n\ncasgstatus(gp, oldstatus, Gcopystack), assuming oldstatus is Gwaiting or Grunnable. Returns old status. Cannot call casgstatus directly, because we are racing with an async wakeup that might come in from netpoll. If we see Gwaiting from the readgstatus, it might have become Grunnable by the time we get to the cas. If we called casgstatus, it would loop waiting for the status to go back to Gwaiting, which it never will. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#casGToPreemptScan",
              "documentation": {
                "identifier": "casGToPreemptScan",
                "newPage": false,
                "searchKey": "runtime.casGToPreemptScan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func casGToPreemptScan(gp *g, old, new uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc casGToPreemptScan(gp *g, old, new uint32)\n```\n\ncasGToPreemptScan transitions gp from _Grunning to _Gscan|_Gpreempted. \n\nTODO(austin): This is the only status operation that both changes the status and locks the _Gscan bit. Rethink this. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#casGFromPreempted",
              "documentation": {
                "identifier": "casGFromPreempted",
                "newPage": false,
                "searchKey": "runtime.casGFromPreempted",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func casGFromPreempted(gp *g, old, new uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc casGFromPreempted(gp *g, old, new uint32) bool\n```\n\ncasGFromPreempted attempts to transition gp from _Gpreempted to _Gwaiting. If successful, the caller is responsible for re-scheduling gp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stopTheWorld",
              "documentation": {
                "identifier": "stopTheWorld",
                "newPage": false,
                "searchKey": "runtime.stopTheWorld",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stopTheWorld(reason string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stopTheWorld(reason string)\n```\n\nstopTheWorld stops all P's from executing goroutines, interrupting all goroutines at GC safe points and records reason as the reason for the stop. On return, only the current goroutine's P is running. stopTheWorld must not be called from a system stack and the caller must not hold worldsema. The caller must call startTheWorld when other P's should resume execution. \n\nstopTheWorld is safe for multiple goroutines to call at the same time. Each will execute its own stop, and the stops will be serialized. \n\nThis is also used by routines that do stack dumps. If the system is in panic or being exited, this may not reliably stop all goroutines. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#startTheWorld",
              "documentation": {
                "identifier": "startTheWorld",
                "newPage": false,
                "searchKey": "runtime.startTheWorld",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func startTheWorld()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc startTheWorld()\n```\n\nstartTheWorld undoes the effects of stopTheWorld. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stopTheWorldGC",
              "documentation": {
                "identifier": "stopTheWorldGC",
                "newPage": false,
                "searchKey": "runtime.stopTheWorldGC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stopTheWorldGC(reason string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stopTheWorldGC(reason string)\n```\n\nstopTheWorldGC has the same effect as stopTheWorld, but blocks until the GC is not running. It also blocks a GC from starting until startTheWorldGC is called. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#startTheWorldGC",
              "documentation": {
                "identifier": "startTheWorldGC",
                "newPage": false,
                "searchKey": "runtime.startTheWorldGC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func startTheWorldGC()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc startTheWorldGC()\n```\n\nstartTheWorldGC undoes the effects of stopTheWorldGC. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stopTheWorldWithSema",
              "documentation": {
                "identifier": "stopTheWorldWithSema",
                "newPage": false,
                "searchKey": "runtime.stopTheWorldWithSema",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stopTheWorldWithSema()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stopTheWorldWithSema()\n```\n\nstopTheWorldWithSema is the core implementation of stopTheWorld. The caller is responsible for acquiring worldsema and disabling preemption first and then should stopTheWorldWithSema on the system stack: \n\n```\nsemacquire(&worldsema, 0)\nm.preemptoff = \"reason\"\nsystemstack(stopTheWorldWithSema)\n\n```\nWhen finished, the caller must either call startTheWorld or undo these three operations separately: \n\n```\nm.preemptoff = \"\"\nsystemstack(startTheWorldWithSema)\nsemrelease(&worldsema)\n\n```\nIt is allowed to acquire worldsema once and then execute multiple startTheWorldWithSema/stopTheWorldWithSema pairs. Other P's are able to execute between successive calls to startTheWorldWithSema and stopTheWorldWithSema. Holding worldsema causes any other goroutines invoking stopTheWorld to block. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#startTheWorldWithSema",
              "documentation": {
                "identifier": "startTheWorldWithSema",
                "newPage": false,
                "searchKey": "runtime.startTheWorldWithSema",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func startTheWorldWithSema(emitTraceEvent bool) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc startTheWorldWithSema(emitTraceEvent bool) int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#usesLibcall",
              "documentation": {
                "identifier": "usesLibcall",
                "newPage": false,
                "searchKey": "runtime.usesLibcall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func usesLibcall() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc usesLibcall() bool\n```\n\nusesLibcall indicates whether this runtime performs system calls via libcall. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mStackIsSystemAllocated",
              "documentation": {
                "identifier": "mStackIsSystemAllocated",
                "newPage": false,
                "searchKey": "runtime.mStackIsSystemAllocated",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mStackIsSystemAllocated() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mStackIsSystemAllocated() bool\n```\n\nmStackIsSystemAllocated indicates whether this runtime starts on a system-allocated stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mstart",
              "documentation": {
                "identifier": "mstart",
                "newPage": false,
                "searchKey": "runtime.mstart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mstart()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mstart()\n```\n\nmstart is the entry-point for new Ms. It is written in assembly, uses ABI0, is marked TOPFRAME, and calls mstart0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mstart0",
              "documentation": {
                "identifier": "mstart0",
                "newPage": false,
                "searchKey": "runtime.mstart0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mstart0()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mstart0()\n```\n\nmstart0 is the Go entry-point for new Ms. This must not split the stack because we may not even have stack bounds set up yet. \n\nMay run during STW (because it doesn't have a P yet), so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mstart1",
              "documentation": {
                "identifier": "mstart1",
                "newPage": false,
                "searchKey": "runtime.mstart1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mstart1()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mstart1()\n```\n\nThe go:noinline is to guarantee the getcallerpc/getcallersp below are safe, so that we can set up g0.sched to return to the call of mstart1 above. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mstartm0",
              "documentation": {
                "identifier": "mstartm0",
                "newPage": false,
                "searchKey": "runtime.mstartm0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mstartm0()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mstartm0()\n```\n\nmstartm0 implements part of mstart1 that only runs on the m0. \n\nWrite barriers are allowed here because we know the GC can't be running yet, so they'll be no-ops. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mPark",
              "documentation": {
                "identifier": "mPark",
                "newPage": false,
                "searchKey": "runtime.mPark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mPark()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mPark()\n```\n\nmPark causes a thread to park itself - temporarily waking for fixups but otherwise waiting to be fully woken. This is the only way that m's should park themselves. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mexit",
              "documentation": {
                "identifier": "mexit",
                "newPage": false,
                "searchKey": "runtime.mexit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mexit(osStack bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mexit(osStack bool)\n```\n\nmexit tears down and exits the current thread. \n\nDon't call this directly to exit the thread, since it must run at the top of the thread stack. Instead, use gogo(&_g_.m.g0.sched) to unwind the stack to the point that exits the thread. \n\nIt is entered with m.p != nil, so write barriers are allowed. It will release the P before exiting. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#forEachP",
              "documentation": {
                "identifier": "forEachP",
                "newPage": false,
                "searchKey": "runtime.forEachP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func forEachP(fn func(*p))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc forEachP(fn func(*p))\n```\n\nforEachP calls fn(p) for every P p when p reaches a GC safe point. If a P is currently executing code, this will bring the P to a GC safe point and execute fn on that P. If the P is not executing code (it is idle or in a syscall), this will call fn(p) directly while preventing the P from exiting its state. This does not ensure that fn will run on every CPU executing Go code, but it acts as a global memory barrier. GC uses this as a \"ragged barrier.\" \n\nThe caller must hold worldsema. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_runtime_doAllThreadsSyscall",
              "documentation": {
                "identifier": "syscall_runtime_doAllThreadsSyscall",
                "newPage": false,
                "searchKey": "runtime.syscall_runtime_doAllThreadsSyscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_runtime_doAllThreadsSyscall(fn func(bool) bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_runtime_doAllThreadsSyscall(fn func(bool) bool)\n```\n\nsyscall_runtime_doAllThreadsSyscall serializes Go execution and executes a specified fn() call on all m's. \n\nThe boolean argument to fn() indicates whether the function's return value will be consulted or not. That is, fn(true) should return true if fn() succeeds, and fn(true) should return false if it failed. When fn(false) is called, its return status will be ignored. \n\nsyscall_runtime_doAllThreadsSyscall first invokes fn(true) on a single, coordinating, m, and only if it returns true does it go on to invoke fn(false) on all of the other m's known to the process. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runSafePointFn",
              "documentation": {
                "identifier": "runSafePointFn",
                "newPage": false,
                "searchKey": "runtime.runSafePointFn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runSafePointFn()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runSafePointFn()\n```\n\nrunSafePointFn runs the safe point function, if any, for this P. This should be called like \n\n```\nif getg().m.p.runSafePointFn != 0 {\n    runSafePointFn()\n}\n\n```\nrunSafePointFn must be checked on any transition in to _Pidle or _Psyscall to avoid a race where forEachP sees that the P is running just before the P goes into _Pidle/_Psyscall and neither forEachP nor the P run the safe-point function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#needm",
              "documentation": {
                "identifier": "needm",
                "newPage": false,
                "searchKey": "runtime.needm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func needm()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc needm()\n```\n\nneedm is called when a cgo callback happens on a thread without an m (a thread not created by Go). In this case, needm is expected to find an m to use and return with m, g initialized correctly. Since m and g are not set now (likely nil, but see below) needm is limited in what routines it can call. In particular it can only call nosplit functions (textflag 7) and cannot do any scheduling that requires an m. \n\nIn order to avoid needing heavy lifting here, we adopt the following strategy: there is a stack of available m's that can be stolen. Using compare-and-swap to pop from the stack has ABA races, so we simulate a lock by doing an exchange (via Casuintptr) to steal the stack head and replace the top pointer with MLOCKED (1). This serves as a simple spin lock that we can use even without an m. The thread that locks the stack in this way unlocks the stack by storing a valid stack head pointer. \n\nIn order to make sure that there is always an m structure available to be stolen, we maintain the invariant that there is always one more than needed. At the beginning of the program (if cgo is in use) the list is seeded with a single m. If needm finds that it has taken the last m off the list, its job is - once it has installed its own m so that it can do things like allocate memory - to create a spare m and put it on the list. \n\nEach of these extra m's also has a g0 and a curg that are pressed into service as the scheduling stack and current goroutine for the duration of the cgo callback. \n\nWhen the callback is done with the m, it calls dropm to put the m back on the list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#newextram",
              "documentation": {
                "identifier": "newextram",
                "newPage": false,
                "searchKey": "runtime.newextram",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newextram()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newextram()\n```\n\nnewextram allocates m's and puts them on the extra list. It is called with a working local m, so that it can do things like call schedlock and allocate. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#oneNewExtraM",
              "documentation": {
                "identifier": "oneNewExtraM",
                "newPage": false,
                "searchKey": "runtime.oneNewExtraM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func oneNewExtraM()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc oneNewExtraM()\n```\n\noneNewExtraM allocates an m and puts it on the extra list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dropm",
              "documentation": {
                "identifier": "dropm",
                "newPage": false,
                "searchKey": "runtime.dropm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dropm()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dropm()\n```\n\ndropm is called when a cgo callback has called needm but is now done with the callback and returning back into the non-Go thread. It puts the current m back onto the extra list. \n\nThe main expense here is the call to signalstack to release the m's signal stack, and then the call to needm on the next callback from this thread. It is tempting to try to save the m for next time, which would eliminate both these costs, but there might not be a next time: the current thread (which Go does not control) might exit. If we saved the m for that thread, there would be an m leak each time such a thread exited. Instead, we acquire and release an m on each call. These should typically not be scheduling operations, just a few atomics, so the cost should be small. \n\nTODO(rsc): An alternative would be to allocate a dummy pthread per-thread variable using pthread_key_create. Unlike the pthread keys we already use on OS X, this dummy key would never be read by Go code. It would exist only so that we could register at thread-exit-time destructor. That destructor would put the m back onto the extra list. This is purely a performance optimization. The current version, in which dropm happens on each cgo call, is still correct too. We may have to keep the current version on systems with cgo but without pthreads, like Windows. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#getm",
              "documentation": {
                "identifier": "getm",
                "newPage": false,
                "searchKey": "runtime.getm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getm() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getm() uintptr\n```\n\nA helper function for EnsureDropM. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unlockextra",
              "documentation": {
                "identifier": "unlockextra",
                "newPage": false,
                "searchKey": "runtime.unlockextra",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unlockextra(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unlockextra(mp *m)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#newm",
              "documentation": {
                "identifier": "newm",
                "newPage": false,
                "searchKey": "runtime.newm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newm(fn func(), _p_ *p, id int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newm(fn func(), _p_ *p, id int64)\n```\n\nCreate a new m. It will start off with a call to fn, or else the scheduler. fn needs to be static and not a heap allocated closure. May run with m.p==nil, so write barriers are not allowed. \n\nid is optional pre-allocated m ID. Omit by passing -1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#newm1",
              "documentation": {
                "identifier": "newm1",
                "newPage": false,
                "searchKey": "runtime.newm1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newm1(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newm1(mp *m)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#startTemplateThread",
              "documentation": {
                "identifier": "startTemplateThread",
                "newPage": false,
                "searchKey": "runtime.startTemplateThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func startTemplateThread()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc startTemplateThread()\n```\n\nstartTemplateThread starts the template thread if it is not already running. \n\nThe calling thread must itself be in a known-good state. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mDoFixup",
              "documentation": {
                "identifier": "mDoFixup",
                "newPage": false,
                "searchKey": "runtime.mDoFixup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mDoFixup() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mDoFixup() bool\n```\n\nmDoFixup runs any outstanding fixup function for the running m. Returns true if a fixup was outstanding and actually executed. \n\nNote: to avoid deadlocks, and the need for the fixup function itself to be async safe, signals are blocked for the working m while it holds the mFixup lock. (See golang.org/issue/44193) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mDoFixupAndOSYield",
              "documentation": {
                "identifier": "mDoFixupAndOSYield",
                "newPage": false,
                "searchKey": "runtime.mDoFixupAndOSYield",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mDoFixupAndOSYield()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mDoFixupAndOSYield()\n```\n\nmDoFixupAndOSYield is called when an m is unable to send a signal because the allThreadsSyscall mechanism is in progress. That is, an mPark() has been interrupted with this signal handler so we need to ensure the fixup is executed from this context. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#templateThread",
              "documentation": {
                "identifier": "templateThread",
                "newPage": false,
                "searchKey": "runtime.templateThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func templateThread()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc templateThread()\n```\n\ntemplateThread is a thread in a known-good state that exists solely to start new threads in known-good states when the calling thread may not be in a good state. \n\nMany programs never need this, so templateThread is started lazily when we first enter a state that might lead to running on a thread in an unknown state. \n\ntemplateThread runs on an M without a P, so it must not have write barriers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stopm",
              "documentation": {
                "identifier": "stopm",
                "newPage": false,
                "searchKey": "runtime.stopm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stopm()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stopm()\n```\n\nStops execution of the current m until new work is available. Returns with acquired P. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mspinning",
              "documentation": {
                "identifier": "mspinning",
                "newPage": false,
                "searchKey": "runtime.mspinning",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mspinning()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mspinning()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#startm",
              "documentation": {
                "identifier": "startm",
                "newPage": false,
                "searchKey": "runtime.startm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func startm(_p_ *p, spinning bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc startm(_p_ *p, spinning bool)\n```\n\nSchedules some M to run the p (creates an M if necessary). If p==nil, tries to get an idle P, if no idle P's does nothing. May run with m.p==nil, so write barriers are not allowed. If spinning is set, the caller has incremented nmspinning and startm will either decrement nmspinning or set m.spinning in the newly started M. \n\nCallers passing a non-nil P must call from a non-preemptible context. See comment on acquirem below. \n\nMust not have write barriers because this may be called without a P. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#handoffp",
              "documentation": {
                "identifier": "handoffp",
                "newPage": false,
                "searchKey": "runtime.handoffp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func handoffp(_p_ *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc handoffp(_p_ *p)\n```\n\nHands off P from syscall or locked M. Always runs without a P, so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#wakep",
              "documentation": {
                "identifier": "wakep",
                "newPage": false,
                "searchKey": "runtime.wakep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func wakep()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc wakep()\n```\n\nTries to add one more P to execute G's. Called when a G is made runnable (newproc, ready). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stoplockedm",
              "documentation": {
                "identifier": "stoplockedm",
                "newPage": false,
                "searchKey": "runtime.stoplockedm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stoplockedm()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stoplockedm()\n```\n\nStops execution of the current m that is locked to a g until the g is runnable again. Returns with acquired P. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#startlockedm",
              "documentation": {
                "identifier": "startlockedm",
                "newPage": false,
                "searchKey": "runtime.startlockedm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func startlockedm(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc startlockedm(gp *g)\n```\n\nSchedules the locked m to run the locked gp. May run during STW, so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcstopm",
              "documentation": {
                "identifier": "gcstopm",
                "newPage": false,
                "searchKey": "runtime.gcstopm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcstopm()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcstopm()\n```\n\nStops the current m for stopTheWorld. Returns when the world is restarted. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#execute",
              "documentation": {
                "identifier": "execute",
                "newPage": false,
                "searchKey": "runtime.execute",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func execute(gp *g, inheritTime bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc execute(gp *g, inheritTime bool)\n```\n\nSchedules gp to run on the current M. If inheritTime is true, gp inherits the remaining time in the current time slice. Otherwise, it starts a new time slice. Never returns. \n\nWrite barriers are allowed because this is called immediately after acquiring a P in several places. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pollWork",
              "documentation": {
                "identifier": "pollWork",
                "newPage": false,
                "searchKey": "runtime.pollWork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pollWork() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pollWork() bool\n```\n\npollWork reports whether there is non-background work this P could be doing. This is a fairly lightweight check to be used for background work loops, like idle GC. It checks a subset of the conditions checked by the actual scheduler. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#checkTimersNoP",
              "documentation": {
                "identifier": "checkTimersNoP",
                "newPage": false,
                "searchKey": "runtime.checkTimersNoP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkTimersNoP(allpSnapshot []*p, timerpMaskSnapshot pMask, pollUntil int64) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkTimersNoP(allpSnapshot []*p, timerpMaskSnapshot pMask, pollUntil int64) int64\n```\n\nCheck all Ps for a timer expiring sooner than pollUntil. \n\nReturns updated pollUntil value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#wakeNetPoller",
              "documentation": {
                "identifier": "wakeNetPoller",
                "newPage": false,
                "searchKey": "runtime.wakeNetPoller",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func wakeNetPoller(when int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc wakeNetPoller(when int64)\n```\n\nwakeNetPoller wakes up the thread sleeping in the network poller if it isn't going to wake up before the when argument; or it wakes an idle P to service timers and the network poller if there isn't one already. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#resetspinning",
              "documentation": {
                "identifier": "resetspinning",
                "newPage": false,
                "searchKey": "runtime.resetspinning",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func resetspinning()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resetspinning()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#injectglist",
              "documentation": {
                "identifier": "injectglist",
                "newPage": false,
                "searchKey": "runtime.injectglist",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func injectglist(glist *gList)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc injectglist(glist *gList)\n```\n\ninjectglist adds each runnable G on the list to some run queue, and clears glist. If there is no current P, they are added to the global queue, and up to npidle M's are started to run them. Otherwise, for each idle P, this adds a G to the global queue and starts an M. Any remaining G's are added to the current P's local run queue. This may temporarily acquire sched.lock. Can run concurrently with GC. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#schedule",
              "documentation": {
                "identifier": "schedule",
                "newPage": false,
                "searchKey": "runtime.schedule",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func schedule()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc schedule()\n```\n\nOne round of scheduler: find a runnable goroutine and execute it. Never returns. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dropg",
              "documentation": {
                "identifier": "dropg",
                "newPage": false,
                "searchKey": "runtime.dropg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dropg()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dropg()\n```\n\ndropg removes the association between m and the current goroutine m->curg (gp for short). Typically a caller sets gp's status away from Grunning and then immediately calls dropg to finish the job. The caller is also responsible for arranging that gp will be restarted using ready at an appropriate time. After calling dropg and arranging for gp to be readied later, the caller can do other work but eventually should call schedule to restart the scheduling of goroutines on this m. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#checkTimers",
              "documentation": {
                "identifier": "checkTimers",
                "newPage": false,
                "searchKey": "runtime.checkTimers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool)\n```\n\ncheckTimers runs any timers for the P that are ready. If now is not 0 it is the current time. It returns the passed time or the current time if now was passed as 0. and the time when the next timer should run or 0 if there is no next timer, and reports whether it ran any timers. If the time when the next timer should run is not 0, it is always larger than the returned time. We pass now in and out to avoid extra calls of nanotime. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#parkunlock_c",
              "documentation": {
                "identifier": "parkunlock_c",
                "newPage": false,
                "searchKey": "runtime.parkunlock_c",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parkunlock_c(gp *g, lock unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parkunlock_c(gp *g, lock unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#park_m",
              "documentation": {
                "identifier": "park_m",
                "newPage": false,
                "searchKey": "runtime.park_m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func park_m(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc park_m(gp *g)\n```\n\npark continuation on g0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goschedImpl",
              "documentation": {
                "identifier": "goschedImpl",
                "newPage": false,
                "searchKey": "runtime.goschedImpl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goschedImpl(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goschedImpl(gp *g)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gosched_m",
              "documentation": {
                "identifier": "gosched_m",
                "newPage": false,
                "searchKey": "runtime.gosched_m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gosched_m(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gosched_m(gp *g)\n```\n\nGosched continuation on g0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goschedguarded_m",
              "documentation": {
                "identifier": "goschedguarded_m",
                "newPage": false,
                "searchKey": "runtime.goschedguarded_m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goschedguarded_m(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goschedguarded_m(gp *g)\n```\n\ngoschedguarded is a forbidden-states-avoided version of gosched_m \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gopreempt_m",
              "documentation": {
                "identifier": "gopreempt_m",
                "newPage": false,
                "searchKey": "runtime.gopreempt_m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gopreempt_m(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gopreempt_m(gp *g)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#preemptPark",
              "documentation": {
                "identifier": "preemptPark",
                "newPage": false,
                "searchKey": "runtime.preemptPark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func preemptPark(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc preemptPark(gp *g)\n```\n\npreemptPark parks gp and puts it in _Gpreempted. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goyield",
              "documentation": {
                "identifier": "goyield",
                "newPage": false,
                "searchKey": "runtime.goyield",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goyield()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goyield()\n```\n\ngoyield is like Gosched, but it: - emits a GoPreempt trace event instead of a GoSched trace event - puts the current G on the runq of the current P instead of the globrunq \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goyield_m",
              "documentation": {
                "identifier": "goyield_m",
                "newPage": false,
                "searchKey": "runtime.goyield_m",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goyield_m(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goyield_m(gp *g)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goexit1",
              "documentation": {
                "identifier": "goexit1",
                "newPage": false,
                "searchKey": "runtime.goexit1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goexit1()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goexit1()\n```\n\nFinishes execution of the current goroutine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goexit0",
              "documentation": {
                "identifier": "goexit0",
                "newPage": false,
                "searchKey": "runtime.goexit0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goexit0(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goexit0(gp *g)\n```\n\ngoexit continuation on g0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#save",
              "documentation": {
                "identifier": "save",
                "newPage": false,
                "searchKey": "runtime.save",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func save(pc, sp uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc save(pc, sp uintptr)\n```\n\nsave updates getg().sched to refer to pc and sp so that a following gogo will restore pc and sp. \n\nsave must not have write barriers because invoking a write barrier can clobber getg().sched. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reentersyscall",
              "documentation": {
                "identifier": "reentersyscall",
                "newPage": false,
                "searchKey": "runtime.reentersyscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reentersyscall(pc, sp uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reentersyscall(pc, sp uintptr)\n```\n\nThe goroutine g is about to enter a system call. Record that it's not using the cpu anymore. This is called only from the go syscall library and cgocall, not from the low-level system calls used by the runtime. \n\nEntersyscall cannot split the stack: the save must make g->sched refer to the caller's stack segment, because entersyscall is going to return immediately after. \n\nNothing entersyscall calls can split the stack either. We cannot safely move the stack during an active call to syscall, because we do not know which of the uintptr arguments are really pointers (back into the stack). In practice, this means that we make the fast path run through entersyscall doing no-split things, and the slow path has to use systemstack to run bigger things on the system stack. \n\nreentersyscall is the entry point used by cgo callbacks, where explicitly saved SP and PC are restored. This is needed when exitsyscall will be called from a function further up in the call stack than the parent, as g->syscallsp must always point to a valid stack frame. entersyscall below is the normal entry point for syscalls, which obtains the SP and PC from the caller. \n\nSyscall tracing: At the start of a syscall we emit traceGoSysCall to capture the stack trace. If the syscall does not block, that is it, we do not emit any other events. If the syscall blocks (that is, P is retaken), retaker emits traceGoSysBlock; when syscall returns we emit traceGoSysExit and when the goroutine starts running (potentially instantly, if exitsyscallfast returns true) we emit traceGoStart. To ensure that traceGoSysExit is emitted strictly after traceGoSysBlock, we remember current value of syscalltick in m (_g_.m.syscalltick = _g_.m.p.ptr().syscalltick), whoever emits traceGoSysBlock increments p.syscalltick afterwards; and we wait for the increment before emitting traceGoSysExit. Note that the increment is done even if tracing is not enabled, because tracing can be enabled in the middle of syscall. We don't want the wait to hang. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#entersyscall",
              "documentation": {
                "identifier": "entersyscall",
                "newPage": false,
                "searchKey": "runtime.entersyscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func entersyscall()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc entersyscall()\n```\n\nStandard syscall entry used by the go syscall library and normal cgo calls. \n\nThis is exported via linkname to assembly in the syscall package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#entersyscall_sysmon",
              "documentation": {
                "identifier": "entersyscall_sysmon",
                "newPage": false,
                "searchKey": "runtime.entersyscall_sysmon",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func entersyscall_sysmon()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc entersyscall_sysmon()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#entersyscall_gcwait",
              "documentation": {
                "identifier": "entersyscall_gcwait",
                "newPage": false,
                "searchKey": "runtime.entersyscall_gcwait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func entersyscall_gcwait()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc entersyscall_gcwait()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#entersyscallblock",
              "documentation": {
                "identifier": "entersyscallblock",
                "newPage": false,
                "searchKey": "runtime.entersyscallblock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func entersyscallblock()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc entersyscallblock()\n```\n\nThe same as entersyscall(), but with a hint that the syscall is blocking. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#entersyscallblock_handoff",
              "documentation": {
                "identifier": "entersyscallblock_handoff",
                "newPage": false,
                "searchKey": "runtime.entersyscallblock_handoff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func entersyscallblock_handoff()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc entersyscallblock_handoff()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#exitsyscall",
              "documentation": {
                "identifier": "exitsyscall",
                "newPage": false,
                "searchKey": "runtime.exitsyscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func exitsyscall()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc exitsyscall()\n```\n\nThe goroutine g exited its system call. Arrange for it to run on a cpu again. This is called only from the go syscall library, not from the low-level system calls used by the runtime. \n\nWrite barriers are not allowed because our P may have been stolen. \n\nThis is exported via linkname to assembly in the syscall package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#exitsyscallfast",
              "documentation": {
                "identifier": "exitsyscallfast",
                "newPage": false,
                "searchKey": "runtime.exitsyscallfast",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func exitsyscallfast(oldp *p) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc exitsyscallfast(oldp *p) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#exitsyscallfast_reacquired",
              "documentation": {
                "identifier": "exitsyscallfast_reacquired",
                "newPage": false,
                "searchKey": "runtime.exitsyscallfast_reacquired",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func exitsyscallfast_reacquired()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc exitsyscallfast_reacquired()\n```\n\nexitsyscallfast_reacquired is the exitsyscall path on which this G has successfully reacquired the P it was running on before the syscall. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#exitsyscallfast_pidle",
              "documentation": {
                "identifier": "exitsyscallfast_pidle",
                "newPage": false,
                "searchKey": "runtime.exitsyscallfast_pidle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func exitsyscallfast_pidle() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc exitsyscallfast_pidle() bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#exitsyscall0",
              "documentation": {
                "identifier": "exitsyscall0",
                "newPage": false,
                "searchKey": "runtime.exitsyscall0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func exitsyscall0(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc exitsyscall0(gp *g)\n```\n\nexitsyscall slow path on g0. Failed to acquire P, enqueue gp as runnable. \n\nCalled via mcall, so gp is the calling g from this M. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#beforefork",
              "documentation": {
                "identifier": "beforefork",
                "newPage": false,
                "searchKey": "runtime.beforefork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func beforefork()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc beforefork()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_runtime_BeforeFork",
              "documentation": {
                "identifier": "syscall_runtime_BeforeFork",
                "newPage": false,
                "searchKey": "runtime.syscall_runtime_BeforeFork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_runtime_BeforeFork()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_runtime_BeforeFork()\n```\n\nCalled from syscall package before fork. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#afterfork",
              "documentation": {
                "identifier": "afterfork",
                "newPage": false,
                "searchKey": "runtime.afterfork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func afterfork()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc afterfork()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_runtime_AfterFork",
              "documentation": {
                "identifier": "syscall_runtime_AfterFork",
                "newPage": false,
                "searchKey": "runtime.syscall_runtime_AfterFork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_runtime_AfterFork()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_runtime_AfterFork()\n```\n\nCalled from syscall package after fork in parent. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_runtime_AfterForkInChild",
              "documentation": {
                "identifier": "syscall_runtime_AfterForkInChild",
                "newPage": false,
                "searchKey": "runtime.syscall_runtime_AfterForkInChild",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_runtime_AfterForkInChild()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_runtime_AfterForkInChild()\n```\n\nCalled from syscall package after fork in child. It resets non-sigignored signals to the default handler, and restores the signal mask in preparation for the exec. \n\nBecause this might be called during a vfork, and therefore may be temporarily sharing address space with the parent process, this must not change any global variables or calling into C code that may do so. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_runtime_BeforeExec",
              "documentation": {
                "identifier": "syscall_runtime_BeforeExec",
                "newPage": false,
                "searchKey": "runtime.syscall_runtime_BeforeExec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_runtime_BeforeExec()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_runtime_BeforeExec()\n```\n\nCalled from syscall package before Exec. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_runtime_AfterExec",
              "documentation": {
                "identifier": "syscall_runtime_AfterExec",
                "newPage": false,
                "searchKey": "runtime.syscall_runtime_AfterExec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_runtime_AfterExec()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_runtime_AfterExec()\n```\n\nCalled from syscall package after Exec. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#newproc",
              "documentation": {
                "identifier": "newproc",
                "newPage": false,
                "searchKey": "runtime.newproc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newproc(siz int32, fn *funcval)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newproc(siz int32, fn *funcval)\n```\n\nCreate a new g running fn with siz bytes of arguments. Put it on the queue of g's waiting to run. The compiler turns a go statement into a call to this. \n\nThe stack layout of this call is unusual: it assumes that the arguments to pass to fn are on the stack sequentially immediately after &fn. Hence, they are logically part of newproc's argument frame, even though they don't appear in its signature (and can't because their types differ between call sites). \n\nThis must be nosplit because this stack layout means there are untyped arguments in newproc's argument frame. Stack copies won't be able to adjust them and stack splits won't be able to copy them. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#saveAncestors",
              "documentation": {
                "identifier": "saveAncestors",
                "newPage": false,
                "searchKey": "runtime.saveAncestors",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func saveAncestors(callergp *g) *[]ancestorInfo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc saveAncestors(callergp *g) *[]ancestorInfo\n```\n\nsaveAncestors copies previous ancestors of the given caller g and includes infor for the current caller into a new set of tracebacks for a g being created. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gfput",
              "documentation": {
                "identifier": "gfput",
                "newPage": false,
                "searchKey": "runtime.gfput",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gfput(_p_ *p, gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gfput(_p_ *p, gp *g)\n```\n\nPut on gfree list. If local list is too long, transfer a batch to the global list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gfpurge",
              "documentation": {
                "identifier": "gfpurge",
                "newPage": false,
                "searchKey": "runtime.gfpurge",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gfpurge(_p_ *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gfpurge(_p_ *p)\n```\n\nPurge all cached G's from gfree list to the global list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Breakpoint",
              "documentation": {
                "identifier": "Breakpoint",
                "newPage": false,
                "searchKey": "runtime.Breakpoint",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Breakpoint()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Breakpoint()\n```\n\nBreakpoint executes a breakpoint trap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dolockOSThread",
              "documentation": {
                "identifier": "dolockOSThread",
                "newPage": false,
                "searchKey": "runtime.dolockOSThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dolockOSThread()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dolockOSThread()\n```\n\ndolockOSThread is called by LockOSThread and lockOSThread below after they modify m.locked. Do not allow preemption during this call, or else the m might be different in this function than in the caller. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#LockOSThread",
              "documentation": {
                "identifier": "LockOSThread",
                "newPage": false,
                "searchKey": "runtime.LockOSThread",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func LockOSThread()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LockOSThread()\n```\n\nLockOSThread wires the calling goroutine to its current operating system thread. The calling goroutine will always execute in that thread, and no other goroutine will execute in it, until the calling goroutine has made as many calls to UnlockOSThread as to LockOSThread. If the calling goroutine exits without unlocking the thread, the thread will be terminated. \n\nAll init functions are run on the startup thread. Calling LockOSThread from an init function will cause the main function to be invoked on that thread. \n\nA goroutine should call LockOSThread before calling OS services or non-Go library functions that depend on per-thread state. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#lockOSThread",
              "documentation": {
                "identifier": "lockOSThread",
                "newPage": false,
                "searchKey": "runtime.lockOSThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lockOSThread()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lockOSThread()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dounlockOSThread",
              "documentation": {
                "identifier": "dounlockOSThread",
                "newPage": false,
                "searchKey": "runtime.dounlockOSThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dounlockOSThread()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dounlockOSThread()\n```\n\ndounlockOSThread is called by UnlockOSThread and unlockOSThread below after they update m->locked. Do not allow preemption during this call, or else the m might be in different in this function than in the caller. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#UnlockOSThread",
              "documentation": {
                "identifier": "UnlockOSThread",
                "newPage": false,
                "searchKey": "runtime.UnlockOSThread",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func UnlockOSThread()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc UnlockOSThread()\n```\n\nUnlockOSThread undoes an earlier call to LockOSThread. If this drops the number of active LockOSThread calls on the calling goroutine to zero, it unwires the calling goroutine from its fixed operating system thread. If there are no active LockOSThread calls, this is a no-op. \n\nBefore calling UnlockOSThread, the caller must ensure that the OS thread is suitable for running other goroutines. If the caller made any permanent changes to the state of the thread that would affect other goroutines, it should not call this function and thus leave the goroutine locked to the OS thread until the goroutine (and hence the thread) exits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unlockOSThread",
              "documentation": {
                "identifier": "unlockOSThread",
                "newPage": false,
                "searchKey": "runtime.unlockOSThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unlockOSThread()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unlockOSThread()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badunlockosthread",
              "documentation": {
                "identifier": "badunlockosthread",
                "newPage": false,
                "searchKey": "runtime.badunlockosthread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badunlockosthread()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badunlockosthread()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcount",
              "documentation": {
                "identifier": "gcount",
                "newPage": false,
                "searchKey": "runtime.gcount",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcount() int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcount() int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mcount",
              "documentation": {
                "identifier": "mcount",
                "newPage": false,
                "searchKey": "runtime.mcount",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mcount() int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mcount() int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_System",
              "documentation": {
                "identifier": "_System",
                "newPage": false,
                "searchKey": "runtime._System",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func _System()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc _System()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_ExternalCode",
              "documentation": {
                "identifier": "_ExternalCode",
                "newPage": false,
                "searchKey": "runtime._ExternalCode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func _ExternalCode()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc _ExternalCode()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_LostExternalCode",
              "documentation": {
                "identifier": "_LostExternalCode",
                "newPage": false,
                "searchKey": "runtime._LostExternalCode",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func _LostExternalCode()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc _LostExternalCode()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_GC",
              "documentation": {
                "identifier": "_GC",
                "newPage": false,
                "searchKey": "runtime._GC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func _GC()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc _GC()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_LostSIGPROFDuringAtomic64",
              "documentation": {
                "identifier": "_LostSIGPROFDuringAtomic64",
                "newPage": false,
                "searchKey": "runtime._LostSIGPROFDuringAtomic64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func _LostSIGPROFDuringAtomic64()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc _LostSIGPROFDuringAtomic64()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#_VDSO",
              "documentation": {
                "identifier": "_VDSO",
                "newPage": false,
                "searchKey": "runtime._VDSO",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func _VDSO()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc _VDSO()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigprof",
              "documentation": {
                "identifier": "sigprof",
                "newPage": false,
                "searchKey": "runtime.sigprof",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigprof(pc, sp, lr uintptr, gp *g, mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigprof(pc, sp, lr uintptr, gp *g, mp *m)\n```\n\nCalled if we receive a SIGPROF signal. Called by the signal handler, may run during STW. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigprofNonGo",
              "documentation": {
                "identifier": "sigprofNonGo",
                "newPage": false,
                "searchKey": "runtime.sigprofNonGo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigprofNonGo()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigprofNonGo()\n```\n\nsigprofNonGo is called if we receive a SIGPROF signal on a non-Go thread, and the signal handler collected a stack trace in sigprofCallers. When this is called, sigprofCallersUse will be non-zero. g is nil, and what we can do is very limited. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigprofNonGoPC",
              "documentation": {
                "identifier": "sigprofNonGoPC",
                "newPage": false,
                "searchKey": "runtime.sigprofNonGoPC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigprofNonGoPC(pc uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigprofNonGoPC(pc uintptr)\n```\n\nsigprofNonGoPC is called when a profiling signal arrived on a non-Go thread and we have a single PC value, not a stack trace. g is nil, and what we can do is very limited. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setcpuprofilerate",
              "documentation": {
                "identifier": "setcpuprofilerate",
                "newPage": false,
                "searchKey": "runtime.setcpuprofilerate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setcpuprofilerate(hz int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setcpuprofilerate(hz int32)\n```\n\nsetcpuprofilerate sets the CPU profiling rate to hz times per second. If hz <= 0, setcpuprofilerate turns off CPU profiling. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#acquirep",
              "documentation": {
                "identifier": "acquirep",
                "newPage": false,
                "searchKey": "runtime.acquirep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func acquirep(_p_ *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc acquirep(_p_ *p)\n```\n\nAssociate p and the current m. \n\nThis function is allowed to have write barriers even if the caller isn't because it immediately acquires _p_. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#wirep",
              "documentation": {
                "identifier": "wirep",
                "newPage": false,
                "searchKey": "runtime.wirep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func wirep(_p_ *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc wirep(_p_ *p)\n```\n\nwirep is the first step of acquirep, which actually associates the current M to _p_. This is broken out so we can disallow write barriers for this part, since we don't yet have a P. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#incidlelocked",
              "documentation": {
                "identifier": "incidlelocked",
                "newPage": false,
                "searchKey": "runtime.incidlelocked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func incidlelocked(v int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc incidlelocked(v int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#checkdead",
              "documentation": {
                "identifier": "checkdead",
                "newPage": false,
                "searchKey": "runtime.checkdead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkdead()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkdead()\n```\n\nCheck for deadlock situation. The check is based on number of running M's, if 0 -> deadlock. sched.lock must be held. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysmon",
              "documentation": {
                "identifier": "sysmon",
                "newPage": false,
                "searchKey": "runtime.sysmon",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysmon()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysmon()\n```\n\nAlways runs without a P, so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retake",
              "documentation": {
                "identifier": "retake",
                "newPage": false,
                "searchKey": "runtime.retake",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retake(now int64) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retake(now int64) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#preemptall",
              "documentation": {
                "identifier": "preemptall",
                "newPage": false,
                "searchKey": "runtime.preemptall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func preemptall() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc preemptall() bool\n```\n\nTell all goroutines that they have been preempted and they should stop. This function is purely best-effort. It can fail to inform a goroutine if a processor just started running it. No locks need to be held. Returns true if preemption request was issued to at least one goroutine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#preemptone",
              "documentation": {
                "identifier": "preemptone",
                "newPage": false,
                "searchKey": "runtime.preemptone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func preemptone(_p_ *p) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc preemptone(_p_ *p) bool\n```\n\nTell the goroutine running on processor P to stop. This function is purely best-effort. It can incorrectly fail to inform the goroutine. It can inform the wrong goroutine. Even if it informs the correct goroutine, that goroutine might ignore the request if it is simultaneously executing newstack. No lock needs to be held. Returns true if preemption request was issued. The actual preemption will happen at some point in the future and will be indicated by the gp->status no longer being Grunning \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#schedtrace",
              "documentation": {
                "identifier": "schedtrace",
                "newPage": false,
                "searchKey": "runtime.schedtrace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func schedtrace(detailed bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc schedtrace(detailed bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#schedEnableUser",
              "documentation": {
                "identifier": "schedEnableUser",
                "newPage": false,
                "searchKey": "runtime.schedEnableUser",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func schedEnableUser(enable bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc schedEnableUser(enable bool)\n```\n\nschedEnableUser enables or disables the scheduling of user goroutines. \n\nThis does not stop already running user goroutines, so the caller should first stop the world when disabling user goroutines. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#schedEnabled",
              "documentation": {
                "identifier": "schedEnabled",
                "newPage": false,
                "searchKey": "runtime.schedEnabled",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func schedEnabled(gp *g) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc schedEnabled(gp *g) bool\n```\n\nschedEnabled reports whether gp should be scheduled. It returns false is scheduling of gp is disabled. \n\nsched.lock must be held. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mput",
              "documentation": {
                "identifier": "mput",
                "newPage": false,
                "searchKey": "runtime.mput",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mput(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mput(mp *m)\n```\n\nPut mp on midle list. sched.lock must be held. May run during STW, so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#globrunqput",
              "documentation": {
                "identifier": "globrunqput",
                "newPage": false,
                "searchKey": "runtime.globrunqput",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func globrunqput(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc globrunqput(gp *g)\n```\n\nPut gp on the global runnable queue. sched.lock must be held. May run during STW, so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#globrunqputhead",
              "documentation": {
                "identifier": "globrunqputhead",
                "newPage": false,
                "searchKey": "runtime.globrunqputhead",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func globrunqputhead(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc globrunqputhead(gp *g)\n```\n\nPut gp at the head of the global runnable queue. sched.lock must be held. May run during STW, so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#globrunqputbatch",
              "documentation": {
                "identifier": "globrunqputbatch",
                "newPage": false,
                "searchKey": "runtime.globrunqputbatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func globrunqputbatch(batch *gQueue, n int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc globrunqputbatch(batch *gQueue, n int32)\n```\n\nPut a batch of runnable goroutines on the global runnable queue. This clears *batch. sched.lock must be held. May run during STW, so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#updateTimerPMask",
              "documentation": {
                "identifier": "updateTimerPMask",
                "newPage": false,
                "searchKey": "runtime.updateTimerPMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func updateTimerPMask(pp *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc updateTimerPMask(pp *p)\n```\n\nupdateTimerPMask clears pp's timer mask if it has no timers on its heap. \n\nIdeally, the timer mask would be kept immediately consistent on any timer operations. Unfortunately, updating a shared global data structure in the timer hot path adds too much overhead in applications frequently switching between no timers and some timers. \n\nAs a compromise, the timer mask is updated only on pidleget / pidleput. A running P (returned by pidleget) may add a timer at any time, so its mask must be set. An idle P (passed to pidleput) cannot add new timers while idle, so if it has no timers at that time, its mask may be cleared. \n\nThus, we get the following effects on timer-stealing in findrunnable: \n\n* Idle Ps with no timers when they go idle are never checked in findrunnable \n\n```\n(for work- or timer-stealing; this is the ideal case).\n\n```\n* Running Ps must always be checked. * Idle Ps whose timers are stolen must continue to be checked until they run \n\n```\nagain, even after timer expiration.\n\n```\nWhen the P starts running again, the mask should be set, as a timer may be added at any time. \n\nTODO(prattmic): Additional targeted updates may improve the above cases. e.g., updating the mask when stealing a timer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pidleput",
              "documentation": {
                "identifier": "pidleput",
                "newPage": false,
                "searchKey": "runtime.pidleput",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pidleput(_p_ *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pidleput(_p_ *p)\n```\n\npidleput puts p to on the _Pidle list. \n\nThis releases ownership of p. Once sched.lock is released it is no longer safe to use p. \n\nsched.lock must be held. \n\nMay run during STW, so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runqempty",
              "documentation": {
                "identifier": "runqempty",
                "newPage": false,
                "searchKey": "runtime.runqempty",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runqempty(_p_ *p) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runqempty(_p_ *p) bool\n```\n\nrunqempty reports whether _p_ has no Gs on its local run queue. It never returns true spuriously. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runqput",
              "documentation": {
                "identifier": "runqput",
                "newPage": false,
                "searchKey": "runtime.runqput",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runqput(_p_ *p, gp *g, next bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runqput(_p_ *p, gp *g, next bool)\n```\n\nrunqput tries to put g on the local runnable queue. If next is false, runqput adds g to the tail of the runnable queue. If next is true, runqput puts g in the _p_.runnext slot. If the run queue is full, runnext puts g on the global queue. Executed only by the owner P. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runqputslow",
              "documentation": {
                "identifier": "runqputslow",
                "newPage": false,
                "searchKey": "runtime.runqputslow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runqputslow(_p_ *p, gp *g, h, t uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runqputslow(_p_ *p, gp *g, h, t uint32) bool\n```\n\nPut g and a batch of work from local runnable queue on global queue. Executed only by the owner P. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runqputbatch",
              "documentation": {
                "identifier": "runqputbatch",
                "newPage": false,
                "searchKey": "runtime.runqputbatch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runqputbatch(pp *p, q *gQueue, qsize int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runqputbatch(pp *p, q *gQueue, qsize int)\n```\n\nrunqputbatch tries to put all the G's on q on the local runnable queue. If the queue is full, they are put on the global queue; in that case this will temporarily acquire the scheduler lock. Executed only by the owner P. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runqgrab",
              "documentation": {
                "identifier": "runqgrab",
                "newPage": false,
                "searchKey": "runtime.runqgrab",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32\n```\n\nGrabs a batch of goroutines from _p_'s runnable queue into batch. Batch is a ring buffer starting at batchHead. Returns number of grabbed goroutines. Can be executed by any P. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setMaxThreads",
              "documentation": {
                "identifier": "setMaxThreads",
                "newPage": false,
                "searchKey": "runtime.setMaxThreads",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setMaxThreads(in int) (out int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setMaxThreads(in int) (out int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#procPin",
              "documentation": {
                "identifier": "procPin",
                "newPage": false,
                "searchKey": "runtime.procPin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func procPin() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc procPin() int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#procUnpin",
              "documentation": {
                "identifier": "procUnpin",
                "newPage": false,
                "searchKey": "runtime.procUnpin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func procUnpin()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc procUnpin()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_runtime_procPin",
              "documentation": {
                "identifier": "sync_runtime_procPin",
                "newPage": false,
                "searchKey": "runtime.sync_runtime_procPin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_runtime_procPin() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_runtime_procPin() int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_runtime_procUnpin",
              "documentation": {
                "identifier": "sync_runtime_procUnpin",
                "newPage": false,
                "searchKey": "runtime.sync_runtime_procUnpin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_runtime_procUnpin()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_runtime_procUnpin()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_atomic_runtime_procPin",
              "documentation": {
                "identifier": "sync_atomic_runtime_procPin",
                "newPage": false,
                "searchKey": "runtime.sync_atomic_runtime_procPin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_atomic_runtime_procPin() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_atomic_runtime_procPin() int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_atomic_runtime_procUnpin",
              "documentation": {
                "identifier": "sync_atomic_runtime_procUnpin",
                "newPage": false,
                "searchKey": "runtime.sync_atomic_runtime_procUnpin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_atomic_runtime_procUnpin()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_atomic_runtime_procUnpin()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_runtime_canSpin",
              "documentation": {
                "identifier": "sync_runtime_canSpin",
                "newPage": false,
                "searchKey": "runtime.sync_runtime_canSpin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_runtime_canSpin(i int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_runtime_canSpin(i int) bool\n```\n\nActive spinning for sync.Mutex. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_runtime_doSpin",
              "documentation": {
                "identifier": "sync_runtime_doSpin",
                "newPage": false,
                "searchKey": "runtime.sync_runtime_doSpin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_runtime_doSpin()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_runtime_doSpin()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcd",
              "documentation": {
                "identifier": "gcd",
                "newPage": false,
                "searchKey": "runtime.gcd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcd(a, b uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcd(a, b uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#doInit",
              "documentation": {
                "identifier": "doInit",
                "newPage": false,
                "searchKey": "runtime.doInit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func doInit(t *initTask)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc doInit(t *initTask)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#countSub",
              "documentation": {
                "identifier": "countSub",
                "newPage": false,
                "searchKey": "runtime.countSub",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func countSub(x, y uint32) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc countSub(x, y uint32) int\n```\n\ncountSub subtracts two counts obtained from profIndex.dataCount or profIndex.tagCount, assuming that they are no more than 2^29 apart (guaranteed since they are never more than len(data) or len(tags) apart, respectively). tagCount wraps at 2^30, while dataCount wraps at 2^32. This function works for both. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtime_setProfLabel",
              "documentation": {
                "identifier": "runtime_setProfLabel",
                "newPage": false,
                "searchKey": "runtime.runtime_setProfLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtime_setProfLabel(labels unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtime_setProfLabel(labels unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtime_getProfLabel",
              "documentation": {
                "identifier": "runtime_getProfLabel",
                "newPage": false,
                "searchKey": "runtime.runtime_getProfLabel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtime_getProfLabel() unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtime_getProfLabel() unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raceReadObjectPC",
              "documentation": {
                "identifier": "raceReadObjectPC",
                "newPage": false,
                "searchKey": "runtime.raceReadObjectPC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raceReadObjectPC(t *_type, addr unsafe.Pointer, callerpc, pc uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raceReadObjectPC(t *_type, addr unsafe.Pointer, callerpc, pc uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raceWriteObjectPC",
              "documentation": {
                "identifier": "raceWriteObjectPC",
                "newPage": false,
                "searchKey": "runtime.raceWriteObjectPC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raceWriteObjectPC(t *_type, addr unsafe.Pointer, callerpc, pc uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raceWriteObjectPC(t *_type, addr unsafe.Pointer, callerpc, pc uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raceinit",
              "documentation": {
                "identifier": "raceinit",
                "newPage": false,
                "searchKey": "runtime.raceinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raceinit() (uintptr, uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raceinit() (uintptr, uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racefini",
              "documentation": {
                "identifier": "racefini",
                "newPage": false,
                "searchKey": "runtime.racefini",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racefini()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racefini()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raceproccreate",
              "documentation": {
                "identifier": "raceproccreate",
                "newPage": false,
                "searchKey": "runtime.raceproccreate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raceproccreate() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raceproccreate() uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raceprocdestroy",
              "documentation": {
                "identifier": "raceprocdestroy",
                "newPage": false,
                "searchKey": "runtime.raceprocdestroy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raceprocdestroy(ctx uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raceprocdestroy(ctx uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racemapshadow",
              "documentation": {
                "identifier": "racemapshadow",
                "newPage": false,
                "searchKey": "runtime.racemapshadow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racemapshadow(addr unsafe.Pointer, size uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racemapshadow(addr unsafe.Pointer, size uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racewritepc",
              "documentation": {
                "identifier": "racewritepc",
                "newPage": false,
                "searchKey": "runtime.racewritepc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racewritepc(addr unsafe.Pointer, callerpc, pc uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racewritepc(addr unsafe.Pointer, callerpc, pc uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racereadpc",
              "documentation": {
                "identifier": "racereadpc",
                "newPage": false,
                "searchKey": "runtime.racereadpc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racereadpc(addr unsafe.Pointer, callerpc, pc uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racereadpc(addr unsafe.Pointer, callerpc, pc uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racereadrangepc",
              "documentation": {
                "identifier": "racereadrangepc",
                "newPage": false,
                "searchKey": "runtime.racereadrangepc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racereadrangepc(addr unsafe.Pointer, sz, callerpc, pc uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racereadrangepc(addr unsafe.Pointer, sz, callerpc, pc uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racewriterangepc",
              "documentation": {
                "identifier": "racewriterangepc",
                "newPage": false,
                "searchKey": "runtime.racewriterangepc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racewriterangepc(addr unsafe.Pointer, sz, callerpc, pc uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racewriterangepc(addr unsafe.Pointer, sz, callerpc, pc uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raceacquire",
              "documentation": {
                "identifier": "raceacquire",
                "newPage": false,
                "searchKey": "runtime.raceacquire",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raceacquire(addr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raceacquire(addr unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raceacquireg",
              "documentation": {
                "identifier": "raceacquireg",
                "newPage": false,
                "searchKey": "runtime.raceacquireg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raceacquireg(gp *g, addr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raceacquireg(gp *g, addr unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raceacquirectx",
              "documentation": {
                "identifier": "raceacquirectx",
                "newPage": false,
                "searchKey": "runtime.raceacquirectx",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raceacquirectx(racectx uintptr, addr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raceacquirectx(racectx uintptr, addr unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racerelease",
              "documentation": {
                "identifier": "racerelease",
                "newPage": false,
                "searchKey": "runtime.racerelease",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racerelease(addr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racerelease(addr unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racereleaseg",
              "documentation": {
                "identifier": "racereleaseg",
                "newPage": false,
                "searchKey": "runtime.racereleaseg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racereleaseg(gp *g, addr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racereleaseg(gp *g, addr unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racereleaseacquire",
              "documentation": {
                "identifier": "racereleaseacquire",
                "newPage": false,
                "searchKey": "runtime.racereleaseacquire",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racereleaseacquire(addr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racereleaseacquire(addr unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racereleaseacquireg",
              "documentation": {
                "identifier": "racereleaseacquireg",
                "newPage": false,
                "searchKey": "runtime.racereleaseacquireg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racereleaseacquireg(gp *g, addr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racereleaseacquireg(gp *g, addr unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racereleasemerge",
              "documentation": {
                "identifier": "racereleasemerge",
                "newPage": false,
                "searchKey": "runtime.racereleasemerge",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racereleasemerge(addr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racereleasemerge(addr unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racereleasemergeg",
              "documentation": {
                "identifier": "racereleasemergeg",
                "newPage": false,
                "searchKey": "runtime.racereleasemergeg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racereleasemergeg(gp *g, addr unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racereleasemergeg(gp *g, addr unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racefingo",
              "documentation": {
                "identifier": "racefingo",
                "newPage": false,
                "searchKey": "runtime.racefingo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racefingo()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racefingo()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racemalloc",
              "documentation": {
                "identifier": "racemalloc",
                "newPage": false,
                "searchKey": "runtime.racemalloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racemalloc(p unsafe.Pointer, sz uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racemalloc(p unsafe.Pointer, sz uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racefree",
              "documentation": {
                "identifier": "racefree",
                "newPage": false,
                "searchKey": "runtime.racefree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racefree(p unsafe.Pointer, sz uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racefree(p unsafe.Pointer, sz uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racegostart",
              "documentation": {
                "identifier": "racegostart",
                "newPage": false,
                "searchKey": "runtime.racegostart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racegostart(pc uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racegostart(pc uintptr) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racegoend",
              "documentation": {
                "identifier": "racegoend",
                "newPage": false,
                "searchKey": "runtime.racegoend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racegoend()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racegoend()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#racectxend",
              "documentation": {
                "identifier": "racectxend",
                "newPage": false,
                "searchKey": "runtime.racectxend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func racectxend(racectx uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc racectxend(racectx uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setMaxStack",
              "documentation": {
                "identifier": "setMaxStack",
                "newPage": false,
                "searchKey": "runtime.setMaxStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setMaxStack(in int) (out int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setMaxStack(in int) (out int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setPanicOnFault",
              "documentation": {
                "identifier": "setPanicOnFault",
                "newPage": false,
                "searchKey": "runtime.setPanicOnFault",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setPanicOnFault(new bool) (old bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setPanicOnFault(new bool) (old bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#osRelax",
              "documentation": {
                "identifier": "osRelax",
                "newPage": false,
                "searchKey": "runtime.osRelax",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func osRelax(relax bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc osRelax(relax bool)\n```\n\nosRelax is called by the scheduler when transitioning to and from all Ps being idle. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tickspersecond",
              "documentation": {
                "identifier": "tickspersecond",
                "newPage": false,
                "searchKey": "runtime.tickspersecond",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tickspersecond() int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tickspersecond() int64\n```\n\nNote: Called by runtime/pprof in addition to runtime code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_runtime_envs",
              "documentation": {
                "identifier": "syscall_runtime_envs",
                "newPage": false,
                "searchKey": "runtime.syscall_runtime_envs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_runtime_envs() []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_runtime_envs() []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_Getpagesize",
              "documentation": {
                "identifier": "syscall_Getpagesize",
                "newPage": false,
                "searchKey": "runtime.syscall_Getpagesize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_Getpagesize() int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_Getpagesize() int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#os_runtime_args",
              "documentation": {
                "identifier": "os_runtime_args",
                "newPage": false,
                "searchKey": "runtime.os_runtime_args",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func os_runtime_args() []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc os_runtime_args() []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_Exit",
              "documentation": {
                "identifier": "syscall_Exit",
                "newPage": false,
                "searchKey": "runtime.syscall_Exit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_Exit(code int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_Exit(code int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gotraceback",
              "documentation": {
                "identifier": "gotraceback",
                "newPage": false,
                "searchKey": "runtime.gotraceback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gotraceback() (level int32, all, crash bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gotraceback() (level int32, all, crash bool)\n```\n\ngotraceback returns the current traceback settings. \n\nIf level is 0, suppress all tracebacks. If level is 1, show tracebacks, but exclude runtime frames. If level is 2, show tracebacks including runtime frames. If all is set, print all goroutine stacks. Otherwise, print just the current goroutine. If crash is set, crash (core dump, etc) after tracebacking. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#argv_index",
              "documentation": {
                "identifier": "argv_index",
                "newPage": false,
                "searchKey": "runtime.argv_index",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func argv_index(argv **byte, i int32) *byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc argv_index(argv **byte, i int32) *byte\n```\n\nnosplit for use in linux startup sysargs \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#args",
              "documentation": {
                "identifier": "args",
                "newPage": false,
                "searchKey": "runtime.args",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func args(c int32, v **byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc args(c int32, v **byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goargs",
              "documentation": {
                "identifier": "goargs",
                "newPage": false,
                "searchKey": "runtime.goargs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goargs()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goargs()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goenvs_unix",
              "documentation": {
                "identifier": "goenvs_unix",
                "newPage": false,
                "searchKey": "runtime.goenvs_unix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goenvs_unix()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goenvs_unix()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#environ",
              "documentation": {
                "identifier": "environ",
                "newPage": false,
                "searchKey": "runtime.environ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func environ() []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc environ() []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#testAtomic64",
              "documentation": {
                "identifier": "testAtomic64",
                "newPage": false,
                "searchKey": "runtime.testAtomic64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testAtomic64()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testAtomic64()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#check",
              "documentation": {
                "identifier": "check",
                "newPage": false,
                "searchKey": "runtime.check",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func check()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc check()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#parsedebugvars",
              "documentation": {
                "identifier": "parsedebugvars",
                "newPage": false,
                "searchKey": "runtime.parsedebugvars",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func parsedebugvars()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc parsedebugvars()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setTraceback",
              "documentation": {
                "identifier": "setTraceback",
                "newPage": false,
                "searchKey": "runtime.setTraceback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setTraceback(level string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setTraceback(level string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timediv",
              "documentation": {
                "identifier": "timediv",
                "newPage": false,
                "searchKey": "runtime.timediv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func timediv(v int64, div int32, rem *int32) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc timediv(v int64, div int32, rem *int32) int32\n```\n\nPoor mans 64-bit division. This is a very special function, do not use it if you are not sure what you are doing. int64 division is lowered into _divv() call on 386, which does not fit into nosplit functions. Handles overflow in a time-specific manner. This keeps us within no-split stack limits on 32-bit processors. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#releasem",
              "documentation": {
                "identifier": "releasem",
                "newPage": false,
                "searchKey": "runtime.releasem",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func releasem(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc releasem(mp *m)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_typelinks",
              "documentation": {
                "identifier": "reflect_typelinks",
                "newPage": false,
                "searchKey": "runtime.reflect_typelinks",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_typelinks() ([]unsafe.Pointer, [][]int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_typelinks() ([]unsafe.Pointer, [][]int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_resolveNameOff",
              "documentation": {
                "identifier": "reflect_resolveNameOff",
                "newPage": false,
                "searchKey": "runtime.reflect_resolveNameOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_resolveNameOff(ptrInModule unsafe.Pointer, off int32) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_resolveNameOff(ptrInModule unsafe.Pointer, off int32) unsafe.Pointer\n```\n\nreflect_resolveNameOff resolves a name offset from a base pointer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_resolveTypeOff",
              "documentation": {
                "identifier": "reflect_resolveTypeOff",
                "newPage": false,
                "searchKey": "runtime.reflect_resolveTypeOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_resolveTypeOff(rtype unsafe.Pointer, off int32) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_resolveTypeOff(rtype unsafe.Pointer, off int32) unsafe.Pointer\n```\n\nreflect_resolveTypeOff resolves an *rtype offset from a base type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_resolveTextOff",
              "documentation": {
                "identifier": "reflect_resolveTextOff",
                "newPage": false,
                "searchKey": "runtime.reflect_resolveTextOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_resolveTextOff(rtype unsafe.Pointer, off int32) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_resolveTextOff(rtype unsafe.Pointer, off int32) unsafe.Pointer\n```\n\nreflect_resolveTextOff resolves a function pointer offset from a base type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectlite_resolveNameOff",
              "documentation": {
                "identifier": "reflectlite_resolveNameOff",
                "newPage": false,
                "searchKey": "runtime.reflectlite_resolveNameOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectlite_resolveNameOff(ptrInModule unsafe.Pointer, off int32) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectlite_resolveNameOff(ptrInModule unsafe.Pointer, off int32) unsafe.Pointer\n```\n\nreflectlite_resolveNameOff resolves a name offset from a base pointer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectlite_resolveTypeOff",
              "documentation": {
                "identifier": "reflectlite_resolveTypeOff",
                "newPage": false,
                "searchKey": "runtime.reflectlite_resolveTypeOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectlite_resolveTypeOff(rtype unsafe.Pointer, off int32) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectlite_resolveTypeOff(rtype unsafe.Pointer, off int32) unsafe.Pointer\n```\n\nreflectlite_resolveTypeOff resolves an *rtype offset from a base type. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_addReflectOff",
              "documentation": {
                "identifier": "reflect_addReflectOff",
                "newPage": false,
                "searchKey": "runtime.reflect_addReflectOff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_addReflectOff(ptr unsafe.Pointer) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_addReflectOff(ptr unsafe.Pointer) int32\n```\n\nreflect_addReflectOff adds a pointer to the reflection offset lookup map. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setGNoWB",
              "documentation": {
                "identifier": "setGNoWB",
                "newPage": false,
                "searchKey": "runtime.setGNoWB",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setGNoWB(gp **g, new *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setGNoWB(gp **g, new *g)\n```\n\nsetGNoWB performs *gp = new without a write barrier. For times when it's impractical to use a guintptr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setMNoWB",
              "documentation": {
                "identifier": "setMNoWB",
                "newPage": false,
                "searchKey": "runtime.setMNoWB",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setMNoWB(mp **m, new *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setMNoWB(mp **m, new *m)\n```\n\nsetMNoWB performs *mp = new without a write barrier. For times when it's impractical to use an muintptr. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#extendRandom",
              "documentation": {
                "identifier": "extendRandom",
                "newPage": false,
                "searchKey": "runtime.extendRandom",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func extendRandom(r []byte, n int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc extendRandom(r []byte, n int)\n```\n\nextendRandom extends the random numbers in r[:n] to the whole slice r. Treats n<0 as n==0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#selectsetpc",
              "documentation": {
                "identifier": "selectsetpc",
                "newPage": false,
                "searchKey": "runtime.selectsetpc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func selectsetpc(pc *uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc selectsetpc(pc *uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sellock",
              "documentation": {
                "identifier": "sellock",
                "newPage": false,
                "searchKey": "runtime.sellock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sellock(scases []scase, lockorder []uint16)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sellock(scases []scase, lockorder []uint16)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#selunlock",
              "documentation": {
                "identifier": "selunlock",
                "newPage": false,
                "searchKey": "runtime.selunlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func selunlock(scases []scase, lockorder []uint16)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc selunlock(scases []scase, lockorder []uint16)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#selparkcommit",
              "documentation": {
                "identifier": "selparkcommit",
                "newPage": false,
                "searchKey": "runtime.selparkcommit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func selparkcommit(gp *g, _ unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc selparkcommit(gp *g, _ unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#block",
              "documentation": {
                "identifier": "block",
                "newPage": false,
                "searchKey": "runtime.block",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func block()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc block()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#selectgo",
              "documentation": {
                "identifier": "selectgo",
                "newPage": false,
                "searchKey": "runtime.selectgo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func selectgo(cas0 *scase, order0 *uint16, pc0 *uintptr, nsends, nrecvs int, block bool) (int, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc selectgo(cas0 *scase, order0 *uint16, pc0 *uintptr, nsends, nrecvs int, block bool) (int, bool)\n```\n\nselectgo implements the select statement. \n\ncas0 points to an array of type [ncases]scase, and order0 points to an array of type [2*ncases]uint16 where ncases must be <= 65536. Both reside on the goroutine's stack (regardless of any escaping in selectgo). \n\nFor race detector builds, pc0 points to an array of type [ncases]uintptr (also on the stack); for other builds, it's set to nil. \n\nselectgo returns the index of the chosen scase, which matches the ordinal position of its respective select{recv,send,default} call. Also, if the chosen scase was a receive operation, it reports whether a value was received. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_rselect",
              "documentation": {
                "identifier": "reflect_rselect",
                "newPage": false,
                "searchKey": "runtime.reflect_rselect",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_rselect(cases []runtimeSelect) (int, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_rselect(cases []runtimeSelect) (int, bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_runtime_Semacquire",
              "documentation": {
                "identifier": "sync_runtime_Semacquire",
                "newPage": false,
                "searchKey": "runtime.sync_runtime_Semacquire",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_runtime_Semacquire(addr *uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_runtime_Semacquire(addr *uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#poll_runtime_Semacquire",
              "documentation": {
                "identifier": "poll_runtime_Semacquire",
                "newPage": false,
                "searchKey": "runtime.poll_runtime_Semacquire",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func poll_runtime_Semacquire(addr *uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc poll_runtime_Semacquire(addr *uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_runtime_Semrelease",
              "documentation": {
                "identifier": "sync_runtime_Semrelease",
                "newPage": false,
                "searchKey": "runtime.sync_runtime_Semrelease",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_runtime_Semrelease(addr *uint32, handoff bool, skipframes int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_runtime_Semrelease(addr *uint32, handoff bool, skipframes int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_runtime_SemacquireMutex",
              "documentation": {
                "identifier": "sync_runtime_SemacquireMutex",
                "newPage": false,
                "searchKey": "runtime.sync_runtime_SemacquireMutex",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_runtime_SemacquireMutex(addr *uint32, lifo bool, skipframes int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_runtime_SemacquireMutex(addr *uint32, lifo bool, skipframes int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#poll_runtime_Semrelease",
              "documentation": {
                "identifier": "poll_runtime_Semrelease",
                "newPage": false,
                "searchKey": "runtime.poll_runtime_Semrelease",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func poll_runtime_Semrelease(addr *uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc poll_runtime_Semrelease(addr *uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readyWithTime",
              "documentation": {
                "identifier": "readyWithTime",
                "newPage": false,
                "searchKey": "runtime.readyWithTime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readyWithTime(s *sudog, traceskip int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readyWithTime(s *sudog, traceskip int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semacquire",
              "documentation": {
                "identifier": "semacquire",
                "newPage": false,
                "searchKey": "runtime.semacquire",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func semacquire(addr *uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc semacquire(addr *uint32)\n```\n\nCalled from runtime. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semacquire1",
              "documentation": {
                "identifier": "semacquire1",
                "newPage": false,
                "searchKey": "runtime.semacquire1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags, skipframes int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc semacquire1(addr *uint32, lifo bool, profile semaProfileFlags, skipframes int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semrelease",
              "documentation": {
                "identifier": "semrelease",
                "newPage": false,
                "searchKey": "runtime.semrelease",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func semrelease(addr *uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc semrelease(addr *uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#semrelease1",
              "documentation": {
                "identifier": "semrelease1",
                "newPage": false,
                "searchKey": "runtime.semrelease1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func semrelease1(addr *uint32, handoff bool, skipframes int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc semrelease1(addr *uint32, handoff bool, skipframes int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cansemacquire",
              "documentation": {
                "identifier": "cansemacquire",
                "newPage": false,
                "searchKey": "runtime.cansemacquire",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cansemacquire(addr *uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cansemacquire(addr *uint32) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#less",
              "documentation": {
                "identifier": "less",
                "newPage": false,
                "searchKey": "runtime.less",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func less(a, b uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc less(a, b uint32) bool\n```\n\nless checks if a < b, considering a & b running counts that may overflow the 32-bit range, and that their \"unwrapped\" difference is always less than 2^31. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notifyListAdd",
              "documentation": {
                "identifier": "notifyListAdd",
                "newPage": false,
                "searchKey": "runtime.notifyListAdd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func notifyListAdd(l *notifyList) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notifyListAdd(l *notifyList) uint32\n```\n\nnotifyListAdd adds the caller to a notify list such that it can receive notifications. The caller must eventually call notifyListWait to wait for such a notification, passing the returned ticket number. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notifyListWait",
              "documentation": {
                "identifier": "notifyListWait",
                "newPage": false,
                "searchKey": "runtime.notifyListWait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func notifyListWait(l *notifyList, t uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notifyListWait(l *notifyList, t uint32)\n```\n\nnotifyListWait waits for a notification. If one has been sent since notifyListAdd was called, it returns immediately. Otherwise, it blocks. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notifyListNotifyAll",
              "documentation": {
                "identifier": "notifyListNotifyAll",
                "newPage": false,
                "searchKey": "runtime.notifyListNotifyAll",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func notifyListNotifyAll(l *notifyList)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notifyListNotifyAll(l *notifyList)\n```\n\nnotifyListNotifyAll notifies all entries in the list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notifyListNotifyOne",
              "documentation": {
                "identifier": "notifyListNotifyOne",
                "newPage": false,
                "searchKey": "runtime.notifyListNotifyOne",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func notifyListNotifyOne(l *notifyList)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notifyListNotifyOne(l *notifyList)\n```\n\nnotifyListNotifyOne notifies one entry in the list. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#notifyListCheck",
              "documentation": {
                "identifier": "notifyListCheck",
                "newPage": false,
                "searchKey": "runtime.notifyListCheck",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func notifyListCheck(sz uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc notifyListCheck(sz uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_nanotime",
              "documentation": {
                "identifier": "sync_nanotime",
                "newPage": false,
                "searchKey": "runtime.sync_nanotime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_nanotime() int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_nanotime() int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dumpregs",
              "documentation": {
                "identifier": "dumpregs",
                "newPage": false,
                "searchKey": "runtime.dumpregs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dumpregs(c *sigctxt)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dumpregs(c *sigctxt)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#os_sigpipe",
              "documentation": {
                "identifier": "os_sigpipe",
                "newPage": false,
                "searchKey": "runtime.os_sigpipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func os_sigpipe()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc os_sigpipe()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#signame",
              "documentation": {
                "identifier": "signame",
                "newPage": false,
                "searchKey": "runtime.signame",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signame(sig uint32) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signame(sig uint32) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "runtime.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#initsig",
              "documentation": {
                "identifier": "initsig",
                "newPage": false,
                "searchKey": "runtime.initsig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func initsig(preinit bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc initsig(preinit bool)\n```\n\nInitialize signals. Called by libpreinit so runtime may not be initialized. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigInstallGoHandler",
              "documentation": {
                "identifier": "sigInstallGoHandler",
                "newPage": false,
                "searchKey": "runtime.sigInstallGoHandler",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigInstallGoHandler(sig uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigInstallGoHandler(sig uint32) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigenable",
              "documentation": {
                "identifier": "sigenable",
                "newPage": false,
                "searchKey": "runtime.sigenable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigenable(sig uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigenable(sig uint32)\n```\n\nsigenable enables the Go signal handler to catch the signal sig. It is only called while holding the os/signal.handlers lock, via os/signal.enableSignal and signal_enable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigdisable",
              "documentation": {
                "identifier": "sigdisable",
                "newPage": false,
                "searchKey": "runtime.sigdisable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigdisable(sig uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigdisable(sig uint32)\n```\n\nsigdisable disables the Go signal handler for the signal sig. It is only called while holding the os/signal.handlers lock, via os/signal.disableSignal and signal_disable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigignore",
              "documentation": {
                "identifier": "sigignore",
                "newPage": false,
                "searchKey": "runtime.sigignore",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigignore(sig uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigignore(sig uint32)\n```\n\nsigignore ignores the signal sig. It is only called while holding the os/signal.handlers lock, via os/signal.ignoreSignal and signal_ignore. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#clearSignalHandlers",
              "documentation": {
                "identifier": "clearSignalHandlers",
                "newPage": false,
                "searchKey": "runtime.clearSignalHandlers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func clearSignalHandlers()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc clearSignalHandlers()\n```\n\nclearSignalHandlers clears all signal handlers that are not ignored back to the default. This is called by the child after a fork, so that we can enable the signal mask for the exec without worrying about running a signal handler in the child. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setProcessCPUProfiler",
              "documentation": {
                "identifier": "setProcessCPUProfiler",
                "newPage": false,
                "searchKey": "runtime.setProcessCPUProfiler",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setProcessCPUProfiler(hz int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setProcessCPUProfiler(hz int32)\n```\n\nsetProcessCPUProfiler is called when the profiling timer changes. It is called with prof.lock held. hz is the new timer, and is 0 if profiling is being disabled. Enable or disable the signal as required for -buildmode=c-archive. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setThreadCPUProfiler",
              "documentation": {
                "identifier": "setThreadCPUProfiler",
                "newPage": false,
                "searchKey": "runtime.setThreadCPUProfiler",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setThreadCPUProfiler(hz int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setThreadCPUProfiler(hz int32)\n```\n\nsetThreadCPUProfiler makes any thread-specific changes required to implement profiling at a rate of hz. No changes required on Unix systems. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigpipe",
              "documentation": {
                "identifier": "sigpipe",
                "newPage": false,
                "searchKey": "runtime.sigpipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigpipe()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigpipe()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#doSigPreempt",
              "documentation": {
                "identifier": "doSigPreempt",
                "newPage": false,
                "searchKey": "runtime.doSigPreempt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func doSigPreempt(gp *g, ctxt *sigctxt)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc doSigPreempt(gp *g, ctxt *sigctxt)\n```\n\ndoSigPreempt handles a preemption signal on gp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#preemptM",
              "documentation": {
                "identifier": "preemptM",
                "newPage": false,
                "searchKey": "runtime.preemptM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func preemptM(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc preemptM(mp *m)\n```\n\npreemptM sends a preemption request to mp. This request may be handled asynchronously and may be coalesced with other requests to the M. When the request is received, if the running G or P are marked for preemption and the goroutine is at an asynchronous safe-point, it will preempt the goroutine. It always atomically increments mp.preemptGen after handling a preemption request. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigtrampgo",
              "documentation": {
                "identifier": "sigtrampgo",
                "newPage": false,
                "searchKey": "runtime.sigtrampgo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigtrampgo(sig uint32, info *siginfo, ctx unsafe.Pointer)\n```\n\nsigtrampgo is called from the signal handler function, sigtramp, written in assembly code. This is called by the signal handler, and the world may be stopped. \n\nIt must be nosplit because getg() is still the G that was running (if any) when the signal was delivered, but it's (usually) called on the gsignal stack. Until this switches the G to gsignal, the stack bounds check won't work. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#adjustSignalStack",
              "documentation": {
                "identifier": "adjustSignalStack",
                "newPage": false,
                "searchKey": "runtime.adjustSignalStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func adjustSignalStack(sig uint32, mp *m, gsigStack *gsignalStack) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc adjustSignalStack(sig uint32, mp *m, gsigStack *gsignalStack) bool\n```\n\nadjustSignalStack adjusts the current stack guard based on the stack pointer that is actually in use while handling a signal. We do this in case some non-Go code called sigaltstack. This reports whether the stack was adjusted, and if so stores the old signal stack in *gsigstack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sighandler",
              "documentation": {
                "identifier": "sighandler",
                "newPage": false,
                "searchKey": "runtime.sighandler",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g)\n```\n\nsighandler is invoked when a signal occurs. The global g will be set to a gsignal goroutine and we will be running on the alternate signal stack. The parameter g will be the value of the global g when the signal occurred. The sig, info, and ctxt parameters are from the system signal handler: they are the parameters passed when the SA is passed to the sigaction system call. \n\nThe garbage collector may have stopped the world, so write barriers are not allowed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigpanic",
              "documentation": {
                "identifier": "sigpanic",
                "newPage": false,
                "searchKey": "runtime.sigpanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigpanic()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigpanic()\n```\n\nsigpanic turns a synchronous signal into a run-time panic. If the signal handler sees a synchronous panic, it arranges the stack to look like the function where the signal occurred called sigpanic, sets the signal's PC value to sigpanic, and returns from the signal handler. The effect is that the program will act as though the function that got the signal simply called sigpanic instead. \n\nThis must NOT be nosplit because the linker doesn't know where sigpanic calls can be injected. \n\nThe signal handler must not inject a call to sigpanic if getg().throwsplit, since sigpanic may need to grow the stack. \n\nThis is exported via linkname to assembly in runtime/cgo. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dieFromSignal",
              "documentation": {
                "identifier": "dieFromSignal",
                "newPage": false,
                "searchKey": "runtime.dieFromSignal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dieFromSignal(sig uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dieFromSignal(sig uint32)\n```\n\ndieFromSignal kills the program with a signal. This provides the expected exit status for the shell. This is only called with fatal signals expected to kill the process. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raisebadsignal",
              "documentation": {
                "identifier": "raisebadsignal",
                "newPage": false,
                "searchKey": "runtime.raisebadsignal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raisebadsignal(sig uint32, c *sigctxt)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raisebadsignal(sig uint32, c *sigctxt)\n```\n\nraisebadsignal is called when a signal is received on a non-Go thread, and the Go program does not want to handle it (that is, the program has not called os/signal.Notify for the signal). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#crash",
              "documentation": {
                "identifier": "crash",
                "newPage": false,
                "searchKey": "runtime.crash",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func crash()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc crash()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ensureSigM",
              "documentation": {
                "identifier": "ensureSigM",
                "newPage": false,
                "searchKey": "runtime.ensureSigM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ensureSigM()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ensureSigM()\n```\n\nensureSigM starts one global, sleeping thread to make sure at least one thread is available to catch signals enabled for os/signal. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#noSignalStack",
              "documentation": {
                "identifier": "noSignalStack",
                "newPage": false,
                "searchKey": "runtime.noSignalStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func noSignalStack(sig uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc noSignalStack(sig uint32)\n```\n\nThis is called when we receive a signal when there is no signal stack. This can only happen if non-Go code calls sigaltstack to disable the signal stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigNotOnStack",
              "documentation": {
                "identifier": "sigNotOnStack",
                "newPage": false,
                "searchKey": "runtime.sigNotOnStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigNotOnStack(sig uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigNotOnStack(sig uint32)\n```\n\nThis is called if we receive a signal when there is a signal stack but we are not on it. This can only happen if non-Go code called sigaction without setting the SS_ONSTACK flag. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#signalDuringFork",
              "documentation": {
                "identifier": "signalDuringFork",
                "newPage": false,
                "searchKey": "runtime.signalDuringFork",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signalDuringFork(sig uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signalDuringFork(sig uint32)\n```\n\nsignalDuringFork is called if we receive a signal while doing a fork. We do not want signals at that time, as a signal sent to the process group may be delivered to the child process, causing confusion. This should never be called, because we block signals across the fork; this function is just a safety check. See issue 18600 for background. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badsignal",
              "documentation": {
                "identifier": "badsignal",
                "newPage": false,
                "searchKey": "runtime.badsignal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badsignal(sig uintptr, c *sigctxt)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badsignal(sig uintptr, c *sigctxt)\n```\n\nThis runs on a foreign stack, without an m or a g. No stack split. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigfwd",
              "documentation": {
                "identifier": "sigfwd",
                "newPage": false,
                "searchKey": "runtime.sigfwd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigfwd(fn uintptr, sig uint32, info *siginfo, ctx unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigfwd(fn uintptr, sig uint32, info *siginfo, ctx unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigfwdgo",
              "documentation": {
                "identifier": "sigfwdgo",
                "newPage": false,
                "searchKey": "runtime.sigfwdgo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigfwdgo(sig uint32, info *siginfo, ctx unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigfwdgo(sig uint32, info *siginfo, ctx unsafe.Pointer) bool\n```\n\nDetermines if the signal should be handled by Go and if not, forwards the signal to the handler that was installed before Go's. Returns whether the signal was forwarded. This is called by the signal handler, and the world may be stopped. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigsave",
              "documentation": {
                "identifier": "sigsave",
                "newPage": false,
                "searchKey": "runtime.sigsave",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigsave(p *sigset)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigsave(p *sigset)\n```\n\nsigsave saves the current thread's signal mask into *p. This is used to preserve the non-Go signal mask when a non-Go thread calls a Go function. This is nosplit and nowritebarrierrec because it is called by needm which may be called on a non-Go thread with no g available. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#msigrestore",
              "documentation": {
                "identifier": "msigrestore",
                "newPage": false,
                "searchKey": "runtime.msigrestore",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func msigrestore(sigmask sigset)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc msigrestore(sigmask sigset)\n```\n\nmsigrestore sets the current thread's signal mask to sigmask. This is used to restore the non-Go signal mask when a non-Go thread calls a Go function. This is nosplit and nowritebarrierrec because it is called by dropm after g has been cleared. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigblock",
              "documentation": {
                "identifier": "sigblock",
                "newPage": false,
                "searchKey": "runtime.sigblock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigblock(exiting bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigblock(exiting bool)\n```\n\nsigblock blocks signals in the current thread's signal mask. This is used to block signals while setting up and tearing down g when a non-Go thread calls a Go function. When a thread is exiting we use the sigsetAllExiting value, otherwise the OS specific definition of sigset_all is used. This is nosplit and nowritebarrierrec because it is called by needm which may be called on a non-Go thread with no g available. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unblocksig",
              "documentation": {
                "identifier": "unblocksig",
                "newPage": false,
                "searchKey": "runtime.unblocksig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unblocksig(sig uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unblocksig(sig uint32)\n```\n\nunblocksig removes sig from the current thread's signal mask. This is nosplit and nowritebarrierrec because it is called from dieFromSignal, which can be called by sigfwdgo while running in the signal handler, on the signal stack, with no g available. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minitSignals",
              "documentation": {
                "identifier": "minitSignals",
                "newPage": false,
                "searchKey": "runtime.minitSignals",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func minitSignals()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc minitSignals()\n```\n\nminitSignals is called when initializing a new m to set the thread's alternate signal stack and signal mask. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minitSignalStack",
              "documentation": {
                "identifier": "minitSignalStack",
                "newPage": false,
                "searchKey": "runtime.minitSignalStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func minitSignalStack()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc minitSignalStack()\n```\n\nminitSignalStack is called when initializing a new m to set the alternate signal stack. If the alternate signal stack is not set for the thread (the normal case) then set the alternate signal stack to the gsignal stack. If the alternate signal stack is set for the thread (the case when a non-Go thread sets the alternate signal stack and then calls a Go function) then set the gsignal stack to the alternate signal stack. We also set the alternate signal stack to the gsignal stack if cgo is not used (regardless of whether it is already set). Record which choice was made in newSigstack, so that it can be undone in unminit. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#minitSignalMask",
              "documentation": {
                "identifier": "minitSignalMask",
                "newPage": false,
                "searchKey": "runtime.minitSignalMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func minitSignalMask()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc minitSignalMask()\n```\n\nminitSignalMask is called when initializing a new m to set the thread's signal mask. When this is called all signals have been blocked for the thread.  This starts with m.sigmask, which was set either from initSigmask for a newly created thread or by calling sigsave if this is a non-Go thread calling a Go function. It removes all essential signals from the mask, thus causing those signals to not be blocked. Then it sets the thread's signal mask. After this is called the thread can receive signals. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unminitSignals",
              "documentation": {
                "identifier": "unminitSignals",
                "newPage": false,
                "searchKey": "runtime.unminitSignals",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unminitSignals()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unminitSignals()\n```\n\nunminitSignals is called from dropm, via unminit, to undo the effect of calling minit on a non-Go thread. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#blockableSig",
              "documentation": {
                "identifier": "blockableSig",
                "newPage": false,
                "searchKey": "runtime.blockableSig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func blockableSig(sig uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc blockableSig(sig uint32) bool\n```\n\nblockableSig reports whether sig may be blocked by the signal mask. We never want to block the signals marked _SigUnblock; these are the synchronous signals that turn into a Go panic. In a Go program--not a c-archive/c-shared--we never want to block the signals marked _SigKill or _SigThrow, as otherwise it's possible for all running threads to block them and delay their delivery until we start a new thread. When linked into a C program we let the C code decide on the disposition of those signals. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setGsignalStack",
              "documentation": {
                "identifier": "setGsignalStack",
                "newPage": false,
                "searchKey": "runtime.setGsignalStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setGsignalStack(st *stackt, old *gsignalStack)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setGsignalStack(st *stackt, old *gsignalStack)\n```\n\nsetGsignalStack sets the gsignal stack of the current m to an alternate signal stack returned from the sigaltstack system call. It saves the old values in *old for use by restoreGsignalStack. This is used when handling a signal if non-Go code has set the alternate signal stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#restoreGsignalStack",
              "documentation": {
                "identifier": "restoreGsignalStack",
                "newPage": false,
                "searchKey": "runtime.restoreGsignalStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func restoreGsignalStack(st *gsignalStack)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc restoreGsignalStack(st *gsignalStack)\n```\n\nrestoreGsignalStack restores the gsignal stack to the value it had before entering the signal handler. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#signalstack",
              "documentation": {
                "identifier": "signalstack",
                "newPage": false,
                "searchKey": "runtime.signalstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signalstack(s *stack)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signalstack(s *stack)\n```\n\nsignalstack sets the current thread's alternate signal stack to s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setsigsegv",
              "documentation": {
                "identifier": "setsigsegv",
                "newPage": false,
                "searchKey": "runtime.setsigsegv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setsigsegv(pc uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setsigsegv(pc uintptr)\n```\n\nsetsigsegv is used on darwin/arm64 to fake a segmentation fault. \n\nThis is exported via linkname to assembly in runtime/cgo. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigsend",
              "documentation": {
                "identifier": "sigsend",
                "newPage": false,
                "searchKey": "runtime.sigsend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigsend(s uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigsend(s uint32) bool\n```\n\nsigsend delivers a signal from sighandler to the internal signal delivery queue. It reports whether the signal was sent. If not, the caller typically crashes the program. It runs from the signal handler, so it's limited in what it can do. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigRecvPrepareForFixup",
              "documentation": {
                "identifier": "sigRecvPrepareForFixup",
                "newPage": false,
                "searchKey": "runtime.sigRecvPrepareForFixup",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigRecvPrepareForFixup()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigRecvPrepareForFixup()\n```\n\nsigRecvPrepareForFixup is used to temporarily wake up the signal_recv() running thread while it is blocked waiting for the arrival of a signal. If it causes the thread to wake up, the sig.state travels through this sequence: sigReceiving -> sigFixup -> sigIdle -> sigReceiving and resumes. (This is only called while GC is disabled.) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#signal_recv",
              "documentation": {
                "identifier": "signal_recv",
                "newPage": false,
                "searchKey": "runtime.signal_recv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signal_recv() uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signal_recv() uint32\n```\n\nCalled to receive the next queued signal. Must only be called from a single goroutine at a time. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#signalWaitUntilIdle",
              "documentation": {
                "identifier": "signalWaitUntilIdle",
                "newPage": false,
                "searchKey": "runtime.signalWaitUntilIdle",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signalWaitUntilIdle()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signalWaitUntilIdle()\n```\n\nsignalWaitUntilIdle waits until the signal delivery mechanism is idle. This is used to ensure that we do not drop a signal notification due to a race between disabling a signal and receiving a signal. This assumes that signal delivery has already been disabled for the signal(s) in question, and here we are just waiting to make sure that all the signals have been delivered to the user channels by the os/signal package. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#signal_enable",
              "documentation": {
                "identifier": "signal_enable",
                "newPage": false,
                "searchKey": "runtime.signal_enable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signal_enable(s uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signal_enable(s uint32)\n```\n\nMust only be called from a single goroutine at a time. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#signal_disable",
              "documentation": {
                "identifier": "signal_disable",
                "newPage": false,
                "searchKey": "runtime.signal_disable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signal_disable(s uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signal_disable(s uint32)\n```\n\nMust only be called from a single goroutine at a time. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#signal_ignore",
              "documentation": {
                "identifier": "signal_ignore",
                "newPage": false,
                "searchKey": "runtime.signal_ignore",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signal_ignore(s uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signal_ignore(s uint32)\n```\n\nMust only be called from a single goroutine at a time. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigInitIgnored",
              "documentation": {
                "identifier": "sigInitIgnored",
                "newPage": false,
                "searchKey": "runtime.sigInitIgnored",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigInitIgnored(s uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigInitIgnored(s uint32)\n```\n\nsigInitIgnored marks the signal as already ignored. This is called at program start by initsig. In a shared library initsig is called by libpreinit, so the runtime may not be initialized yet. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#signal_ignored",
              "documentation": {
                "identifier": "signal_ignored",
                "newPage": false,
                "searchKey": "runtime.signal_ignored",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func signal_ignored(s uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc signal_ignored(s uint32) bool\n```\n\nChecked by signal handlers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicmakeslicelen",
              "documentation": {
                "identifier": "panicmakeslicelen",
                "newPage": false,
                "searchKey": "runtime.panicmakeslicelen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicmakeslicelen()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicmakeslicelen()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicmakeslicecap",
              "documentation": {
                "identifier": "panicmakeslicecap",
                "newPage": false,
                "searchKey": "runtime.panicmakeslicecap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicmakeslicecap()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicmakeslicecap()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#makeslicecopy",
              "documentation": {
                "identifier": "makeslicecopy",
                "newPage": false,
                "searchKey": "runtime.makeslicecopy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makeslicecopy(et *_type, tolen int, fromlen int, from unsafe.Pointer) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makeslicecopy(et *_type, tolen int, fromlen int, from unsafe.Pointer) unsafe.Pointer\n```\n\nmakeslicecopy allocates a slice of \"tolen\" elements of type \"et\", then copies \"fromlen\" elements of type \"et\" into that new allocation from \"from\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#makeslice",
              "documentation": {
                "identifier": "makeslice",
                "newPage": false,
                "searchKey": "runtime.makeslice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makeslice(et *_type, len, cap int) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makeslice(et *_type, len, cap int) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#makeslice64",
              "documentation": {
                "identifier": "makeslice64",
                "newPage": false,
                "searchKey": "runtime.makeslice64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unsafeslice",
              "documentation": {
                "identifier": "unsafeslice",
                "newPage": false,
                "searchKey": "runtime.unsafeslice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unsafeslice(et *_type, len int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unsafeslice(et *_type, len int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unsafeslice64",
              "documentation": {
                "identifier": "unsafeslice64",
                "newPage": false,
                "searchKey": "runtime.unsafeslice64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unsafeslice64(et *_type, len64 int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unsafeslice64(et *_type, len64 int64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#panicunsafeslicelen",
              "documentation": {
                "identifier": "panicunsafeslicelen",
                "newPage": false,
                "searchKey": "runtime.panicunsafeslicelen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func panicunsafeslicelen()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc panicunsafeslicelen()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isPowerOfTwo",
              "documentation": {
                "identifier": "isPowerOfTwo",
                "newPage": false,
                "searchKey": "runtime.isPowerOfTwo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isPowerOfTwo(x uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isPowerOfTwo(x uintptr) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#slicecopy",
              "documentation": {
                "identifier": "slicecopy",
                "newPage": false,
                "searchKey": "runtime.slicecopy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func slicecopy(toPtr unsafe.Pointer, toLen int, fromPtr unsafe.Pointer, fromLen int, width uintptr) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc slicecopy(toPtr unsafe.Pointer, toLen int, fromPtr unsafe.Pointer, fromLen int, width uintptr) int\n```\n\nslicecopy is used to copy from a string or slice of pointerless elements into a slice. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funpack64",
              "documentation": {
                "identifier": "funpack64",
                "newPage": false,
                "searchKey": "runtime.funpack64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funpack64(f uint64) (sign, mant uint64, exp int, inf, nan bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funpack64(f uint64) (sign, mant uint64, exp int, inf, nan bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funpack32",
              "documentation": {
                "identifier": "funpack32",
                "newPage": false,
                "searchKey": "runtime.funpack32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funpack32(f uint32) (sign, mant uint32, exp int, inf, nan bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funpack32(f uint32) (sign, mant uint32, exp int, inf, nan bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fpack64",
              "documentation": {
                "identifier": "fpack64",
                "newPage": false,
                "searchKey": "runtime.fpack64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fpack64(sign, mant uint64, exp int, trunc uint64) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fpack64(sign, mant uint64, exp int, trunc uint64) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fpack32",
              "documentation": {
                "identifier": "fpack32",
                "newPage": false,
                "searchKey": "runtime.fpack32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fpack32(sign, mant uint32, exp int, trunc uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fpack32(sign, mant uint32, exp int, trunc uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fadd64",
              "documentation": {
                "identifier": "fadd64",
                "newPage": false,
                "searchKey": "runtime.fadd64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fadd64(f, g uint64) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fadd64(f, g uint64) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fsub64",
              "documentation": {
                "identifier": "fsub64",
                "newPage": false,
                "searchKey": "runtime.fsub64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fsub64(f, g uint64) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fsub64(f, g uint64) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fneg64",
              "documentation": {
                "identifier": "fneg64",
                "newPage": false,
                "searchKey": "runtime.fneg64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fneg64(f uint64) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fneg64(f uint64) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fmul64",
              "documentation": {
                "identifier": "fmul64",
                "newPage": false,
                "searchKey": "runtime.fmul64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fmul64(f, g uint64) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fmul64(f, g uint64) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fdiv64",
              "documentation": {
                "identifier": "fdiv64",
                "newPage": false,
                "searchKey": "runtime.fdiv64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fdiv64(f, g uint64) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fdiv64(f, g uint64) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f64to32",
              "documentation": {
                "identifier": "f64to32",
                "newPage": false,
                "searchKey": "runtime.f64to32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f64to32(f uint64) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f64to32(f uint64) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f32to64",
              "documentation": {
                "identifier": "f32to64",
                "newPage": false,
                "searchKey": "runtime.f32to64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f32to64(f uint32) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f32to64(f uint32) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fcmp64",
              "documentation": {
                "identifier": "fcmp64",
                "newPage": false,
                "searchKey": "runtime.fcmp64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fcmp64(f, g uint64) (cmp int32, isnan bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fcmp64(f, g uint64) (cmp int32, isnan bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f64toint",
              "documentation": {
                "identifier": "f64toint",
                "newPage": false,
                "searchKey": "runtime.f64toint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f64toint(f uint64) (val int64, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f64toint(f uint64) (val int64, ok bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fintto64",
              "documentation": {
                "identifier": "fintto64",
                "newPage": false,
                "searchKey": "runtime.fintto64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fintto64(val int64) (f uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fintto64(val int64) (f uint64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mullu",
              "documentation": {
                "identifier": "mullu",
                "newPage": false,
                "searchKey": "runtime.mullu",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mullu(u, v uint64) (lo, hi uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mullu(u, v uint64) (lo, hi uint64)\n```\n\n64x64 -> 128 multiply. adapted from hacker's delight. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#divlu",
              "documentation": {
                "identifier": "divlu",
                "newPage": false,
                "searchKey": "runtime.divlu",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func divlu(u1, u0, v uint64) (q, r uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc divlu(u1, u0, v uint64) (q, r uint64)\n```\n\n128/64 -> 64 quotient, 64 remainder. adapted from hacker's delight \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fadd32",
              "documentation": {
                "identifier": "fadd32",
                "newPage": false,
                "searchKey": "runtime.fadd32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fadd32(x, y uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fadd32(x, y uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fmul32",
              "documentation": {
                "identifier": "fmul32",
                "newPage": false,
                "searchKey": "runtime.fmul32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fmul32(x, y uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fmul32(x, y uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fdiv32",
              "documentation": {
                "identifier": "fdiv32",
                "newPage": false,
                "searchKey": "runtime.fdiv32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fdiv32(x, y uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fdiv32(x, y uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#feq32",
              "documentation": {
                "identifier": "feq32",
                "newPage": false,
                "searchKey": "runtime.feq32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func feq32(x, y uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc feq32(x, y uint32) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fgt32",
              "documentation": {
                "identifier": "fgt32",
                "newPage": false,
                "searchKey": "runtime.fgt32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fgt32(x, y uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fgt32(x, y uint32) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fge32",
              "documentation": {
                "identifier": "fge32",
                "newPage": false,
                "searchKey": "runtime.fge32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fge32(x, y uint32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fge32(x, y uint32) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#feq64",
              "documentation": {
                "identifier": "feq64",
                "newPage": false,
                "searchKey": "runtime.feq64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func feq64(x, y uint64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc feq64(x, y uint64) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fgt64",
              "documentation": {
                "identifier": "fgt64",
                "newPage": false,
                "searchKey": "runtime.fgt64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fgt64(x, y uint64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fgt64(x, y uint64) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fge64",
              "documentation": {
                "identifier": "fge64",
                "newPage": false,
                "searchKey": "runtime.fge64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fge64(x, y uint64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fge64(x, y uint64) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fint32to32",
              "documentation": {
                "identifier": "fint32to32",
                "newPage": false,
                "searchKey": "runtime.fint32to32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fint32to32(x int32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fint32to32(x int32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fint32to64",
              "documentation": {
                "identifier": "fint32to64",
                "newPage": false,
                "searchKey": "runtime.fint32to64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fint32to64(x int32) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fint32to64(x int32) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fint64to32",
              "documentation": {
                "identifier": "fint64to32",
                "newPage": false,
                "searchKey": "runtime.fint64to32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fint64to32(x int64) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fint64to32(x int64) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fint64to64",
              "documentation": {
                "identifier": "fint64to64",
                "newPage": false,
                "searchKey": "runtime.fint64to64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fint64to64(x int64) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fint64to64(x int64) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f32toint32",
              "documentation": {
                "identifier": "f32toint32",
                "newPage": false,
                "searchKey": "runtime.f32toint32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f32toint32(x uint32) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f32toint32(x uint32) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f32toint64",
              "documentation": {
                "identifier": "f32toint64",
                "newPage": false,
                "searchKey": "runtime.f32toint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f32toint64(x uint32) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f32toint64(x uint32) int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f64toint32",
              "documentation": {
                "identifier": "f64toint32",
                "newPage": false,
                "searchKey": "runtime.f64toint32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f64toint32(x uint64) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f64toint32(x uint64) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f64toint64",
              "documentation": {
                "identifier": "f64toint64",
                "newPage": false,
                "searchKey": "runtime.f64toint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f64toint64(x uint64) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f64toint64(x uint64) int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f64touint64",
              "documentation": {
                "identifier": "f64touint64",
                "newPage": false,
                "searchKey": "runtime.f64touint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f64touint64(x float64) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f64touint64(x float64) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#f32touint64",
              "documentation": {
                "identifier": "f32touint64",
                "newPage": false,
                "searchKey": "runtime.f32touint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func f32touint64(x float32) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc f32touint64(x float32) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fuint64to64",
              "documentation": {
                "identifier": "fuint64to64",
                "newPage": false,
                "searchKey": "runtime.fuint64to64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fuint64to64(x uint64) float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fuint64to64(x uint64) float64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fuint64to32",
              "documentation": {
                "identifier": "fuint64to32",
                "newPage": false,
                "searchKey": "runtime.fuint64to32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fuint64to32(x uint64) float32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fuint64to32(x uint64) float32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackinit",
              "documentation": {
                "identifier": "stackinit",
                "newPage": false,
                "searchKey": "runtime.stackinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stackinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stackinit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stacklog2",
              "documentation": {
                "identifier": "stacklog2",
                "newPage": false,
                "searchKey": "runtime.stacklog2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stacklog2(n uintptr) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stacklog2(n uintptr) int\n```\n\nstacklog2 returns ⌊log_2(n)⌋. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackpoolfree",
              "documentation": {
                "identifier": "stackpoolfree",
                "newPage": false,
                "searchKey": "runtime.stackpoolfree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stackpoolfree(x gclinkptr, order uint8)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stackpoolfree(x gclinkptr, order uint8)\n```\n\nAdds stack x to the free pool. Must be called with stackpool[order].item.mu held. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackcacherefill",
              "documentation": {
                "identifier": "stackcacherefill",
                "newPage": false,
                "searchKey": "runtime.stackcacherefill",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stackcacherefill(c *mcache, order uint8)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stackcacherefill(c *mcache, order uint8)\n```\n\nstackcacherefill/stackcacherelease implement a global pool of stack segments. The pool is required to prevent unlimited growth of per-thread caches. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackcacherelease",
              "documentation": {
                "identifier": "stackcacherelease",
                "newPage": false,
                "searchKey": "runtime.stackcacherelease",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stackcacherelease(c *mcache, order uint8)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stackcacherelease(c *mcache, order uint8)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackcache_clear",
              "documentation": {
                "identifier": "stackcache_clear",
                "newPage": false,
                "searchKey": "runtime.stackcache_clear",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stackcache_clear(c *mcache)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stackcache_clear(c *mcache)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackfree",
              "documentation": {
                "identifier": "stackfree",
                "newPage": false,
                "searchKey": "runtime.stackfree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stackfree(stk stack)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stackfree(stk stack)\n```\n\nstackfree frees an n byte stack allocation at stk. \n\nstackfree must run on the system stack because it uses per-P resources and must not split the stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#adjustpointer",
              "documentation": {
                "identifier": "adjustpointer",
                "newPage": false,
                "searchKey": "runtime.adjustpointer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func adjustpointer(adjinfo *adjustinfo, vpp unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc adjustpointer(adjinfo *adjustinfo, vpp unsafe.Pointer)\n```\n\nAdjustpointer checks whether *vpp is in the old stack described by adjinfo. If so, it rewrites *vpp to point into the new stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#adjustpointers",
              "documentation": {
                "identifier": "adjustpointers",
                "newPage": false,
                "searchKey": "runtime.adjustpointers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func adjustpointers(scanp unsafe.Pointer, bv *bitvector, adjinfo *adjustinfo, f funcInfo)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc adjustpointers(scanp unsafe.Pointer, bv *bitvector, adjinfo *adjustinfo, f funcInfo)\n```\n\nbv describes the memory starting at address scanp. Adjust any pointers contained therein. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#adjustframe",
              "documentation": {
                "identifier": "adjustframe",
                "newPage": false,
                "searchKey": "runtime.adjustframe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func adjustframe(frame *stkframe, arg unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc adjustframe(frame *stkframe, arg unsafe.Pointer) bool\n```\n\nNote: the argument/return area is adjusted by the callee. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#adjustctxt",
              "documentation": {
                "identifier": "adjustctxt",
                "newPage": false,
                "searchKey": "runtime.adjustctxt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func adjustctxt(gp *g, adjinfo *adjustinfo)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc adjustctxt(gp *g, adjinfo *adjustinfo)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#adjustdefers",
              "documentation": {
                "identifier": "adjustdefers",
                "newPage": false,
                "searchKey": "runtime.adjustdefers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func adjustdefers(gp *g, adjinfo *adjustinfo)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc adjustdefers(gp *g, adjinfo *adjustinfo)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#adjustpanics",
              "documentation": {
                "identifier": "adjustpanics",
                "newPage": false,
                "searchKey": "runtime.adjustpanics",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func adjustpanics(gp *g, adjinfo *adjustinfo)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc adjustpanics(gp *g, adjinfo *adjustinfo)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#adjustsudogs",
              "documentation": {
                "identifier": "adjustsudogs",
                "newPage": false,
                "searchKey": "runtime.adjustsudogs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func adjustsudogs(gp *g, adjinfo *adjustinfo)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc adjustsudogs(gp *g, adjinfo *adjustinfo)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fillstack",
              "documentation": {
                "identifier": "fillstack",
                "newPage": false,
                "searchKey": "runtime.fillstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fillstack(stk stack, b byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fillstack(stk stack, b byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#findsghi",
              "documentation": {
                "identifier": "findsghi",
                "newPage": false,
                "searchKey": "runtime.findsghi",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func findsghi(gp *g, stk stack) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc findsghi(gp *g, stk stack) uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syncadjustsudogs",
              "documentation": {
                "identifier": "syncadjustsudogs",
                "newPage": false,
                "searchKey": "runtime.syncadjustsudogs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syncadjustsudogs(gp *g, used uintptr, adjinfo *adjustinfo) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syncadjustsudogs(gp *g, used uintptr, adjinfo *adjustinfo) uintptr\n```\n\nsyncadjustsudogs adjusts gp's sudogs and copies the part of gp's stack they refer to while synchronizing with concurrent channel operations. It returns the number of bytes of stack copied. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#copystack",
              "documentation": {
                "identifier": "copystack",
                "newPage": false,
                "searchKey": "runtime.copystack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func copystack(gp *g, newsize uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc copystack(gp *g, newsize uintptr)\n```\n\nCopies gp's stack to a new stack of a different size. Caller must have changed gp status to Gcopystack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#round2",
              "documentation": {
                "identifier": "round2",
                "newPage": false,
                "searchKey": "runtime.round2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func round2(x int32) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc round2(x int32) int32\n```\n\nround x up to a power of 2. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#newstack",
              "documentation": {
                "identifier": "newstack",
                "newPage": false,
                "searchKey": "runtime.newstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func newstack()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc newstack()\n```\n\nCalled from runtime·morestack when more stack is needed. Allocate larger stack and relocate to new stack. Stack growth is multiplicative, for constant amortized cost. \n\ng->atomicstatus will be Grunning or Gscanrunning upon entry. If the scheduler is trying to stop this g, then it will set preemptStop. \n\nThis must be nowritebarrierrec because it can be called as part of stack growth from other nowritebarrierrec functions, but the compiler doesn't check this. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nilfunc",
              "documentation": {
                "identifier": "nilfunc",
                "newPage": false,
                "searchKey": "runtime.nilfunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nilfunc()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nilfunc()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gostartcallfn",
              "documentation": {
                "identifier": "gostartcallfn",
                "newPage": false,
                "searchKey": "runtime.gostartcallfn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gostartcallfn(gobuf *gobuf, fv *funcval)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gostartcallfn(gobuf *gobuf, fv *funcval)\n```\n\nadjust Gobuf as if it executed a call to fn and then stopped before the first instruction in fn. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isShrinkStackSafe",
              "documentation": {
                "identifier": "isShrinkStackSafe",
                "newPage": false,
                "searchKey": "runtime.isShrinkStackSafe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isShrinkStackSafe(gp *g) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isShrinkStackSafe(gp *g) bool\n```\n\nisShrinkStackSafe returns whether it's safe to attempt to shrink gp's stack. Shrinking the stack is only safe when we have precise pointer maps for all frames on the stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#shrinkstack",
              "documentation": {
                "identifier": "shrinkstack",
                "newPage": false,
                "searchKey": "runtime.shrinkstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func shrinkstack(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc shrinkstack(gp *g)\n```\n\nMaybe shrink the stack being used by gp. \n\ngp must be stopped and we must own its stack. It may be in _Grunning, but only if this is our own user G. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#freeStackSpans",
              "documentation": {
                "identifier": "freeStackSpans",
                "newPage": false,
                "searchKey": "runtime.freeStackSpans",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func freeStackSpans()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc freeStackSpans()\n```\n\nfreeStackSpans frees unused stack spans at the end of GC. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#init",
              "documentation": {
                "identifier": "init",
                "newPage": false,
                "searchKey": "runtime.init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func init()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc init()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#morestackc",
              "documentation": {
                "identifier": "morestackc",
                "newPage": false,
                "searchKey": "runtime.morestackc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func morestackc()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc morestackc()\n```\n\nThis is exported as ABI0 via linkname so obj can call it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#concatstrings",
              "documentation": {
                "identifier": "concatstrings",
                "newPage": false,
                "searchKey": "runtime.concatstrings",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func concatstrings(buf *tmpBuf, a []string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc concatstrings(buf *tmpBuf, a []string) string\n```\n\nconcatstrings implements a Go string concatenation x+y+z+... The operands are passed in the slice a. If buf != nil, the compiler has determined that the result does not escape the calling function, so the string data can be stored in buf if small enough. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#concatstring2",
              "documentation": {
                "identifier": "concatstring2",
                "newPage": false,
                "searchKey": "runtime.concatstring2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func concatstring2(buf *tmpBuf, a0, a1 string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc concatstring2(buf *tmpBuf, a0, a1 string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#concatstring3",
              "documentation": {
                "identifier": "concatstring3",
                "newPage": false,
                "searchKey": "runtime.concatstring3",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func concatstring3(buf *tmpBuf, a0, a1, a2 string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc concatstring3(buf *tmpBuf, a0, a1, a2 string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#concatstring4",
              "documentation": {
                "identifier": "concatstring4",
                "newPage": false,
                "searchKey": "runtime.concatstring4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func concatstring4(buf *tmpBuf, a0, a1, a2, a3 string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc concatstring4(buf *tmpBuf, a0, a1, a2, a3 string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#concatstring5",
              "documentation": {
                "identifier": "concatstring5",
                "newPage": false,
                "searchKey": "runtime.concatstring5",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func concatstring5(buf *tmpBuf, a0, a1, a2, a3, a4 string) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc concatstring5(buf *tmpBuf, a0, a1, a2, a3, a4 string) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#slicebytetostring",
              "documentation": {
                "identifier": "slicebytetostring",
                "newPage": false,
                "searchKey": "runtime.slicebytetostring",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string)\n```\n\nslicebytetostring converts a byte slice to a string. It is inserted by the compiler into generated code. ptr is a pointer to the first element of the slice; n is the length of the slice. Buf is a fixed-size buffer for the result, it is not nil if the result does not escape. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stringDataOnStack",
              "documentation": {
                "identifier": "stringDataOnStack",
                "newPage": false,
                "searchKey": "runtime.stringDataOnStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringDataOnStack(s string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringDataOnStack(s string) bool\n```\n\nstringDataOnStack reports whether the string's data is stored on the current goroutine's stack. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#rawstringtmp",
              "documentation": {
                "identifier": "rawstringtmp",
                "newPage": false,
                "searchKey": "runtime.rawstringtmp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rawstringtmp(buf *tmpBuf, l int) (s string, b []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#slicebytetostringtmp",
              "documentation": {
                "identifier": "slicebytetostringtmp",
                "newPage": false,
                "searchKey": "runtime.slicebytetostringtmp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func slicebytetostringtmp(ptr *byte, n int) (str string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc slicebytetostringtmp(ptr *byte, n int) (str string)\n```\n\nslicebytetostringtmp returns a \"string\" referring to the actual []byte bytes. \n\nCallers need to ensure that the returned string will not be used after the calling goroutine modifies the original slice or synchronizes with another goroutine. \n\nThe function is only called when instrumenting and otherwise intrinsified by the compiler. \n\nSome internal compiler optimizations use this function. - Used for m[T1{... Tn{..., string(k), ...} ...}] and m[string(k)] \n\n```\nwhere k is []byte, T1 to Tn is a nesting of struct and array literals.\n\n```\n- Used for \"<\"+string(b)+\">\" concatenation where b is []byte. - Used for string(b)==\"foo\" comparison where b is []byte. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stringtoslicebyte",
              "documentation": {
                "identifier": "stringtoslicebyte",
                "newPage": false,
                "searchKey": "runtime.stringtoslicebyte",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringtoslicebyte(buf *tmpBuf, s string) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringtoslicebyte(buf *tmpBuf, s string) []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stringtoslicerune",
              "documentation": {
                "identifier": "stringtoslicerune",
                "newPage": false,
                "searchKey": "runtime.stringtoslicerune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stringtoslicerune(buf *[tmpStringBufSize]rune, s string) []rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stringtoslicerune(buf *[tmpStringBufSize]rune, s string) []rune\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#slicerunetostring",
              "documentation": {
                "identifier": "slicerunetostring",
                "newPage": false,
                "searchKey": "runtime.slicerunetostring",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func slicerunetostring(buf *tmpBuf, a []rune) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc slicerunetostring(buf *tmpBuf, a []rune) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#intstring",
              "documentation": {
                "identifier": "intstring",
                "newPage": false,
                "searchKey": "runtime.intstring",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func intstring(buf *[4]byte, v int64) (s string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc intstring(buf *[4]byte, v int64) (s string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#rawstring",
              "documentation": {
                "identifier": "rawstring",
                "newPage": false,
                "searchKey": "runtime.rawstring",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func rawstring(size int) (s string, b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rawstring(size int) (s string, b []byte)\n```\n\nrawstring allocates storage for a new string. The returned string and byte slice both refer to the same storage. The storage is not zeroed. Callers should use b to set the string contents and then drop b. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#rawbyteslice",
              "documentation": {
                "identifier": "rawbyteslice",
                "newPage": false,
                "searchKey": "runtime.rawbyteslice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func rawbyteslice(size int) (b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rawbyteslice(size int) (b []byte)\n```\n\nrawbyteslice allocates a new byte slice. The byte slice is not zeroed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#rawruneslice",
              "documentation": {
                "identifier": "rawruneslice",
                "newPage": false,
                "searchKey": "runtime.rawruneslice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func rawruneslice(size int) (b []rune)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rawruneslice(size int) (b []rune)\n```\n\nrawruneslice allocates a new rune slice. The rune slice is not zeroed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gobytes",
              "documentation": {
                "identifier": "gobytes",
                "newPage": false,
                "searchKey": "runtime.gobytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gobytes(p *byte, n int) (b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gobytes(p *byte, n int) (b []byte)\n```\n\nused by cmd/cgo \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gostring",
              "documentation": {
                "identifier": "gostring",
                "newPage": false,
                "searchKey": "runtime.gostring",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gostring(p *byte) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gostring(p *byte) string\n```\n\nThis is exported via linkname to assembly in syscall (for Plan9). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gostringn",
              "documentation": {
                "identifier": "gostringn",
                "newPage": false,
                "searchKey": "runtime.gostringn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gostringn(p *byte, l int) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gostringn(p *byte, l int) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#hasPrefix",
              "documentation": {
                "identifier": "hasPrefix",
                "newPage": false,
                "searchKey": "runtime.hasPrefix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func hasPrefix(s, prefix string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc hasPrefix(s, prefix string) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#atoi",
              "documentation": {
                "identifier": "atoi",
                "newPage": false,
                "searchKey": "runtime.atoi",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func atoi(s string) (int, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc atoi(s string) (int, bool)\n```\n\natoi parses an int from a string s. The bool result reports whether s is a number representable by a value of type int. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#atoi32",
              "documentation": {
                "identifier": "atoi32",
                "newPage": false,
                "searchKey": "runtime.atoi32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func atoi32(s string) (int32, bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc atoi32(s string) (int32, bool)\n```\n\natoi32 is like atoi but for integers that fit into an int32. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#findnull",
              "documentation": {
                "identifier": "findnull",
                "newPage": false,
                "searchKey": "runtime.findnull",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func findnull(s *byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc findnull(s *byte) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#findnullw",
              "documentation": {
                "identifier": "findnullw",
                "newPage": false,
                "searchKey": "runtime.findnullw",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func findnullw(s *uint16) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc findnullw(s *uint16) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gostringnocopy",
              "documentation": {
                "identifier": "gostringnocopy",
                "newPage": false,
                "searchKey": "runtime.gostringnocopy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gostringnocopy(str *byte) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gostringnocopy(str *byte) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gostringw",
              "documentation": {
                "identifier": "gostringw",
                "newPage": false,
                "searchKey": "runtime.gostringw",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gostringw(strw *uint16) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gostringw(strw *uint16) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#add",
              "documentation": {
                "identifier": "add",
                "newPage": false,
                "searchKey": "runtime.add",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func add(p unsafe.Pointer, x uintptr) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc add(p unsafe.Pointer, x uintptr) unsafe.Pointer\n```\n\nShould be a built-in for unsafe.Pointer? \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mcall",
              "documentation": {
                "identifier": "mcall",
                "newPage": false,
                "searchKey": "runtime.mcall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mcall(fn func(*g))"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mcall(fn func(*g))\n```\n\nmcall switches from the g to the g0 stack and invokes fn(g), where g is the goroutine that made the call. mcall saves g's current PC/SP in g->sched so that it can be restored later. It is up to fn to arrange for that later execution, typically by recording g in a data structure, causing something to call ready(g) later. mcall returns to the original goroutine g later, when g has been rescheduled. fn must not return at all; typically it ends by calling schedule, to let the m run other goroutines. \n\nmcall can only be called from g stacks (not g0, not gsignal). \n\nThis must NOT be go:noescape: if fn is a stack-allocated closure, fn puts g on a run queue, and g executes before fn returns, the closure will be invalidated while it is still executing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#systemstack",
              "documentation": {
                "identifier": "systemstack",
                "newPage": false,
                "searchKey": "runtime.systemstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func systemstack(fn func())"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc systemstack(fn func())\n```\n\nsystemstack runs fn on a system stack. If systemstack is called from the per-OS-thread (g0) stack, or if systemstack is called from the signal handling (gsignal) stack, systemstack calls fn directly and returns. Otherwise, systemstack is being called from the limited stack of an ordinary goroutine. In this case, systemstack switches to the per-OS-thread stack, calls fn, and switches back. It is common to use a func literal as the argument, in order to share inputs and outputs with the code around the call to system stack: \n\n```\n... set up y ...\nsystemstack(func() {\n\tx = bigcall(y)\n})\n... use x ...\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badsystemstack",
              "documentation": {
                "identifier": "badsystemstack",
                "newPage": false,
                "searchKey": "runtime.badsystemstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badsystemstack()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badsystemstack()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memclrNoHeapPointers",
              "documentation": {
                "identifier": "memclrNoHeapPointers",
                "newPage": false,
                "searchKey": "runtime.memclrNoHeapPointers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memclrNoHeapPointers(ptr unsafe.Pointer, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memclrNoHeapPointers(ptr unsafe.Pointer, n uintptr)\n```\n\nmemclrNoHeapPointers clears n bytes starting at ptr. \n\nUsually you should use typedmemclr. memclrNoHeapPointers should be used only when the caller knows that *ptr contains no heap pointers because either: \n\n*ptr is initialized memory and its type is pointer-free, or \n\n*ptr is uninitialized memory (e.g., memory that's being reused for a new allocation) and hence contains only \"junk\". \n\nmemclrNoHeapPointers ensures that if ptr is pointer-aligned, and n is a multiple of the pointer size, then any pointer-aligned, pointer-sized portion is cleared atomically. Despite the function name, this is necessary because this function is the underlying implementation of typedmemclr and memclrHasPointers. See the doc of memmove for more details. \n\nThe (CPU-specific) implementations of this function are in memclr_*.s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_memclrNoHeapPointers",
              "documentation": {
                "identifier": "reflect_memclrNoHeapPointers",
                "newPage": false,
                "searchKey": "runtime.reflect_memclrNoHeapPointers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_memclrNoHeapPointers(ptr unsafe.Pointer, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_memclrNoHeapPointers(ptr unsafe.Pointer, n uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memmove",
              "documentation": {
                "identifier": "memmove",
                "newPage": false,
                "searchKey": "runtime.memmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memmove(to, from unsafe.Pointer, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memmove(to, from unsafe.Pointer, n uintptr)\n```\n\nmemmove copies n bytes from \"from\" to \"to\". \n\nmemmove ensures that any pointer in \"from\" is written to \"to\" with an indivisible write, so that racy reads cannot observe a half-written pointer. This is necessary to prevent the garbage collector from observing invalid pointers, and differs from memmove in unmanaged languages. However, memmove is only required to do this if \"from\" and \"to\" may contain pointers, which can only be the case if \"from\", \"to\", and \"n\" are all be word-aligned. \n\nImplementations are in memmove_*.s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflect_memmove",
              "documentation": {
                "identifier": "reflect_memmove",
                "newPage": false,
                "searchKey": "runtime.reflect_memmove",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflect_memmove(to, from unsafe.Pointer, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflect_memmove(to, from unsafe.Pointer, n uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fastrand",
              "documentation": {
                "identifier": "fastrand",
                "newPage": false,
                "searchKey": "runtime.fastrand",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fastrand() uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fastrand() uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fastrandn",
              "documentation": {
                "identifier": "fastrandn",
                "newPage": false,
                "searchKey": "runtime.fastrandn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fastrandn(n uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fastrandn(n uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sync_fastrand",
              "documentation": {
                "identifier": "sync_fastrand",
                "newPage": false,
                "searchKey": "runtime.sync_fastrand",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sync_fastrand() uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sync_fastrand() uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#net_fastrand",
              "documentation": {
                "identifier": "net_fastrand",
                "newPage": false,
                "searchKey": "runtime.net_fastrand",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func net_fastrand() uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc net_fastrand() uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#os_fastrand",
              "documentation": {
                "identifier": "os_fastrand",
                "newPage": false,
                "searchKey": "runtime.os_fastrand",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func os_fastrand() uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc os_fastrand() uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memequal",
              "documentation": {
                "identifier": "memequal",
                "newPage": false,
                "searchKey": "runtime.memequal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memequal(a, b unsafe.Pointer, size uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memequal(a, b unsafe.Pointer, size uintptr) bool\n```\n\nin internal/bytealg/equal_*.s \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#noescape",
              "documentation": {
                "identifier": "noescape",
                "newPage": false,
                "searchKey": "runtime.noescape",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func noescape(p unsafe.Pointer) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc noescape(p unsafe.Pointer) unsafe.Pointer\n```\n\nnoescape hides a pointer from escape analysis.  noescape is the identity function but escape analysis doesn't think the output depends on the input.  noescape is inlined and currently compiles down to zero instructions. USE CAREFULLY! \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgocallback",
              "documentation": {
                "identifier": "cgocallback",
                "newPage": false,
                "searchKey": "runtime.cgocallback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgocallback(fn, frame, ctxt uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgocallback(fn, frame, ctxt uintptr)\n```\n\nNot all cgocallback frames are actually cgocallback, so not all have these arguments. Mark them uintptr so that the GC does not misinterpret memory when the arguments are not present. cgocallback is not called from Go, only from crosscall2. This in turn calls cgocallbackg, which is where we'll find pointer-declared arguments. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gogo",
              "documentation": {
                "identifier": "gogo",
                "newPage": false,
                "searchKey": "runtime.gogo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gogo(buf *gobuf)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gogo(buf *gobuf)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#jmpdefer",
              "documentation": {
                "identifier": "jmpdefer",
                "newPage": false,
                "searchKey": "runtime.jmpdefer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func jmpdefer(fv *funcval, argp uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc jmpdefer(fv *funcval, argp uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#asminit",
              "documentation": {
                "identifier": "asminit",
                "newPage": false,
                "searchKey": "runtime.asminit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func asminit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc asminit()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setg",
              "documentation": {
                "identifier": "setg",
                "newPage": false,
                "searchKey": "runtime.setg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setg(gg *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setg(gg *g)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#breakpoint",
              "documentation": {
                "identifier": "breakpoint",
                "newPage": false,
                "searchKey": "runtime.breakpoint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func breakpoint()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc breakpoint()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectcall",
              "documentation": {
                "identifier": "reflectcall",
                "newPage": false,
                "searchKey": "runtime.reflectcall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectcall(stackArgsType *_type, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectcall(stackArgsType *_type, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\nreflectcall calls fn with arguments described by stackArgs, stackArgsSize, frameSize, and regArgs. \n\nArguments passed on the stack and space for return values passed on the stack must be laid out at the space pointed to by stackArgs (with total length stackArgsSize) according to the ABI. \n\nstackRetOffset must be some value <= stackArgsSize that indicates the offset within stackArgs where the return value space begins. \n\nframeSize is the total size of the argument frame at stackArgs and must therefore be >= stackArgsSize. It must include additional space for spilling register arguments for stack growth and preemption. \n\nTODO(mknyszek): Once we don't need the additional spill space, remove frameSize, since frameSize will be redundant with stackArgsSize. \n\nArguments passed in registers must be laid out in regArgs according to the ABI. regArgs will hold any return values passed in registers after the call. \n\nreflectcall copies stack arguments from stackArgs to the goroutine stack, and then copies back stackArgsSize-stackRetOffset bytes back to the return space in stackArgs once fn has completed. It also \"unspills\" argument registers from regArgs before calling fn, and spills them back into regArgs immediately following the call to fn. If there are results being returned on the stack, the caller should pass the argument frame type as stackArgsType so that reflectcall can execute appropriate write barriers during the copy. \n\nreflectcall expects regArgs.ReturnIsPtr to be populated indicating which registers on the return path will contain Go pointers. It will then store these pointers in regArgs.Ptrs such that they are visible to the GC. \n\nPackage reflect passes a frame type. In package runtime, there is only one call that copies results back, in callbackWrap in syscall_windows.go, and it does NOT pass a frame type, meaning there are no write barriers invoked. See that call site for justification. \n\nPackage reflect accesses this symbol through a linkname. \n\nArguments passed through to reflectcall do not escape. The type is used only in a very limited callee of reflectcall, the stackArgs are copied, and regArgs is only used in the reflectcall frame. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#procyield",
              "documentation": {
                "identifier": "procyield",
                "newPage": false,
                "searchKey": "runtime.procyield",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func procyield(cycles uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc procyield(cycles uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goexit",
              "documentation": {
                "identifier": "goexit",
                "newPage": false,
                "searchKey": "runtime.goexit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goexit(neverCallThisFunction)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goexit(neverCallThisFunction)\n```\n\ngoexit is the return stub at the top of every goroutine call stack. Each goroutine stack is constructed as if goexit called the goroutine's entry point function, so that when the entry point function returns, it will return to goexit, which will call goexit1 to perform the actual exit. \n\nThis function must never be called directly. Call goexit1 instead. gentraceback assumes that goexit terminates the stack. A direct call on the stack will cause gentraceback to stop walking the stack prematurely and if there is leftover state it may panic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#publicationBarrier",
              "documentation": {
                "identifier": "publicationBarrier",
                "newPage": false,
                "searchKey": "runtime.publicationBarrier",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func publicationBarrier()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc publicationBarrier()\n```\n\npublicationBarrier performs a store/store barrier (a \"publication\" or \"export\" barrier). Some form of synchronization is required between initializing an object and making that object accessible to another processor. Without synchronization, the initialization writes and the \"publication\" write may be reordered, allowing the other processor to follow the pointer and observe an uninitialized object. In general, higher-level synchronization should be used, such as locking or an atomic pointer write. publicationBarrier is for when those aren't an option, such as in the implementation of the memory manager. \n\nThere's no corresponding barrier for the read side because the read side naturally has a data dependency order. All architectures that Go supports or seems likely to ever support automatically enforce data dependency ordering. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#getcallerpc",
              "documentation": {
                "identifier": "getcallerpc",
                "newPage": false,
                "searchKey": "runtime.getcallerpc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getcallerpc() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getcallerpc() uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#getcallersp",
              "documentation": {
                "identifier": "getcallersp",
                "newPage": false,
                "searchKey": "runtime.getcallersp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getcallersp() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getcallersp() uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#getclosureptr",
              "documentation": {
                "identifier": "getclosureptr",
                "newPage": false,
                "searchKey": "runtime.getclosureptr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func getclosureptr() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc getclosureptr() uintptr\n```\n\ngetclosureptr returns the pointer to the current closure. getclosureptr can only be used in an assignment statement at the entry of a function. Moreover, go:nosplit directive must be specified at the declaration of caller function, so that the function prolog does not clobber the closure register. for example: \n\n```\n//go:nosplit\nfunc f(arg1, arg2, arg3 int) {\n\tdx := getclosureptr()\n}\n\n```\nThe compiler rewrites calls to this function into instructions that fetch the pointer from a well-known register (DX on x86 architecture, etc.) directly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#asmcgocall",
              "documentation": {
                "identifier": "asmcgocall",
                "newPage": false,
                "searchKey": "runtime.asmcgocall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func asmcgocall(fn, arg unsafe.Pointer) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc asmcgocall(fn, arg unsafe.Pointer) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#morestack",
              "documentation": {
                "identifier": "morestack",
                "newPage": false,
                "searchKey": "runtime.morestack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func morestack()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc morestack()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#morestack_noctxt",
              "documentation": {
                "identifier": "morestack_noctxt",
                "newPage": false,
                "searchKey": "runtime.morestack_noctxt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func morestack_noctxt()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc morestack_noctxt()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#rt0_go",
              "documentation": {
                "identifier": "rt0_go",
                "newPage": false,
                "searchKey": "runtime.rt0_go",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func rt0_go()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rt0_go()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#return0",
              "documentation": {
                "identifier": "return0",
                "newPage": false,
                "searchKey": "runtime.return0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func return0()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc return0()\n```\n\nreturn0 is a stub used to return 0 from deferproc. It is called at the very end of deferproc to signal the calling Go function that it should not jump to deferreturn. in asm_*.s \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call16",
              "documentation": {
                "identifier": "call16",
                "newPage": false,
                "searchKey": "runtime.call16",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call16(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call16(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\nin asm_*.s not called directly; definitions here supply type information for traceback. These must have the same signature (arg pointer map) as reflectcall. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call32",
              "documentation": {
                "identifier": "call32",
                "newPage": false,
                "searchKey": "runtime.call32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call32(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call32(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call64",
              "documentation": {
                "identifier": "call64",
                "newPage": false,
                "searchKey": "runtime.call64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call64(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call64(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call128",
              "documentation": {
                "identifier": "call128",
                "newPage": false,
                "searchKey": "runtime.call128",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call128(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call128(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call256",
              "documentation": {
                "identifier": "call256",
                "newPage": false,
                "searchKey": "runtime.call256",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call256(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call256(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call512",
              "documentation": {
                "identifier": "call512",
                "newPage": false,
                "searchKey": "runtime.call512",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call512(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call512(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call1024",
              "documentation": {
                "identifier": "call1024",
                "newPage": false,
                "searchKey": "runtime.call1024",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call1024(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call1024(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call2048",
              "documentation": {
                "identifier": "call2048",
                "newPage": false,
                "searchKey": "runtime.call2048",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call2048(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call2048(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call4096",
              "documentation": {
                "identifier": "call4096",
                "newPage": false,
                "searchKey": "runtime.call4096",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call4096(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call4096(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call8192",
              "documentation": {
                "identifier": "call8192",
                "newPage": false,
                "searchKey": "runtime.call8192",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call8192(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call8192(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call16384",
              "documentation": {
                "identifier": "call16384",
                "newPage": false,
                "searchKey": "runtime.call16384",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call16384(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call16384(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call32768",
              "documentation": {
                "identifier": "call32768",
                "newPage": false,
                "searchKey": "runtime.call32768",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call32768(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call32768(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call65536",
              "documentation": {
                "identifier": "call65536",
                "newPage": false,
                "searchKey": "runtime.call65536",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call65536(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call65536(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call131072",
              "documentation": {
                "identifier": "call131072",
                "newPage": false,
                "searchKey": "runtime.call131072",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call131072(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call131072(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call262144",
              "documentation": {
                "identifier": "call262144",
                "newPage": false,
                "searchKey": "runtime.call262144",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call262144(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call262144(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call524288",
              "documentation": {
                "identifier": "call524288",
                "newPage": false,
                "searchKey": "runtime.call524288",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call524288(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call524288(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call1048576",
              "documentation": {
                "identifier": "call1048576",
                "newPage": false,
                "searchKey": "runtime.call1048576",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call1048576(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call1048576(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call2097152",
              "documentation": {
                "identifier": "call2097152",
                "newPage": false,
                "searchKey": "runtime.call2097152",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call2097152(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call2097152(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call4194304",
              "documentation": {
                "identifier": "call4194304",
                "newPage": false,
                "searchKey": "runtime.call4194304",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call4194304(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call4194304(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call8388608",
              "documentation": {
                "identifier": "call8388608",
                "newPage": false,
                "searchKey": "runtime.call8388608",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call8388608(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call8388608(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call16777216",
              "documentation": {
                "identifier": "call16777216",
                "newPage": false,
                "searchKey": "runtime.call16777216",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call16777216(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call16777216(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call33554432",
              "documentation": {
                "identifier": "call33554432",
                "newPage": false,
                "searchKey": "runtime.call33554432",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call33554432(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call33554432(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call67108864",
              "documentation": {
                "identifier": "call67108864",
                "newPage": false,
                "searchKey": "runtime.call67108864",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call67108864(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call67108864(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call134217728",
              "documentation": {
                "identifier": "call134217728",
                "newPage": false,
                "searchKey": "runtime.call134217728",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call134217728(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call134217728(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call268435456",
              "documentation": {
                "identifier": "call268435456",
                "newPage": false,
                "searchKey": "runtime.call268435456",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call268435456(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call268435456(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call536870912",
              "documentation": {
                "identifier": "call536870912",
                "newPage": false,
                "searchKey": "runtime.call536870912",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call536870912(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call536870912(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#call1073741824",
              "documentation": {
                "identifier": "call1073741824",
                "newPage": false,
                "searchKey": "runtime.call1073741824",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func call1073741824(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc call1073741824(typ, fn, stackArgs unsafe.Pointer, stackArgsSize, stackRetOffset, frameSize uint32, regArgs *abi.RegArgs)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#systemstack_switch",
              "documentation": {
                "identifier": "systemstack_switch",
                "newPage": false,
                "searchKey": "runtime.systemstack_switch",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func systemstack_switch()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc systemstack_switch()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#alignUp",
              "documentation": {
                "identifier": "alignUp",
                "newPage": false,
                "searchKey": "runtime.alignUp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func alignUp(n, a uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc alignUp(n, a uintptr) uintptr\n```\n\nalignUp rounds n up to a multiple of a. a must be a power of 2. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#alignDown",
              "documentation": {
                "identifier": "alignDown",
                "newPage": false,
                "searchKey": "runtime.alignDown",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func alignDown(n, a uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc alignDown(n, a uintptr) uintptr\n```\n\nalignDown rounds n down to a multiple of a. a must be a power of 2. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#divRoundUp",
              "documentation": {
                "identifier": "divRoundUp",
                "newPage": false,
                "searchKey": "runtime.divRoundUp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func divRoundUp(n, a uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc divRoundUp(n, a uintptr) uintptr\n```\n\ndivRoundUp returns ceil(n / a). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#checkASM",
              "documentation": {
                "identifier": "checkASM",
                "newPage": false,
                "searchKey": "runtime.checkASM",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkASM() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkASM() bool\n```\n\ncheckASM reports whether assembly runtime checks have passed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#memequal_varlen",
              "documentation": {
                "identifier": "memequal_varlen",
                "newPage": false,
                "searchKey": "runtime.memequal_varlen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func memequal_varlen(a, b unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc memequal_varlen(a, b unsafe.Pointer) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#bool2int",
              "documentation": {
                "identifier": "bool2int",
                "newPage": false,
                "searchKey": "runtime.bool2int",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func bool2int(x bool) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc bool2int(x bool) int\n```\n\nbool2int returns 0 if x is false or 1 if x is true. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#abort",
              "documentation": {
                "identifier": "abort",
                "newPage": false,
                "searchKey": "runtime.abort",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func abort()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc abort()\n```\n\nabort crashes the runtime in situations where even throw might not work. In general it should do something a debugger will recognize (e.g., an INT3 on x86). A crash in abort is recognized by the signal handler, which will attempt to tear down the runtime immediately. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcWriteBarrier",
              "documentation": {
                "identifier": "gcWriteBarrier",
                "newPage": false,
                "searchKey": "runtime.gcWriteBarrier",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcWriteBarrier()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcWriteBarrier()\n```\n\nCalled from compiled code; declared for vet; do NOT call from Go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#duffzero",
              "documentation": {
                "identifier": "duffzero",
                "newPage": false,
                "searchKey": "runtime.duffzero",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func duffzero()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc duffzero()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#duffcopy",
              "documentation": {
                "identifier": "duffcopy",
                "newPage": false,
                "searchKey": "runtime.duffcopy",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func duffcopy()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc duffcopy()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#addmoduledata",
              "documentation": {
                "identifier": "addmoduledata",
                "newPage": false,
                "searchKey": "runtime.addmoduledata",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addmoduledata()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addmoduledata()\n```\n\nCalled from linker-generated .initarray; declared for go vet; do NOT call from Go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigpanic0",
              "documentation": {
                "identifier": "sigpanic0",
                "newPage": false,
                "searchKey": "runtime.sigpanic0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigpanic0()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigpanic0()\n```\n\nInjected by the signal handler for panicking signals. Initializes any registers that have fixed meaning at calls but are scratch in bodies and calls sigpanic. On many platforms it just jumps to sigpanic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcWriteBarrierCX",
              "documentation": {
                "identifier": "gcWriteBarrierCX",
                "newPage": false,
                "searchKey": "runtime.gcWriteBarrierCX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcWriteBarrierCX()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcWriteBarrierCX()\n```\n\nCalled from compiled code; declared for vet; do NOT call from Go. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcWriteBarrierDX",
              "documentation": {
                "identifier": "gcWriteBarrierDX",
                "newPage": false,
                "searchKey": "runtime.gcWriteBarrierDX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcWriteBarrierDX()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcWriteBarrierDX()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcWriteBarrierBX",
              "documentation": {
                "identifier": "gcWriteBarrierBX",
                "newPage": false,
                "searchKey": "runtime.gcWriteBarrierBX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcWriteBarrierBX()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcWriteBarrierBX()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcWriteBarrierBP",
              "documentation": {
                "identifier": "gcWriteBarrierBP",
                "newPage": false,
                "searchKey": "runtime.gcWriteBarrierBP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcWriteBarrierBP()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcWriteBarrierBP()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcWriteBarrierSI",
              "documentation": {
                "identifier": "gcWriteBarrierSI",
                "newPage": false,
                "searchKey": "runtime.gcWriteBarrierSI",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcWriteBarrierSI()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcWriteBarrierSI()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcWriteBarrierR8",
              "documentation": {
                "identifier": "gcWriteBarrierR8",
                "newPage": false,
                "searchKey": "runtime.gcWriteBarrierR8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcWriteBarrierR8()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcWriteBarrierR8()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcWriteBarrierR9",
              "documentation": {
                "identifier": "gcWriteBarrierR9",
                "newPage": false,
                "searchKey": "runtime.gcWriteBarrierR9",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcWriteBarrierR9()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcWriteBarrierR9()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackcheck",
              "documentation": {
                "identifier": "stackcheck",
                "newPage": false,
                "searchKey": "runtime.stackcheck",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stackcheck()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stackcheck()\n```\n\nstackcheck checks that SP is in range [g->stack.lo, g->stack.hi). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#settls",
              "documentation": {
                "identifier": "settls",
                "newPage": false,
                "searchKey": "runtime.settls",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func settls()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc settls()\n```\n\nCalled from assembly only; declared for go vet. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineAX",
              "documentation": {
                "identifier": "retpolineAX",
                "newPage": false,
                "searchKey": "runtime.retpolineAX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineAX()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineAX()\n```\n\nRetpolines, used by -spectre=ret flag in cmd/asm, cmd/compile. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineCX",
              "documentation": {
                "identifier": "retpolineCX",
                "newPage": false,
                "searchKey": "runtime.retpolineCX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineCX()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineCX()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineDX",
              "documentation": {
                "identifier": "retpolineDX",
                "newPage": false,
                "searchKey": "runtime.retpolineDX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineDX()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineDX()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineBX",
              "documentation": {
                "identifier": "retpolineBX",
                "newPage": false,
                "searchKey": "runtime.retpolineBX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineBX()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineBX()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineBP",
              "documentation": {
                "identifier": "retpolineBP",
                "newPage": false,
                "searchKey": "runtime.retpolineBP",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineBP()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineBP()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineSI",
              "documentation": {
                "identifier": "retpolineSI",
                "newPage": false,
                "searchKey": "runtime.retpolineSI",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineSI()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineSI()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineDI",
              "documentation": {
                "identifier": "retpolineDI",
                "newPage": false,
                "searchKey": "runtime.retpolineDI",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineDI()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineDI()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineR8",
              "documentation": {
                "identifier": "retpolineR8",
                "newPage": false,
                "searchKey": "runtime.retpolineR8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineR8()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineR8()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineR9",
              "documentation": {
                "identifier": "retpolineR9",
                "newPage": false,
                "searchKey": "runtime.retpolineR9",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineR9()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineR9()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineR10",
              "documentation": {
                "identifier": "retpolineR10",
                "newPage": false,
                "searchKey": "runtime.retpolineR10",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineR10()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineR10()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineR11",
              "documentation": {
                "identifier": "retpolineR11",
                "newPage": false,
                "searchKey": "runtime.retpolineR11",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineR11()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineR11()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineR12",
              "documentation": {
                "identifier": "retpolineR12",
                "newPage": false,
                "searchKey": "runtime.retpolineR12",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineR12()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineR12()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineR13",
              "documentation": {
                "identifier": "retpolineR13",
                "newPage": false,
                "searchKey": "runtime.retpolineR13",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineR13()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineR13()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineR14",
              "documentation": {
                "identifier": "retpolineR14",
                "newPage": false,
                "searchKey": "runtime.retpolineR14",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineR14()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineR14()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#retpolineR15",
              "documentation": {
                "identifier": "retpolineR15",
                "newPage": false,
                "searchKey": "runtime.retpolineR15",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func retpolineR15()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc retpolineR15()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#asmcgocall_no_g",
              "documentation": {
                "identifier": "asmcgocall_no_g",
                "newPage": false,
                "searchKey": "runtime.asmcgocall_no_g",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func asmcgocall_no_g(fn, arg unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc asmcgocall_no_g(fn, arg unsafe.Pointer)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#spillArgs",
              "documentation": {
                "identifier": "spillArgs",
                "newPage": false,
                "searchKey": "runtime.spillArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func spillArgs()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc spillArgs()\n```\n\nUsed by reflectcall and the reflect package. \n\nSpills/loads arguments in registers to/from an internal/abi.RegArgs respectively. Does not follow the Go ABI. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unspillArgs",
              "documentation": {
                "identifier": "unspillArgs",
                "newPage": false,
                "searchKey": "runtime.unspillArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unspillArgs()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unspillArgs()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sbrk0",
              "documentation": {
                "identifier": "sbrk0",
                "newPage": false,
                "searchKey": "runtime.sbrk0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sbrk0() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sbrk0() uintptr\n```\n\nsbrk0 returns the current process brk, or 0 if not implemented. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtime_expandFinalInlineFrame",
              "documentation": {
                "identifier": "runtime_expandFinalInlineFrame",
                "newPage": false,
                "searchKey": "runtime.runtime_expandFinalInlineFrame",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtime_expandFinalInlineFrame(stk []uintptr) []uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtime_expandFinalInlineFrame(stk []uintptr) []uintptr\n```\n\nruntime_expandFinalInlineFrame expands the final pc in stk to include all \"callers\" if pc is inline. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#expandCgoFrames",
              "documentation": {
                "identifier": "expandCgoFrames",
                "newPage": false,
                "searchKey": "runtime.expandCgoFrames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func expandCgoFrames(pc uintptr) []Frame"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc expandCgoFrames(pc uintptr) []Frame\n```\n\nexpandCgoFrames expands frame information for pc, known to be a non-Go function, using the cgoSymbolizer hook. expandCgoFrames returns nil if pc could not be expanded. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#activeModules",
              "documentation": {
                "identifier": "activeModules",
                "newPage": false,
                "searchKey": "runtime.activeModules",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func activeModules() []*moduledata"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc activeModules() []*moduledata\n```\n\nactiveModules returns a slice of active modules. \n\nA module is active once its gcdatamask and gcbssmask have been assembled and it is usable by the GC. \n\nThis is nosplit/nowritebarrier because it is called by the cgo pointer checking code. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#modulesinit",
              "documentation": {
                "identifier": "modulesinit",
                "newPage": false,
                "searchKey": "runtime.modulesinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func modulesinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc modulesinit()\n```\n\nmodulesinit creates the active modules slice out of all loaded modules. \n\nWhen a module is first loaded by the dynamic linker, an .init_array function (written by cmd/link) is invoked to call addmoduledata, appending to the module to the linked list that starts with firstmoduledata. \n\nThere are two times this can happen in the lifecycle of a Go program. First, if compiled with -linkshared, a number of modules built with -buildmode=shared can be loaded at program initialization. Second, a Go program can load a module while running that was built with -buildmode=plugin. \n\nAfter loading, this function is called which initializes the moduledata so it is usable by the GC and creates a new activeModules list. \n\nOnly one goroutine may call modulesinit at a time. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#moduledataverify",
              "documentation": {
                "identifier": "moduledataverify",
                "newPage": false,
                "searchKey": "runtime.moduledataverify",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func moduledataverify()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc moduledataverify()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#moduledataverify1",
              "documentation": {
                "identifier": "moduledataverify1",
                "newPage": false,
                "searchKey": "runtime.moduledataverify1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func moduledataverify1(datap *moduledata)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc moduledataverify1(datap *moduledata)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pcvalueCacheKey",
              "documentation": {
                "identifier": "pcvalueCacheKey",
                "newPage": false,
                "searchKey": "runtime.pcvalueCacheKey",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pcvalueCacheKey(targetpc uintptr) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pcvalueCacheKey(targetpc uintptr) uintptr\n```\n\npcvalueCacheKey returns the outermost index in a pcvalueCache to use for targetpc. It must be very cheap to calculate. For now, align to sys.PtrSize and reduce mod the number of entries. In practice, this appears to be fairly randomly and evenly distributed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pcvalue",
              "documentation": {
                "identifier": "pcvalue",
                "newPage": false,
                "searchKey": "runtime.pcvalue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pcvalue(f funcInfo, off uint32, targetpc uintptr, cache *pcvalueCache, strict bool) (int32, uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pcvalue(f funcInfo, off uint32, targetpc uintptr, cache *pcvalueCache, strict bool) (int32, uintptr)\n```\n\nReturns the PCData value, and the PC where this value starts. TODO: the start PC is returned only when cache is nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cfuncname",
              "documentation": {
                "identifier": "cfuncname",
                "newPage": false,
                "searchKey": "runtime.cfuncname",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cfuncname(f funcInfo) *byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cfuncname(f funcInfo) *byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcname",
              "documentation": {
                "identifier": "funcname",
                "newPage": false,
                "searchKey": "runtime.funcname",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcname(f funcInfo) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcname(f funcInfo) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcpkgpath",
              "documentation": {
                "identifier": "funcpkgpath",
                "newPage": false,
                "searchKey": "runtime.funcpkgpath",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcpkgpath(f funcInfo) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcpkgpath(f funcInfo) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cfuncnameFromNameoff",
              "documentation": {
                "identifier": "cfuncnameFromNameoff",
                "newPage": false,
                "searchKey": "runtime.cfuncnameFromNameoff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cfuncnameFromNameoff(f funcInfo, nameoff int32) *byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cfuncnameFromNameoff(f funcInfo, nameoff int32) *byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcnameFromNameoff",
              "documentation": {
                "identifier": "funcnameFromNameoff",
                "newPage": false,
                "searchKey": "runtime.funcnameFromNameoff",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcnameFromNameoff(f funcInfo, nameoff int32) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcnameFromNameoff(f funcInfo, nameoff int32) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcfile",
              "documentation": {
                "identifier": "funcfile",
                "newPage": false,
                "searchKey": "runtime.funcfile",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcfile(f funcInfo, fileno int32) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcfile(f funcInfo, fileno int32) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcline1",
              "documentation": {
                "identifier": "funcline1",
                "newPage": false,
                "searchKey": "runtime.funcline1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcline1(f funcInfo, targetpc uintptr, strict bool) (file string, line int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcline1(f funcInfo, targetpc uintptr, strict bool) (file string, line int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcline",
              "documentation": {
                "identifier": "funcline",
                "newPage": false,
                "searchKey": "runtime.funcline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcline(f funcInfo, targetpc uintptr) (file string, line int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcline(f funcInfo, targetpc uintptr) (file string, line int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcspdelta",
              "documentation": {
                "identifier": "funcspdelta",
                "newPage": false,
                "searchKey": "runtime.funcspdelta",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcspdelta(f funcInfo, targetpc uintptr, cache *pcvalueCache) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcspdelta(f funcInfo, targetpc uintptr, cache *pcvalueCache) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcMaxSPDelta",
              "documentation": {
                "identifier": "funcMaxSPDelta",
                "newPage": false,
                "searchKey": "runtime.funcMaxSPDelta",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcMaxSPDelta(f funcInfo) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcMaxSPDelta(f funcInfo) int32\n```\n\nfuncMaxSPDelta returns the maximum spdelta at any point in f. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pcdatastart",
              "documentation": {
                "identifier": "pcdatastart",
                "newPage": false,
                "searchKey": "runtime.pcdatastart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pcdatastart(f funcInfo, table uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pcdatastart(f funcInfo, table uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pcdatavalue",
              "documentation": {
                "identifier": "pcdatavalue",
                "newPage": false,
                "searchKey": "runtime.pcdatavalue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pcdatavalue(f funcInfo, table uint32, targetpc uintptr, cache *pcvalueCache) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pcdatavalue(f funcInfo, table uint32, targetpc uintptr, cache *pcvalueCache) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pcdatavalue1",
              "documentation": {
                "identifier": "pcdatavalue1",
                "newPage": false,
                "searchKey": "runtime.pcdatavalue1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pcdatavalue1(f funcInfo, table uint32, targetpc uintptr, cache *pcvalueCache, strict bool) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pcdatavalue1(f funcInfo, table uint32, targetpc uintptr, cache *pcvalueCache, strict bool) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pcdatavalue2",
              "documentation": {
                "identifier": "pcdatavalue2",
                "newPage": false,
                "searchKey": "runtime.pcdatavalue2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pcdatavalue2(f funcInfo, table uint32, targetpc uintptr) (int32, uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pcdatavalue2(f funcInfo, table uint32, targetpc uintptr) (int32, uintptr)\n```\n\nLike pcdatavalue, but also return the start PC of this PCData value. It doesn't take a cache. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#funcdata",
              "documentation": {
                "identifier": "funcdata",
                "newPage": false,
                "searchKey": "runtime.funcdata",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func funcdata(f funcInfo, i uint8) unsafe.Pointer"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc funcdata(f funcInfo, i uint8) unsafe.Pointer\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#step",
              "documentation": {
                "identifier": "step",
                "newPage": false,
                "searchKey": "runtime.step",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool)\n```\n\nstep advances to the next pc, value pair in the encoded table. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#readvarint",
              "documentation": {
                "identifier": "readvarint",
                "newPage": false,
                "searchKey": "runtime.readvarint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func readvarint(p []byte) (read uint32, val uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc readvarint(p []byte) (read uint32, val uint32)\n```\n\nreadvarint reads a varint from p. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_syscall",
              "documentation": {
                "identifier": "syscall_syscall",
                "newPage": false,
                "searchKey": "runtime.syscall_syscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_syscall(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_syscall(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall",
              "documentation": {
                "identifier": "syscall",
                "newPage": false,
                "searchKey": "runtime.syscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_syscallX",
              "documentation": {
                "identifier": "syscall_syscallX",
                "newPage": false,
                "searchKey": "runtime.syscall_syscallX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_syscallX(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_syscallX(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscallX",
              "documentation": {
                "identifier": "syscallX",
                "newPage": false,
                "searchKey": "runtime.syscallX",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscallX()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscallX()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_syscall6",
              "documentation": {
                "identifier": "syscall_syscall6",
                "newPage": false,
                "searchKey": "runtime.syscall_syscall6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_syscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_syscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall6",
              "documentation": {
                "identifier": "syscall6",
                "newPage": false,
                "searchKey": "runtime.syscall6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall6()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall6()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_syscall6X",
              "documentation": {
                "identifier": "syscall_syscall6X",
                "newPage": false,
                "searchKey": "runtime.syscall_syscall6X",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_syscall6X(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_syscall6X(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall6X",
              "documentation": {
                "identifier": "syscall6X",
                "newPage": false,
                "searchKey": "runtime.syscall6X",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall6X()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall6X()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_syscallPtr",
              "documentation": {
                "identifier": "syscall_syscallPtr",
                "newPage": false,
                "searchKey": "runtime.syscall_syscallPtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_syscallPtr(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_syscallPtr(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscallPtr",
              "documentation": {
                "identifier": "syscallPtr",
                "newPage": false,
                "searchKey": "runtime.syscallPtr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscallPtr()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscallPtr()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_rawSyscall",
              "documentation": {
                "identifier": "syscall_rawSyscall",
                "newPage": false,
                "searchKey": "runtime.syscall_rawSyscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_rawSyscall(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_rawSyscall(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscall_rawSyscall6",
              "documentation": {
                "identifier": "syscall_rawSyscall6",
                "newPage": false,
                "searchKey": "runtime.syscall_rawSyscall6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscall_rawSyscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscall_rawSyscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#crypto_x509_syscall",
              "documentation": {
                "identifier": "crypto_x509_syscall",
                "newPage": false,
                "searchKey": "runtime.crypto_x509_syscall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func crypto_x509_syscall(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1 uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc crypto_x509_syscall(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1 uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#syscallNoErr",
              "documentation": {
                "identifier": "syscallNoErr",
                "newPage": false,
                "searchKey": "runtime.syscallNoErr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func syscallNoErr()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc syscallNoErr()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_attr_init",
              "documentation": {
                "identifier": "pthread_attr_init",
                "newPage": false,
                "searchKey": "runtime.pthread_attr_init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_attr_init(attr *pthreadattr) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_attr_init(attr *pthreadattr) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_attr_init_trampoline",
              "documentation": {
                "identifier": "pthread_attr_init_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_attr_init_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_attr_init_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_attr_init_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_attr_getstacksize",
              "documentation": {
                "identifier": "pthread_attr_getstacksize",
                "newPage": false,
                "searchKey": "runtime.pthread_attr_getstacksize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_attr_getstacksize(attr *pthreadattr, size *uintptr) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_attr_getstacksize(attr *pthreadattr, size *uintptr) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_attr_getstacksize_trampoline",
              "documentation": {
                "identifier": "pthread_attr_getstacksize_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_attr_getstacksize_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_attr_getstacksize_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_attr_getstacksize_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_attr_setdetachstate",
              "documentation": {
                "identifier": "pthread_attr_setdetachstate",
                "newPage": false,
                "searchKey": "runtime.pthread_attr_setdetachstate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_attr_setdetachstate(attr *pthreadattr, state int) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_attr_setdetachstate(attr *pthreadattr, state int) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_attr_setdetachstate_trampoline",
              "documentation": {
                "identifier": "pthread_attr_setdetachstate_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_attr_setdetachstate_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_attr_setdetachstate_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_attr_setdetachstate_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_create",
              "documentation": {
                "identifier": "pthread_create",
                "newPage": false,
                "searchKey": "runtime.pthread_create",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_create(attr *pthreadattr, start uintptr, arg unsafe.Pointer) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_create(attr *pthreadattr, start uintptr, arg unsafe.Pointer) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_create_trampoline",
              "documentation": {
                "identifier": "pthread_create_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_create_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_create_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_create_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raise",
              "documentation": {
                "identifier": "raise",
                "newPage": false,
                "searchKey": "runtime.raise",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raise(sig uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raise(sig uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raise_trampoline",
              "documentation": {
                "identifier": "raise_trampoline",
                "newPage": false,
                "searchKey": "runtime.raise_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raise_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raise_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_self_trampoline",
              "documentation": {
                "identifier": "pthread_self_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_self_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_self_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_self_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_kill",
              "documentation": {
                "identifier": "pthread_kill",
                "newPage": false,
                "searchKey": "runtime.pthread_kill",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_kill(t pthread, sig uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_kill(t pthread, sig uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_kill_trampoline",
              "documentation": {
                "identifier": "pthread_kill_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_kill_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_kill_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_kill_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mmap",
              "documentation": {
                "identifier": "mmap",
                "newPage": false,
                "searchKey": "runtime.mmap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) (unsafe.Pointer, int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) (unsafe.Pointer, int)\n```\n\nmmap is used to do low-level memory allocation via mmap. Don't allow stack splits, since this function (used by sysAlloc) is called in a lot of low-level parts of the runtime and callers often assume it won't acquire any locks. go:nosplit \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mmap_trampoline",
              "documentation": {
                "identifier": "mmap_trampoline",
                "newPage": false,
                "searchKey": "runtime.mmap_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mmap_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mmap_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#munmap",
              "documentation": {
                "identifier": "munmap",
                "newPage": false,
                "searchKey": "runtime.munmap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func munmap(addr unsafe.Pointer, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc munmap(addr unsafe.Pointer, n uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#munmap_trampoline",
              "documentation": {
                "identifier": "munmap_trampoline",
                "newPage": false,
                "searchKey": "runtime.munmap_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func munmap_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc munmap_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#madvise",
              "documentation": {
                "identifier": "madvise",
                "newPage": false,
                "searchKey": "runtime.madvise",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func madvise(addr unsafe.Pointer, n uintptr, flags int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc madvise(addr unsafe.Pointer, n uintptr, flags int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#madvise_trampoline",
              "documentation": {
                "identifier": "madvise_trampoline",
                "newPage": false,
                "searchKey": "runtime.madvise_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func madvise_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc madvise_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mlock",
              "documentation": {
                "identifier": "mlock",
                "newPage": false,
                "searchKey": "runtime.mlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mlock(addr unsafe.Pointer, n uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mlock(addr unsafe.Pointer, n uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#mlock_trampoline",
              "documentation": {
                "identifier": "mlock_trampoline",
                "newPage": false,
                "searchKey": "runtime.mlock_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mlock_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mlock_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#read",
              "documentation": {
                "identifier": "read",
                "newPage": false,
                "searchKey": "runtime.read",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func read(fd int32, p unsafe.Pointer, n int32) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc read(fd int32, p unsafe.Pointer, n int32) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#read_trampoline",
              "documentation": {
                "identifier": "read_trampoline",
                "newPage": false,
                "searchKey": "runtime.read_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func read_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc read_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pipe",
              "documentation": {
                "identifier": "pipe",
                "newPage": false,
                "searchKey": "runtime.pipe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pipe() (r, w int32, errno int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pipe() (r, w int32, errno int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pipe_trampoline",
              "documentation": {
                "identifier": "pipe_trampoline",
                "newPage": false,
                "searchKey": "runtime.pipe_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pipe_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pipe_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#closefd",
              "documentation": {
                "identifier": "closefd",
                "newPage": false,
                "searchKey": "runtime.closefd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func closefd(fd int32) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc closefd(fd int32) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#close_trampoline",
              "documentation": {
                "identifier": "close_trampoline",
                "newPage": false,
                "searchKey": "runtime.close_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func close_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc close_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#exit",
              "documentation": {
                "identifier": "exit",
                "newPage": false,
                "searchKey": "runtime.exit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func exit(code int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc exit(code int32)\n```\n\nThis is exported via linkname to assembly in runtime/cgo. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#exit_trampoline",
              "documentation": {
                "identifier": "exit_trampoline",
                "newPage": false,
                "searchKey": "runtime.exit_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func exit_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc exit_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#usleep",
              "documentation": {
                "identifier": "usleep",
                "newPage": false,
                "searchKey": "runtime.usleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func usleep(usec uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc usleep(usec uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#usleep_trampoline",
              "documentation": {
                "identifier": "usleep_trampoline",
                "newPage": false,
                "searchKey": "runtime.usleep_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func usleep_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc usleep_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#usleep_no_g",
              "documentation": {
                "identifier": "usleep_no_g",
                "newPage": false,
                "searchKey": "runtime.usleep_no_g",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func usleep_no_g(usec uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc usleep_no_g(usec uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#write1",
              "documentation": {
                "identifier": "write1",
                "newPage": false,
                "searchKey": "runtime.write1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func write1(fd uintptr, p unsafe.Pointer, n int32) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc write1(fd uintptr, p unsafe.Pointer, n int32) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#write_trampoline",
              "documentation": {
                "identifier": "write_trampoline",
                "newPage": false,
                "searchKey": "runtime.write_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func write_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc write_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#open",
              "documentation": {
                "identifier": "open",
                "newPage": false,
                "searchKey": "runtime.open",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func open(name *byte, mode, perm int32) (ret int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc open(name *byte, mode, perm int32) (ret int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#open_trampoline",
              "documentation": {
                "identifier": "open_trampoline",
                "newPage": false,
                "searchKey": "runtime.open_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func open_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc open_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nanotime1",
              "documentation": {
                "identifier": "nanotime1",
                "newPage": false,
                "searchKey": "runtime.nanotime1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nanotime1() int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nanotime1() int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nanotime_trampoline",
              "documentation": {
                "identifier": "nanotime_trampoline",
                "newPage": false,
                "searchKey": "runtime.nanotime_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nanotime_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nanotime_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#walltime",
              "documentation": {
                "identifier": "walltime",
                "newPage": false,
                "searchKey": "runtime.walltime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func walltime() (int64, int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc walltime() (int64, int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#walltime_trampoline",
              "documentation": {
                "identifier": "walltime_trampoline",
                "newPage": false,
                "searchKey": "runtime.walltime_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func walltime_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc walltime_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigaction",
              "documentation": {
                "identifier": "sigaction",
                "newPage": false,
                "searchKey": "runtime.sigaction",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigaction(sig uint32, new *usigactiont, old *usigactiont)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigaction(sig uint32, new *usigactiont, old *usigactiont)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigaction_trampoline",
              "documentation": {
                "identifier": "sigaction_trampoline",
                "newPage": false,
                "searchKey": "runtime.sigaction_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigaction_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigaction_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigprocmask",
              "documentation": {
                "identifier": "sigprocmask",
                "newPage": false,
                "searchKey": "runtime.sigprocmask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigprocmask(how uint32, new *sigset, old *sigset)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigprocmask(how uint32, new *sigset, old *sigset)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigprocmask_trampoline",
              "documentation": {
                "identifier": "sigprocmask_trampoline",
                "newPage": false,
                "searchKey": "runtime.sigprocmask_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigprocmask_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigprocmask_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigaltstack",
              "documentation": {
                "identifier": "sigaltstack",
                "newPage": false,
                "searchKey": "runtime.sigaltstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigaltstack(new *stackt, old *stackt)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigaltstack(new *stackt, old *stackt)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigaltstack_trampoline",
              "documentation": {
                "identifier": "sigaltstack_trampoline",
                "newPage": false,
                "searchKey": "runtime.sigaltstack_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigaltstack_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigaltstack_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raiseproc",
              "documentation": {
                "identifier": "raiseproc",
                "newPage": false,
                "searchKey": "runtime.raiseproc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raiseproc(sig uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raiseproc(sig uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#raiseproc_trampoline",
              "documentation": {
                "identifier": "raiseproc_trampoline",
                "newPage": false,
                "searchKey": "runtime.raiseproc_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func raiseproc_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc raiseproc_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setitimer",
              "documentation": {
                "identifier": "setitimer",
                "newPage": false,
                "searchKey": "runtime.setitimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setitimer(mode int32, new, old *itimerval)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setitimer(mode int32, new, old *itimerval)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setitimer_trampoline",
              "documentation": {
                "identifier": "setitimer_trampoline",
                "newPage": false,
                "searchKey": "runtime.setitimer_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setitimer_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setitimer_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysctl",
              "documentation": {
                "identifier": "sysctl",
                "newPage": false,
                "searchKey": "runtime.sysctl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysctl(mib *uint32, miblen uint32, oldp *byte, oldlenp *uintptr, newp *byte, newlen uintptr) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysctl(mib *uint32, miblen uint32, oldp *byte, oldlenp *uintptr, newp *byte, newlen uintptr) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysctl_trampoline",
              "documentation": {
                "identifier": "sysctl_trampoline",
                "newPage": false,
                "searchKey": "runtime.sysctl_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysctl_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysctl_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysctlbyname",
              "documentation": {
                "identifier": "sysctlbyname",
                "newPage": false,
                "searchKey": "runtime.sysctlbyname",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysctlbyname(name *byte, oldp *byte, oldlenp *uintptr, newp *byte, newlen uintptr) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysctlbyname(name *byte, oldp *byte, oldlenp *uintptr, newp *byte, newlen uintptr) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sysctlbyname_trampoline",
              "documentation": {
                "identifier": "sysctlbyname_trampoline",
                "newPage": false,
                "searchKey": "runtime.sysctlbyname_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sysctlbyname_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sysctlbyname_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fcntl",
              "documentation": {
                "identifier": "fcntl",
                "newPage": false,
                "searchKey": "runtime.fcntl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fcntl(fd, cmd, arg int32) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fcntl(fd, cmd, arg int32) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#fcntl_trampoline",
              "documentation": {
                "identifier": "fcntl_trampoline",
                "newPage": false,
                "searchKey": "runtime.fcntl_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fcntl_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fcntl_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kqueue",
              "documentation": {
                "identifier": "kqueue",
                "newPage": false,
                "searchKey": "runtime.kqueue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func kqueue() int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc kqueue() int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kqueue_trampoline",
              "documentation": {
                "identifier": "kqueue_trampoline",
                "newPage": false,
                "searchKey": "runtime.kqueue_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func kqueue_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc kqueue_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kevent",
              "documentation": {
                "identifier": "kevent",
                "newPage": false,
                "searchKey": "runtime.kevent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func kevent(kq int32, ch *keventt, nch int32, ev *keventt, nev int32, ts *timespec) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc kevent(kq int32, ch *keventt, nch int32, ev *keventt, nev int32, ts *timespec) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#kevent_trampoline",
              "documentation": {
                "identifier": "kevent_trampoline",
                "newPage": false,
                "searchKey": "runtime.kevent_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func kevent_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc kevent_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_mutex_init",
              "documentation": {
                "identifier": "pthread_mutex_init",
                "newPage": false,
                "searchKey": "runtime.pthread_mutex_init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_mutex_init(m *pthreadmutex, attr *pthreadmutexattr) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_mutex_init(m *pthreadmutex, attr *pthreadmutexattr) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_mutex_init_trampoline",
              "documentation": {
                "identifier": "pthread_mutex_init_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_mutex_init_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_mutex_init_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_mutex_init_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_mutex_lock",
              "documentation": {
                "identifier": "pthread_mutex_lock",
                "newPage": false,
                "searchKey": "runtime.pthread_mutex_lock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_mutex_lock(m *pthreadmutex) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_mutex_lock(m *pthreadmutex) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_mutex_lock_trampoline",
              "documentation": {
                "identifier": "pthread_mutex_lock_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_mutex_lock_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_mutex_lock_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_mutex_lock_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_mutex_unlock",
              "documentation": {
                "identifier": "pthread_mutex_unlock",
                "newPage": false,
                "searchKey": "runtime.pthread_mutex_unlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_mutex_unlock(m *pthreadmutex) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_mutex_unlock(m *pthreadmutex) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_mutex_unlock_trampoline",
              "documentation": {
                "identifier": "pthread_mutex_unlock_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_mutex_unlock_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_mutex_unlock_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_mutex_unlock_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_cond_init",
              "documentation": {
                "identifier": "pthread_cond_init",
                "newPage": false,
                "searchKey": "runtime.pthread_cond_init",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_cond_init(c *pthreadcond, attr *pthreadcondattr) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_cond_init(c *pthreadcond, attr *pthreadcondattr) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_cond_init_trampoline",
              "documentation": {
                "identifier": "pthread_cond_init_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_cond_init_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_cond_init_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_cond_init_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_cond_wait",
              "documentation": {
                "identifier": "pthread_cond_wait",
                "newPage": false,
                "searchKey": "runtime.pthread_cond_wait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_cond_wait(c *pthreadcond, m *pthreadmutex) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_cond_wait(c *pthreadcond, m *pthreadmutex) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_cond_wait_trampoline",
              "documentation": {
                "identifier": "pthread_cond_wait_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_cond_wait_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_cond_wait_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_cond_wait_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_cond_timedwait_relative_np",
              "documentation": {
                "identifier": "pthread_cond_timedwait_relative_np",
                "newPage": false,
                "searchKey": "runtime.pthread_cond_timedwait_relative_np",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_cond_timedwait_relative_np(c *pthreadcond, m *pthreadmutex, t *timespec) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_cond_timedwait_relative_np(c *pthreadcond, m *pthreadmutex, t *timespec) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_cond_timedwait_relative_np_trampoline",
              "documentation": {
                "identifier": "pthread_cond_timedwait_relative_np_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_cond_timedwait_relative_np_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_cond_timedwait_relative_np_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_cond_timedwait_relative_np_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_cond_signal",
              "documentation": {
                "identifier": "pthread_cond_signal",
                "newPage": false,
                "searchKey": "runtime.pthread_cond_signal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_cond_signal(c *pthreadcond) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_cond_signal(c *pthreadcond) int32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#pthread_cond_signal_trampoline",
              "documentation": {
                "identifier": "pthread_cond_signal_trampoline",
                "newPage": false,
                "searchKey": "runtime.pthread_cond_signal_trampoline",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func pthread_cond_signal_trampoline()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc pthread_cond_signal_trampoline()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#exitThread",
              "documentation": {
                "identifier": "exitThread",
                "newPage": false,
                "searchKey": "runtime.exitThread",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func exitThread(wait *uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc exitThread(wait *uint32)\n```\n\nNot used on Darwin, but must be defined. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#closeonexec",
              "documentation": {
                "identifier": "closeonexec",
                "newPage": false,
                "searchKey": "runtime.closeonexec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func closeonexec(fd int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc closeonexec(fd int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#setNonblock",
              "documentation": {
                "identifier": "setNonblock",
                "newPage": false,
                "searchKey": "runtime.setNonblock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func setNonblock(fd int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc setNonblock(fd int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#libcCall",
              "documentation": {
                "identifier": "libcCall",
                "newPage": false,
                "searchKey": "runtime.libcCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func libcCall(fn, arg unsafe.Pointer) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc libcCall(fn, arg unsafe.Pointer) int32\n```\n\nCall fn with arg as its argument. Return what fn returns. fn is the raw pc value of the entry point of the desired function. Switches to the system stack, if not already there. Preserves the calling point as the location where a profiler traceback will begin. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#prepGoExitFrame",
              "documentation": {
                "identifier": "prepGoExitFrame",
                "newPage": false,
                "searchKey": "runtime.prepGoExitFrame",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func prepGoExitFrame(sp uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc prepGoExitFrame(sp uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gostartcall",
              "documentation": {
                "identifier": "gostartcall",
                "newPage": false,
                "searchKey": "runtime.gostartcall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer)\n```\n\nadjust Gobuf as if it executed a call to fn with context ctxt and then stopped before the first instruction in fn. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#timeSleep",
              "documentation": {
                "identifier": "timeSleep",
                "newPage": false,
                "searchKey": "runtime.timeSleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func timeSleep(ns int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc timeSleep(ns int64)\n```\n\ntimeSleep puts the current goroutine to sleep for at least ns nanoseconds. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#resetForSleep",
              "documentation": {
                "identifier": "resetForSleep",
                "newPage": false,
                "searchKey": "runtime.resetForSleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func resetForSleep(gp *g, ut unsafe.Pointer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resetForSleep(gp *g, ut unsafe.Pointer) bool\n```\n\nresetForSleep is called after the goroutine is parked for timeSleep. We can't call resettimer in timeSleep itself because if this is a short sleep and there are many goroutines then the P can wind up running the timer function, goroutineReady, before the goroutine has been parked. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#startTimer",
              "documentation": {
                "identifier": "startTimer",
                "newPage": false,
                "searchKey": "runtime.startTimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func startTimer(t *timer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc startTimer(t *timer)\n```\n\nstartTimer adds t to the timer heap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stopTimer",
              "documentation": {
                "identifier": "stopTimer",
                "newPage": false,
                "searchKey": "runtime.stopTimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stopTimer(t *timer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stopTimer(t *timer) bool\n```\n\nstopTimer stops a timer. It reports whether t was stopped before being run. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#resetTimer",
              "documentation": {
                "identifier": "resetTimer",
                "newPage": false,
                "searchKey": "runtime.resetTimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func resetTimer(t *timer, when int64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resetTimer(t *timer, when int64) bool\n```\n\nresetTimer resets an inactive timer, adding it to the heap. Reports whether the timer was modified before it was run. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#modTimer",
              "documentation": {
                "identifier": "modTimer",
                "newPage": false,
                "searchKey": "runtime.modTimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func modTimer(t *timer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc modTimer(t *timer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr)\n```\n\nmodTimer modifies an existing timer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goroutineReady",
              "documentation": {
                "identifier": "goroutineReady",
                "newPage": false,
                "searchKey": "runtime.goroutineReady",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goroutineReady(arg interface{}, seq uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goroutineReady(arg interface{}, seq uintptr)\n```\n\nReady the goroutine arg. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#addtimer",
              "documentation": {
                "identifier": "addtimer",
                "newPage": false,
                "searchKey": "runtime.addtimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addtimer(t *timer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addtimer(t *timer)\n```\n\naddtimer adds a timer to the current P. This should only be called with a newly created timer. That avoids the risk of changing the when field of a timer in some P's heap, which could cause the heap to become unsorted. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#doaddtimer",
              "documentation": {
                "identifier": "doaddtimer",
                "newPage": false,
                "searchKey": "runtime.doaddtimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func doaddtimer(pp *p, t *timer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc doaddtimer(pp *p, t *timer)\n```\n\ndoaddtimer adds t to the current P's heap. The caller must have locked the timers for pp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#deltimer",
              "documentation": {
                "identifier": "deltimer",
                "newPage": false,
                "searchKey": "runtime.deltimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func deltimer(t *timer) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc deltimer(t *timer) bool\n```\n\ndeltimer deletes the timer t. It may be on some other P, so we can't actually remove it from the timers heap. We can only mark it as deleted. It will be removed in due course by the P whose heap it is on. Reports whether the timer was removed before it was run. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dodeltimer",
              "documentation": {
                "identifier": "dodeltimer",
                "newPage": false,
                "searchKey": "runtime.dodeltimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dodeltimer(pp *p, i int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dodeltimer(pp *p, i int)\n```\n\ndodeltimer removes timer i from the current P's heap. We are locked on the P when this is called. It reports whether it saw no problems due to races. The caller must have locked the timers for pp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#dodeltimer0",
              "documentation": {
                "identifier": "dodeltimer0",
                "newPage": false,
                "searchKey": "runtime.dodeltimer0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func dodeltimer0(pp *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc dodeltimer0(pp *p)\n```\n\ndodeltimer0 removes timer 0 from the current P's heap. We are locked on the P when this is called. It reports whether it saw no problems due to races. The caller must have locked the timers for pp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#modtimer",
              "documentation": {
                "identifier": "modtimer",
                "newPage": false,
                "searchKey": "runtime.modtimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func modtimer(t *timer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc modtimer(t *timer, when, period int64, f func(interface{}, uintptr), arg interface{}, seq uintptr) bool\n```\n\nmodtimer modifies an existing timer. This is called by the netpoll code or time.Ticker.Reset or time.Timer.Reset. Reports whether the timer was modified before it was run. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#resettimer",
              "documentation": {
                "identifier": "resettimer",
                "newPage": false,
                "searchKey": "runtime.resettimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func resettimer(t *timer, when int64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resettimer(t *timer, when int64) bool\n```\n\nresettimer resets the time when a timer should fire. If used for an inactive timer, the timer will become active. This should be called instead of addtimer if the timer value has been, or may have been, used previously. Reports whether the timer was modified before it was run. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cleantimers",
              "documentation": {
                "identifier": "cleantimers",
                "newPage": false,
                "searchKey": "runtime.cleantimers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cleantimers(pp *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cleantimers(pp *p)\n```\n\ncleantimers cleans up the head of the timer queue. This speeds up programs that create and delete timers; leaving them in the heap slows down addtimer. Reports whether no timer problems were found. The caller must have locked the timers for pp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#moveTimers",
              "documentation": {
                "identifier": "moveTimers",
                "newPage": false,
                "searchKey": "runtime.moveTimers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func moveTimers(pp *p, timers []*timer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc moveTimers(pp *p, timers []*timer)\n```\n\nmoveTimers moves a slice of timers to pp. The slice has been taken from a different P. This is currently called when the world is stopped, but the caller is expected to have locked the timers for pp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#adjusttimers",
              "documentation": {
                "identifier": "adjusttimers",
                "newPage": false,
                "searchKey": "runtime.adjusttimers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func adjusttimers(pp *p, now int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc adjusttimers(pp *p, now int64)\n```\n\nadjusttimers looks through the timers in the current P's heap for any timers that have been modified to run earlier, and puts them in the correct place in the heap. While looking for those timers, it also moves timers that have been modified to run later, and removes deleted timers. The caller must have locked the timers for pp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#addAdjustedTimers",
              "documentation": {
                "identifier": "addAdjustedTimers",
                "newPage": false,
                "searchKey": "runtime.addAdjustedTimers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addAdjustedTimers(pp *p, moved []*timer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addAdjustedTimers(pp *p, moved []*timer)\n```\n\naddAdjustedTimers adds any timers we adjusted in adjusttimers back to the timer heap. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nobarrierWakeTime",
              "documentation": {
                "identifier": "nobarrierWakeTime",
                "newPage": false,
                "searchKey": "runtime.nobarrierWakeTime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nobarrierWakeTime(pp *p) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nobarrierWakeTime(pp *p) int64\n```\n\nnobarrierWakeTime looks at P's timers and returns the time when we should wake up the netpoller. It returns 0 if there are no timers. This function is invoked when dropping a P, and must run without any write barriers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runtimer",
              "documentation": {
                "identifier": "runtimer",
                "newPage": false,
                "searchKey": "runtime.runtimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runtimer(pp *p, now int64) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runtimer(pp *p, now int64) int64\n```\n\nruntimer examines the first timer in timers. If it is ready based on now, it runs the timer and removes or updates it. Returns 0 if it ran a timer, -1 if there are no more timers, or the time when the first timer should run. The caller must have locked the timers for pp. If a timer is run, this will temporarily unlock the timers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#runOneTimer",
              "documentation": {
                "identifier": "runOneTimer",
                "newPage": false,
                "searchKey": "runtime.runOneTimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runOneTimer(pp *p, t *timer, now int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runOneTimer(pp *p, t *timer, now int64)\n```\n\nrunOneTimer runs a single timer. The caller must have locked the timers for pp. This will temporarily unlock the timers while running the timer function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#clearDeletedTimers",
              "documentation": {
                "identifier": "clearDeletedTimers",
                "newPage": false,
                "searchKey": "runtime.clearDeletedTimers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func clearDeletedTimers(pp *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc clearDeletedTimers(pp *p)\n```\n\nclearDeletedTimers removes all deleted timers from the P's timer heap. This is used to avoid clogging up the heap if the program starts a lot of long-running timers and then stops them. For example, this can happen via context.WithTimeout. \n\nThis is the only function that walks through the entire timer heap, other than moveTimers which only runs when the world is stopped. \n\nThe caller must have locked the timers for pp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#verifyTimerHeap",
              "documentation": {
                "identifier": "verifyTimerHeap",
                "newPage": false,
                "searchKey": "runtime.verifyTimerHeap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func verifyTimerHeap(pp *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc verifyTimerHeap(pp *p)\n```\n\nverifyTimerHeap verifies that the timer heap is in a valid state. This is only for debugging, and is only called if verifyTimers is true. The caller must have locked the timers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#updateTimer0When",
              "documentation": {
                "identifier": "updateTimer0When",
                "newPage": false,
                "searchKey": "runtime.updateTimer0When",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func updateTimer0When(pp *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc updateTimer0When(pp *p)\n```\n\nupdateTimer0When sets the P's timer0When field. The caller must have locked the timers for pp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#updateTimerModifiedEarliest",
              "documentation": {
                "identifier": "updateTimerModifiedEarliest",
                "newPage": false,
                "searchKey": "runtime.updateTimerModifiedEarliest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func updateTimerModifiedEarliest(pp *p, nextwhen int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc updateTimerModifiedEarliest(pp *p, nextwhen int64)\n```\n\nupdateTimerModifiedEarliest updates the recorded nextwhen field of the earlier timerModifiedEarier value. The timers for pp will not be locked. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#siftupTimer",
              "documentation": {
                "identifier": "siftupTimer",
                "newPage": false,
                "searchKey": "runtime.siftupTimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func siftupTimer(t []*timer, i int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc siftupTimer(t []*timer, i int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#siftdownTimer",
              "documentation": {
                "identifier": "siftdownTimer",
                "newPage": false,
                "searchKey": "runtime.siftdownTimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func siftdownTimer(t []*timer, i int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc siftdownTimer(t []*timer, i int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#badTimer",
              "documentation": {
                "identifier": "badTimer",
                "newPage": false,
                "searchKey": "runtime.badTimer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func badTimer()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc badTimer()\n```\n\nbadTimer is called if the timer data structures have been corrupted, presumably due to racy use by the program. We panic here rather than panicing due to invalid slice access while holding locks. See issue #25686. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#nanotime",
              "documentation": {
                "identifier": "nanotime",
                "newPage": false,
                "searchKey": "runtime.nanotime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nanotime() int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nanotime() int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#write",
              "documentation": {
                "identifier": "write",
                "newPage": false,
                "searchKey": "runtime.write",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func write(fd uintptr, p unsafe.Pointer, n int32) int32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc write(fd uintptr, p unsafe.Pointer, n int32) int32\n```\n\nwrite must be nosplit on Windows (see write1) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#time_now",
              "documentation": {
                "identifier": "time_now",
                "newPage": false,
                "searchKey": "runtime.time_now",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func time_now() (sec int64, nsec int32, mono int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc time_now() (sec int64, nsec int32, mono int64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#osSetupTLS",
              "documentation": {
                "identifier": "osSetupTLS",
                "newPage": false,
                "searchKey": "runtime.osSetupTLS",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func osSetupTLS(mp *m)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc osSetupTLS(mp *m)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#StartTrace",
              "documentation": {
                "identifier": "StartTrace",
                "newPage": false,
                "searchKey": "runtime.StartTrace",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func StartTrace() error"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc StartTrace() error\n```\n\nStartTrace enables tracing for the current process. While tracing, the data will be buffered and available via ReadTrace. StartTrace returns an error if tracing is already enabled. Most clients should use the runtime/trace package or the testing package's -test.trace flag instead of calling StartTrace directly. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#StopTrace",
              "documentation": {
                "identifier": "StopTrace",
                "newPage": false,
                "searchKey": "runtime.StopTrace",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func StopTrace()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc StopTrace()\n```\n\nStopTrace stops tracing, if it was previously enabled. StopTrace only returns after all the reads for the trace have completed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ReadTrace",
              "documentation": {
                "identifier": "ReadTrace",
                "newPage": false,
                "searchKey": "runtime.ReadTrace",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func ReadTrace() []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ReadTrace() []byte\n```\n\nReadTrace returns the next chunk of binary tracing data, blocking until data is available. If tracing is turned off and all the data accumulated while it was on has been returned, ReadTrace returns nil. The caller must copy the returned data before calling ReadTrace again. ReadTrace must be called from one goroutine at a time. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceProcFree",
              "documentation": {
                "identifier": "traceProcFree",
                "newPage": false,
                "searchKey": "runtime.traceProcFree",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceProcFree(pp *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceProcFree(pp *p)\n```\n\ntraceProcFree frees trace buffer associated with pp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceFullQueue",
              "documentation": {
                "identifier": "traceFullQueue",
                "newPage": false,
                "searchKey": "runtime.traceFullQueue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceFullQueue(buf traceBufPtr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceFullQueue(buf traceBufPtr)\n```\n\ntraceFullQueue queues buf into queue of full buffers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEvent",
              "documentation": {
                "identifier": "traceEvent",
                "newPage": false,
                "searchKey": "runtime.traceEvent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceEvent(ev byte, skip int, args ...uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceEvent(ev byte, skip int, args ...uint64)\n```\n\ntraceEvent writes a single event to trace buffer, flushing the buffer if necessary. ev is event type. If skip > 0, write current stack id as the last argument (skipping skip top frames). If skip = 0, this event type should contain a stack, but we don't want to collect and remember it for this particular call. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceEventLocked",
              "documentation": {
                "identifier": "traceEventLocked",
                "newPage": false,
                "searchKey": "runtime.traceEventLocked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceEventLocked(extraBytes int, mp *m, pid int32, bufp *traceBufPtr, ev byte, skip int, args ...uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceEventLocked(extraBytes int, mp *m, pid int32, bufp *traceBufPtr, ev byte, skip int, args ...uint64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceStackID",
              "documentation": {
                "identifier": "traceStackID",
                "newPage": false,
                "searchKey": "runtime.traceStackID",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceStackID(mp *m, buf []uintptr, skip int) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceStackID(mp *m, buf []uintptr, skip int) uint64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceReleaseBuffer",
              "documentation": {
                "identifier": "traceReleaseBuffer",
                "newPage": false,
                "searchKey": "runtime.traceReleaseBuffer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceReleaseBuffer(pid int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceReleaseBuffer(pid int32)\n```\n\ntraceReleaseBuffer releases a buffer previously acquired with traceAcquireBuffer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceAppend",
              "documentation": {
                "identifier": "traceAppend",
                "newPage": false,
                "searchKey": "runtime.traceAppend",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceAppend(buf []byte, v uint64) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceAppend(buf []byte, v uint64) []byte\n```\n\ntraceAppend appends v to buf in little-endian-base-128 encoding. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#allFrames",
              "documentation": {
                "identifier": "allFrames",
                "newPage": false,
                "searchKey": "runtime.allFrames",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func allFrames(pcs []uintptr) []Frame"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc allFrames(pcs []uintptr) []Frame\n```\n\nallFrames returns all of the Frames corresponding to pcs. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGomaxprocs",
              "documentation": {
                "identifier": "traceGomaxprocs",
                "newPage": false,
                "searchKey": "runtime.traceGomaxprocs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGomaxprocs(procs int32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGomaxprocs(procs int32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceProcStart",
              "documentation": {
                "identifier": "traceProcStart",
                "newPage": false,
                "searchKey": "runtime.traceProcStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceProcStart()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceProcStart()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceProcStop",
              "documentation": {
                "identifier": "traceProcStop",
                "newPage": false,
                "searchKey": "runtime.traceProcStop",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceProcStop(pp *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceProcStop(pp *p)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGCStart",
              "documentation": {
                "identifier": "traceGCStart",
                "newPage": false,
                "searchKey": "runtime.traceGCStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGCStart()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGCStart()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGCDone",
              "documentation": {
                "identifier": "traceGCDone",
                "newPage": false,
                "searchKey": "runtime.traceGCDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGCDone()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGCDone()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGCSTWStart",
              "documentation": {
                "identifier": "traceGCSTWStart",
                "newPage": false,
                "searchKey": "runtime.traceGCSTWStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGCSTWStart(kind int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGCSTWStart(kind int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGCSTWDone",
              "documentation": {
                "identifier": "traceGCSTWDone",
                "newPage": false,
                "searchKey": "runtime.traceGCSTWDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGCSTWDone()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGCSTWDone()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGCSweepStart",
              "documentation": {
                "identifier": "traceGCSweepStart",
                "newPage": false,
                "searchKey": "runtime.traceGCSweepStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGCSweepStart()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGCSweepStart()\n```\n\ntraceGCSweepStart prepares to trace a sweep loop. This does not emit any events until traceGCSweepSpan is called. \n\ntraceGCSweepStart must be paired with traceGCSweepDone and there must be no preemption points between these two calls. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGCSweepSpan",
              "documentation": {
                "identifier": "traceGCSweepSpan",
                "newPage": false,
                "searchKey": "runtime.traceGCSweepSpan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGCSweepSpan(bytesSwept uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGCSweepSpan(bytesSwept uintptr)\n```\n\ntraceGCSweepSpan traces the sweep of a single page. \n\nThis may be called outside a traceGCSweepStart/traceGCSweepDone pair; however, it will not emit any trace events in this case. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGCSweepDone",
              "documentation": {
                "identifier": "traceGCSweepDone",
                "newPage": false,
                "searchKey": "runtime.traceGCSweepDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGCSweepDone()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGCSweepDone()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGCMarkAssistStart",
              "documentation": {
                "identifier": "traceGCMarkAssistStart",
                "newPage": false,
                "searchKey": "runtime.traceGCMarkAssistStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGCMarkAssistStart()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGCMarkAssistStart()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGCMarkAssistDone",
              "documentation": {
                "identifier": "traceGCMarkAssistDone",
                "newPage": false,
                "searchKey": "runtime.traceGCMarkAssistDone",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGCMarkAssistDone()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGCMarkAssistDone()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGoCreate",
              "documentation": {
                "identifier": "traceGoCreate",
                "newPage": false,
                "searchKey": "runtime.traceGoCreate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGoCreate(newg *g, pc uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGoCreate(newg *g, pc uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGoStart",
              "documentation": {
                "identifier": "traceGoStart",
                "newPage": false,
                "searchKey": "runtime.traceGoStart",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGoStart()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGoStart()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGoEnd",
              "documentation": {
                "identifier": "traceGoEnd",
                "newPage": false,
                "searchKey": "runtime.traceGoEnd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGoEnd()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGoEnd()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGoSched",
              "documentation": {
                "identifier": "traceGoSched",
                "newPage": false,
                "searchKey": "runtime.traceGoSched",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGoSched()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGoSched()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGoPreempt",
              "documentation": {
                "identifier": "traceGoPreempt",
                "newPage": false,
                "searchKey": "runtime.traceGoPreempt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGoPreempt()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGoPreempt()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGoPark",
              "documentation": {
                "identifier": "traceGoPark",
                "newPage": false,
                "searchKey": "runtime.traceGoPark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGoPark(traceEv byte, skip int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGoPark(traceEv byte, skip int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGoUnpark",
              "documentation": {
                "identifier": "traceGoUnpark",
                "newPage": false,
                "searchKey": "runtime.traceGoUnpark",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGoUnpark(gp *g, skip int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGoUnpark(gp *g, skip int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGoSysCall",
              "documentation": {
                "identifier": "traceGoSysCall",
                "newPage": false,
                "searchKey": "runtime.traceGoSysCall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGoSysCall()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGoSysCall()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGoSysExit",
              "documentation": {
                "identifier": "traceGoSysExit",
                "newPage": false,
                "searchKey": "runtime.traceGoSysExit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGoSysExit(ts int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGoSysExit(ts int64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceGoSysBlock",
              "documentation": {
                "identifier": "traceGoSysBlock",
                "newPage": false,
                "searchKey": "runtime.traceGoSysBlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceGoSysBlock(pp *p)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceGoSysBlock(pp *p)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceHeapAlloc",
              "documentation": {
                "identifier": "traceHeapAlloc",
                "newPage": false,
                "searchKey": "runtime.traceHeapAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceHeapAlloc()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceHeapAlloc()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceHeapGoal",
              "documentation": {
                "identifier": "traceHeapGoal",
                "newPage": false,
                "searchKey": "runtime.traceHeapGoal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceHeapGoal()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceHeapGoal()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#trace_userTaskCreate",
              "documentation": {
                "identifier": "trace_userTaskCreate",
                "newPage": false,
                "searchKey": "runtime.trace_userTaskCreate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func trace_userTaskCreate(id, parentID uint64, taskType string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc trace_userTaskCreate(id, parentID uint64, taskType string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#trace_userTaskEnd",
              "documentation": {
                "identifier": "trace_userTaskEnd",
                "newPage": false,
                "searchKey": "runtime.trace_userTaskEnd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func trace_userTaskEnd(id uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc trace_userTaskEnd(id uint64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#trace_userRegion",
              "documentation": {
                "identifier": "trace_userRegion",
                "newPage": false,
                "searchKey": "runtime.trace_userRegion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func trace_userRegion(id, mode uint64, name string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc trace_userRegion(id, mode uint64, name string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#trace_userLog",
              "documentation": {
                "identifier": "trace_userLog",
                "newPage": false,
                "searchKey": "runtime.trace_userLog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func trace_userLog(id uint64, category, message string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc trace_userLog(id uint64, category, message string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracebackdefers",
              "documentation": {
                "identifier": "tracebackdefers",
                "newPage": false,
                "searchKey": "runtime.tracebackdefers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tracebackdefers(gp *g, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tracebackdefers(gp *g, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer)\n```\n\nTraceback over the deferred function calls. Report them like calls that have been invoked but not started executing yet. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gentraceback",
              "documentation": {
                "identifier": "gentraceback",
                "newPage": false,
                "searchKey": "runtime.gentraceback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gentraceback(pc0, sp0, lr0 uintptr, gp *g, skip int, pcbuf *uintptr, max int, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer, flags uint) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gentraceback(pc0, sp0, lr0 uintptr, gp *g, skip int, pcbuf *uintptr, max int, callback func(*stkframe, unsafe.Pointer) bool, v unsafe.Pointer, flags uint) int\n```\n\nGeneric traceback. Handles runtime stack prints (pcbuf == nil), the runtime.Callers function (pcbuf != nil), as well as the garbage collector (callback != nil).  A little clunky to merge these, but avoids duplicating the code and all its subtlety. \n\nThe skip argument is only valid with pcbuf != nil and counts the number of logical frames to skip rather than physical frames (with inlining, a PC in pcbuf can represent multiple calls). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printArgs",
              "documentation": {
                "identifier": "printArgs",
                "newPage": false,
                "searchKey": "runtime.printArgs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printArgs(f funcInfo, argp unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printArgs(f funcInfo, argp unsafe.Pointer)\n```\n\nprintArgs prints function arguments in traceback. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracebackCgoContext",
              "documentation": {
                "identifier": "tracebackCgoContext",
                "newPage": false,
                "searchKey": "runtime.tracebackCgoContext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tracebackCgoContext(pcbuf *uintptr, printing bool, ctxt uintptr, n, max int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tracebackCgoContext(pcbuf *uintptr, printing bool, ctxt uintptr, n, max int) int\n```\n\ntracebackCgoContext handles tracing back a cgo context value, from the context argument to setCgoTraceback, for the gentraceback function. It returns the new value of n. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printcreatedby",
              "documentation": {
                "identifier": "printcreatedby",
                "newPage": false,
                "searchKey": "runtime.printcreatedby",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printcreatedby(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printcreatedby(gp *g)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printcreatedby1",
              "documentation": {
                "identifier": "printcreatedby1",
                "newPage": false,
                "searchKey": "runtime.printcreatedby1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printcreatedby1(f funcInfo, pc uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printcreatedby1(f funcInfo, pc uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceback",
              "documentation": {
                "identifier": "traceback",
                "newPage": false,
                "searchKey": "runtime.traceback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceback(pc, sp, lr uintptr, gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceback(pc, sp, lr uintptr, gp *g)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracebacktrap",
              "documentation": {
                "identifier": "tracebacktrap",
                "newPage": false,
                "searchKey": "runtime.tracebacktrap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tracebacktrap(pc, sp, lr uintptr, gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tracebacktrap(pc, sp, lr uintptr, gp *g)\n```\n\ntracebacktrap is like traceback but expects that the PC and SP were obtained from a trap, not from gp->sched or gp->syscallpc/gp->syscallsp or getcallerpc/getcallersp. Because they are from a trap instead of from a saved pair, the initial PC must not be rewound to the previous instruction. (All the saved pairs record a PC that is a return address, so we rewind it into the CALL instruction.) If gp.m.libcall{g,pc,sp} information is available, it uses that information in preference to the pc/sp/lr passed in. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#traceback1",
              "documentation": {
                "identifier": "traceback1",
                "newPage": false,
                "searchKey": "runtime.traceback1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func traceback1(pc, sp, lr uintptr, gp *g, flags uint)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc traceback1(pc, sp, lr uintptr, gp *g, flags uint)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printAncestorTraceback",
              "documentation": {
                "identifier": "printAncestorTraceback",
                "newPage": false,
                "searchKey": "runtime.printAncestorTraceback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printAncestorTraceback(ancestor ancestorInfo)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printAncestorTraceback(ancestor ancestorInfo)\n```\n\nprintAncestorTraceback prints the traceback of the given ancestor. TODO: Unify this with gentraceback and CallersFrames. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printAncestorTracebackFuncInfo",
              "documentation": {
                "identifier": "printAncestorTracebackFuncInfo",
                "newPage": false,
                "searchKey": "runtime.printAncestorTracebackFuncInfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printAncestorTracebackFuncInfo(f funcInfo, pc uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printAncestorTracebackFuncInfo(f funcInfo, pc uintptr)\n```\n\nprintAncestorTraceback prints the given function info at a given pc within an ancestor traceback. The precision of this info is reduced due to only have access to the pcs at the time of the caller goroutine being created. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#callers",
              "documentation": {
                "identifier": "callers",
                "newPage": false,
                "searchKey": "runtime.callers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func callers(skip int, pcbuf []uintptr) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc callers(skip int, pcbuf []uintptr) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#gcallers",
              "documentation": {
                "identifier": "gcallers",
                "newPage": false,
                "searchKey": "runtime.gcallers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func gcallers(gp *g, skip int, pcbuf []uintptr) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc gcallers(gp *g, skip int, pcbuf []uintptr) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#showframe",
              "documentation": {
                "identifier": "showframe",
                "newPage": false,
                "searchKey": "runtime.showframe",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func showframe(f funcInfo, gp *g, firstFrame bool, funcID, childID funcID) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc showframe(f funcInfo, gp *g, firstFrame bool, funcID, childID funcID) bool\n```\n\nshowframe reports whether the frame with the given characteristics should be printed during a traceback. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#showfuncinfo",
              "documentation": {
                "identifier": "showfuncinfo",
                "newPage": false,
                "searchKey": "runtime.showfuncinfo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func showfuncinfo(f funcInfo, firstFrame bool, funcID, childID funcID) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc showfuncinfo(f funcInfo, firstFrame bool, funcID, childID funcID) bool\n```\n\nshowfuncinfo reports whether a function with the given characteristics should be printed during a traceback. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isExportedRuntime",
              "documentation": {
                "identifier": "isExportedRuntime",
                "newPage": false,
                "searchKey": "runtime.isExportedRuntime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isExportedRuntime(name string) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isExportedRuntime(name string) bool\n```\n\nisExportedRuntime reports whether name is an exported runtime function. It is only for runtime functions, so ASCII A-Z is fine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#elideWrapperCalling",
              "documentation": {
                "identifier": "elideWrapperCalling",
                "newPage": false,
                "searchKey": "runtime.elideWrapperCalling",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func elideWrapperCalling(id funcID) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc elideWrapperCalling(id funcID) bool\n```\n\nelideWrapperCalling reports whether a wrapper function that called function id should be elided from stack traces. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#goroutineheader",
              "documentation": {
                "identifier": "goroutineheader",
                "newPage": false,
                "searchKey": "runtime.goroutineheader",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func goroutineheader(gp *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc goroutineheader(gp *g)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracebackothers",
              "documentation": {
                "identifier": "tracebackothers",
                "newPage": false,
                "searchKey": "runtime.tracebackothers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tracebackothers(me *g)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tracebackothers(me *g)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#tracebackHexdump",
              "documentation": {
                "identifier": "tracebackHexdump",
                "newPage": false,
                "searchKey": "runtime.tracebackHexdump",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func tracebackHexdump(stk stack, frame *stkframe, bad uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc tracebackHexdump(stk stack, frame *stkframe, bad uintptr)\n```\n\ntracebackHexdump hexdumps part of stk around frame.sp and frame.fp for debugging purposes. If the address bad is included in the hexdumped range, it will mark it as well. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isSystemGoroutine",
              "documentation": {
                "identifier": "isSystemGoroutine",
                "newPage": false,
                "searchKey": "runtime.isSystemGoroutine",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isSystemGoroutine(gp *g, fixed bool) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isSystemGoroutine(gp *g, fixed bool) bool\n```\n\nisSystemGoroutine reports whether the goroutine g must be omitted in stack dumps and deadlock detector. This is any goroutine that starts at a runtime.* entry point, except for runtime.main, runtime.handleAsyncEvent (wasm only) and sometimes runtime.runfinq. \n\nIf fixed is true, any goroutine that can vary between user and system (that is, the finalizer goroutine) is considered a user goroutine. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#SetCgoTraceback",
              "documentation": {
                "identifier": "SetCgoTraceback",
                "newPage": false,
                "searchKey": "runtime.SetCgoTraceback",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetCgoTraceback(version int, traceback, context, symbolizer unsafe.Pointer)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetCgoTraceback(version int, traceback, context, symbolizer unsafe.Pointer)\n```\n\nSetCgoTraceback records three C functions to use to gather traceback information from C code and to convert that traceback information into symbolic information. These are used when printing stack traces for a program that uses cgo. \n\nThe traceback and context functions may be called from a signal handler, and must therefore use only async-signal safe functions. The symbolizer function may be called while the program is crashing, and so must be cautious about using memory.  None of the functions may call back into Go. \n\nThe context function will be called with a single argument, a pointer to a struct: \n\n```\nstruct {\n\tContext uintptr\n}\n\n```\nIn C syntax, this struct will be \n\n```\nstruct {\n\tuintptr_t Context;\n};\n\n```\nIf the Context field is 0, the context function is being called to record the current traceback context. It should record in the Context field whatever information is needed about the current point of execution to later produce a stack trace, probably the stack pointer and PC. In this case the context function will be called from C code. \n\nIf the Context field is not 0, then it is a value returned by a previous call to the context function. This case is called when the context is no longer needed; that is, when the Go code is returning to its C code caller. This permits the context function to release any associated resources. \n\nWhile it would be correct for the context function to record a complete a stack trace whenever it is called, and simply copy that out in the traceback function, in a typical program the context function will be called many times without ever recording a traceback for that context. Recording a complete stack trace in a call to the context function is likely to be inefficient. \n\nThe traceback function will be called with a single argument, a pointer to a struct: \n\n```\nstruct {\n\tContext    uintptr\n\tSigContext uintptr\n\tBuf        *uintptr\n\tMax        uintptr\n}\n\n```\nIn C syntax, this struct will be \n\n```\nstruct {\n\tuintptr_t  Context;\n\tuintptr_t  SigContext;\n\tuintptr_t* Buf;\n\tuintptr_t  Max;\n};\n\n```\nThe Context field will be zero to gather a traceback from the current program execution point. In this case, the traceback function will be called from C code. \n\nOtherwise Context will be a value previously returned by a call to the context function. The traceback function should gather a stack trace from that saved point in the program execution. The traceback function may be called from an execution thread other than the one that recorded the context, but only when the context is known to be valid and unchanging. The traceback function may also be called deeper in the call stack on the same thread that recorded the context. The traceback function may be called multiple times with the same Context value; it will usually be appropriate to cache the result, if possible, the first time this is called for a specific context value. \n\nIf the traceback function is called from a signal handler on a Unix system, SigContext will be the signal context argument passed to the signal handler (a C ucontext_t* cast to uintptr_t). This may be used to start tracing at the point where the signal occurred. If the traceback function is not called from a signal handler, SigContext will be zero. \n\nBuf is where the traceback information should be stored. It should be PC values, such that Buf[0] is the PC of the caller, Buf[1] is the PC of that function's caller, and so on.  Max is the maximum number of entries to store.  The function should store a zero to indicate the top of the stack, or that the caller is on a different stack, presumably a Go stack. \n\nUnlike runtime.Callers, the PC values returned should, when passed to the symbolizer function, return the file/line of the call instruction.  No additional subtraction is required or appropriate. \n\nOn all platforms, the traceback function is invoked when a call from Go to C to Go requests a stack trace. On linux/amd64, linux/ppc64le, and freebsd/amd64, the traceback function is also invoked when a signal is received by a thread that is executing a cgo call. The traceback function should not make assumptions about when it is called, as future versions of Go may make additional calls. \n\nThe symbolizer function will be called with a single argument, a pointer to a struct: \n\n```\nstruct {\n\tPC      uintptr // program counter to fetch information for\n\tFile    *byte   // file name (NUL terminated)\n\tLineno  uintptr // line number\n\tFunc    *byte   // function name (NUL terminated)\n\tEntry   uintptr // function entry point\n\tMore    uintptr // set non-zero if more info for this PC\n\tData    uintptr // unused by runtime, available for function\n}\n\n```\nIn C syntax, this struct will be \n\n```\nstruct {\n\tuintptr_t PC;\n\tchar*     File;\n\tuintptr_t Lineno;\n\tchar*     Func;\n\tuintptr_t Entry;\n\tuintptr_t More;\n\tuintptr_t Data;\n};\n\n```\nThe PC field will be a value returned by a call to the traceback function. \n\nThe first time the function is called for a particular traceback, all the fields except PC will be 0. The function should fill in the other fields if possible, setting them to 0/nil if the information is not available. The Data field may be used to store any useful information across calls. The More field should be set to non-zero if there is more information for this PC, zero otherwise. If More is set non-zero, the function will be called again with the same PC, and may return different information (this is intended for use with inlined functions). If More is zero, the function will be called with the next PC value in the traceback. When the traceback is complete, the function will be called once more with PC set to zero; this may be used to free any information. Each call will leave the fields of the struct set to the same values they had upon return, except for the PC field when the More field is zero. The function must not keep a copy of the struct pointer between calls. \n\nWhen calling SetCgoTraceback, the version argument is the version number of the structs that the functions expect to receive. Currently this must be zero. \n\nThe symbolizer function may be nil, in which case the results of the traceback function will be displayed as numbers. If the traceback function is nil, the symbolizer function will never be called. The context function may be nil, in which case the traceback function will only be called with the context field set to zero.  If the context function is nil, then calls from Go to C to Go will not show a traceback for the C portion of the call stack. \n\nSetCgoTraceback should be called only once, ideally from an init function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printCgoTraceback",
              "documentation": {
                "identifier": "printCgoTraceback",
                "newPage": false,
                "searchKey": "runtime.printCgoTraceback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printCgoTraceback(callers *cgoCallers)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printCgoTraceback(callers *cgoCallers)\n```\n\ncgoTraceback prints a traceback of callers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#printOneCgoTraceback",
              "documentation": {
                "identifier": "printOneCgoTraceback",
                "newPage": false,
                "searchKey": "runtime.printOneCgoTraceback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func printOneCgoTraceback(pc uintptr, max int, arg *cgoSymbolizerArg) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc printOneCgoTraceback(pc uintptr, max int, arg *cgoSymbolizerArg) int\n```\n\nprintOneCgoTraceback prints the traceback of a single cgo caller. This can print more than one line because of inlining. Returns the number of frames printed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#callCgoSymbolizer",
              "documentation": {
                "identifier": "callCgoSymbolizer",
                "newPage": false,
                "searchKey": "runtime.callCgoSymbolizer",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func callCgoSymbolizer(arg *cgoSymbolizerArg)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc callCgoSymbolizer(arg *cgoSymbolizerArg)\n```\n\ncallCgoSymbolizer calls the cgoSymbolizer function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#cgoContextPCs",
              "documentation": {
                "identifier": "cgoContextPCs",
                "newPage": false,
                "searchKey": "runtime.cgoContextPCs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cgoContextPCs(ctxt uintptr, buf []uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cgoContextPCs(ctxt uintptr, buf []uintptr)\n```\n\ncgoContextPCs gets the PC values from a cgo traceback. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectOffsLock",
              "documentation": {
                "identifier": "reflectOffsLock",
                "newPage": false,
                "searchKey": "runtime.reflectOffsLock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectOffsLock()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectOffsLock()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#reflectOffsUnlock",
              "documentation": {
                "identifier": "reflectOffsUnlock",
                "newPage": false,
                "searchKey": "runtime.reflectOffsUnlock",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func reflectOffsUnlock()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc reflectOffsUnlock()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typelinksinit",
              "documentation": {
                "identifier": "typelinksinit",
                "newPage": false,
                "searchKey": "runtime.typelinksinit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typelinksinit()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typelinksinit()\n```\n\ntypelinksinit scans the types from extra modules and builds the moduledata typemap used to de-duplicate type pointers. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#typesEqual",
              "documentation": {
                "identifier": "typesEqual",
                "newPage": false,
                "searchKey": "runtime.typesEqual",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func typesEqual(t, v *_type, seen map[_typePair]struct{}) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc typesEqual(t, v *_type, seen map[_typePair]struct{}) bool\n```\n\ntypesEqual reports whether two types are equal. \n\nEverywhere in the runtime and reflect packages, it is assumed that there is exactly one *_type per Go type, so that pointer equality can be used to test if types are equal. There is one place that breaks this assumption: buildmode=shared. In this case a type can appear as two different pieces of memory. This is hidden from the runtime and reflect package by the per-module typemap built in typelinksinit. It uses typesEqual to map types from later modules back into earlier ones. \n\nOnly typelinksinit needs this function. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#isDirectIface",
              "documentation": {
                "identifier": "isDirectIface",
                "newPage": false,
                "searchKey": "runtime.isDirectIface",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isDirectIface(t *_type) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isDirectIface(t *_type) bool\n```\n\nisDirectIface reports whether t is stored directly in an interface value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#countrunes",
              "documentation": {
                "identifier": "countrunes",
                "newPage": false,
                "searchKey": "runtime.countrunes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func countrunes(s string) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc countrunes(s string) int\n```\n\ncountrunes returns the number of runes in s. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#decoderune",
              "documentation": {
                "identifier": "decoderune",
                "newPage": false,
                "searchKey": "runtime.decoderune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func decoderune(s string, k int) (r rune, pos int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc decoderune(s string, k int) (r rune, pos int)\n```\n\ndecoderune returns the non-ASCII rune at the start of s[k:] and the index after the rune in s. \n\ndecoderune assumes that caller has checked that the to be decoded rune is a non-ASCII rune. \n\nIf the string appears to be incomplete or decoding problems are encountered (runeerror, k + 1) is returned to ensure progress when decoderune is used to iterate over a string. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#encoderune",
              "documentation": {
                "identifier": "encoderune",
                "newPage": false,
                "searchKey": "runtime.encoderune",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func encoderune(p []byte, r rune) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc encoderune(p []byte, r rune) int\n```\n\nencoderune writes into p (which must be large enough) the UTF-8 encoding of the rune. It returns the number of bytes written. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#inVDSOPage",
              "documentation": {
                "identifier": "inVDSOPage",
                "newPage": false,
                "searchKey": "runtime.inVDSOPage",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func inVDSOPage(pc uintptr) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc inVDSOPage(pc uintptr) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#writeErr",
              "documentation": {
                "identifier": "writeErr",
                "newPage": false,
                "searchKey": "runtime.writeErr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeErr(b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeErr(b []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Fcntl",
              "documentation": {
                "identifier": "Fcntl",
                "newPage": false,
                "searchKey": "runtime.Fcntl",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Fcntl(fd, cmd, arg uintptr) (uintptr, uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Fcntl(fd, cmd, arg uintptr) (uintptr, uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#DumpDebugLog",
              "documentation": {
                "identifier": "DumpDebugLog",
                "newPage": false,
                "searchKey": "runtime.DumpDebugLog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func DumpDebugLog() string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc DumpDebugLog() string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ResetDebugLog",
              "documentation": {
                "identifier": "ResetDebugLog",
                "newPage": false,
                "searchKey": "runtime.ResetDebugLog",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ResetDebugLog()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ResetDebugLog()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GetPhysPageSize",
              "documentation": {
                "identifier": "GetPhysPageSize",
                "newPage": false,
                "searchKey": "runtime.GetPhysPageSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func GetPhysPageSize() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc GetPhysPageSize() uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#LFStackPush",
              "documentation": {
                "identifier": "LFStackPush",
                "newPage": false,
                "searchKey": "runtime.LFStackPush",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func LFStackPush(head *uint64, node *LFNode)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LFStackPush(head *uint64, node *LFNode)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Netpoll",
              "documentation": {
                "identifier": "Netpoll",
                "newPage": false,
                "searchKey": "runtime.Netpoll",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Netpoll(delta int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Netpoll(delta int64)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GCMask",
              "documentation": {
                "identifier": "GCMask",
                "newPage": false,
                "searchKey": "runtime.GCMask",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func GCMask(x interface{}) (ret []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc GCMask(x interface{}) (ret []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#RunSchedLocalQueueTest",
              "documentation": {
                "identifier": "RunSchedLocalQueueTest",
                "newPage": false,
                "searchKey": "runtime.RunSchedLocalQueueTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func RunSchedLocalQueueTest()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc RunSchedLocalQueueTest()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#RunSchedLocalQueueStealTest",
              "documentation": {
                "identifier": "RunSchedLocalQueueStealTest",
                "newPage": false,
                "searchKey": "runtime.RunSchedLocalQueueStealTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func RunSchedLocalQueueStealTest()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc RunSchedLocalQueueStealTest()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#RunSchedLocalQueueEmptyTest",
              "documentation": {
                "identifier": "RunSchedLocalQueueEmptyTest",
                "newPage": false,
                "searchKey": "runtime.RunSchedLocalQueueEmptyTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func RunSchedLocalQueueEmptyTest(iters int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc RunSchedLocalQueueEmptyTest(iters int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MemclrBytes",
              "documentation": {
                "identifier": "MemclrBytes",
                "newPage": false,
                "searchKey": "runtime.MemclrBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func MemclrBytes(b []byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MemclrBytes(b []byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GostringW",
              "documentation": {
                "identifier": "GostringW",
                "newPage": false,
                "searchKey": "runtime.GostringW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func GostringW(w []uint16) (s string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc GostringW(w []uint16) (s string)\n```\n\nentry point for testing \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Envs",
              "documentation": {
                "identifier": "Envs",
                "newPage": false,
                "searchKey": "runtime.Envs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Envs() []string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Envs() []string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#SetEnvs",
              "documentation": {
                "identifier": "SetEnvs",
                "newPage": false,
                "searchKey": "runtime.SetEnvs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetEnvs(e []string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetEnvs(e []string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#BenchSetType",
              "documentation": {
                "identifier": "BenchSetType",
                "newPage": false,
                "searchKey": "runtime.BenchSetType",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchSetType(n int, x interface{})"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchSetType(n int, x interface{})\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#SetTracebackEnv",
              "documentation": {
                "identifier": "SetTracebackEnv",
                "newPage": false,
                "searchKey": "runtime.SetTracebackEnv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetTracebackEnv(level string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetTracebackEnv(level string)\n```\n\nSetTracebackEnv is like runtime/debug.SetTraceback, but it raises the \"environment\" traceback level, so later calls to debug.SetTraceback (e.g., from testing timeouts) can't lower it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#CountPagesInUse",
              "documentation": {
                "identifier": "CountPagesInUse",
                "newPage": false,
                "searchKey": "runtime.CountPagesInUse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func CountPagesInUse() (pagesInUse, counted uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc CountPagesInUse() (pagesInUse, counted uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Fastrand",
              "documentation": {
                "identifier": "Fastrand",
                "newPage": false,
                "searchKey": "runtime.Fastrand",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Fastrand() uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Fastrand() uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Fastrandn",
              "documentation": {
                "identifier": "Fastrandn",
                "newPage": false,
                "searchKey": "runtime.Fastrandn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Fastrandn(n uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Fastrandn(n uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#ReadMetricsSlow",
              "documentation": {
                "identifier": "ReadMetricsSlow",
                "newPage": false,
                "searchKey": "runtime.ReadMetricsSlow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ReadMetricsSlow(memStats *MemStats, samplesp unsafe.Pointer, len, cap int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ReadMetricsSlow(memStats *MemStats, samplesp unsafe.Pointer, len, cap int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#BlockOnSystemStack",
              "documentation": {
                "identifier": "BlockOnSystemStack",
                "newPage": false,
                "searchKey": "runtime.BlockOnSystemStack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BlockOnSystemStack()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BlockOnSystemStack()\n```\n\nBlockOnSystemStack switches to the system stack, prints \"x\\n\" to stderr, and blocks in a stack containing \"runtime.blockOnSystemStackInternal\". \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#blockOnSystemStackInternal",
              "documentation": {
                "identifier": "blockOnSystemStackInternal",
                "newPage": false,
                "searchKey": "runtime.blockOnSystemStackInternal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func blockOnSystemStackInternal()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc blockOnSystemStackInternal()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MapBucketsCount",
              "documentation": {
                "identifier": "MapBucketsCount",
                "newPage": false,
                "searchKey": "runtime.MapBucketsCount",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func MapBucketsCount(m map[int]int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MapBucketsCount(m map[int]int) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MapBucketsPointerIsNil",
              "documentation": {
                "identifier": "MapBucketsPointerIsNil",
                "newPage": false,
                "searchKey": "runtime.MapBucketsPointerIsNil",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func MapBucketsPointerIsNil(m map[int]int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MapBucketsPointerIsNil(m map[int]int) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#LockOSCounts",
              "documentation": {
                "identifier": "LockOSCounts",
                "newPage": false,
                "searchKey": "runtime.LockOSCounts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func LockOSCounts() (external, internal uint32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LockOSCounts() (external, internal uint32)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#TracebackSystemstack",
              "documentation": {
                "identifier": "TracebackSystemstack",
                "newPage": false,
                "searchKey": "runtime.TracebackSystemstack",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TracebackSystemstack(stk []uintptr, i int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TracebackSystemstack(stk []uintptr, i int) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#KeepNArenaHints",
              "documentation": {
                "identifier": "KeepNArenaHints",
                "newPage": false,
                "searchKey": "runtime.KeepNArenaHints",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func KeepNArenaHints(n int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc KeepNArenaHints(n int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MapNextArenaHint",
              "documentation": {
                "identifier": "MapNextArenaHint",
                "newPage": false,
                "searchKey": "runtime.MapNextArenaHint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func MapNextArenaHint() (start, end uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MapNextArenaHint() (start, end uintptr)\n```\n\nMapNextArenaHint reserves a page at the next arena growth hint, preventing the arena from growing there, and returns the range of addresses that are no longer viable. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GetNextArenaHint",
              "documentation": {
                "identifier": "GetNextArenaHint",
                "newPage": false,
                "searchKey": "runtime.GetNextArenaHint",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func GetNextArenaHint() uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc GetNextArenaHint() uintptr\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PanicForTesting",
              "documentation": {
                "identifier": "PanicForTesting",
                "newPage": false,
                "searchKey": "runtime.PanicForTesting",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func PanicForTesting(b []byte, i int) byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc PanicForTesting(b []byte, i int) byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#unexportedPanicForTesting",
              "documentation": {
                "identifier": "unexportedPanicForTesting",
                "newPage": false,
                "searchKey": "runtime.unexportedPanicForTesting",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func unexportedPanicForTesting(b []byte, i int) byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc unexportedPanicForTesting(b []byte, i int) byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#G0StackOverflow",
              "documentation": {
                "identifier": "G0StackOverflow",
                "newPage": false,
                "searchKey": "runtime.G0StackOverflow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func G0StackOverflow()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc G0StackOverflow()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#stackOverflow",
              "documentation": {
                "identifier": "stackOverflow",
                "newPage": false,
                "searchKey": "runtime.stackOverflow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func stackOverflow(x *byte)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc stackOverflow(x *byte)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MapTombstoneCheck",
              "documentation": {
                "identifier": "MapTombstoneCheck",
                "newPage": false,
                "searchKey": "runtime.MapTombstoneCheck",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func MapTombstoneCheck(m map[int]int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MapTombstoneCheck(m map[int]int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#RunGetgThreadSwitchTest",
              "documentation": {
                "identifier": "RunGetgThreadSwitchTest",
                "newPage": false,
                "searchKey": "runtime.RunGetgThreadSwitchTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func RunGetgThreadSwitchTest()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc RunGetgThreadSwitchTest()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#FindBitRange64",
              "documentation": {
                "identifier": "FindBitRange64",
                "newPage": false,
                "searchKey": "runtime.FindBitRange64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func FindBitRange64(c uint64, n uint) uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc FindBitRange64(c uint64, n uint) uint\n```\n\nExpose non-trivial helpers for testing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#DiffPallocBits",
              "documentation": {
                "identifier": "DiffPallocBits",
                "newPage": false,
                "searchKey": "runtime.DiffPallocBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func DiffPallocBits(a, b *PallocBits) []BitRange"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc DiffPallocBits(a, b *PallocBits) []BitRange\n```\n\nGiven two PallocBits, returns a set of bit ranges where they differ. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#StringifyPallocBits",
              "documentation": {
                "identifier": "StringifyPallocBits",
                "newPage": false,
                "searchKey": "runtime.StringifyPallocBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func StringifyPallocBits(b *PallocBits, r BitRange) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc StringifyPallocBits(b *PallocBits, r BitRange) string\n```\n\nStringifyPallocBits gets the bits in the bit range r from b, and returns a string containing the bits as ASCII 0 and 1 characters. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#FillAligned",
              "documentation": {
                "identifier": "FillAligned",
                "newPage": false,
                "searchKey": "runtime.FillAligned",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func FillAligned(x uint64, m uint) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc FillAligned(x uint64, m uint) uint64\n```\n\nExpose fillAligned for testing. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#FreePageAlloc",
              "documentation": {
                "identifier": "FreePageAlloc",
                "newPage": false,
                "searchKey": "runtime.FreePageAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func FreePageAlloc(pp *PageAlloc)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc FreePageAlloc(pp *PageAlloc)\n```\n\nFreePageAlloc releases hard OS resources owned by the pageAlloc. Once this is called the pageAlloc may no longer be used. The object itself will be collected by the garbage collector once it is no longer live. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PageBase",
              "documentation": {
                "identifier": "PageBase",
                "newPage": false,
                "searchKey": "runtime.PageBase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func PageBase(c ChunkIdx, pageIdx uint) uintptr"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc PageBase(c ChunkIdx, pageIdx uint) uintptr\n```\n\nPageBase returns an address given a chunk index and a page index relative to that chunk. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#CheckScavengedBitsCleared",
              "documentation": {
                "identifier": "CheckScavengedBitsCleared",
                "newPage": false,
                "searchKey": "runtime.CheckScavengedBitsCleared",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func CheckScavengedBitsCleared(mismatches []BitsMismatch) (n int, ok bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc CheckScavengedBitsCleared(mismatches []BitsMismatch) (n int, ok bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#PageCachePagesLeaked",
              "documentation": {
                "identifier": "PageCachePagesLeaked",
                "newPage": false,
                "searchKey": "runtime.PageCachePagesLeaked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func PageCachePagesLeaked() (leaked uintptr)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc PageCachePagesLeaked() (leaked uintptr)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#SemNwait",
              "documentation": {
                "identifier": "SemNwait",
                "newPage": false,
                "searchKey": "runtime.SemNwait",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func SemNwait(addr *uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SemNwait(addr *uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#FreeMSpan",
              "documentation": {
                "identifier": "FreeMSpan",
                "newPage": false,
                "searchKey": "runtime.FreeMSpan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func FreeMSpan(s *MSpan)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc FreeMSpan(s *MSpan)\n```\n\nFree an allocated mspan. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#MSpanCountAlloc",
              "documentation": {
                "identifier": "MSpanCountAlloc",
                "newPage": false,
                "searchKey": "runtime.MSpanCountAlloc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func MSpanCountAlloc(ms *MSpan, bits []byte) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc MSpanCountAlloc(ms *MSpan, bits []byte) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#SetIntArgRegs",
              "documentation": {
                "identifier": "SetIntArgRegs",
                "newPage": false,
                "searchKey": "runtime.SetIntArgRegs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func SetIntArgRegs(a int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SetIntArgRegs(a int) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#FinalizerGAsleep",
              "documentation": {
                "identifier": "FinalizerGAsleep",
                "newPage": false,
                "searchKey": "runtime.FinalizerGAsleep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func FinalizerGAsleep() bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc FinalizerGAsleep() bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GCTestIsReachable",
              "documentation": {
                "identifier": "GCTestIsReachable",
                "newPage": false,
                "searchKey": "runtime.GCTestIsReachable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func GCTestIsReachable(ptrs ...unsafe.Pointer) (mask uint64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc GCTestIsReachable(ptrs ...unsafe.Pointer) (mask uint64)\n```\n\nFor GCTestIsReachable, it's important that we do this as a call so escape analysis can see through it. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#GCTestPointerClass",
              "documentation": {
                "identifier": "GCTestPointerClass",
                "newPage": false,
                "searchKey": "runtime.GCTestPointerClass",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func GCTestPointerClass(p unsafe.Pointer) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc GCTestPointerClass(p unsafe.Pointer) string\n```\n\nFor GCTestPointerClass, it's important that we do this as a call so escape analysis can see through it. \n\nThis is nosplit because gcTestPointerClass is. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#sigismember",
              "documentation": {
                "identifier": "sigismember",
                "newPage": false,
                "searchKey": "runtime.sigismember",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func sigismember(mask *sigset, i int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc sigismember(mask *sigset, i int) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#Sigisblocked",
              "documentation": {
                "identifier": "Sigisblocked",
                "newPage": false,
                "searchKey": "runtime.Sigisblocked",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func Sigisblocked(i int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Sigisblocked(i int) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#WaitForSigusr1",
              "documentation": {
                "identifier": "WaitForSigusr1",
                "newPage": false,
                "searchKey": "runtime.WaitForSigusr1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func WaitForSigusr1(r, w int32, ready func(mp *M)) (int64, int64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc WaitForSigusr1(r, w int32, ready func(mp *M)) (int64, int64)\n```\n\nWaitForSigusr1 blocks until a SIGUSR1 is received. It calls ready when it is set up to receive SIGUSR1. The ready function should cause a SIGUSR1 to be sent. The r and w arguments are a pipe that the signal handler can use to report when the signal is received. \n\nOnce SIGUSR1 is received, it returns the ID of the current M and the ID of the M the SIGUSR1 was received on. If the caller writes a non-zero byte to w, WaitForSigusr1 returns immediately with -1, -1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#waitForSigusr1Callback",
              "documentation": {
                "identifier": "waitForSigusr1Callback",
                "newPage": false,
                "searchKey": "runtime.waitForSigusr1Callback",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func waitForSigusr1Callback(gp *g) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc waitForSigusr1Callback(gp *g) bool\n```\n\nwaitForSigusr1Callback is called from the signal handler during WaitForSigusr1. It must not have write barriers because there may not be a P. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#SendSigusr1",
              "documentation": {
                "identifier": "SendSigusr1",
                "newPage": false,
                "searchKey": "runtime.SendSigusr1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func SendSigusr1(mp *M)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc SendSigusr1(mp *M)\n```\n\nSendSigusr1 sends SIGUSR1 to mp. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/runtime#RunStealOrderTest",
              "documentation": {
                "identifier": "RunStealOrderTest",
                "newPage": false,
                "searchKey": "runtime.RunStealOrderTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func RunStealOrderTest()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc RunStealOrderTest()\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "pathID": "/std/runtime/cgo"
    },
    {
      "pathID": "/std/runtime/debug"
    },
    {
      "pathID": "/std/runtime/debug_test"
    },
    {
      "pathID": "/std/runtime/metrics"
    },
    {
      "pathID": "/std/runtime/metrics_test"
    },
    {
      "pathID": "/std/runtime/pprof"
    },
    {
      "pathID": "/std/runtime/race"
    },
    {
      "pathID": "/std/runtime/trace"
    },
    {
      "pathID": "/std/runtime/trace_test"
    }
  ]
}
