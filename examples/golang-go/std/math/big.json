{
  "pathID": "/std/math/big",
  "documentation": {
    "identifier": "big",
    "newPage": true,
    "searchKey": "std/math/big",
    "tags": [
      "exported"
    ]
  },
  "label": {
    "kind": "plaintext",
    "value": "Package big"
  },
  "detail": {
    "kind": "markdown",
    "value": "Package big implements arbitrary-precision arithmetic (big numbers). The following numeric types are supported: \n\n```\nInt    signed integers\nRat    rational numbers\nFloat  floating-point numbers\n\n```\nThe zero value for an Int, Rat, or Float correspond to 0. Thus, new values can be declared in the usual ways and denote 0 without further initialization: \n\n```\nvar x Int        // &x is an *Int of value 0\nvar r = &Rat{}   // r is a *Rat of value 0\ny := new(Float)  // y is a *Float of value 0\n\n```\nAlternatively, new values can be allocated and initialized with factory functions of the form: \n\n```\nfunc NewT(v V) *T\n\n```\nFor instance, NewInt(x) returns an *Int set to the value of the int64 argument x, NewRat(a, b) returns a *Rat set to the fraction a/b where a and b are int64 values, and NewFloat(f) returns a *Float initialized to the float64 argument f. More flexibility is provided with explicit setters, for instance: \n\n```\nvar z1 Int\nz1.SetUint64(123)                 // z1 := 123\nz2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4\nz3 := new(Float).SetInt(z1)       // z3 := 123.0\n\n```\nSetters, numeric operations and predicates are represented as methods of the form: \n\n```\nfunc (z *T) SetV(v V) *T          // z = v\nfunc (z *T) Unary(x *T) *T        // z = unary x\nfunc (z *T) Binary(x, y *T) *T    // z = x binary y\nfunc (x *T) Pred() P              // p = pred(x)\n\n```\nwith T one of Int, Rat, or Float. For unary and binary operations, the result is the receiver (usually named z in that case; see below); if it is one of the operands x or y it may be safely overwritten (and its memory reused). \n\nArithmetic expressions are typically written as a sequence of individual method calls, with each call corresponding to an operation. The receiver denotes the result and the method arguments are the operation's operands. For instance, given three *Int values a, b and c, the invocation \n\n```\nc.Add(a, b)\n\n```\ncomputes the sum a + b and stores the result in c, overwriting whatever value was held in c before. Unless specified otherwise, operations permit aliasing of parameters, so it is perfectly ok to write \n\n```\nsum.Add(sum, x)\n\n```\nto accumulate values x in a sum. \n\n(By always passing in a result value via the receiver, memory use can be much better controlled. Instead of having to allocate new memory for each result, an operation can reuse the space allocated for the result value, and overwrite that value with the new result in the process.) \n\nNotational convention: Incoming method parameters (including the receiver) are named consistently in the API to clarify their use. Incoming operands are usually named x, y, a, b, and so on, but never z. A parameter specifying the result is named z (typically the receiver). \n\nFor instance, the arguments for (*Int).Add are named x and y, and because the receiver specifies the result destination, it is called z: \n\n```\nfunc (z *Int) Add(x, y *Int) *Int\n\n```\nMethods of this form typically return the incoming receiver as well, to enable simple call chaining. \n\nMethods which don't require a result value to be passed in (for instance, Int.Sign), simply return the result. In this case, the receiver is typically the first operand, named x: \n\n```\nfunc (x *Int) Sign() int\n\n```\nVarious methods support conversions between strings and corresponding numeric values, and vice versa: *Int, *Rat, and *Float values implement the Stringer interface for a (default) string representation of the value, but also provide SetString methods to initialize a value from a string in a variety of supported formats (see the respective SetString documentation). \n\nFinally, *Int, *Rat, and *Float satisfy the fmt package's Scanner interface for scanning and (except for *Rat) the Formatter interface for formatted printing. \n\n"
  },
  "children": [
    {
      "node": {
        "pathID": "/std/math/big#const",
        "documentation": {
          "identifier": "const",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Constants"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/math/big#_Accuracy_name",
              "documentation": {
                "identifier": "_Accuracy_name",
                "newPage": false,
                "searchKey": "big._Accuracy_name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _Accuracy_name"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _Accuracy_name = \"BelowExactAbove\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#_S",
              "documentation": {
                "identifier": "_S",
                "newPage": false,
                "searchKey": "big._S",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _S"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _S = _W / 8 // word size in bytes\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#_W",
              "documentation": {
                "identifier": "_W",
                "newPage": false,
                "searchKey": "big._W",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _W"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _W = bits.UintSize // word size in bits\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#_B",
              "documentation": {
                "identifier": "_B",
                "newPage": false,
                "searchKey": "big._B",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _B"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _B = 1 << _W // digit base\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#_M",
              "documentation": {
                "identifier": "_M",
                "newPage": false,
                "searchKey": "big._M",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _M"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _M = _B - 1 // digit mask\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#maxShift",
              "documentation": {
                "identifier": "maxShift",
                "newPage": false,
                "searchKey": "big.maxShift",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxShift"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxShift = _W - 4\n```\n\nMaximum shift amount that can be done in one pass without overflow. A Word has _W bits and (1<<maxShift - 1)*10 + 9 must fit into Word. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#debugFloat",
              "documentation": {
                "identifier": "debugFloat",
                "newPage": false,
                "searchKey": "big.debugFloat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const debugFloat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst debugFloat = false // enable for debugging\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#MaxExp",
              "documentation": {
                "identifier": "MaxExp",
                "newPage": false,
                "searchKey": "big.MaxExp",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MaxExp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MaxExp = math.MaxInt32 // largest supported exponent\n\n```\n\nExponent and precision limits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#MinExp",
              "documentation": {
                "identifier": "MinExp",
                "newPage": false,
                "searchKey": "big.MinExp",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MinExp"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MinExp = math.MinInt32 // smallest supported exponent\n\n```\n\nExponent and precision limits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#MaxPrec",
              "documentation": {
                "identifier": "MaxPrec",
                "newPage": false,
                "searchKey": "big.MaxPrec",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MaxPrec"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MaxPrec // largest (theoretically) supported precision; likely memory-limited\n = ...\n```\n\nExponent and precision limits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#zero",
              "documentation": {
                "identifier": "zero",
                "newPage": false,
                "searchKey": "big.zero",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const zero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst zero form = iota\n```\n\nThe form value order is relevant - do not change! \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#finite",
              "documentation": {
                "identifier": "finite",
                "newPage": false,
                "searchKey": "big.finite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const finite"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst finite\n```\n\nThe form value order is relevant - do not change! \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#inf",
              "documentation": {
                "identifier": "inf",
                "newPage": false,
                "searchKey": "big.inf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const inf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst inf\n```\n\nThe form value order is relevant - do not change! \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ToNearestEven",
              "documentation": {
                "identifier": "ToNearestEven",
                "newPage": false,
                "searchKey": "big.ToNearestEven",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ToNearestEven"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ToNearestEven RoundingMode = iota // == IEEE 754-2008 roundTiesToEven\n\n```\n\nThese constants define supported rounding modes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ToNearestAway",
              "documentation": {
                "identifier": "ToNearestAway",
                "newPage": false,
                "searchKey": "big.ToNearestAway",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ToNearestAway"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ToNearestAway // == IEEE 754-2008 roundTiesToAway\n\n```\n\nThese constants define supported rounding modes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ToZero",
              "documentation": {
                "identifier": "ToZero",
                "newPage": false,
                "searchKey": "big.ToZero",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ToZero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ToZero // == IEEE 754-2008 roundTowardZero\n\n```\n\nThese constants define supported rounding modes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#AwayFromZero",
              "documentation": {
                "identifier": "AwayFromZero",
                "newPage": false,
                "searchKey": "big.AwayFromZero",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const AwayFromZero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst AwayFromZero // no IEEE 754-2008 equivalent\n\n```\n\nThese constants define supported rounding modes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ToNegativeInf",
              "documentation": {
                "identifier": "ToNegativeInf",
                "newPage": false,
                "searchKey": "big.ToNegativeInf",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ToNegativeInf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ToNegativeInf // == IEEE 754-2008 roundTowardNegative\n\n```\n\nThese constants define supported rounding modes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ToPositiveInf",
              "documentation": {
                "identifier": "ToPositiveInf",
                "newPage": false,
                "searchKey": "big.ToPositiveInf",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const ToPositiveInf"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ToPositiveInf // == IEEE 754-2008 roundTowardPositive\n\n```\n\nThese constants define supported rounding modes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#Below",
              "documentation": {
                "identifier": "Below",
                "newPage": false,
                "searchKey": "big.Below",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Below"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Below Accuracy = -1\n```\n\nConstants describing the Accuracy of a Float. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#Exact",
              "documentation": {
                "identifier": "Exact",
                "newPage": false,
                "searchKey": "big.Exact",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Exact"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Exact Accuracy = 0\n```\n\nConstants describing the Accuracy of a Float. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#Above",
              "documentation": {
                "identifier": "Above",
                "newPage": false,
                "searchKey": "big.Above",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const Above"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst Above Accuracy = +1\n```\n\nConstants describing the Accuracy of a Float. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#floatGobVersion",
              "documentation": {
                "identifier": "floatGobVersion",
                "newPage": false,
                "searchKey": "big.floatGobVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const floatGobVersion"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst floatGobVersion byte = 1\n```\n\nGob codec version. Permits backward-compatible changes to the encoding. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#intGobVersion",
              "documentation": {
                "identifier": "intGobVersion",
                "newPage": false,
                "searchKey": "big.intGobVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const intGobVersion"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst intGobVersion byte = 1\n```\n\nGob codec version. Permits backward-compatible changes to the encoding. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#digits",
              "documentation": {
                "identifier": "digits",
                "newPage": false,
                "searchKey": "big.digits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const digits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst digits = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#MaxBase",
              "documentation": {
                "identifier": "MaxBase",
                "newPage": false,
                "searchKey": "big.MaxBase",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "const MaxBase"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst MaxBase = 10 + ('z' - 'a' + 1) + ('Z' - 'A' + 1)\n```\n\nMaxBase is the largest number base accepted for string conversions. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#maxBaseSmall",
              "documentation": {
                "identifier": "maxBaseSmall",
                "newPage": false,
                "searchKey": "big.maxBaseSmall",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const maxBaseSmall"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst maxBaseSmall = 10 + ('z' - 'a' + 1)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#divRecursiveThreshold",
              "documentation": {
                "identifier": "divRecursiveThreshold",
                "newPage": false,
                "searchKey": "big.divRecursiveThreshold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const divRecursiveThreshold"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst divRecursiveThreshold = 100\n```\n\ndivRecursiveThreshold is the number of divisor digits at which point divRecursive is faster than divBasic. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ratGobVersion",
              "documentation": {
                "identifier": "ratGobVersion",
                "newPage": false,
                "searchKey": "big.ratGobVersion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const ratGobVersion"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst ratGobVersion byte = 1\n```\n\nGob codec version. Permits backward-compatible changes to the encoding. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#_RoundingMode_name",
              "documentation": {
                "identifier": "_RoundingMode_name",
                "newPage": false,
                "searchKey": "big._RoundingMode_name",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const _RoundingMode_name"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst _RoundingMode_name = \"ToNearestEvenToNearestAwayToZeroAwayFromZeroToNegativeInfToPositiveInf\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#issue42838Value",
              "documentation": {
                "identifier": "issue42838Value",
                "newPage": false,
                "searchKey": "big.issue42838Value",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const issue42838Value"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst issue42838Value = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testsNumber",
              "documentation": {
                "identifier": "testsNumber",
                "newPage": false,
                "searchKey": "big.testsNumber",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const testsNumber"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst testsNumber = 1 << 16\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#sqrModeMul",
              "documentation": {
                "identifier": "sqrModeMul",
                "newPage": false,
                "searchKey": "big.sqrModeMul",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sqrModeMul"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sqrModeMul = \"mul(x, x)\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#sqrModeBasic",
              "documentation": {
                "identifier": "sqrModeBasic",
                "newPage": false,
                "searchKey": "big.sqrModeBasic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sqrModeBasic"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sqrModeBasic = \"basicSqr(x)\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#sqrModeKaratsuba",
              "documentation": {
                "identifier": "sqrModeKaratsuba",
                "newPage": false,
                "searchKey": "big.sqrModeKaratsuba",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const sqrModeKaratsuba"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst sqrModeKaratsuba = \"karatsubaSqr(x)\"\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#below1e23",
              "documentation": {
                "identifier": "below1e23",
                "newPage": false,
                "searchKey": "big.below1e23",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const below1e23"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst below1e23 = 99999999999999974834176\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#above1e23",
              "documentation": {
                "identifier": "above1e23",
                "newPage": false,
                "searchKey": "big.above1e23",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "const above1e23"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nconst above1e23 = 100000000000000008388608\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/math/big#var",
        "documentation": {
          "identifier": "var",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Variables"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/math/big#_Accuracy_index",
              "documentation": {
                "identifier": "_Accuracy_index",
                "newPage": false,
                "searchKey": "big._Accuracy_index",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _Accuracy_index"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _Accuracy_index = [...]uint8{0, 5, 10, 15}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#support_adx",
              "documentation": {
                "identifier": "support_adx",
                "newPage": false,
                "searchKey": "big.support_adx",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var support_adx"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar support_adx = cpu.X86.HasADX && cpu.X86.HasBMI2\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#floatZero",
              "documentation": {
                "identifier": "floatZero",
                "newPage": false,
                "searchKey": "big.floatZero",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var floatZero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar floatZero Float\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#pow5tab",
              "documentation": {
                "identifier": "pow5tab",
                "newPage": false,
                "searchKey": "big.pow5tab",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var pow5tab"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar pow5tab = ...\n```\n\nThese powers of 5 fit into a uint64. \n\n```\nfor p, q := uint64(0), uint64(1); p < q; p, q = q, q*5 {\n\tfmt.Println(q)\n}\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#intOne",
              "documentation": {
                "identifier": "intOne",
                "newPage": false,
                "searchKey": "big.intOne",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var intOne"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar intOne = &Int{false, natOne}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#natOne",
              "documentation": {
                "identifier": "natOne",
                "newPage": false,
                "searchKey": "big.natOne",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var natOne"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar natOne = nat{1}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#natTwo",
              "documentation": {
                "identifier": "natTwo",
                "newPage": false,
                "searchKey": "big.natTwo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var natTwo"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar natTwo = nat{2}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#natFive",
              "documentation": {
                "identifier": "natFive",
                "newPage": false,
                "searchKey": "big.natFive",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var natFive"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar natFive = nat{5}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#natTen",
              "documentation": {
                "identifier": "natTen",
                "newPage": false,
                "searchKey": "big.natTen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var natTen"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar natTen = nat{10}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#karatsubaThreshold",
              "documentation": {
                "identifier": "karatsubaThreshold",
                "newPage": false,
                "searchKey": "big.karatsubaThreshold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var karatsubaThreshold"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar karatsubaThreshold = 40 // computed by calibrate_test.go\n\n```\n\nOperands that are shorter than karatsubaThreshold are multiplied using \"grade school\" multiplication; for longer operands the Karatsuba algorithm is used. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#basicSqrThreshold",
              "documentation": {
                "identifier": "basicSqrThreshold",
                "newPage": false,
                "searchKey": "big.basicSqrThreshold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var basicSqrThreshold"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar basicSqrThreshold = 20 // computed by calibrate_test.go\n\n```\n\nOperands that are shorter than basicSqrThreshold are squared using \"grade school\" multiplication; for operands longer than karatsubaSqrThreshold we use the Karatsuba algorithm optimized for x == y. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#karatsubaSqrThreshold",
              "documentation": {
                "identifier": "karatsubaSqrThreshold",
                "newPage": false,
                "searchKey": "big.karatsubaSqrThreshold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var karatsubaSqrThreshold"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar karatsubaSqrThreshold = 260 // computed by calibrate_test.go\n\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#natPool",
              "documentation": {
                "identifier": "natPool",
                "newPage": false,
                "searchKey": "big.natPool",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var natPool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar natPool sync.Pool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#errNoDigits",
              "documentation": {
                "identifier": "errNoDigits",
                "newPage": false,
                "searchKey": "big.errNoDigits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errNoDigits"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errNoDigits = errors.New(\"number has no digits\")\n```\n\nscan errors \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#errInvalSep",
              "documentation": {
                "identifier": "errInvalSep",
                "newPage": false,
                "searchKey": "big.errInvalSep",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var errInvalSep"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar errInvalSep = errors.New(\"'_' must separate successive digits\")\n```\n\nscan errors \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#leafSize",
              "documentation": {
                "identifier": "leafSize",
                "newPage": false,
                "searchKey": "big.leafSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var leafSize"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar leafSize int = 8 // number of Word-size binary values treat as a monolithic block\n\n```\n\nSplit blocks greater than leafSize Words (or set to 0 to disable recursive conversion) Benchmark and configure leafSize using: go test -bench=\"Leaf\" \n\n```\n8 and 16 effective on 3.0 GHz Xeon \"Clovertown\" CPU (128 byte cache lines)\n8 and 16 effective on 2.66 GHz Core 2 Duo \"Penryn\" CPU\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#cacheBase10",
              "documentation": {
                "identifier": "cacheBase10",
                "newPage": false,
                "searchKey": "big.cacheBase10",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cacheBase10"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cacheBase10 struct {\n\tsync.Mutex\n\ttable [64]divisor // cached divisors for base 10\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ratZero",
              "documentation": {
                "identifier": "ratZero",
                "newPage": false,
                "searchKey": "big.ratZero",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ratZero"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ratZero Rat\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#_RoundingMode_index",
              "documentation": {
                "identifier": "_RoundingMode_index",
                "newPage": false,
                "searchKey": "big._RoundingMode_index",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var _RoundingMode_index"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar _RoundingMode_index = [...]uint8{0, 13, 26, 32, 44, 57, 70}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#threeOnce",
              "documentation": {
                "identifier": "threeOnce",
                "newPage": false,
                "searchKey": "big.threeOnce",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var threeOnce"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar threeOnce struct {\n\tsync.Once\n\tv *Float\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#isRaceBuilder",
              "documentation": {
                "identifier": "isRaceBuilder",
                "newPage": false,
                "searchKey": "big.isRaceBuilder",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var isRaceBuilder"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar isRaceBuilder = strings.HasSuffix(testenv.Builder(), \"-race\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#sumVV",
              "documentation": {
                "identifier": "sumVV",
                "newPage": false,
                "searchKey": "big.sumVV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sumVV"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sumVV = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#rnd",
              "documentation": {
                "identifier": "rnd",
                "newPage": false,
                "searchKey": "big.rnd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var rnd"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar rnd = rand.New(rand.NewSource(0))\n```\n\nAlways the same seed for reproducible results. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#benchSizes",
              "documentation": {
                "identifier": "benchSizes",
                "newPage": false,
                "searchKey": "big.benchSizes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var benchSizes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar benchSizes = []int{1, 2, 3, 4, 5, 1e1, 1e2, 1e3, 1e4, 1e5}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#sumVW",
              "documentation": {
                "identifier": "sumVW",
                "newPage": false,
                "searchKey": "big.sumVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sumVW"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sumVW = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#lshVW",
              "documentation": {
                "identifier": "lshVW",
                "newPage": false,
                "searchKey": "big.lshVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lshVW"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lshVW = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#rshVW",
              "documentation": {
                "identifier": "rshVW",
                "newPage": false,
                "searchKey": "big.rshVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var rshVW"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar rshVW = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argshlVUIn",
              "documentation": {
                "identifier": "argshlVUIn",
                "newPage": false,
                "searchKey": "big.argshlVUIn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argshlVUIn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argshlVUIn = []Word{1, 2, 4, 8, 16, 32, 64, 0, 0, 0}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argshlVUr0",
              "documentation": {
                "identifier": "argshlVUr0",
                "newPage": false,
                "searchKey": "big.argshlVUr0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argshlVUr0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argshlVUr0 = []Word{1, 2, 4, 8, 16, 32, 64}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argshlVUr1",
              "documentation": {
                "identifier": "argshlVUr1",
                "newPage": false,
                "searchKey": "big.argshlVUr1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argshlVUr1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argshlVUr1 = []Word{2, 4, 8, 16, 32, 64, 128}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argshlVUrWm1",
              "documentation": {
                "identifier": "argshlVUrWm1",
                "newPage": false,
                "searchKey": "big.argshlVUrWm1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argshlVUrWm1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argshlVUrWm1 = []Word{1 << (_W - 1), 0, 1, 2, 4, 8, 16}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argshlVU",
              "documentation": {
                "identifier": "argshlVU",
                "newPage": false,
                "searchKey": "big.argshlVU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argshlVU"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argshlVU = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argshrVUIn",
              "documentation": {
                "identifier": "argshrVUIn",
                "newPage": false,
                "searchKey": "big.argshrVUIn",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argshrVUIn"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argshrVUIn = []Word{0, 0, 0, 1, 2, 4, 8, 16, 32, 64}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argshrVUr0",
              "documentation": {
                "identifier": "argshrVUr0",
                "newPage": false,
                "searchKey": "big.argshrVUr0",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argshrVUr0"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argshrVUr0 = []Word{1, 2, 4, 8, 16, 32, 64}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argshrVUr1",
              "documentation": {
                "identifier": "argshrVUr1",
                "newPage": false,
                "searchKey": "big.argshrVUr1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argshrVUr1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argshrVUr1 = []Word{0, 1, 2, 4, 8, 16, 32}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argshrVUrWm1",
              "documentation": {
                "identifier": "argshrVUrWm1",
                "newPage": false,
                "searchKey": "big.argshrVUrWm1",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argshrVUrWm1"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argshrVUrWm1 = []Word{4, 8, 16, 32, 64, 128, 0}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argshrVU",
              "documentation": {
                "identifier": "argshrVU",
                "newPage": false,
                "searchKey": "big.argshrVU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var argshrVU"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar argshrVU = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#prodVWW",
              "documentation": {
                "identifier": "prodVWW",
                "newPage": false,
                "searchKey": "big.prodVWW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var prodVWW"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar prodVWW = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#mulWWTests",
              "documentation": {
                "identifier": "mulWWTests",
                "newPage": false,
                "searchKey": "big.mulWWTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mulWWTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mulWWTests = []struct {\n\tx, y Word\n\tq, r Word\n}{\n\t{_M, _M, _M - 1, 1},\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#mulAddWWWTests",
              "documentation": {
                "identifier": "mulAddWWWTests",
                "newPage": false,
                "searchKey": "big.mulAddWWWTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mulAddWWWTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mulAddWWWTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#divWWTests",
              "documentation": {
                "identifier": "divWWTests",
                "newPage": false,
                "searchKey": "big.divWWTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var divWWTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar divWWTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#calibrate",
              "documentation": {
                "identifier": "calibrate",
                "newPage": false,
                "searchKey": "big.calibrate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var calibrate"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar calibrate = flag.Bool(\"calibrate\", false, \"run calibration test\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#sink",
              "documentation": {
                "identifier": "sink",
                "newPage": false,
                "searchKey": "big.sink",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sink"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sink string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#precList",
              "documentation": {
                "identifier": "precList",
                "newPage": false,
                "searchKey": "big.precList",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var precList"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar precList = ...\n```\n\nSelected precisions with which to run various tests. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#bitsList",
              "documentation": {
                "identifier": "bitsList",
                "newPage": false,
                "searchKey": "big.bitsList",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bitsList"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bitsList = [...]Bits{\n\t{},\n\t{0},\n\t{1},\n\t{-1},\n\t{10},\n\t{-10},\n\t{100, 10, 1},\n\t{0, -1, -2, -10},\n}\n```\n\nSelected bits with which to run various tests. Each entry is a list of bits representing a floating-point number (see fromBits). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#long",
              "documentation": {
                "identifier": "long",
                "newPage": false,
                "searchKey": "big.long",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var long"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar long = flag.Bool(\"long\", false, \"run very long tests\")\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#zero_",
              "documentation": {
                "identifier": "zero_",
                "newPage": false,
                "searchKey": "big.zero_",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var zero_"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar zero_ float64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#floatVals",
              "documentation": {
                "identifier": "floatVals",
                "newPage": false,
                "searchKey": "big.floatVals",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var floatVals"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar floatVals = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#sumZZ",
              "documentation": {
                "identifier": "sumZZ",
                "newPage": false,
                "searchKey": "big.sumZZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sumZZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sumZZ = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#prodZZ",
              "documentation": {
                "identifier": "prodZZ",
                "newPage": false,
                "searchKey": "big.prodZZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var prodZZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar prodZZ = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#mulRangesZ",
              "documentation": {
                "identifier": "mulRangesZ",
                "newPage": false,
                "searchKey": "big.mulRangesZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mulRangesZ"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mulRangesZ = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#divisionSignsTests",
              "documentation": {
                "identifier": "divisionSignsTests",
                "newPage": false,
                "searchKey": "big.divisionSignsTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var divisionSignsTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar divisionSignsTests = ...\n```\n\nExamples from the Go Language Spec, section \"Arithmetic operators\" \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#quoTests",
              "documentation": {
                "identifier": "quoTests",
                "newPage": false,
                "searchKey": "big.quoTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var quoTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar quoTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#bitLenTests",
              "documentation": {
                "identifier": "bitLenTests",
                "newPage": false,
                "searchKey": "big.bitLenTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bitLenTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bitLenTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#expTests",
              "documentation": {
                "identifier": "expTests",
                "newPage": false,
                "searchKey": "big.expTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var expTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar expTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#gcdTests",
              "documentation": {
                "identifier": "gcdTests",
                "newPage": false,
                "searchKey": "big.gcdTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var gcdTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar gcdTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#rshTests",
              "documentation": {
                "identifier": "rshTests",
                "newPage": false,
                "searchKey": "big.rshTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var rshTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar rshTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#lshTests",
              "documentation": {
                "identifier": "lshTests",
                "newPage": false,
                "searchKey": "big.lshTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var lshTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar lshTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#cmpAbsTests",
              "documentation": {
                "identifier": "cmpAbsTests",
                "newPage": false,
                "searchKey": "big.cmpAbsTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cmpAbsTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cmpAbsTests = ...\n```\n\nEntries must be sorted by value in ascending order. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#int64Tests",
              "documentation": {
                "identifier": "int64Tests",
                "newPage": false,
                "searchKey": "big.int64Tests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var int64Tests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar int64Tests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#uint64Tests",
              "documentation": {
                "identifier": "uint64Tests",
                "newPage": false,
                "searchKey": "big.uint64Tests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var uint64Tests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar uint64Tests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#bitwiseTests",
              "documentation": {
                "identifier": "bitwiseTests",
                "newPage": false,
                "searchKey": "big.bitwiseTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bitwiseTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bitwiseTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#bitsetTests",
              "documentation": {
                "identifier": "bitsetTests",
                "newPage": false,
                "searchKey": "big.bitsetTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bitsetTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bitsetTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#tzbTests",
              "documentation": {
                "identifier": "tzbTests",
                "newPage": false,
                "searchKey": "big.tzbTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var tzbTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar tzbTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#notTests",
              "documentation": {
                "identifier": "notTests",
                "newPage": false,
                "searchKey": "big.notTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var notTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar notTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#modInverseTests",
              "documentation": {
                "identifier": "modInverseTests",
                "newPage": false,
                "searchKey": "big.modInverseTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var modInverseTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar modInverseTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#stringTests",
              "documentation": {
                "identifier": "stringTests",
                "newPage": false,
                "searchKey": "big.stringTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var stringTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar stringTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#formatTests",
              "documentation": {
                "identifier": "formatTests",
                "newPage": false,
                "searchKey": "big.formatTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var formatTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar formatTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#scanTests",
              "documentation": {
                "identifier": "scanTests",
                "newPage": false,
                "searchKey": "big.scanTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var scanTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar scanTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#encodingTests",
              "documentation": {
                "identifier": "encodingTests",
                "newPage": false,
                "searchKey": "big.encodingTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var encodingTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar encodingTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#cmpTests",
              "documentation": {
                "identifier": "cmpTests",
                "newPage": false,
                "searchKey": "big.cmpTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var cmpTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar cmpTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#sumNN",
              "documentation": {
                "identifier": "sumNN",
                "newPage": false,
                "searchKey": "big.sumNN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sumNN"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sumNN = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#prodNN",
              "documentation": {
                "identifier": "prodNN",
                "newPage": false,
                "searchKey": "big.prodNN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var prodNN"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar prodNN = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#mulRangesN",
              "documentation": {
                "identifier": "mulRangesN",
                "newPage": false,
                "searchKey": "big.mulRangesN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mulRangesN"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mulRangesN = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#mulBenchSizes",
              "documentation": {
                "identifier": "mulBenchSizes",
                "newPage": false,
                "searchKey": "big.mulBenchSizes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var mulBenchSizes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar mulBenchSizes = []int{10, 100, 1000, 10000, 100000}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#leftShiftTests",
              "documentation": {
                "identifier": "leftShiftTests",
                "newPage": false,
                "searchKey": "big.leftShiftTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var leftShiftTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar leftShiftTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#rightShiftTests",
              "documentation": {
                "identifier": "rightShiftTests",
                "newPage": false,
                "searchKey": "big.rightShiftTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var rightShiftTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar rightShiftTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#modWTests32",
              "documentation": {
                "identifier": "modWTests32",
                "newPage": false,
                "searchKey": "big.modWTests32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var modWTests32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar modWTests32 = []modWTest{\n\t{\"23492635982634928349238759823742\", \"252341\", \"220170\"},\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#modWTests64",
              "documentation": {
                "identifier": "modWTests64",
                "newPage": false,
                "searchKey": "big.modWTests64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var modWTests64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar modWTests64 = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#montgomeryTests",
              "documentation": {
                "identifier": "montgomeryTests",
                "newPage": false,
                "searchKey": "big.montgomeryTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var montgomeryTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar montgomeryTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#expNNTests",
              "documentation": {
                "identifier": "expNNTests",
                "newPage": false,
                "searchKey": "big.expNNTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var expNNTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar expNNTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#fiboNums",
              "documentation": {
                "identifier": "fiboNums",
                "newPage": false,
                "searchKey": "big.fiboNums",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var fiboNums"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar fiboNums = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#bitTests",
              "documentation": {
                "identifier": "bitTests",
                "newPage": false,
                "searchKey": "big.bitTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var bitTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar bitTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#stickyTests",
              "documentation": {
                "identifier": "stickyTests",
                "newPage": false,
                "searchKey": "big.stickyTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var stickyTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar stickyTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#sqrBenchSizes",
              "documentation": {
                "identifier": "sqrBenchSizes",
                "newPage": false,
                "searchKey": "big.sqrBenchSizes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var sqrBenchSizes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar sqrBenchSizes = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#strTests",
              "documentation": {
                "identifier": "strTests",
                "newPage": false,
                "searchKey": "big.strTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var strTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar strTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#natScanTests",
              "documentation": {
                "identifier": "natScanTests",
                "newPage": false,
                "searchKey": "big.natScanTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var natScanTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar natScanTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#pi",
              "documentation": {
                "identifier": "pi",
                "newPage": false,
                "searchKey": "big.pi",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var pi"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar pi = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#primes",
              "documentation": {
                "identifier": "primes",
                "newPage": false,
                "searchKey": "big.primes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var primes"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar primes = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#composites",
              "documentation": {
                "identifier": "composites",
                "newPage": false,
                "searchKey": "big.composites",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var composites"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar composites = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ratCmpTests",
              "documentation": {
                "identifier": "ratCmpTests",
                "newPage": false,
                "searchKey": "big.ratCmpTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ratCmpTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ratCmpTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ratBinTests",
              "documentation": {
                "identifier": "ratBinTests",
                "newPage": false,
                "searchKey": "big.ratBinTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ratBinTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ratBinTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#setFrac64Tests",
              "documentation": {
                "identifier": "setFrac64Tests",
                "newPage": false,
                "searchKey": "big.setFrac64Tests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var setFrac64Tests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar setFrac64Tests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#exponentTests",
              "documentation": {
                "identifier": "exponentTests",
                "newPage": false,
                "searchKey": "big.exponentTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var exponentTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar exponentTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#setStringTests",
              "documentation": {
                "identifier": "setStringTests",
                "newPage": false,
                "searchKey": "big.setStringTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var setStringTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar setStringTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#setStringTests2",
              "documentation": {
                "identifier": "setStringTests2",
                "newPage": false,
                "searchKey": "big.setStringTests2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var setStringTests2"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar setStringTests2 = ...\n```\n\nThese are not supported by fmt.Fscanf. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#floatStringTests",
              "documentation": {
                "identifier": "floatStringTests",
                "newPage": false,
                "searchKey": "big.floatStringTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var floatStringTests"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar floatStringTests = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#float64inputs",
              "documentation": {
                "identifier": "float64inputs",
                "newPage": false,
                "searchKey": "big.float64inputs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var float64inputs"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar float64inputs = ...\n```\n\nTest inputs to Rat.SetString. The prefix \"long:\" causes the test to be skipped except in -long mode.  (The threshold is about 500us.) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ratNums",
              "documentation": {
                "identifier": "ratNums",
                "newPage": false,
                "searchKey": "big.ratNums",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ratNums"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ratNums = ...\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ratDenoms",
              "documentation": {
                "identifier": "ratDenoms",
                "newPage": false,
                "searchKey": "big.ratDenoms",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "var ratDenoms"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nvar ratDenoms = ...\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/math/big#type",
        "documentation": {
          "identifier": "type",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Types"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/math/big#Word",
              "documentation": {
                "identifier": "Word",
                "newPage": false,
                "searchKey": "big.Word",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Word uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Word uint\n```\n\nA Word represents a single digit of a multi-precision unsigned integer. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#mulWW_g",
                    "documentation": {
                      "identifier": "mulWW_g",
                      "newPage": false,
                      "searchKey": "big.mulWW_g",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mulWW_g(x, y Word) (z1, z0 Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mulWW_g(x, y Word) (z1, z0 Word)\n```\n\nz1<<_W + z0 = x*y \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#mulAddWWW_g",
                    "documentation": {
                      "identifier": "mulAddWWW_g",
                      "newPage": false,
                      "searchKey": "big.mulAddWWW_g",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mulAddWWW_g(x, y, c Word) (z1, z0 Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mulAddWWW_g(x, y, c Word) (z1, z0 Word)\n```\n\nz1<<_W + z0 = x*y + c \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#addVV_g",
                    "documentation": {
                      "identifier": "addVV_g",
                      "newPage": false,
                      "searchKey": "big.addVV_g",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func addVV_g(z, x, y []Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc addVV_g(z, x, y []Word) (c Word)\n```\n\nThe resulting carry c is either 0 or 1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#subVV_g",
                    "documentation": {
                      "identifier": "subVV_g",
                      "newPage": false,
                      "searchKey": "big.subVV_g",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func subVV_g(z, x, y []Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc subVV_g(z, x, y []Word) (c Word)\n```\n\nThe resulting carry c is either 0 or 1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#addVW_g",
                    "documentation": {
                      "identifier": "addVW_g",
                      "newPage": false,
                      "searchKey": "big.addVW_g",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func addVW_g(z, x []Word, y Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc addVW_g(z, x []Word, y Word) (c Word)\n```\n\nThe resulting carry c is either 0 or 1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#addVWlarge",
                    "documentation": {
                      "identifier": "addVWlarge",
                      "newPage": false,
                      "searchKey": "big.addVWlarge",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func addVWlarge(z, x []Word, y Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc addVWlarge(z, x []Word, y Word) (c Word)\n```\n\naddVWlarge is addVW, but intended for large z. The only difference is that we check on every iteration whether we are done with carries, and if so, switch to a much faster copy instead. This is only a good idea for large z, because the overhead of the check and the function call outweigh the benefits when z is small. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#subVW_g",
                    "documentation": {
                      "identifier": "subVW_g",
                      "newPage": false,
                      "searchKey": "big.subVW_g",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func subVW_g(z, x []Word, y Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc subVW_g(z, x []Word, y Word) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#subVWlarge",
                    "documentation": {
                      "identifier": "subVWlarge",
                      "newPage": false,
                      "searchKey": "big.subVWlarge",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func subVWlarge(z, x []Word, y Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc subVWlarge(z, x []Word, y Word) (c Word)\n```\n\nsubVWlarge is to subVW as addVWlarge is to addVW. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#shlVU_g",
                    "documentation": {
                      "identifier": "shlVU_g",
                      "newPage": false,
                      "searchKey": "big.shlVU_g",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func shlVU_g(z, x []Word, s uint) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc shlVU_g(z, x []Word, s uint) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#shrVU_g",
                    "documentation": {
                      "identifier": "shrVU_g",
                      "newPage": false,
                      "searchKey": "big.shrVU_g",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func shrVU_g(z, x []Word, s uint) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc shrVU_g(z, x []Word, s uint) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#mulAddVWW_g",
                    "documentation": {
                      "identifier": "mulAddVWW_g",
                      "newPage": false,
                      "searchKey": "big.mulAddVWW_g",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mulAddVWW_g(z, x []Word, y, r Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mulAddVWW_g(z, x []Word, y, r Word) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#addMulVVW_g",
                    "documentation": {
                      "identifier": "addMulVVW_g",
                      "newPage": false,
                      "searchKey": "big.addMulVVW_g",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func addMulVVW_g(z, x []Word, y Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc addMulVVW_g(z, x []Word, y Word) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#divWW",
                    "documentation": {
                      "identifier": "divWW",
                      "newPage": false,
                      "searchKey": "big.divWW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func divWW(x1, x0, y, m Word) (q, r Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc divWW(x1, x0, y, m Word) (q, r Word)\n```\n\nq = ( x1 << _W + x0 - r)/y. m = floor(( _B^2 - 1 ) / d - _B). Requiring x1<y. An approximate reciprocal with a reference to \"Improved Division by Invariant Integers (IEEE Transactions on Computers, 11 Jun. 2010)\" \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#reciprocalWord",
                    "documentation": {
                      "identifier": "reciprocalWord",
                      "newPage": false,
                      "searchKey": "big.reciprocalWord",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func reciprocalWord(d1 Word) Word"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc reciprocalWord(d1 Word) Word\n```\n\nreciprocalWord return the reciprocal of the divisor. rec = floor(( _B^2 - 1 ) / u - _B). u = d1 << nlz(d1). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#mulWW",
                    "documentation": {
                      "identifier": "mulWW",
                      "newPage": false,
                      "searchKey": "big.mulWW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mulWW(x, y Word) (z1, z0 Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mulWW(x, y Word) (z1, z0 Word)\n```\n\nimplemented in arith_$GOARCH.s \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#addVV",
                    "documentation": {
                      "identifier": "addVV",
                      "newPage": false,
                      "searchKey": "big.addVV",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func addVV(z, x, y []Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc addVV(z, x, y []Word) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#subVV",
                    "documentation": {
                      "identifier": "subVV",
                      "newPage": false,
                      "searchKey": "big.subVV",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func subVV(z, x, y []Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc subVV(z, x, y []Word) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#addVW",
                    "documentation": {
                      "identifier": "addVW",
                      "newPage": false,
                      "searchKey": "big.addVW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func addVW(z, x []Word, y Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc addVW(z, x []Word, y Word) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#subVW",
                    "documentation": {
                      "identifier": "subVW",
                      "newPage": false,
                      "searchKey": "big.subVW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func subVW(z, x []Word, y Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc subVW(z, x []Word, y Word) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#shlVU",
                    "documentation": {
                      "identifier": "shlVU",
                      "newPage": false,
                      "searchKey": "big.shlVU",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func shlVU(z, x []Word, s uint) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc shlVU(z, x []Word, s uint) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#shrVU",
                    "documentation": {
                      "identifier": "shrVU",
                      "newPage": false,
                      "searchKey": "big.shrVU",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func shrVU(z, x []Word, s uint) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc shrVU(z, x []Word, s uint) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#mulAddVWW",
                    "documentation": {
                      "identifier": "mulAddVWW",
                      "newPage": false,
                      "searchKey": "big.mulAddVWW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mulAddVWW(z, x []Word, y, r Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mulAddVWW(z, x []Word, y, r Word) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#addMulVVW",
                    "documentation": {
                      "identifier": "addMulVVW",
                      "newPage": false,
                      "searchKey": "big.addMulVVW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func addMulVVW(z, x []Word, y Word) (c Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc addMulVVW(z, x []Word, y Word) (c Word)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#lehmerSimulate",
                    "documentation": {
                      "identifier": "lehmerSimulate",
                      "newPage": false,
                      "searchKey": "big.lehmerSimulate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func lehmerSimulate(A, B *Int) (u0, u1, v0, v1 Word, even bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc lehmerSimulate(A, B *Int) (u0, u1, v0, v1 Word, even bool)\n```\n\nlehmerSimulate attempts to simulate several Euclidean update steps using the leading digits of A and B.  It returns u0, u1, v0, v1 such that A and B can be updated as: \n\n```\nA = u0*A + v0*B\nB = u1*A + v1*B\n\n```\nRequirements: A >= B and len(B.abs) >= 2 Since we are calculating with full words to avoid overflow, we use 'even' to track the sign of the cosequences. For even iterations: u0, v1 >= 0 && u1, v0 <= 0 For odd  iterations: u0, v1 <= 0 && u1, v0 >= 0 \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#bigEndianWord",
                    "documentation": {
                      "identifier": "bigEndianWord",
                      "newPage": false,
                      "searchKey": "big.bigEndianWord",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func bigEndianWord(buf []byte) Word"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc bigEndianWord(buf []byte) Word\n```\n\nbigEndianWord returns the contents of buf interpreted as a big-endian encoded Word value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#maxPow",
                    "documentation": {
                      "identifier": "maxPow",
                      "newPage": false,
                      "searchKey": "big.maxPow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func maxPow(b Word) (p Word, n int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc maxPow(b Word) (p Word, n int)\n```\n\nmaxPow returns (b**n, n) such that b**n is the largest power b**n <= _M. For instance maxPow(10) == (1e19, 19) for 19 decimal digits in a 64bit Word. In other words, at most n digits in base b fit into a Word. TODO(gri) replace this with a table, generated at build time. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#pow",
                    "documentation": {
                      "identifier": "pow",
                      "newPage": false,
                      "searchKey": "big.pow",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func pow(x Word, n int) (p Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc pow(x Word, n int) (p Word)\n```\n\npow returns x**n for n > 0, and 1 otherwise. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#divWVW",
                    "documentation": {
                      "identifier": "divWVW",
                      "newPage": false,
                      "searchKey": "big.divWVW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func divWVW(z []Word, xn Word, x []Word, y Word) (r Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc divWVW(z []Word, xn Word, x []Word, y Word) (r Word)\n```\n\ndivWVW overwrites z with x/y, returning the remainder r. The caller must ensure that len(z) = len(x). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#rndW",
                    "documentation": {
                      "identifier": "rndW",
                      "newPage": false,
                      "searchKey": "big.rndW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func rndW() Word"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc rndW() Word\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#decimal",
              "documentation": {
                "identifier": "decimal",
                "newPage": false,
                "searchKey": "big.decimal",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type decimal struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype decimal struct {\n\tmant []byte // mantissa ASCII digits, big-endian\n\texp  int    // exponent\n}\n```\n\nA decimal represents an unsigned floating-point number in decimal representation. The value of a non-zero decimal d is d.mant * 10**d.exp with 0.1 <= d.mant < 1, with the most-significant mantissa digit at index 0. For the zero decimal, the mantissa length and exponent are 0. The zero value for decimal represents a ready-to-use 0.0. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#decimal.at",
                    "documentation": {
                      "identifier": "decimal.at",
                      "newPage": false,
                      "searchKey": "big.decimal.at",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (d *decimal) at(i int) byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (d *decimal) at(i int) byte\n```\n\nat returns the i'th mantissa digit, starting with the most significant digit at 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#decimal.init",
                    "documentation": {
                      "identifier": "decimal.init",
                      "newPage": false,
                      "searchKey": "big.decimal.init",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *decimal) init(m nat, shift int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *decimal) init(m nat, shift int)\n```\n\nInit initializes x to the decimal representation of m << shift (for shift >= 0), or m >> -shift (for shift < 0). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#decimal.String",
                    "documentation": {
                      "identifier": "decimal.String",
                      "newPage": false,
                      "searchKey": "big.decimal.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *decimal) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *decimal) String() string\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#decimal.round",
                    "documentation": {
                      "identifier": "decimal.round",
                      "newPage": false,
                      "searchKey": "big.decimal.round",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *decimal) round(n int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *decimal) round(n int)\n```\n\nround sets x to (at most) n mantissa digits by rounding it to the nearest even value with n (or fever) mantissa digits. If n < 0, x remains unchanged. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#decimal.roundUp",
                    "documentation": {
                      "identifier": "decimal.roundUp",
                      "newPage": false,
                      "searchKey": "big.decimal.roundUp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *decimal) roundUp(n int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *decimal) roundUp(n int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#decimal.roundDown",
                    "documentation": {
                      "identifier": "decimal.roundDown",
                      "newPage": false,
                      "searchKey": "big.decimal.roundDown",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *decimal) roundDown(n int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *decimal) roundDown(n int)\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#Float",
              "documentation": {
                "identifier": "Float",
                "newPage": false,
                "searchKey": "big.Float",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Float struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Float struct {\n\tprec uint32\n\tmode RoundingMode\n\tacc  Accuracy\n\tform form\n\tneg  bool\n\tmant nat\n\texp  int32\n}\n```\n\nA nonzero finite Float represents a multi-precision floating point number \n\n```\nsign  mantissa  2**exponent\n\n```\nwith 0.5 <= mantissa < 1.0, and MinExp <= exponent <= MaxExp. A Float may also be zero (+0, -0) or infinite (+Inf, -Inf). All Floats are ordered, and the ordering of two Floats x and y is defined by x.Cmp(y). \n\nEach Float value also has a precision, rounding mode, and accuracy. The precision is the maximum number of mantissa bits available to represent the value. The rounding mode specifies how a result should be rounded to fit into the mantissa bits, and accuracy describes the rounding error with respect to the exact result. \n\nUnless specified otherwise, all operations (including setters) that specify a *Float variable for the result (usually via the receiver with the exception of MantExp), round the numeric result according to the precision and rounding mode of the result variable. \n\nIf the provided result precision is 0 (see below), it is set to the precision of the argument with the largest precision value before any rounding takes place, and the rounding mode remains unchanged. Thus, uninitialized Floats provided as result arguments will have their precision set to a reasonable value determined by the operands, and their mode is the zero value for RoundingMode (ToNearestEven). \n\nBy setting the desired precision to 24 or 53 and using matching rounding mode (typically ToNearestEven), Float operations produce the same results as the corresponding float32 or float64 IEEE-754 arithmetic for operands that correspond to normal (i.e., not denormal) float32 or float64 numbers. Exponent underflow and overflow lead to a 0 or an Infinity for different values than IEEE-754 because Float exponents have a much larger range. \n\nThe zero (uninitialized) value for a Float is ready to use and represents the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven. \n\nOperations always take pointer arguments (*Float) rather than Float values, and each unique Float value requires its own unique *Float pointer. To \"copy\" a Float value, an existing (or newly allocated) Float must be set to a new value using the Float.Set method; shallow copies of Floats are not supported and may lead to errors. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#NewFloat",
                    "documentation": {
                      "identifier": "NewFloat",
                      "newPage": false,
                      "searchKey": "big.NewFloat",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewFloat(x float64) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewFloat(x float64) *Float\n```\n\nNewFloat allocates and returns a new Float set to x, with precision 53 and rounding mode ToNearestEven. NewFloat panics with ErrNaN if x is a NaN. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#ParseFloat",
                    "documentation": {
                      "identifier": "ParseFloat",
                      "newPage": false,
                      "searchKey": "big.ParseFloat",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func ParseFloat(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc ParseFloat(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)\n```\n\nParseFloat is like f.Parse(s, base) with f set to the given precision and rounding mode. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#three",
                    "documentation": {
                      "identifier": "three",
                      "newPage": false,
                      "searchKey": "big.three",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func three() *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc three() *Float\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#newFloat",
                    "documentation": {
                      "identifier": "newFloat",
                      "newPage": false,
                      "searchKey": "big.newFloat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newFloat(prec2 uint32) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newFloat(prec2 uint32) *Float\n```\n\nnewFloat returns a new *Float with space for twice the given precision. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#makeFloat",
                    "documentation": {
                      "identifier": "makeFloat",
                      "newPage": false,
                      "searchKey": "big.makeFloat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeFloat(s string) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeFloat(s string) *Float\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.SetPrec",
                    "documentation": {
                      "identifier": "Float.SetPrec",
                      "newPage": false,
                      "searchKey": "big.Float.SetPrec",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) SetPrec(prec uint) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) SetPrec(prec uint) *Float\n```\n\nSetPrec sets z's precision to prec and returns the (possibly) rounded value of z. Rounding occurs according to z's rounding mode if the mantissa cannot be represented in prec bits without loss of precision. SetPrec(0) maps all finite values to 0; infinite values remain unchanged. If prec > MaxPrec, it is set to MaxPrec. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.SetMode",
                    "documentation": {
                      "identifier": "Float.SetMode",
                      "newPage": false,
                      "searchKey": "big.Float.SetMode",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) SetMode(mode RoundingMode) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) SetMode(mode RoundingMode) *Float\n```\n\nSetMode sets z's rounding mode to mode and returns an exact z. z remains unchanged otherwise. z.SetMode(z.Mode()) is a cheap way to set z's accuracy to Exact. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Prec",
                    "documentation": {
                      "identifier": "Float.Prec",
                      "newPage": false,
                      "searchKey": "big.Float.Prec",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Prec() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Prec() uint\n```\n\nPrec returns the mantissa precision of x in bits. The result may be 0 for |x| == 0 and |x| == Inf. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.MinPrec",
                    "documentation": {
                      "identifier": "Float.MinPrec",
                      "newPage": false,
                      "searchKey": "big.Float.MinPrec",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) MinPrec() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) MinPrec() uint\n```\n\nMinPrec returns the minimum precision required to represent x exactly (i.e., the smallest prec before x.SetPrec(prec) would start rounding x). The result is 0 for |x| == 0 and |x| == Inf. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Mode",
                    "documentation": {
                      "identifier": "Float.Mode",
                      "newPage": false,
                      "searchKey": "big.Float.Mode",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Mode() RoundingMode"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Mode() RoundingMode\n```\n\nMode returns the rounding mode of x. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Acc",
                    "documentation": {
                      "identifier": "Float.Acc",
                      "newPage": false,
                      "searchKey": "big.Float.Acc",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Acc() Accuracy"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Acc() Accuracy\n```\n\nAcc returns the accuracy of x produced by the most recent operation, unless explicitly documented otherwise by that operation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Sign",
                    "documentation": {
                      "identifier": "Float.Sign",
                      "newPage": false,
                      "searchKey": "big.Float.Sign",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Sign() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Sign() int\n```\n\nSign returns: \n\n```\n-1 if x <   0\n 0 if x is 0\n+1 if x >   0\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.MantExp",
                    "documentation": {
                      "identifier": "Float.MantExp",
                      "newPage": false,
                      "searchKey": "big.Float.MantExp",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) MantExp(mant *Float) (exp int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) MantExp(mant *Float) (exp int)\n```\n\nMantExp breaks x into its mantissa and exponent components and returns the exponent. If a non-nil mant argument is provided its value is set to the mantissa of x, with the same precision and rounding mode as x. The components satisfy x == mant  2**exp, with 0.5 <= |mant| < 1.0. Calling MantExp with a nil argument is an efficient way to get the exponent of the receiver. \n\nSpecial cases are: \n\n```\n(  0).MantExp(mant) = 0, with mant set to   0\n(Inf).MantExp(mant) = 0, with mant set to Inf\n\n```\nx and mant may be the same in which case x is set to its mantissa value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.setExpAndRound",
                    "documentation": {
                      "identifier": "Float.setExpAndRound",
                      "newPage": false,
                      "searchKey": "big.Float.setExpAndRound",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) setExpAndRound(exp int64, sbit uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) setExpAndRound(exp int64, sbit uint)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.SetMantExp",
                    "documentation": {
                      "identifier": "Float.SetMantExp",
                      "newPage": false,
                      "searchKey": "big.Float.SetMantExp",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) SetMantExp(mant *Float, exp int) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) SetMantExp(mant *Float, exp int) *Float\n```\n\nSetMantExp sets z to mant  2**exp and returns z. The result z has the same precision and rounding mode as mant. SetMantExp is an inverse of MantExp but does not require 0.5 <= |mant| < 1.0. Specifically: \n\n```\nmant := new(Float)\nnew(Float).SetMantExp(mant, x.MantExp(mant)).Cmp(x) == 0\n\n```\nSpecial cases are: \n\n```\nz.SetMantExp(  0, exp) =   0\nz.SetMantExp(Inf, exp) = Inf\n\n```\nz and mant may be the same in which case z's exponent is set to exp. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Signbit",
                    "documentation": {
                      "identifier": "Float.Signbit",
                      "newPage": false,
                      "searchKey": "big.Float.Signbit",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Signbit() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Signbit() bool\n```\n\nSignbit reports whether x is negative or negative zero. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.IsInf",
                    "documentation": {
                      "identifier": "Float.IsInf",
                      "newPage": false,
                      "searchKey": "big.Float.IsInf",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) IsInf() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) IsInf() bool\n```\n\nIsInf reports whether x is +Inf or -Inf. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.IsInt",
                    "documentation": {
                      "identifier": "Float.IsInt",
                      "newPage": false,
                      "searchKey": "big.Float.IsInt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) IsInt() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) IsInt() bool\n```\n\nIsInt reports whether x is an integer. Inf values are not integers. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.validate",
                    "documentation": {
                      "identifier": "Float.validate",
                      "newPage": false,
                      "searchKey": "big.Float.validate",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) validate()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) validate()\n```\n\ndebugging support \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.round",
                    "documentation": {
                      "identifier": "Float.round",
                      "newPage": false,
                      "searchKey": "big.Float.round",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) round(sbit uint)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) round(sbit uint)\n```\n\nround rounds z according to z.mode to z.prec bits and sets z.acc accordingly. sbit must be 0 or 1 and summarizes any \"sticky bit\" information one might have before calling round. z's mantissa must be normalized (with the msb set) or empty. \n\nCAUTION: The rounding modes ToNegativeInf, ToPositiveInf are affected by the sign of z. For correct rounding, the sign of z must be set correctly before calling round. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.setBits64",
                    "documentation": {
                      "identifier": "Float.setBits64",
                      "newPage": false,
                      "searchKey": "big.Float.setBits64",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) setBits64(neg bool, x uint64) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) setBits64(neg bool, x uint64) *Float\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.SetUint64",
                    "documentation": {
                      "identifier": "Float.SetUint64",
                      "newPage": false,
                      "searchKey": "big.Float.SetUint64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) SetUint64(x uint64) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) SetUint64(x uint64) *Float\n```\n\nSetUint64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.SetInt64",
                    "documentation": {
                      "identifier": "Float.SetInt64",
                      "newPage": false,
                      "searchKey": "big.Float.SetInt64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) SetInt64(x int64) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) SetInt64(x int64) *Float\n```\n\nSetInt64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 64 (and rounding will have no effect). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.SetFloat64",
                    "documentation": {
                      "identifier": "Float.SetFloat64",
                      "newPage": false,
                      "searchKey": "big.Float.SetFloat64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) SetFloat64(x float64) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) SetFloat64(x float64) *Float\n```\n\nSetFloat64 sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to 53 (and rounding will have no effect). SetFloat64 panics with ErrNaN if x is a NaN. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.SetInt",
                    "documentation": {
                      "identifier": "Float.SetInt",
                      "newPage": false,
                      "searchKey": "big.Float.SetInt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) SetInt(x *Int) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) SetInt(x *Int) *Float\n```\n\nSetInt sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the larger of x.BitLen() or 64 (and rounding will have no effect). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.SetRat",
                    "documentation": {
                      "identifier": "Float.SetRat",
                      "newPage": false,
                      "searchKey": "big.Float.SetRat",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) SetRat(x *Rat) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) SetRat(x *Rat) *Float\n```\n\nSetRat sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the largest of a.BitLen(), b.BitLen(), or 64; with x = a/b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.SetInf",
                    "documentation": {
                      "identifier": "Float.SetInf",
                      "newPage": false,
                      "searchKey": "big.Float.SetInf",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) SetInf(signbit bool) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) SetInf(signbit bool) *Float\n```\n\nSetInf sets z to the infinite Float -Inf if signbit is set, or +Inf if signbit is not set, and returns z. The precision of z is unchanged and the result is always Exact. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Set",
                    "documentation": {
                      "identifier": "Float.Set",
                      "newPage": false,
                      "searchKey": "big.Float.Set",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) Set(x *Float) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) Set(x *Float) *Float\n```\n\nSet sets z to the (possibly rounded) value of x and returns z. If z's precision is 0, it is changed to the precision of x before setting z (and rounding will have no effect). Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Copy",
                    "documentation": {
                      "identifier": "Float.Copy",
                      "newPage": false,
                      "searchKey": "big.Float.Copy",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) Copy(x *Float) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) Copy(x *Float) *Float\n```\n\nCopy sets z to x, with the same precision, rounding mode, and accuracy as x, and returns z. x is not changed even if z and x are the same. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Uint64",
                    "documentation": {
                      "identifier": "Float.Uint64",
                      "newPage": false,
                      "searchKey": "big.Float.Uint64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Uint64() (uint64, Accuracy)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Uint64() (uint64, Accuracy)\n```\n\nUint64 returns the unsigned integer resulting from truncating x towards zero. If 0 <= x <= math.MaxUint64, the result is Exact if x is an integer and Below otherwise. The result is (0, Above) for x < 0, and (math.MaxUint64, Below) for x > math.MaxUint64. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Int64",
                    "documentation": {
                      "identifier": "Float.Int64",
                      "newPage": false,
                      "searchKey": "big.Float.Int64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Int64() (int64, Accuracy)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Int64() (int64, Accuracy)\n```\n\nInt64 returns the integer resulting from truncating x towards zero. If math.MinInt64 <= x <= math.MaxInt64, the result is Exact if x is an integer, and Above (x < 0) or Below (x > 0) otherwise. The result is (math.MinInt64, Above) for x < math.MinInt64, and (math.MaxInt64, Below) for x > math.MaxInt64. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Float32",
                    "documentation": {
                      "identifier": "Float.Float32",
                      "newPage": false,
                      "searchKey": "big.Float.Float32",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Float32() (float32, Accuracy)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Float32() (float32, Accuracy)\n```\n\nFloat32 returns the float32 value nearest to x. If x is too small to be represented by a float32 (|x| < math.SmallestNonzeroFloat32), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float32 (|x| > math.MaxFloat32), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Float64",
                    "documentation": {
                      "identifier": "Float.Float64",
                      "newPage": false,
                      "searchKey": "big.Float.Float64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Float64() (float64, Accuracy)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Float64() (float64, Accuracy)\n```\n\nFloat64 returns the float64 value nearest to x. If x is too small to be represented by a float64 (|x| < math.SmallestNonzeroFloat64), the result is (0, Below) or (-0, Above), respectively, depending on the sign of x. If x is too large to be represented by a float64 (|x| > math.MaxFloat64), the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Int",
                    "documentation": {
                      "identifier": "Float.Int",
                      "newPage": false,
                      "searchKey": "big.Float.Int",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Int(z *Int) (*Int, Accuracy)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Int(z *Int) (*Int, Accuracy)\n```\n\nInt returns the result of truncating x towards zero; or nil if x is an infinity. The result is Exact if x.IsInt(); otherwise it is Below for x > 0, and Above for x < 0. If a non-nil *Int argument z is provided, Int stores the result in z instead of allocating a new Int. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Rat",
                    "documentation": {
                      "identifier": "Float.Rat",
                      "newPage": false,
                      "searchKey": "big.Float.Rat",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Rat(z *Rat) (*Rat, Accuracy)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Rat(z *Rat) (*Rat, Accuracy)\n```\n\nRat returns the rational number corresponding to x; or nil if x is an infinity. The result is Exact if x is not an Inf. If a non-nil *Rat argument z is provided, Rat stores the result in z instead of allocating a new Rat. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Abs",
                    "documentation": {
                      "identifier": "Float.Abs",
                      "newPage": false,
                      "searchKey": "big.Float.Abs",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) Abs(x *Float) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) Abs(x *Float) *Float\n```\n\nAbs sets z to the (possibly rounded) value |x| (the absolute value of x) and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Neg",
                    "documentation": {
                      "identifier": "Float.Neg",
                      "newPage": false,
                      "searchKey": "big.Float.Neg",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) Neg(x *Float) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) Neg(x *Float) *Float\n```\n\nNeg sets z to the (possibly rounded) value of x with its sign negated, and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.uadd",
                    "documentation": {
                      "identifier": "Float.uadd",
                      "newPage": false,
                      "searchKey": "big.Float.uadd",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) uadd(x, y *Float)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) uadd(x, y *Float)\n```\n\nz = x + y, ignoring signs of x and y for the addition but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.usub",
                    "documentation": {
                      "identifier": "Float.usub",
                      "newPage": false,
                      "searchKey": "big.Float.usub",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) usub(x, y *Float)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) usub(x, y *Float)\n```\n\nz = x - y for |x| > |y|, ignoring signs of x and y for the subtraction but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.umul",
                    "documentation": {
                      "identifier": "Float.umul",
                      "newPage": false,
                      "searchKey": "big.Float.umul",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) umul(x, y *Float)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) umul(x, y *Float)\n```\n\nz = x * y, ignoring signs of x and y for the multiplication but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.uquo",
                    "documentation": {
                      "identifier": "Float.uquo",
                      "newPage": false,
                      "searchKey": "big.Float.uquo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) uquo(x, y *Float)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) uquo(x, y *Float)\n```\n\nz = x / y, ignoring signs of x and y for the division but using the sign of z for rounding the result. x and y must have a non-empty mantissa and valid exponent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.ucmp",
                    "documentation": {
                      "identifier": "Float.ucmp",
                      "newPage": false,
                      "searchKey": "big.Float.ucmp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) ucmp(y *Float) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) ucmp(y *Float) int\n```\n\nucmp returns -1, 0, or +1, depending on whether |x| < |y|, |x| == |y|, or |x| > |y|. x and y must have a non-empty mantissa and valid exponent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Add",
                    "documentation": {
                      "identifier": "Float.Add",
                      "newPage": false,
                      "searchKey": "big.Float.Add",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) Add(x, y *Float) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) Add(x, y *Float) *Float\n```\n\nAdd sets z to the rounded sum x+y and returns z. If z's precision is 0, it is changed to the larger of x's or y's precision before the operation. Rounding is performed according to z's precision and rounding mode; and z's accuracy reports the result error relative to the exact (not rounded) result. Add panics with ErrNaN if x and y are infinities with opposite signs. The value of z is undefined in that case. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Sub",
                    "documentation": {
                      "identifier": "Float.Sub",
                      "newPage": false,
                      "searchKey": "big.Float.Sub",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) Sub(x, y *Float) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) Sub(x, y *Float) *Float\n```\n\nSub sets z to the rounded difference x-y and returns z. Precision, rounding, and accuracy reporting are as for Add. Sub panics with ErrNaN if x and y are infinities with equal signs. The value of z is undefined in that case. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Mul",
                    "documentation": {
                      "identifier": "Float.Mul",
                      "newPage": false,
                      "searchKey": "big.Float.Mul",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) Mul(x, y *Float) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) Mul(x, y *Float) *Float\n```\n\nMul sets z to the rounded product x*y and returns z. Precision, rounding, and accuracy reporting are as for Add. Mul panics with ErrNaN if one operand is zero and the other operand an infinity. The value of z is undefined in that case. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Quo",
                    "documentation": {
                      "identifier": "Float.Quo",
                      "newPage": false,
                      "searchKey": "big.Float.Quo",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) Quo(x, y *Float) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) Quo(x, y *Float) *Float\n```\n\nQuo sets z to the rounded quotient x/y and returns z. Precision, rounding, and accuracy reporting are as for Add. Quo panics with ErrNaN if both operands are zero or infinities. The value of z is undefined in that case. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Cmp",
                    "documentation": {
                      "identifier": "Float.Cmp",
                      "newPage": false,
                      "searchKey": "big.Float.Cmp",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Cmp(y *Float) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Cmp(y *Float) int\n```\n\nCmp compares x and y and returns: \n\n```\n-1 if x <  y\n 0 if x == y (incl. -0 == 0, -Inf == -Inf, and +Inf == +Inf)\n+1 if x >  y\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.ord",
                    "documentation": {
                      "identifier": "Float.ord",
                      "newPage": false,
                      "searchKey": "big.Float.ord",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) ord() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) ord() int\n```\n\nord classifies x and returns: \n\n```\n-2 if -Inf == x\n-1 if -Inf < x < 0\n 0 if x == 0 (signed or unsigned)\n+1 if 0 < x < +Inf\n+2 if x == +Inf\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.SetString",
                    "documentation": {
                      "identifier": "Float.SetString",
                      "newPage": false,
                      "searchKey": "big.Float.SetString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) SetString(s string) (*Float, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) SetString(s string) (*Float, bool)\n```\n\nSetString sets z to the value of s and returns z and a boolean indicating success. s must be a floating-point number of the same format as accepted by Parse, with base argument 0. The entire string (not just a prefix) must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.scan",
                    "documentation": {
                      "identifier": "Float.scan",
                      "newPage": false,
                      "searchKey": "big.Float.scan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) scan(r io.ByteScanner, base int) (f *Float, b int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) scan(r io.ByteScanner, base int) (f *Float, b int, err error)\n```\n\nscan is like Parse but reads the longest possible prefix representing a valid floating point number from an io.ByteScanner rather than a string. It serves as the implementation of Parse. It does not recognize Inf and does not expect EOF at the end. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.pow5",
                    "documentation": {
                      "identifier": "Float.pow5",
                      "newPage": false,
                      "searchKey": "big.Float.pow5",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) pow5(n uint64) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) pow5(n uint64) *Float\n```\n\npow5 sets z to 5**n and returns z. n must not be negative. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Parse",
                    "documentation": {
                      "identifier": "Float.Parse",
                      "newPage": false,
                      "searchKey": "big.Float.Parse",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) Parse(s string, base int) (f *Float, b int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) Parse(s string, base int) (f *Float, b int, err error)\n```\n\nParse parses s which must contain a text representation of a floating- point number with a mantissa in the given conversion base (the exponent is always a decimal number), or a string representing an infinite value. \n\nFor base 0, an underscore character `_' may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number, or the returned digit count. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and thus terminate scanning like any other character that is not a valid radix point or digit. \n\nIt sets z to the (possibly rounded) value of the corresponding floating- point value, and returns z, the actual base b, and an error err, if any. The entire string (not just a prefix) must be consumed for success. If z's precision is 0, it is changed to 64 before rounding takes effect. The number must be of the form: \n\n```\nnumber    = [ sign ] ( float | \"inf\" | \"Inf\" ) .\nsign      = \"+\" | \"-\" .\nfloat     = ( mantissa | prefix pmantissa ) [ exponent ] .\nprefix    = \"0\" [ \"b\" | \"B\" | \"o\" | \"O\" | \"x\" | \"X\" ] .\nmantissa  = digits \".\" [ digits ] | digits | \".\" digits .\npmantissa = [ \"_\" ] digits \".\" [ digits ] | [ \"_\" ] digits | \".\" digits .\nexponent  = ( \"e\" | \"E\" | \"p\" | \"P\" ) [ sign ] digits .\ndigits    = digit { [ \"_\" ] digit } .\ndigit     = \"0\" ... \"9\" | \"a\" ... \"z\" | \"A\" ... \"Z\" .\n\n```\nThe base argument must be 0, 2, 8, 10, or 16. Providing an invalid base argument will lead to a run-time panic. \n\nFor base 0, the number prefix determines the actual base: A prefix of `0b' or `0B' selects base 2, `0o' or `0O' selects base 8, and `0x' or `0X' selects base 16. Otherwise, the actual base is 10 and no prefix is accepted. The octal prefix \"0\" is not supported (a leading \"0\" is simply considered a \"0\"). \n\nA \"p\" or \"P\" exponent indicates a base 2 (rather then base 10) exponent; for instance, \"0x1.fffffffffffffp1023\" (using base 0) represents the maximum float64 value. For hexadecimal mantissae, the exponent character must be one of 'p' or 'P', if present (an \"e\" or \"E\" exponent indicator cannot be distinguished from a mantissa digit). \n\nThe returned *Float f is nil and the value of z is valid but not defined if an error is reported. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Scan",
                    "documentation": {
                      "identifier": "Float.Scan",
                      "newPage": false,
                      "searchKey": "big.Float.Scan",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) Scan(s fmt.ScanState, ch rune) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) Scan(s fmt.ScanState, ch rune) error\n```\n\nScan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts formats whose verbs are supported by fmt.Scan for floating point values, which are: 'b' (binary), 'e', 'E', 'f', 'F', 'g' and 'G'. Scan doesn't handle Inf. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.GobEncode",
                    "documentation": {
                      "identifier": "Float.GobEncode",
                      "newPage": false,
                      "searchKey": "big.Float.GobEncode",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) GobEncode() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) GobEncode() ([]byte, error)\n```\n\nGobEncode implements the gob.GobEncoder interface. The Float value and all its attributes (precision, rounding mode, accuracy) are marshaled. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.GobDecode",
                    "documentation": {
                      "identifier": "Float.GobDecode",
                      "newPage": false,
                      "searchKey": "big.Float.GobDecode",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) GobDecode(buf []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) GobDecode(buf []byte) error\n```\n\nGobDecode implements the gob.GobDecoder interface. The result is rounded per the precision and rounding mode of z unless z's precision is 0, in which case z is set exactly to the decoded value. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.MarshalText",
                    "documentation": {
                      "identifier": "Float.MarshalText",
                      "newPage": false,
                      "searchKey": "big.Float.MarshalText",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) MarshalText() (text []byte, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) MarshalText() (text []byte, err error)\n```\n\nMarshalText implements the encoding.TextMarshaler interface. Only the Float value is marshaled (in full precision), other attributes such as precision or accuracy are ignored. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.UnmarshalText",
                    "documentation": {
                      "identifier": "Float.UnmarshalText",
                      "newPage": false,
                      "searchKey": "big.Float.UnmarshalText",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) UnmarshalText(text []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) UnmarshalText(text []byte) error\n```\n\nUnmarshalText implements the encoding.TextUnmarshaler interface. The result is rounded per the precision and rounding mode of z. If z's precision is 0, it is changed to 64 before rounding takes effect. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Text",
                    "documentation": {
                      "identifier": "Float.Text",
                      "newPage": false,
                      "searchKey": "big.Float.Text",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Text(format byte, prec int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Text(format byte, prec int) string\n```\n\nText converts the floating-point number x to a string according to the given format and precision prec. The format is one of: \n\n```\n'e'\t-d.ddddedd, decimal exponent, at least two (possibly 0) exponent digits\n'E'\t-d.ddddEdd, decimal exponent, at least two (possibly 0) exponent digits\n'f'\t-ddddd.dddd, no exponent\n'g'\tlike 'e' for large exponents, like 'f' otherwise\n'G'\tlike 'E' for large exponents, like 'f' otherwise\n'x'\t-0xd.dddddpdd, hexadecimal mantissa, decimal power of two exponent\n'p'\t-0x.dddpdd, hexadecimal mantissa, decimal power of two exponent (non-standard)\n'b'\t-ddddddpdd, decimal mantissa, decimal power of two exponent (non-standard)\n\n```\nFor the power-of-two exponent formats, the mantissa is printed in normalized form: \n\n```\n'x'\thexadecimal mantissa in [1, 2), or 0\n'p'\thexadecimal mantissa in [, 1), or 0\n'b'\tdecimal integer mantissa using x.Prec() bits, or 0\n\n```\nNote that the 'x' form is the one used by most other languages and libraries. \n\nIf format is a different character, Text returns a \"%\" followed by the unrecognized format character. \n\nThe precision prec controls the number of digits (excluding the exponent) printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats. For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point. For 'g' and 'G' it is the total number of digits. A negative precision selects the smallest number of decimal digits necessary to identify the value x uniquely using x.Prec() mantissa bits. The prec value is ignored for the 'b' and 'p' formats. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.String",
                    "documentation": {
                      "identifier": "Float.String",
                      "newPage": false,
                      "searchKey": "big.Float.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) String() string\n```\n\nString formats x like x.Text('g', 10). (String must be called explicitly, Float.Format does not support %s verb.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Append",
                    "documentation": {
                      "identifier": "Float.Append",
                      "newPage": false,
                      "searchKey": "big.Float.Append",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Append(buf []byte, fmt byte, prec int) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Append(buf []byte, fmt byte, prec int) []byte\n```\n\nAppend appends to buf the string form of the floating-point number x, as generated by x.Text, and returns the extended buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.fmtB",
                    "documentation": {
                      "identifier": "Float.fmtB",
                      "newPage": false,
                      "searchKey": "big.Float.fmtB",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) fmtB(buf []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) fmtB(buf []byte) []byte\n```\n\nfmtB appends the string of x in the format mantissa \"p\" exponent with a decimal mantissa and a binary exponent, or 0\" if x is zero, and returns the extended buffer. The mantissa is normalized such that is uses x.Prec() bits in binary representation. The sign of x is ignored, and x must not be an Inf. (The caller handles Inf before invoking fmtB.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.fmtX",
                    "documentation": {
                      "identifier": "Float.fmtX",
                      "newPage": false,
                      "searchKey": "big.Float.fmtX",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) fmtX(buf []byte, prec int) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) fmtX(buf []byte, prec int) []byte\n```\n\nfmtX appends the string of x in the format \"0x1.\" mantissa \"p\" exponent with a hexadecimal mantissa and a binary exponent, or \"0x0p0\" if x is zero, and returns the extended buffer. A non-zero mantissa is normalized such that 1.0 <= mantissa < 2.0. The sign of x is ignored, and x must not be an Inf. (The caller handles Inf before invoking fmtX.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.fmtP",
                    "documentation": {
                      "identifier": "Float.fmtP",
                      "newPage": false,
                      "searchKey": "big.Float.fmtP",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) fmtP(buf []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) fmtP(buf []byte) []byte\n```\n\nfmtP appends the string of x in the format \"0x.\" mantissa \"p\" exponent with a hexadecimal mantissa and a binary exponent, or \"0\" if x is zero, and returns the extended buffer. The mantissa is normalized such that 0.5 <= 0.mantissa < 1.0. The sign of x is ignored, and x must not be an Inf. (The caller handles Inf before invoking fmtP.) \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Format",
                    "documentation": {
                      "identifier": "Float.Format",
                      "newPage": false,
                      "searchKey": "big.Float.Format",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) Format(s fmt.State, format rune)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) Format(s fmt.State, format rune)\n```\n\nFormat implements fmt.Formatter. It accepts all the regular formats for floating-point numbers ('b', 'e', 'E', 'f', 'F', 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the interpretation of 'p'. The 'v' format is handled like 'g'. Format also supports specification of the minimum precision in digits, the output field width, as well as the format flags '+' and ' ' for sign control, '0' for space or zero padding, and '-' for left or right justification. See the fmt package for details. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.Sqrt",
                    "documentation": {
                      "identifier": "Float.Sqrt",
                      "newPage": false,
                      "searchKey": "big.Float.Sqrt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) Sqrt(x *Float) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) Sqrt(x *Float) *Float\n```\n\nSqrt sets z to the rounded square root of x, and returns it. \n\nIf z's precision is 0, it is changed to x's precision before the operation. Rounding is performed according to z's precision and rounding mode, but z's accuracy is not computed. Specifically, the result of z.Acc() is undefined. \n\nThe function panics if z < 0. The value of z is undefined in that case. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.sqrtInverse",
                    "documentation": {
                      "identifier": "Float.sqrtInverse",
                      "newPage": false,
                      "searchKey": "big.Float.sqrtInverse",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Float) sqrtInverse(x *Float)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Float) sqrtInverse(x *Float)\n```\n\nCompute x (to z.prec precision) by solving \n\n```\n1/t - x = 0\n\n```\nfor t (using Newton's method), and then inverting. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.uint64",
                    "documentation": {
                      "identifier": "Float.uint64",
                      "newPage": false,
                      "searchKey": "big.Float.uint64",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) uint64() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) uint64() uint64\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Float.int64",
                    "documentation": {
                      "identifier": "Float.int64",
                      "newPage": false,
                      "searchKey": "big.Float.int64",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Float) int64() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Float) int64() int64\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ErrNaN",
              "documentation": {
                "identifier": "ErrNaN",
                "newPage": false,
                "searchKey": "big.ErrNaN",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type ErrNaN struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ErrNaN struct {\n\tmsg string\n}\n```\n\nAn ErrNaN panic is raised by a Float operation that would lead to a NaN under IEEE-754 rules. An ErrNaN implements the error interface. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#ErrNaN.Error",
                    "documentation": {
                      "identifier": "ErrNaN.Error",
                      "newPage": false,
                      "searchKey": "big.ErrNaN.Error",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (err ErrNaN) Error() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (err ErrNaN) Error() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#form",
              "documentation": {
                "identifier": "form",
                "newPage": false,
                "searchKey": "big.form",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type form byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype form byte\n```\n\nA form value describes the internal representation. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#RoundingMode",
              "documentation": {
                "identifier": "RoundingMode",
                "newPage": false,
                "searchKey": "big.RoundingMode",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type RoundingMode byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype RoundingMode byte\n```\n\nRoundingMode determines how a Float value is rounded to the desired precision. Rounding may change the Float value; the rounding error is described by the Float's Accuracy. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#RoundingMode.String",
                    "documentation": {
                      "identifier": "RoundingMode.String",
                      "newPage": false,
                      "searchKey": "big.RoundingMode.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i RoundingMode) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i RoundingMode) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#Accuracy",
              "documentation": {
                "identifier": "Accuracy",
                "newPage": false,
                "searchKey": "big.Accuracy",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Accuracy int8"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Accuracy int8\n```\n\nAccuracy describes the rounding error produced by the most recent operation that generated a Float value, relative to the exact value. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#makeAcc",
                    "documentation": {
                      "identifier": "makeAcc",
                      "newPage": false,
                      "searchKey": "big.makeAcc",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeAcc(above bool) Accuracy"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeAcc(above bool) Accuracy\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Accuracy.String",
                    "documentation": {
                      "identifier": "Accuracy.String",
                      "newPage": false,
                      "searchKey": "big.Accuracy.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (i Accuracy) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (i Accuracy) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#Int",
              "documentation": {
                "identifier": "Int",
                "newPage": false,
                "searchKey": "big.Int",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Int struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Int struct {\n\tneg bool // sign\n\tabs nat  // absolute value of the integer\n}\n```\n\nAn Int represents a signed multi-precision integer. The zero value for an Int represents the value 0. \n\nOperations always take pointer arguments (*Int) rather than Int values, and each unique Int value requires its own unique *Int pointer. To \"copy\" an Int value, an existing (or newly allocated) Int must be set to a new value using the Int.Set method; shallow copies of Ints are not supported and may lead to errors. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#NewInt",
                    "documentation": {
                      "identifier": "NewInt",
                      "newPage": false,
                      "searchKey": "big.NewInt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewInt(x int64) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewInt(x int64) *Int\n```\n\nNewInt allocates and returns a new Int set to x. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#randInt",
                    "documentation": {
                      "identifier": "randInt",
                      "newPage": false,
                      "searchKey": "big.randInt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func randInt(r *rand.Rand, size uint) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc randInt(r *rand.Rand, size uint) *Int\n```\n\nrandInt returns a pseudo-random Int in the range [1<<(size-1), (1<<size) - 1] \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#euclidExtGCD",
                    "documentation": {
                      "identifier": "euclidExtGCD",
                      "newPage": false,
                      "searchKey": "big.euclidExtGCD",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func euclidExtGCD(a, b *Int) (g, x, y *Int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc euclidExtGCD(a, b *Int) (g, x, y *Int)\n```\n\neuclidExtGCD is a reference implementation of Euclid's extended GCD algorithm for testing against optimized algorithms. Requirements: a, b > 0 \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#altSetBit",
                    "documentation": {
                      "identifier": "altSetBit",
                      "newPage": false,
                      "searchKey": "big.altSetBit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func altSetBit(z *Int, x *Int, i int, b uint) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc altSetBit(z *Int, x *Int, i int, b uint) *Int\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#tri",
                    "documentation": {
                      "identifier": "tri",
                      "newPage": false,
                      "searchKey": "big.tri",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func tri(n uint) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc tri(n uint) *Int\n```\n\ntri generates the trinomial 2**(n*2) - 2**n - 1, which is always 3 mod 4 and 7 mod 8, so that 2 is always a quadratic residue. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Sign",
                    "documentation": {
                      "identifier": "Int.Sign",
                      "newPage": false,
                      "searchKey": "big.Int.Sign",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) Sign() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) Sign() int\n```\n\nSign returns: \n\n```\n-1 if x <  0\n 0 if x == 0\n+1 if x >  0\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.SetInt64",
                    "documentation": {
                      "identifier": "Int.SetInt64",
                      "newPage": false,
                      "searchKey": "big.Int.SetInt64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) SetInt64(x int64) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) SetInt64(x int64) *Int\n```\n\nSetInt64 sets z to x and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.SetUint64",
                    "documentation": {
                      "identifier": "Int.SetUint64",
                      "newPage": false,
                      "searchKey": "big.Int.SetUint64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) SetUint64(x uint64) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) SetUint64(x uint64) *Int\n```\n\nSetUint64 sets z to x and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Set",
                    "documentation": {
                      "identifier": "Int.Set",
                      "newPage": false,
                      "searchKey": "big.Int.Set",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Set(x *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Set(x *Int) *Int\n```\n\nSet sets z to x and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Bits",
                    "documentation": {
                      "identifier": "Int.Bits",
                      "newPage": false,
                      "searchKey": "big.Int.Bits",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) Bits() []Word"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) Bits() []Word\n```\n\nBits provides raw (unchecked but fast) access to x by returning its absolute value as a little-endian Word slice. The result and x share the same underlying array. Bits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.SetBits",
                    "documentation": {
                      "identifier": "Int.SetBits",
                      "newPage": false,
                      "searchKey": "big.Int.SetBits",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) SetBits(abs []Word) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) SetBits(abs []Word) *Int\n```\n\nSetBits provides raw (unchecked but fast) access to z by setting its value to abs, interpreted as a little-endian Word slice, and returning z. The result and abs share the same underlying array. SetBits is intended to support implementation of missing low-level Int functionality outside this package; it should be avoided otherwise. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Abs",
                    "documentation": {
                      "identifier": "Int.Abs",
                      "newPage": false,
                      "searchKey": "big.Int.Abs",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Abs(x *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Abs(x *Int) *Int\n```\n\nAbs sets z to |x| (the absolute value of x) and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Neg",
                    "documentation": {
                      "identifier": "Int.Neg",
                      "newPage": false,
                      "searchKey": "big.Int.Neg",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Neg(x *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Neg(x *Int) *Int\n```\n\nNeg sets z to -x and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Add",
                    "documentation": {
                      "identifier": "Int.Add",
                      "newPage": false,
                      "searchKey": "big.Int.Add",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Add(x, y *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Add(x, y *Int) *Int\n```\n\nAdd sets z to the sum x+y and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Sub",
                    "documentation": {
                      "identifier": "Int.Sub",
                      "newPage": false,
                      "searchKey": "big.Int.Sub",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Sub(x, y *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Sub(x, y *Int) *Int\n```\n\nSub sets z to the difference x-y and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Mul",
                    "documentation": {
                      "identifier": "Int.Mul",
                      "newPage": false,
                      "searchKey": "big.Int.Mul",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Mul(x, y *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Mul(x, y *Int) *Int\n```\n\nMul sets z to the product x*y and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.MulRange",
                    "documentation": {
                      "identifier": "Int.MulRange",
                      "newPage": false,
                      "searchKey": "big.Int.MulRange",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) MulRange(a, b int64) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) MulRange(a, b int64) *Int\n```\n\nMulRange sets z to the product of all integers in the range [a, b] inclusively and returns z. If a > b (empty range), the result is 1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Binomial",
                    "documentation": {
                      "identifier": "Int.Binomial",
                      "newPage": false,
                      "searchKey": "big.Int.Binomial",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Binomial(n, k int64) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Binomial(n, k int64) *Int\n```\n\nBinomial sets z to the binomial coefficient of (n, k) and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Quo",
                    "documentation": {
                      "identifier": "Int.Quo",
                      "newPage": false,
                      "searchKey": "big.Int.Quo",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Quo(x, y *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Quo(x, y *Int) *Int\n```\n\nQuo sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Quo implements truncated division (like Go); see QuoRem for more details. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Rem",
                    "documentation": {
                      "identifier": "Int.Rem",
                      "newPage": false,
                      "searchKey": "big.Int.Rem",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Rem(x, y *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Rem(x, y *Int) *Int\n```\n\nRem sets z to the remainder x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Rem implements truncated modulus (like Go); see QuoRem for more details. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.QuoRem",
                    "documentation": {
                      "identifier": "Int.QuoRem",
                      "newPage": false,
                      "searchKey": "big.Int.QuoRem",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) QuoRem(x, y, r *Int) (*Int, *Int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) QuoRem(x, y, r *Int) (*Int, *Int)\n```\n\nQuoRem sets z to the quotient x/y and r to the remainder x%y and returns the pair (z, r) for y != 0. If y == 0, a division-by-zero run-time panic occurs. \n\nQuoRem implements T-division and modulus (like Go): \n\n```\nq = x/y      with the result truncated to zero\nr = x - y*q\n\n```\n(See Daan Leijen, `Division and Modulus for Computer Scientists'.) See DivMod for Euclidean division and modulus (unlike Go). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Div",
                    "documentation": {
                      "identifier": "Int.Div",
                      "newPage": false,
                      "searchKey": "big.Int.Div",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Div(x, y *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Div(x, y *Int) *Int\n```\n\nDiv sets z to the quotient x/y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Div implements Euclidean division (unlike Go); see DivMod for more details. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Mod",
                    "documentation": {
                      "identifier": "Int.Mod",
                      "newPage": false,
                      "searchKey": "big.Int.Mod",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Mod(x, y *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Mod(x, y *Int) *Int\n```\n\nMod sets z to the modulus x%y for y != 0 and returns z. If y == 0, a division-by-zero run-time panic occurs. Mod implements Euclidean modulus (unlike Go); see DivMod for more details. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.DivMod",
                    "documentation": {
                      "identifier": "Int.DivMod",
                      "newPage": false,
                      "searchKey": "big.Int.DivMod",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) DivMod(x, y, m *Int) (*Int, *Int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) DivMod(x, y, m *Int) (*Int, *Int)\n```\n\nDivMod sets z to the quotient x div y and m to the modulus x mod y and returns the pair (z, m) for y != 0. If y == 0, a division-by-zero run-time panic occurs. \n\nDivMod implements Euclidean division and modulus (unlike Go): \n\n```\nq = x div y  such that\nm = x - y*q  with 0 <= m < |y|\n\n```\n(See Raymond T. Boute, `The Euclidean definition of the functions div and mod'. ACM Transactions on Programming Languages and Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992. ACM press.) See QuoRem for T-division and modulus (like Go). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Cmp",
                    "documentation": {
                      "identifier": "Int.Cmp",
                      "newPage": false,
                      "searchKey": "big.Int.Cmp",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) Cmp(y *Int) (r int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) Cmp(y *Int) (r int)\n```\n\nCmp compares x and y and returns: \n\n```\n-1 if x <  y\n 0 if x == y\n+1 if x >  y\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.CmpAbs",
                    "documentation": {
                      "identifier": "Int.CmpAbs",
                      "newPage": false,
                      "searchKey": "big.Int.CmpAbs",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) CmpAbs(y *Int) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) CmpAbs(y *Int) int\n```\n\nCmpAbs compares the absolute values of x and y and returns: \n\n```\n-1 if |x| <  |y|\n 0 if |x| == |y|\n+1 if |x| >  |y|\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Int64",
                    "documentation": {
                      "identifier": "Int.Int64",
                      "newPage": false,
                      "searchKey": "big.Int.Int64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) Int64() int64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) Int64() int64\n```\n\nInt64 returns the int64 representation of x. If x cannot be represented in an int64, the result is undefined. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Uint64",
                    "documentation": {
                      "identifier": "Int.Uint64",
                      "newPage": false,
                      "searchKey": "big.Int.Uint64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) Uint64() uint64"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) Uint64() uint64\n```\n\nUint64 returns the uint64 representation of x. If x cannot be represented in a uint64, the result is undefined. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.IsInt64",
                    "documentation": {
                      "identifier": "Int.IsInt64",
                      "newPage": false,
                      "searchKey": "big.Int.IsInt64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) IsInt64() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) IsInt64() bool\n```\n\nIsInt64 reports whether x can be represented as an int64. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.IsUint64",
                    "documentation": {
                      "identifier": "Int.IsUint64",
                      "newPage": false,
                      "searchKey": "big.Int.IsUint64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) IsUint64() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) IsUint64() bool\n```\n\nIsUint64 reports whether x can be represented as a uint64. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.SetString",
                    "documentation": {
                      "identifier": "Int.SetString",
                      "newPage": false,
                      "searchKey": "big.Int.SetString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) SetString(s string, base int) (*Int, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) SetString(s string, base int) (*Int, bool)\n```\n\nSetString sets z to the value of s, interpreted in the given base, and returns z and a boolean indicating success. The entire string (not just a prefix) must be valid for success. If SetString fails, the value of z is undefined but the returned value is nil. \n\nThe base argument must be 0 or a value between 2 and MaxBase. For base 0, the number prefix determines the actual base: A prefix of `0b' or `0B' selects base 2, `0', `0o' or `0O' selects base 8, and `0x' or `0X' selects base 16. Otherwise, the selected base is 10 and no prefix is accepted. \n\nFor bases <= 36, lower and upper case letters are considered the same: The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35. For bases > 36, the upper case letters 'A' to 'Z' represent the digit values 36 to 61. \n\nFor base 0, an underscore character `_' may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and act like any other character that is not a valid digit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.setFromScanner",
                    "documentation": {
                      "identifier": "Int.setFromScanner",
                      "newPage": false,
                      "searchKey": "big.Int.setFromScanner",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) setFromScanner(r io.ByteScanner, base int) (*Int, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) setFromScanner(r io.ByteScanner, base int) (*Int, bool)\n```\n\nsetFromScanner implements SetString given an io.BytesScanner. For documentation see comments of SetString. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.SetBytes",
                    "documentation": {
                      "identifier": "Int.SetBytes",
                      "newPage": false,
                      "searchKey": "big.Int.SetBytes",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) SetBytes(buf []byte) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) SetBytes(buf []byte) *Int\n```\n\nSetBytes interprets buf as the bytes of a big-endian unsigned integer, sets z to that value, and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Bytes",
                    "documentation": {
                      "identifier": "Int.Bytes",
                      "newPage": false,
                      "searchKey": "big.Int.Bytes",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) Bytes() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) Bytes() []byte\n```\n\nBytes returns the absolute value of x as a big-endian byte slice. \n\nTo use a fixed length slice, or a preallocated one, use FillBytes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.FillBytes",
                    "documentation": {
                      "identifier": "Int.FillBytes",
                      "newPage": false,
                      "searchKey": "big.Int.FillBytes",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) FillBytes(buf []byte) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) FillBytes(buf []byte) []byte\n```\n\nFillBytes sets buf to the absolute value of x, storing it as a zero-extended big-endian byte slice, and returns buf. \n\nIf the absolute value of x doesn't fit in buf, FillBytes will panic. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.BitLen",
                    "documentation": {
                      "identifier": "Int.BitLen",
                      "newPage": false,
                      "searchKey": "big.Int.BitLen",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) BitLen() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) BitLen() int\n```\n\nBitLen returns the length of the absolute value of x in bits. The bit length of 0 is 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.TrailingZeroBits",
                    "documentation": {
                      "identifier": "Int.TrailingZeroBits",
                      "newPage": false,
                      "searchKey": "big.Int.TrailingZeroBits",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) TrailingZeroBits() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) TrailingZeroBits() uint\n```\n\nTrailingZeroBits returns the number of consecutive least significant zero bits of |x|. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Exp",
                    "documentation": {
                      "identifier": "Int.Exp",
                      "newPage": false,
                      "searchKey": "big.Int.Exp",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Exp(x, y, m *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Exp(x, y, m *Int) *Int\n```\n\nExp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z. If m == nil or m == 0, z = x**y unless y <= 0 then z = 1. If m != 0, y < 0, and x and m are not relatively prime, z is unchanged and nil is returned. \n\nModular exponentiation of inputs of a particular size is not a cryptographically constant-time operation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.GCD",
                    "documentation": {
                      "identifier": "Int.GCD",
                      "newPage": false,
                      "searchKey": "big.Int.GCD",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) GCD(x, y, a, b *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) GCD(x, y, a, b *Int) *Int\n```\n\nGCD sets z to the greatest common divisor of a and b and returns z. If x or y are not nil, GCD sets their value such that z = a*x + b*y. \n\na and b may be positive, zero or negative. (Before Go 1.14 both had to be > 0.) Regardless of the signs of a and b, z is always >= 0. \n\nIf a == b == 0, GCD sets z = x = y = 0. \n\nIf a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1. \n\nIf a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.lehmerGCD",
                    "documentation": {
                      "identifier": "Int.lehmerGCD",
                      "newPage": false,
                      "searchKey": "big.Int.lehmerGCD",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) lehmerGCD(x, y, a, b *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) lehmerGCD(x, y, a, b *Int) *Int\n```\n\nlehmerGCD sets z to the greatest common divisor of a and b, which both must be != 0, and returns z. If x or y are not nil, their values are set such that z = a*x + b*y. See Knuth, The Art of Computer Programming, Vol. 2, Section 4.5.2, Algorithm L. This implementation uses the improved condition by Collins requiring only one quotient and avoiding the possibility of single Word overflow. See Jebelean, \"Improving the multiprecision Euclidean algorithm\", Design and Implementation of Symbolic Computation Systems, pp 45-58. The cosequences are updated according to Algorithm 10.45 from Cohen et al. \"Handbook of Elliptic and Hyperelliptic Curve Cryptography\" pp 192. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Rand",
                    "documentation": {
                      "identifier": "Int.Rand",
                      "newPage": false,
                      "searchKey": "big.Int.Rand",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Rand(rnd *rand.Rand, n *Int) *Int\n```\n\nRand sets z to a pseudo-random number in [0, n) and returns z. \n\nAs this uses the math/rand package, it must not be used for security-sensitive work. Use crypto/rand.Int instead. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.ModInverse",
                    "documentation": {
                      "identifier": "Int.ModInverse",
                      "newPage": false,
                      "searchKey": "big.Int.ModInverse",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) ModInverse(g, n *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) ModInverse(g, n *Int) *Int\n```\n\nModInverse sets z to the multiplicative inverse of g in the ring /n and returns z. If g and n are not relatively prime, g has no multiplicative inverse in the ring /n.  In this case, z is unchanged and the return value is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.modSqrt3Mod4Prime",
                    "documentation": {
                      "identifier": "Int.modSqrt3Mod4Prime",
                      "newPage": false,
                      "searchKey": "big.Int.modSqrt3Mod4Prime",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) modSqrt3Mod4Prime(x, p *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) modSqrt3Mod4Prime(x, p *Int) *Int\n```\n\nmodSqrt3Mod4 uses the identity \n\n```\n   (a^((p+1)/4))^2  mod p\n== u^(p+1)          mod p\n== u^2              mod p\n\n```\nto calculate the square root of any quadratic residue mod p quickly for 3 mod 4 primes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.modSqrt5Mod8Prime",
                    "documentation": {
                      "identifier": "Int.modSqrt5Mod8Prime",
                      "newPage": false,
                      "searchKey": "big.Int.modSqrt5Mod8Prime",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) modSqrt5Mod8Prime(x, p *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) modSqrt5Mod8Prime(x, p *Int) *Int\n```\n\nmodSqrt5Mod8 uses Atkin's observation that 2 is not a square mod p \n\n```\nalpha ==  (2*a)^((p-5)/8)    mod p\nbeta  ==  2*a*alpha^2        mod p  is a square root of -1\nb     ==  a*alpha*(beta-1)   mod p  is a square root of a\n\n```\nto calculate the square root of any quadratic residue mod p quickly for 5 mod 8 primes. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.modSqrtTonelliShanks",
                    "documentation": {
                      "identifier": "Int.modSqrtTonelliShanks",
                      "newPage": false,
                      "searchKey": "big.Int.modSqrtTonelliShanks",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) modSqrtTonelliShanks(x, p *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) modSqrtTonelliShanks(x, p *Int) *Int\n```\n\nmodSqrtTonelliShanks uses the Tonelli-Shanks algorithm to find the square root of a quadratic residue modulo any prime. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.ModSqrt",
                    "documentation": {
                      "identifier": "Int.ModSqrt",
                      "newPage": false,
                      "searchKey": "big.Int.ModSqrt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) ModSqrt(x, p *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) ModSqrt(x, p *Int) *Int\n```\n\nModSqrt sets z to a square root of x mod p if such a square root exists, and returns z. The modulus p must be an odd prime. If x is not a square mod p, ModSqrt leaves z unchanged and returns nil. This function panics if p is not an odd integer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Lsh",
                    "documentation": {
                      "identifier": "Int.Lsh",
                      "newPage": false,
                      "searchKey": "big.Int.Lsh",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Lsh(x *Int, n uint) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Lsh(x *Int, n uint) *Int\n```\n\nLsh sets z = x << n and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Rsh",
                    "documentation": {
                      "identifier": "Int.Rsh",
                      "newPage": false,
                      "searchKey": "big.Int.Rsh",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Rsh(x *Int, n uint) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Rsh(x *Int, n uint) *Int\n```\n\nRsh sets z = x >> n and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Bit",
                    "documentation": {
                      "identifier": "Int.Bit",
                      "newPage": false,
                      "searchKey": "big.Int.Bit",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) Bit(i int) uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) Bit(i int) uint\n```\n\nBit returns the value of the i'th bit of x. That is, it returns (x>>i)&1. The bit index i must be >= 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.SetBit",
                    "documentation": {
                      "identifier": "Int.SetBit",
                      "newPage": false,
                      "searchKey": "big.Int.SetBit",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) SetBit(x *Int, i int, b uint) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) SetBit(x *Int, i int, b uint) *Int\n```\n\nSetBit sets z to x, with x's i'th bit set to b (0 or 1). That is, if b is 1 SetBit sets z = x | (1 << i); if b is 0 SetBit sets z = x &^ (1 << i). If b is not 0 or 1, SetBit will panic. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.And",
                    "documentation": {
                      "identifier": "Int.And",
                      "newPage": false,
                      "searchKey": "big.Int.And",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) And(x, y *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) And(x, y *Int) *Int\n```\n\nAnd sets z = x & y and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.AndNot",
                    "documentation": {
                      "identifier": "Int.AndNot",
                      "newPage": false,
                      "searchKey": "big.Int.AndNot",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) AndNot(x, y *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) AndNot(x, y *Int) *Int\n```\n\nAndNot sets z = x &^ y and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Or",
                    "documentation": {
                      "identifier": "Int.Or",
                      "newPage": false,
                      "searchKey": "big.Int.Or",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Or(x, y *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Or(x, y *Int) *Int\n```\n\nOr sets z = x | y and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Xor",
                    "documentation": {
                      "identifier": "Int.Xor",
                      "newPage": false,
                      "searchKey": "big.Int.Xor",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Xor(x, y *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Xor(x, y *Int) *Int\n```\n\nXor sets z = x ^ y and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Not",
                    "documentation": {
                      "identifier": "Int.Not",
                      "newPage": false,
                      "searchKey": "big.Int.Not",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Not(x *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Not(x *Int) *Int\n```\n\nNot sets z = ^x and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Sqrt",
                    "documentation": {
                      "identifier": "Int.Sqrt",
                      "newPage": false,
                      "searchKey": "big.Int.Sqrt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Sqrt(x *Int) *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Sqrt(x *Int) *Int\n```\n\nSqrt sets z to x, the largest integer such that z  x, and returns z. It panics if x is negative. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Text",
                    "documentation": {
                      "identifier": "Int.Text",
                      "newPage": false,
                      "searchKey": "big.Int.Text",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) Text(base int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) Text(base int) string\n```\n\nText returns the string representation of x in the given base. Base must be between 2 and 62, inclusive. The result uses the lower-case letters 'a' to 'z' for digit values 10 to 35, and the upper-case letters 'A' to 'Z' for digit values 36 to 61. No prefix (such as \"0x\") is added to the string. If x is a nil pointer it returns \"<nil>\". \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Append",
                    "documentation": {
                      "identifier": "Int.Append",
                      "newPage": false,
                      "searchKey": "big.Int.Append",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) Append(buf []byte, base int) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) Append(buf []byte, base int) []byte\n```\n\nAppend appends the string representation of x, as generated by x.Text(base), to buf and returns the extended buffer. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.String",
                    "documentation": {
                      "identifier": "Int.String",
                      "newPage": false,
                      "searchKey": "big.Int.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) String() string\n```\n\nString returns the decimal representation of x as generated by x.Text(10). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Format",
                    "documentation": {
                      "identifier": "Int.Format",
                      "newPage": false,
                      "searchKey": "big.Int.Format",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) Format(s fmt.State, ch rune)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) Format(s fmt.State, ch rune)\n```\n\nFormat implements fmt.Formatter. It accepts the formats 'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). Also supported are the full suite of package fmt's format flags for integral types, including '+' and ' ' for sign control, '#' for leading zero in octal and for hexadecimal, a leading \"0x\" or \"0X\" for \"%#x\" and \"%#X\" respectively, specification of minimum digits precision, output field width, space or zero padding, and '-' for left or right justification. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.scan",
                    "documentation": {
                      "identifier": "Int.scan",
                      "newPage": false,
                      "searchKey": "big.Int.scan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) scan(r io.ByteScanner, base int) (*Int, int, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) scan(r io.ByteScanner, base int) (*Int, int, error)\n```\n\nscan sets z to the integer value corresponding to the longest possible prefix read from r representing a signed integer number in a given conversion base. It returns z, the actual conversion base used, and an error, if any. In the error case, the value of z is undefined but the returned value is nil. The syntax follows the syntax of integer literals in Go. \n\nThe base argument must be 0 or a value from 2 through MaxBase. If the base is 0, the string prefix determines the actual conversion base. A prefix of `0b' or `0B' selects base 2; a `0', `0o', or `0O' prefix selects base 8, and a `0x' or `0X' prefix selects base 16. Otherwise the selected base is 10. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.Scan",
                    "documentation": {
                      "identifier": "Int.Scan",
                      "newPage": false,
                      "searchKey": "big.Int.Scan",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) Scan(s fmt.ScanState, ch rune) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) Scan(s fmt.ScanState, ch rune) error\n```\n\nScan is a support routine for fmt.Scanner; it sets z to the value of the scanned number. It accepts the formats 'b' (binary), 'o' (octal), 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.GobEncode",
                    "documentation": {
                      "identifier": "Int.GobEncode",
                      "newPage": false,
                      "searchKey": "big.Int.GobEncode",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) GobEncode() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) GobEncode() ([]byte, error)\n```\n\nGobEncode implements the gob.GobEncoder interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.GobDecode",
                    "documentation": {
                      "identifier": "Int.GobDecode",
                      "newPage": false,
                      "searchKey": "big.Int.GobDecode",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) GobDecode(buf []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) GobDecode(buf []byte) error\n```\n\nGobDecode implements the gob.GobDecoder interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.MarshalText",
                    "documentation": {
                      "identifier": "Int.MarshalText",
                      "newPage": false,
                      "searchKey": "big.Int.MarshalText",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) MarshalText() (text []byte, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) MarshalText() (text []byte, err error)\n```\n\nMarshalText implements the encoding.TextMarshaler interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.UnmarshalText",
                    "documentation": {
                      "identifier": "Int.UnmarshalText",
                      "newPage": false,
                      "searchKey": "big.Int.UnmarshalText",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) UnmarshalText(text []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) UnmarshalText(text []byte) error\n```\n\nUnmarshalText implements the encoding.TextUnmarshaler interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.MarshalJSON",
                    "documentation": {
                      "identifier": "Int.MarshalJSON",
                      "newPage": false,
                      "searchKey": "big.Int.MarshalJSON",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) MarshalJSON() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) MarshalJSON() ([]byte, error)\n```\n\nMarshalJSON implements the json.Marshaler interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.UnmarshalJSON",
                    "documentation": {
                      "identifier": "Int.UnmarshalJSON",
                      "newPage": false,
                      "searchKey": "big.Int.UnmarshalJSON",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) UnmarshalJSON(text []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) UnmarshalJSON(text []byte) error\n```\n\nUnmarshalJSON implements the json.Unmarshaler interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.ProbablyPrime",
                    "documentation": {
                      "identifier": "Int.ProbablyPrime",
                      "newPage": false,
                      "searchKey": "big.Int.ProbablyPrime",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Int) ProbablyPrime(n int) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Int) ProbablyPrime(n int) bool\n```\n\nProbablyPrime reports whether x is probably prime, applying the Miller-Rabin test with n pseudorandomly chosen bases as well as a Baillie-PSW test. \n\nIf x is prime, ProbablyPrime returns true. If x is chosen randomly and not prime, ProbablyPrime probably returns false. The probability of returning true for a randomly chosen non-prime is at most . \n\nProbablyPrime is 100% accurate for inputs less than 2. See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149, and FIPS 186-4 Appendix F for further discussion of the error probabilities. \n\nProbablyPrime is not suitable for judging primes that an adversary may have crafted to fool the test. \n\nAs of Go 1.8, ProbablyPrime(0) is allowed and applies only a Baillie-PSW test. Before Go 1.8, ProbablyPrime applied only the Miller-Rabin tests, and ProbablyPrime(0) panicked. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Int.scaleDenom",
                    "documentation": {
                      "identifier": "Int.scaleDenom",
                      "newPage": false,
                      "searchKey": "big.Int.scaleDenom",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Int) scaleDenom(x *Int, f nat)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Int) scaleDenom(x *Int, f nat)\n```\n\nscaleDenom sets z to the product x*f. If f == 0 (zero value of denominator), z is set to (a copy of) x. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#byteReader",
              "documentation": {
                "identifier": "byteReader",
                "newPage": false,
                "searchKey": "big.byteReader",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type byteReader struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype byteReader struct {\n\tfmt.ScanState\n}\n```\n\nbyteReader is a local wrapper around fmt.ScanState; it implements the ByteReader interface. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#byteReader.ReadByte",
                    "documentation": {
                      "identifier": "byteReader.ReadByte",
                      "newPage": false,
                      "searchKey": "big.byteReader.ReadByte",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r byteReader) ReadByte() (byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r byteReader) ReadByte() (byte, error)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#byteReader.UnreadByte",
                    "documentation": {
                      "identifier": "byteReader.UnreadByte",
                      "newPage": false,
                      "searchKey": "big.byteReader.UnreadByte",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (r byteReader) UnreadByte() error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (r byteReader) UnreadByte() error\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#nat",
              "documentation": {
                "identifier": "nat",
                "newPage": false,
                "searchKey": "big.nat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type nat []big.Word"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype nat []Word\n```\n\nAn unsigned integer x of the form \n\n```\nx = x[n-1]*_B^(n-1) + x[n-2]*_B^(n-2) + ... + x[1]*_B + x[0]\n\n```\nwith 0 <= x[i] < _B and 0 <= i < n is stored in a slice of length n, with the digits x[i] as the slice elements. \n\nA number is normalized if the slice contains no leading 0 digits. During arithmetic operations, denormalized values may occur but are always normalized before returning the final result. The normalized representation of 0 is the empty or nil slice (length = 0). \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#getNat",
                    "documentation": {
                      "identifier": "getNat",
                      "newPage": false,
                      "searchKey": "big.getNat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func getNat(n int) *nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc getNat(n int) *nat\n```\n\ngetNat returns a *nat of len n. The contents may not be zero. The pool holds *nat to avoid allocation when converting to interface{}. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#mulDenom",
                    "documentation": {
                      "identifier": "mulDenom",
                      "newPage": false,
                      "searchKey": "big.mulDenom",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func mulDenom(z, x, y nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc mulDenom(z, x, y nat) nat\n```\n\nmulDenom sets z to the denominator product x*y (by taking into account that 0 values for x or y must be interpreted as 1) and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#norm",
                    "documentation": {
                      "identifier": "norm",
                      "newPage": false,
                      "searchKey": "big.norm",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func norm(x nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc norm(x nat) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#natFromString",
                    "documentation": {
                      "identifier": "natFromString",
                      "newPage": false,
                      "searchKey": "big.natFromString",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func natFromString(s string) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc natFromString(s string) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#rndNat",
                    "documentation": {
                      "identifier": "rndNat",
                      "newPage": false,
                      "searchKey": "big.rndNat",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func rndNat(n int) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc rndNat(n int) nat\n```\n\nrndNat returns a random nat value >= 0 of (usually) n words in length. In extremely unlikely cases it may be smaller than n words if the top- most words are 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#rndNat1",
                    "documentation": {
                      "identifier": "rndNat1",
                      "newPage": false,
                      "searchKey": "big.rndNat1",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func rndNat1(n int) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc rndNat1(n int) nat\n```\n\nrndNat1 is like rndNat but the result is guaranteed to be > 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#fibo",
                    "documentation": {
                      "identifier": "fibo",
                      "newPage": false,
                      "searchKey": "big.fibo",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func fibo(n int) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc fibo(n int) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.clear",
                    "documentation": {
                      "identifier": "nat.clear",
                      "newPage": false,
                      "searchKey": "big.nat.clear",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) clear()"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) clear()\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.norm",
                    "documentation": {
                      "identifier": "nat.norm",
                      "newPage": false,
                      "searchKey": "big.nat.norm",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) norm() nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) norm() nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.make",
                    "documentation": {
                      "identifier": "nat.make",
                      "newPage": false,
                      "searchKey": "big.nat.make",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) make(n int) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) make(n int) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.setWord",
                    "documentation": {
                      "identifier": "nat.setWord",
                      "newPage": false,
                      "searchKey": "big.nat.setWord",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) setWord(x Word) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) setWord(x Word) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.setUint64",
                    "documentation": {
                      "identifier": "nat.setUint64",
                      "newPage": false,
                      "searchKey": "big.nat.setUint64",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) setUint64(x uint64) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) setUint64(x uint64) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.set",
                    "documentation": {
                      "identifier": "nat.set",
                      "newPage": false,
                      "searchKey": "big.nat.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) set(x nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) set(x nat) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.add",
                    "documentation": {
                      "identifier": "nat.add",
                      "newPage": false,
                      "searchKey": "big.nat.add",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) add(x, y nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) add(x, y nat) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.sub",
                    "documentation": {
                      "identifier": "nat.sub",
                      "newPage": false,
                      "searchKey": "big.nat.sub",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) sub(x, y nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) sub(x, y nat) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.cmp",
                    "documentation": {
                      "identifier": "nat.cmp",
                      "newPage": false,
                      "searchKey": "big.nat.cmp",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x nat) cmp(y nat) (r int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x nat) cmp(y nat) (r int)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.mulAddWW",
                    "documentation": {
                      "identifier": "nat.mulAddWW",
                      "newPage": false,
                      "searchKey": "big.nat.mulAddWW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) mulAddWW(x nat, y, r Word) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) mulAddWW(x nat, y, r Word) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.montgomery",
                    "documentation": {
                      "identifier": "nat.montgomery",
                      "newPage": false,
                      "searchKey": "big.nat.montgomery",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) montgomery(x, y, m nat, k Word, n int) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) montgomery(x, y, m nat, k Word, n int) nat\n```\n\nmontgomery computes z mod m = x*y*2**(-n*_W) mod m, assuming k = -1/m mod 2**_W. z is used for storing the result which is returned; z must not alias x, y or m. See Gueron, \"Efficient Software Implementations of Modular Exponentiation\". [https://eprint.iacr.org/2011/239.pdf](https://eprint.iacr.org/2011/239.pdf) In the terminology of that paper, this is an \"Almost Montgomery Multiplication\": x and y are required to satisfy 0 <= z < 2**(n*_W) and then the result z is guaranteed to satisfy 0 <= z < 2**(n*_W), but it may not be < m. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.mul",
                    "documentation": {
                      "identifier": "nat.mul",
                      "newPage": false,
                      "searchKey": "big.nat.mul",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) mul(x, y nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) mul(x, y nat) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.sqr",
                    "documentation": {
                      "identifier": "nat.sqr",
                      "newPage": false,
                      "searchKey": "big.nat.sqr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) sqr(x nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) sqr(x nat) nat\n```\n\nz = x*x \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.mulRange",
                    "documentation": {
                      "identifier": "nat.mulRange",
                      "newPage": false,
                      "searchKey": "big.nat.mulRange",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) mulRange(a, b uint64) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) mulRange(a, b uint64) nat\n```\n\nmulRange computes the product of all the unsigned integers in the range [a, b] inclusively. If a > b (empty range), the result is 1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.bitLen",
                    "documentation": {
                      "identifier": "nat.bitLen",
                      "newPage": false,
                      "searchKey": "big.nat.bitLen",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x nat) bitLen() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x nat) bitLen() int\n```\n\nLength of x in bits. x must be normalized. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.trailingZeroBits",
                    "documentation": {
                      "identifier": "nat.trailingZeroBits",
                      "newPage": false,
                      "searchKey": "big.nat.trailingZeroBits",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x nat) trailingZeroBits() uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x nat) trailingZeroBits() uint\n```\n\ntrailingZeroBits returns the number of consecutive least significant zero bits of x. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.shl",
                    "documentation": {
                      "identifier": "nat.shl",
                      "newPage": false,
                      "searchKey": "big.nat.shl",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) shl(x nat, s uint) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) shl(x nat, s uint) nat\n```\n\nz = x << s \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.shr",
                    "documentation": {
                      "identifier": "nat.shr",
                      "newPage": false,
                      "searchKey": "big.nat.shr",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) shr(x nat, s uint) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) shr(x nat, s uint) nat\n```\n\nz = x >> s \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.setBit",
                    "documentation": {
                      "identifier": "nat.setBit",
                      "newPage": false,
                      "searchKey": "big.nat.setBit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) setBit(x nat, i uint, b uint) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) setBit(x nat, i uint, b uint) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.bit",
                    "documentation": {
                      "identifier": "nat.bit",
                      "newPage": false,
                      "searchKey": "big.nat.bit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x nat) bit(i uint) uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x nat) bit(i uint) uint\n```\n\nbit returns the value of the i'th bit, with lsb == bit 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.sticky",
                    "documentation": {
                      "identifier": "nat.sticky",
                      "newPage": false,
                      "searchKey": "big.nat.sticky",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x nat) sticky(i uint) uint"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x nat) sticky(i uint) uint\n```\n\nsticky returns 1 if there's a 1 bit within the i least significant bits, otherwise it returns 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.and",
                    "documentation": {
                      "identifier": "nat.and",
                      "newPage": false,
                      "searchKey": "big.nat.and",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) and(x, y nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) and(x, y nat) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.andNot",
                    "documentation": {
                      "identifier": "nat.andNot",
                      "newPage": false,
                      "searchKey": "big.nat.andNot",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) andNot(x, y nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) andNot(x, y nat) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.or",
                    "documentation": {
                      "identifier": "nat.or",
                      "newPage": false,
                      "searchKey": "big.nat.or",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) or(x, y nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) or(x, y nat) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.xor",
                    "documentation": {
                      "identifier": "nat.xor",
                      "newPage": false,
                      "searchKey": "big.nat.xor",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) xor(x, y nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) xor(x, y nat) nat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.random",
                    "documentation": {
                      "identifier": "nat.random",
                      "newPage": false,
                      "searchKey": "big.nat.random",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) random(rand *rand.Rand, limit nat, n int) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) random(rand *rand.Rand, limit nat, n int) nat\n```\n\nrandom creates a random integer in [0..limit), using the space in z if possible. n is the bit length of limit. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.expNN",
                    "documentation": {
                      "identifier": "nat.expNN",
                      "newPage": false,
                      "searchKey": "big.nat.expNN",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) expNN(x, y, m nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) expNN(x, y, m nat) nat\n```\n\nIf m != 0 (i.e., len(m) != 0), expNN sets z to x**y mod m; otherwise it sets z to x**y. The result is the value of z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.expNNWindowed",
                    "documentation": {
                      "identifier": "nat.expNNWindowed",
                      "newPage": false,
                      "searchKey": "big.nat.expNNWindowed",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) expNNWindowed(x, y, m nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) expNNWindowed(x, y, m nat) nat\n```\n\nexpNNWindowed calculates x**y mod m using a fixed, 4-bit window. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.expNNMontgomery",
                    "documentation": {
                      "identifier": "nat.expNNMontgomery",
                      "newPage": false,
                      "searchKey": "big.nat.expNNMontgomery",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) expNNMontgomery(x, y, m nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) expNNMontgomery(x, y, m nat) nat\n```\n\nexpNNMontgomery calculates x**y mod m using a fixed, 4-bit window. Uses Montgomery representation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.bytes",
                    "documentation": {
                      "identifier": "nat.bytes",
                      "newPage": false,
                      "searchKey": "big.nat.bytes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) bytes(buf []byte) (i int)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) bytes(buf []byte) (i int)\n```\n\nbytes writes the value of z into buf using big-endian encoding. The value of z is encoded in the slice buf[i:]. If the value of z cannot be represented in buf, bytes panics. The number i of unused bytes at the beginning of buf is returned as result. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.setBytes",
                    "documentation": {
                      "identifier": "nat.setBytes",
                      "newPage": false,
                      "searchKey": "big.nat.setBytes",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) setBytes(buf []byte) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) setBytes(buf []byte) nat\n```\n\nsetBytes interprets buf as the bytes of a big-endian unsigned integer, sets z to that value, and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.sqrt",
                    "documentation": {
                      "identifier": "nat.sqrt",
                      "newPage": false,
                      "searchKey": "big.nat.sqrt",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) sqrt(x nat) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) sqrt(x nat) nat\n```\n\nsqrt sets z = x \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.scan",
                    "documentation": {
                      "identifier": "nat.scan",
                      "newPage": false,
                      "searchKey": "big.nat.scan",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) scan(r io.ByteScanner, base int, fracOk bool) (res nat, b, count int, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) scan(r io.ByteScanner, base int, fracOk bool) (res nat, b, count int, err error)\n```\n\nscan scans the number corresponding to the longest possible prefix from r representing an unsigned number in a given conversion base. scan returns the corresponding natural number res, the actual base b, a digit count, and a read or syntax error err, if any. \n\nFor base 0, an underscore character `_' may appear between a base prefix and an adjacent digit, and between successive digits; such underscores do not change the value of the number, or the returned digit count. Incorrect placement of underscores is reported as an error if there are no other errors. If base != 0, underscores are not recognized and thus terminate scanning like any other character that is not a valid radix point or digit. \n\n```\nnumber    = mantissa | prefix pmantissa .\nprefix    = \"0\" [ \"b\" | \"B\" | \"o\" | \"O\" | \"x\" | \"X\" ] .\nmantissa  = digits \".\" [ digits ] | digits | \".\" digits .\npmantissa = [ \"_\" ] digits \".\" [ digits ] | [ \"_\" ] digits | \".\" digits .\ndigits    = digit { [ \"_\" ] digit } .\ndigit     = \"0\" ... \"9\" | \"a\" ... \"z\" | \"A\" ... \"Z\" .\n\n```\nUnless fracOk is set, the base argument must be 0 or a value between 2 and MaxBase. If fracOk is set, the base argument must be one of 0, 2, 8, 10, or 16. Providing an invalid base argument leads to a run- time panic. \n\nFor base 0, the number prefix determines the actual base: A prefix of `0b' or `0B' selects base 2, `0o' or `0O' selects base 8, and `0x' or `0X' selects base 16. If fracOk is false, a `0' prefix (immediately followed by digits) selects base 8 as well. Otherwise, the selected base is 10 and no prefix is accepted. \n\nIf fracOk is set, a period followed by a fractional part is permitted. The result value is computed as if there were no period present; and the count value is used to determine the fractional part. \n\nFor bases <= 36, lower and upper case letters are considered the same: The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35. For bases > 36, the upper case letters 'A' to 'Z' represent the digit values 36 to 61. \n\nA result digit count > 0 corresponds to the number of (non-prefix) digits parsed. A digit count <= 0 indicates the presence of a period (if fracOk is set, only), and -count is the number of fractional digits found. In this case, the actual value of the scanned number is res * b**count. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.utoa",
                    "documentation": {
                      "identifier": "nat.utoa",
                      "newPage": false,
                      "searchKey": "big.nat.utoa",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x nat) utoa(base int) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x nat) utoa(base int) []byte\n```\n\nutoa converts x to an ASCII representation in the given base; base must be between 2 and MaxBase, inclusive. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.itoa",
                    "documentation": {
                      "identifier": "nat.itoa",
                      "newPage": false,
                      "searchKey": "big.nat.itoa",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x nat) itoa(neg bool, base int) []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x nat) itoa(neg bool, base int) []byte\n```\n\nitoa is like utoa but it prepends a '-' if neg && x != 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.convertWords",
                    "documentation": {
                      "identifier": "nat.convertWords",
                      "newPage": false,
                      "searchKey": "big.nat.convertWords",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q nat) convertWords(s []byte, b Word, ndigits int, bb Word, table []divisor)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q nat) convertWords(s []byte, b Word, ndigits int, bb Word, table []divisor)\n```\n\nConvert words of q to base b digits in s. If q is large, it is recursively \"split in half\" by nat/nat division using tabulated divisors. Otherwise, it is converted iteratively using repeated nat/Word division. \n\nThe iterative method processes n Words by n divW() calls, each of which visits every Word in the incrementally shortened q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s. Recursive conversion divides q by its approximate square root, yielding two parts, each half the size of q. Using the iterative method on both halves means 2 * (n/2)(n/2 + 1)/2 divW()'s plus the expensive long div(). Asymptotically, the ratio is favorable at 1/2 the divW()'s, and is made better by splitting the subblocks recursively. Best is to split blocks until one more split would take longer (because of the nat/nat div()) than the twice as many divW()'s of the iterative approach. This threshold is represented by leafSize. Benchmarking of leafSize in the range 2..64 shows that values of 8 and 16 work well, with a 4x speedup at medium lengths and ~30x for 20000 digits. Use nat_test.go's BenchmarkLeafSize tests to optimize leafSize for specific hardware. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.expWW",
                    "documentation": {
                      "identifier": "nat.expWW",
                      "newPage": false,
                      "searchKey": "big.nat.expWW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) expWW(x, y Word) nat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) expWW(x, y Word) nat\n```\n\nexpWW computes x**y \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.div",
                    "documentation": {
                      "identifier": "nat.div",
                      "newPage": false,
                      "searchKey": "big.nat.div",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) div(z2, u, v nat) (q, r nat)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) div(z2, u, v nat) (q, r nat)\n```\n\ndiv returns q, r such that q = u/v and r = u%v = u - qv. It uses z and z2 as the storage for q and r. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.divW",
                    "documentation": {
                      "identifier": "nat.divW",
                      "newPage": false,
                      "searchKey": "big.nat.divW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) divW(x nat, y Word) (q nat, r Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) divW(x nat, y Word) (q nat, r Word)\n```\n\ndivW returns q, r such that q = x/y and r = x%y = x - qy. It uses z as the storage for q. Note that y is a single digit (Word), not a big number. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.modW",
                    "documentation": {
                      "identifier": "nat.modW",
                      "newPage": false,
                      "searchKey": "big.nat.modW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x nat) modW(d Word) (r Word)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x nat) modW(d Word) (r Word)\n```\n\nmodW returns x % d. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.divLarge",
                    "documentation": {
                      "identifier": "nat.divLarge",
                      "newPage": false,
                      "searchKey": "big.nat.divLarge",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) divLarge(u, uIn, vIn nat) (q, r nat)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) divLarge(u, uIn, vIn nat) (q, r nat)\n```\n\ndiv returns q, r such that q = uIn/vIn and r = uIn%vIn = uIn - qvIn. It uses z and u as the storage for q and r. The caller must ensure that len(vIn)  2 (use divW otherwise) and that len(uIn)  len(vIn) (the answer is 0, uIn otherwise). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.divBasic",
                    "documentation": {
                      "identifier": "nat.divBasic",
                      "newPage": false,
                      "searchKey": "big.nat.divBasic",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (q nat) divBasic(u, v nat)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (q nat) divBasic(u, v nat)\n```\n\ndivBasic implements long division as described above. It overwrites q with u/v and overwrites u with the remainder r. q must be large enough to hold u/v. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.divRecursive",
                    "documentation": {
                      "identifier": "nat.divRecursive",
                      "newPage": false,
                      "searchKey": "big.nat.divRecursive",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) divRecursive(u, v nat)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) divRecursive(u, v nat)\n```\n\ndivRecursive implements recursive division as described above. It overwrites z with u/v and overwrites u with the remainder r. z must be large enough to hold u/v. This function is just for allocating and freeing temporaries around divRecursiveStep, the real implementation. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.divRecursiveStep",
                    "documentation": {
                      "identifier": "nat.divRecursiveStep",
                      "newPage": false,
                      "searchKey": "big.nat.divRecursiveStep",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z nat) divRecursiveStep(u, v nat, depth int, tmp *nat, temps []*nat)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z nat) divRecursiveStep(u, v nat, depth int, tmp *nat, temps []*nat)\n```\n\ndivRecursiveStep is the actual implementation of recursive division. It adds u/v to z and overwrites u with the remainder r. z must be large enough to hold u/v. It uses temps[depth] (allocating if needed) as a temporary live across the recursive call. It also uses tmp, but not live across the recursion. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.probablyPrimeMillerRabin",
                    "documentation": {
                      "identifier": "nat.probablyPrimeMillerRabin",
                      "newPage": false,
                      "searchKey": "big.nat.probablyPrimeMillerRabin",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n nat) probablyPrimeMillerRabin(reps int, force2 bool) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n nat) probablyPrimeMillerRabin(reps int, force2 bool) bool\n```\n\nprobablyPrimeMillerRabin reports whether n passes reps rounds of the Miller-Rabin primality test, using pseudo-randomly chosen bases. If force2 is true, one of the rounds is forced to use base 2. See Handbook of Applied Cryptography, p. 139, Algorithm 4.24. The number n is known to be non-zero. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#nat.probablyPrimeLucas",
                    "documentation": {
                      "identifier": "nat.probablyPrimeLucas",
                      "newPage": false,
                      "searchKey": "big.nat.probablyPrimeLucas",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (n nat) probablyPrimeLucas() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (n nat) probablyPrimeLucas() bool\n```\n\nprobablyPrimeLucas reports whether n passes the \"almost extra strong\" Lucas probable prime test, using Baillie-OEIS parameter selection. This corresponds to \"AESLPSP\" on Jacobsen's tables (link below). The combination of this test and a Miller-Rabin/Fermat test with base 2 gives a Baillie-PSW test. \n\nReferences: \n\nBaillie and Wagstaff, \"Lucas Pseudoprimes\", Mathematics of Computation 35(152), October 1980, pp. 1391-1417, especially page 1401. [https://www.ams.org/journals/mcom/1980-35-152/S0025-5718-1980-0583518-6/S0025-5718-1980-0583518-6.pdf](https://www.ams.org/journals/mcom/1980-35-152/S0025-5718-1980-0583518-6/S0025-5718-1980-0583518-6.pdf) \n\nGrantham, \"Frobenius Pseudoprimes\", Mathematics of Computation 70(234), March 2000, pp. 873-891. [https://www.ams.org/journals/mcom/2001-70-234/S0025-5718-00-01197-2/S0025-5718-00-01197-2.pdf](https://www.ams.org/journals/mcom/2001-70-234/S0025-5718-00-01197-2/S0025-5718-00-01197-2.pdf) \n\nBaillie, \"Extra strong Lucas pseudoprimes\", OEIS A217719, [https://oeis.org/A217719](https://oeis.org/A217719). \n\nJacobsen, \"Pseudoprime Statistics, Tables, and Data\", [http://ntheory.org/pseudoprimes.html](http://ntheory.org/pseudoprimes.html). \n\nNicely, \"The Baillie-PSW Primality Test\", [http://www.trnicely.net/misc/bpsw.html](http://www.trnicely.net/misc/bpsw.html). (Note that Nicely's definition of the \"extra strong\" test gives the wrong Jacobi condition, as pointed out by Jacobsen.) \n\nCrandall and Pomerance, Prime Numbers: A Computational Perspective, 2nd ed. Springer, 2005. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#divisor",
              "documentation": {
                "identifier": "divisor",
                "newPage": false,
                "searchKey": "big.divisor",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type divisor struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype divisor struct {\n\tbbb     nat // divisor\n\tnbits   int // bit length of divisor (discounting leading zeros) ~= log2(bbb)\n\tndigits int // digit length of divisor in terms of output base digits\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#Rat",
              "documentation": {
                "identifier": "Rat",
                "newPage": false,
                "searchKey": "big.Rat",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "type Rat struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Rat struct {\n\t// To make zero values for Rat work w/o initialization,\n\t// a zero value of b (len(b) == 0) acts like b == 1. At\n\t// the earliest opportunity (when an assignment to the Rat\n\t// is made), such uninitialized denominators are set to 1.\n\t// a.neg determines the sign of the Rat, b.neg is ignored.\n\ta, b Int\n}\n```\n\nA Rat represents a quotient a/b of arbitrary precision. The zero value for a Rat represents the value 0. \n\nOperations always take pointer arguments (*Rat) rather than Rat values, and each unique Rat value requires its own unique *Rat pointer. To \"copy\" a Rat value, an existing (or newly allocated) Rat must be set to a new value using the Rat.Set method; shallow copies of Rats are not supported and may lead to errors. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#NewRat",
                    "documentation": {
                      "identifier": "NewRat",
                      "newPage": false,
                      "searchKey": "big.NewRat",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func NewRat(a, b int64) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc NewRat(a, b int64) *Rat\n```\n\nNewRat creates a new Rat with numerator a and denominator b. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#delta",
                    "documentation": {
                      "identifier": "delta",
                      "newPage": false,
                      "searchKey": "big.delta",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func delta(r *Rat, f float64) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc delta(r *Rat, f float64) *Rat\n```\n\ndelta returns the absolute difference between r and f. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.SetFloat64",
                    "documentation": {
                      "identifier": "Rat.SetFloat64",
                      "newPage": false,
                      "searchKey": "big.Rat.SetFloat64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) SetFloat64(f float64) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) SetFloat64(f float64) *Rat\n```\n\nSetFloat64 sets z to exactly f and returns z. If f is not finite, SetFloat returns nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Float32",
                    "documentation": {
                      "identifier": "Rat.Float32",
                      "newPage": false,
                      "searchKey": "big.Rat.Float32",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) Float32() (f float32, exact bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) Float32() (f float32, exact bool)\n```\n\nFloat32 returns the nearest float32 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float32, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Float64",
                    "documentation": {
                      "identifier": "Rat.Float64",
                      "newPage": false,
                      "searchKey": "big.Rat.Float64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) Float64() (f float64, exact bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) Float64() (f float64, exact bool)\n```\n\nFloat64 returns the nearest float64 value for x and a bool indicating whether f represents x exactly. If the magnitude of x is too large to be represented by a float64, f is an infinity and exact is false. The sign of f always matches the sign of x, even if f == 0. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.SetFrac",
                    "documentation": {
                      "identifier": "Rat.SetFrac",
                      "newPage": false,
                      "searchKey": "big.Rat.SetFrac",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) SetFrac(a, b *Int) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) SetFrac(a, b *Int) *Rat\n```\n\nSetFrac sets z to a/b and returns z. If b == 0, SetFrac panics. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.SetFrac64",
                    "documentation": {
                      "identifier": "Rat.SetFrac64",
                      "newPage": false,
                      "searchKey": "big.Rat.SetFrac64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) SetFrac64(a, b int64) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) SetFrac64(a, b int64) *Rat\n```\n\nSetFrac64 sets z to a/b and returns z. If b == 0, SetFrac64 panics. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.SetInt",
                    "documentation": {
                      "identifier": "Rat.SetInt",
                      "newPage": false,
                      "searchKey": "big.Rat.SetInt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) SetInt(x *Int) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) SetInt(x *Int) *Rat\n```\n\nSetInt sets z to x (by making a copy of x) and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.SetInt64",
                    "documentation": {
                      "identifier": "Rat.SetInt64",
                      "newPage": false,
                      "searchKey": "big.Rat.SetInt64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) SetInt64(x int64) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) SetInt64(x int64) *Rat\n```\n\nSetInt64 sets z to x and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.SetUint64",
                    "documentation": {
                      "identifier": "Rat.SetUint64",
                      "newPage": false,
                      "searchKey": "big.Rat.SetUint64",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) SetUint64(x uint64) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) SetUint64(x uint64) *Rat\n```\n\nSetUint64 sets z to x and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Set",
                    "documentation": {
                      "identifier": "Rat.Set",
                      "newPage": false,
                      "searchKey": "big.Rat.Set",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) Set(x *Rat) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) Set(x *Rat) *Rat\n```\n\nSet sets z to x (by making a copy of x) and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Abs",
                    "documentation": {
                      "identifier": "Rat.Abs",
                      "newPage": false,
                      "searchKey": "big.Rat.Abs",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) Abs(x *Rat) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) Abs(x *Rat) *Rat\n```\n\nAbs sets z to |x| (the absolute value of x) and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Neg",
                    "documentation": {
                      "identifier": "Rat.Neg",
                      "newPage": false,
                      "searchKey": "big.Rat.Neg",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) Neg(x *Rat) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) Neg(x *Rat) *Rat\n```\n\nNeg sets z to -x and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Inv",
                    "documentation": {
                      "identifier": "Rat.Inv",
                      "newPage": false,
                      "searchKey": "big.Rat.Inv",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) Inv(x *Rat) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) Inv(x *Rat) *Rat\n```\n\nInv sets z to 1/x and returns z. If x == 0, Inv panics. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Sign",
                    "documentation": {
                      "identifier": "Rat.Sign",
                      "newPage": false,
                      "searchKey": "big.Rat.Sign",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) Sign() int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) Sign() int\n```\n\nSign returns: \n\n```\n-1 if x <  0\n 0 if x == 0\n+1 if x >  0\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.IsInt",
                    "documentation": {
                      "identifier": "Rat.IsInt",
                      "newPage": false,
                      "searchKey": "big.Rat.IsInt",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) IsInt() bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) IsInt() bool\n```\n\nIsInt reports whether the denominator of x is 1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Num",
                    "documentation": {
                      "identifier": "Rat.Num",
                      "newPage": false,
                      "searchKey": "big.Rat.Num",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) Num() *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) Num() *Int\n```\n\nNum returns the numerator of x; it may be <= 0. The result is a reference to x's numerator; it may change if a new value is assigned to x, and vice versa. The sign of the numerator corresponds to the sign of x. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Denom",
                    "documentation": {
                      "identifier": "Rat.Denom",
                      "newPage": false,
                      "searchKey": "big.Rat.Denom",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) Denom() *Int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) Denom() *Int\n```\n\nDenom returns the denominator of x; it is always > 0. The result is a reference to x's denominator, unless x is an uninitialized (zero value) Rat, in which case the result is a new Int of value 1. (To initialize x, any operation that sets x will do, including x.Set(x).) If the result is a reference to x's denominator it may change if a new value is assigned to x, and vice versa. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.norm",
                    "documentation": {
                      "identifier": "Rat.norm",
                      "newPage": false,
                      "searchKey": "big.Rat.norm",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) norm() *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) norm() *Rat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Cmp",
                    "documentation": {
                      "identifier": "Rat.Cmp",
                      "newPage": false,
                      "searchKey": "big.Rat.Cmp",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) Cmp(y *Rat) int"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) Cmp(y *Rat) int\n```\n\nCmp compares x and y and returns: \n\n```\n-1 if x <  y\n 0 if x == y\n+1 if x >  y\n\n```\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Add",
                    "documentation": {
                      "identifier": "Rat.Add",
                      "newPage": false,
                      "searchKey": "big.Rat.Add",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) Add(x, y *Rat) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) Add(x, y *Rat) *Rat\n```\n\nAdd sets z to the sum x+y and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Sub",
                    "documentation": {
                      "identifier": "Rat.Sub",
                      "newPage": false,
                      "searchKey": "big.Rat.Sub",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) Sub(x, y *Rat) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) Sub(x, y *Rat) *Rat\n```\n\nSub sets z to the difference x-y and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Mul",
                    "documentation": {
                      "identifier": "Rat.Mul",
                      "newPage": false,
                      "searchKey": "big.Rat.Mul",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) Mul(x, y *Rat) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) Mul(x, y *Rat) *Rat\n```\n\nMul sets z to the product x*y and returns z. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Quo",
                    "documentation": {
                      "identifier": "Rat.Quo",
                      "newPage": false,
                      "searchKey": "big.Rat.Quo",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) Quo(x, y *Rat) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) Quo(x, y *Rat) *Rat\n```\n\nQuo sets z to the quotient x/y and returns z. If y == 0, Quo panics. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.Scan",
                    "documentation": {
                      "identifier": "Rat.Scan",
                      "newPage": false,
                      "searchKey": "big.Rat.Scan",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) Scan(s fmt.ScanState, ch rune) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) Scan(s fmt.ScanState, ch rune) error\n```\n\nScan is a support routine for fmt.Scanner. It accepts the formats 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.SetString",
                    "documentation": {
                      "identifier": "Rat.SetString",
                      "newPage": false,
                      "searchKey": "big.Rat.SetString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) SetString(s string) (*Rat, bool)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) SetString(s string) (*Rat, bool)\n```\n\nSetString sets z to the value of s and returns z and a boolean indicating success. s can be given as a (possibly signed) fraction \"a/b\", or as a floating-point number optionally followed by an exponent. If a fraction is provided, both the dividend and the divisor may be a decimal integer or independently use a prefix of `0b', `0' or `0o', or `0x' (or their upper-case variants) to denote a binary, octal, or hexadecimal integer, respectively. The divisor may not be signed. If a floating-point number is provided, it may be in decimal form or use any of the same prefixes as above but for `0' to denote a non-decimal mantissa. A leading `0' is considered a decimal leading 0; it does not indicate octal representation in this case. An optional base-10 `e' or base-2 `p' (or their upper-case variants) exponent may be provided as well, except for hexadecimal floats which only accept an (optional) `p' exponent (because an `e' or `E' cannot be distinguished from a mantissa digit). If the exponent's absolute value is too large, the operation may fail. The entire string, not just a prefix, must be valid for success. If the operation failed, the value of z is undefined but the returned value is nil. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.String",
                    "documentation": {
                      "identifier": "Rat.String",
                      "newPage": false,
                      "searchKey": "big.Rat.String",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) String() string\n```\n\nString returns a string representation of x in the form \"a/b\" (even if b == 1). \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.marshal",
                    "documentation": {
                      "identifier": "Rat.marshal",
                      "newPage": false,
                      "searchKey": "big.Rat.marshal",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) marshal() []byte"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) marshal() []byte\n```\n\nmarshal implements String returning a slice of bytes \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.RatString",
                    "documentation": {
                      "identifier": "Rat.RatString",
                      "newPage": false,
                      "searchKey": "big.Rat.RatString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) RatString() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) RatString() string\n```\n\nRatString returns a string representation of x in the form \"a/b\" if b != 1, and in the form \"a\" if b == 1. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.FloatString",
                    "documentation": {
                      "identifier": "Rat.FloatString",
                      "newPage": false,
                      "searchKey": "big.Rat.FloatString",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) FloatString(prec int) string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) FloatString(prec int) string\n```\n\nFloatString returns a string representation of x in decimal form with prec digits of precision after the radix point. The last digit is rounded to nearest, with halves rounded away from zero. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.GobEncode",
                    "documentation": {
                      "identifier": "Rat.GobEncode",
                      "newPage": false,
                      "searchKey": "big.Rat.GobEncode",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) GobEncode() ([]byte, error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) GobEncode() ([]byte, error)\n```\n\nGobEncode implements the gob.GobEncoder interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.GobDecode",
                    "documentation": {
                      "identifier": "Rat.GobDecode",
                      "newPage": false,
                      "searchKey": "big.Rat.GobDecode",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) GobDecode(buf []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) GobDecode(buf []byte) error\n```\n\nGobDecode implements the gob.GobDecoder interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.MarshalText",
                    "documentation": {
                      "identifier": "Rat.MarshalText",
                      "newPage": false,
                      "searchKey": "big.Rat.MarshalText",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x *Rat) MarshalText() (text []byte, err error)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x *Rat) MarshalText() (text []byte, err error)\n```\n\nMarshalText implements the encoding.TextMarshaler interface. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Rat.UnmarshalText",
                    "documentation": {
                      "identifier": "Rat.UnmarshalText",
                      "newPage": false,
                      "searchKey": "big.Rat.UnmarshalText",
                      "tags": [
                        "exported"
                      ]
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (z *Rat) UnmarshalText(text []byte) error"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (z *Rat) UnmarshalText(text []byte) error\n```\n\nUnmarshalText implements the encoding.TextUnmarshaler interface. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#funVV",
              "documentation": {
                "identifier": "funVV",
                "newPage": false,
                "searchKey": "big.funVV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funVV func(z []std/math/big.Word, x []std/math/big.Word, y []std/math/big.Word) (c std/math/big.Word)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funVV func(z, x, y []Word) (c Word)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argVV",
              "documentation": {
                "identifier": "argVV",
                "newPage": false,
                "searchKey": "big.argVV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type argVV struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype argVV struct {\n\tz, x, y nat\n\tc       Word\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#funVW",
              "documentation": {
                "identifier": "funVW",
                "newPage": false,
                "searchKey": "big.funVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funVW func(z []std/math/big.Word, x []std/math/big.Word, y std/math/big.Word) (c std/math/big.Word)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funVW func(z, x []Word, y Word) (c Word)\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#makeFunVW",
                    "documentation": {
                      "identifier": "makeFunVW",
                      "newPage": false,
                      "searchKey": "big.makeFunVW",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func makeFunVW(f func(z, x []Word, s uint) (c Word)) funVW"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc makeFunVW(f func(z, x []Word, s uint) (c Word)) funVW\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argVW",
              "documentation": {
                "identifier": "argVW",
                "newPage": false,
                "searchKey": "big.argVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type argVW struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype argVW struct {\n\tz, x nat\n\ty    Word\n\tc    Word\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argVU",
              "documentation": {
                "identifier": "argVU",
                "newPage": false,
                "searchKey": "big.argVU",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type argVU struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype argVU struct {\n\td  []Word // d is a Word slice, the input parameters x and z come from this array.\n\tl  uint   // l is the length of the input parameters x and z.\n\txp uint   // xp is the starting position of the input parameter x, x := d[xp:xp+l].\n\tzp uint   // zp is the starting position of the input parameter z, z := d[zp:zp+l].\n\ts  uint   // s is the shift number.\n\tr  []Word // r is the expected output result z.\n\tc  Word   // c is the expected return value.\n\tm  string // message.\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#funVWW",
              "documentation": {
                "identifier": "funVWW",
                "newPage": false,
                "searchKey": "big.funVWW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funVWW func(z []std/math/big.Word, x []std/math/big.Word, y std/math/big.Word, r std/math/big.Word) (c std/math/big.Word)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funVWW func(z, x []Word, y, r Word) (c Word)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argVWW",
              "documentation": {
                "identifier": "argVWW",
                "newPage": false,
                "searchKey": "big.argVWW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type argVWW struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype argVWW struct {\n\tz, x nat\n\ty, r Word\n\tc    Word\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#funWVW",
              "documentation": {
                "identifier": "funWVW",
                "newPage": false,
                "searchKey": "big.funWVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funWVW func(z []std/math/big.Word, xn std/math/big.Word, x []std/math/big.Word, y std/math/big.Word) (r std/math/big.Word)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funWVW func(z []Word, xn Word, x []Word, y Word) (r Word)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argWVW",
              "documentation": {
                "identifier": "argWVW",
                "newPage": false,
                "searchKey": "big.argWVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type argWVW struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype argWVW struct {\n\tz  nat\n\txn Word\n\tx  nat\n\ty  Word\n\tr  Word\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#Bits",
              "documentation": {
                "identifier": "Bits",
                "newPage": false,
                "searchKey": "big.Bits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type Bits []int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype Bits []int\n```\n\nA Bits value b represents a finite floating-point number x of the form \n\n```\nx = 2**b[0] + 2**b[1] + ... 2**b[len(b)-1]\n\n```\nThe order of slice elements is not significant. Negative elements may be used to form fractions. A Bits value is normalized if each b[i] occurs at most once. For instance Bits{0, 0, 1} is not normalized but represents the same floating-point number as Bits{2}, which is normalized. The zero (nil) value of Bits is a ready to use Bits value and represents the value 0. \n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#Bits.add",
                    "documentation": {
                      "identifier": "Bits.add",
                      "newPage": false,
                      "searchKey": "big.Bits.add",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x Bits) add(y Bits) Bits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x Bits) add(y Bits) Bits\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Bits.mul",
                    "documentation": {
                      "identifier": "Bits.mul",
                      "newPage": false,
                      "searchKey": "big.Bits.mul",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x Bits) mul(y Bits) Bits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x Bits) mul(y Bits) Bits\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Bits.norm",
                    "documentation": {
                      "identifier": "Bits.norm",
                      "newPage": false,
                      "searchKey": "big.Bits.norm",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x Bits) norm() Bits"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x Bits) norm() Bits\n```\n\nnorm returns the normalized bits for x: It removes multiple equal entries by treating them as an addition (e.g., Bits{5, 5} => Bits{6}), and it sorts the result list for reproducible results. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Bits.round",
                    "documentation": {
                      "identifier": "Bits.round",
                      "newPage": false,
                      "searchKey": "big.Bits.round",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (x Bits) round(prec uint, mode RoundingMode) *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (x Bits) round(prec uint, mode RoundingMode) *Float\n```\n\nround returns the Float value corresponding to x after rounding x to prec bits according to mode. \n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#Bits.Float",
                    "documentation": {
                      "identifier": "Bits.Float",
                      "newPage": false,
                      "searchKey": "big.Bits.Float",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (bits Bits) Float() *Float"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (bits Bits) Float() *Float\n```\n\nFloat returns the *Float z of the smallest possible precision such that z = sum(2**bits[i]), with i = range bits. If multiple bits[i] are equal, they are added: Bits{0, 1, 0}.Float() == 2**0 + 2**1 + 2**0 = 4. \n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#matrix",
              "documentation": {
                "identifier": "matrix",
                "newPage": false,
                "searchKey": "big.matrix",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type matrix struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype matrix struct {\n\tn, m int\n\ta    []*Rat\n}\n```\n\n"
              },
              "children": [
                {
                  "node": {
                    "pathID": "/std/math/big#newMatrix",
                    "documentation": {
                      "identifier": "newMatrix",
                      "newPage": false,
                      "searchKey": "big.newMatrix",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newMatrix(n, m int) *matrix"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newMatrix(n, m int) *matrix\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#newUnit",
                    "documentation": {
                      "identifier": "newUnit",
                      "newPage": false,
                      "searchKey": "big.newUnit",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newUnit(n int) *matrix"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newUnit(n int) *matrix\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#newHilbert",
                    "documentation": {
                      "identifier": "newHilbert",
                      "newPage": false,
                      "searchKey": "big.newHilbert",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newHilbert(n int) *matrix"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newHilbert(n int) *matrix\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#newInverseHilbert",
                    "documentation": {
                      "identifier": "newInverseHilbert",
                      "newPage": false,
                      "searchKey": "big.newInverseHilbert",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func newInverseHilbert(n int) *matrix"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc newInverseHilbert(n int) *matrix\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#matrix.at",
                    "documentation": {
                      "identifier": "matrix.at",
                      "newPage": false,
                      "searchKey": "big.matrix.at",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *matrix) at(i, j int) *Rat"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *matrix) at(i, j int) *Rat\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#matrix.set",
                    "documentation": {
                      "identifier": "matrix.set",
                      "newPage": false,
                      "searchKey": "big.matrix.set",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *matrix) set(i, j int, x *Rat)"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *matrix) set(i, j int, x *Rat)\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#matrix.mul",
                    "documentation": {
                      "identifier": "matrix.mul",
                      "newPage": false,
                      "searchKey": "big.matrix.mul",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *matrix) mul(b *matrix) *matrix"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *matrix) mul(b *matrix) *matrix\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#matrix.eql",
                    "documentation": {
                      "identifier": "matrix.eql",
                      "newPage": false,
                      "searchKey": "big.matrix.eql",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *matrix) eql(b *matrix) bool"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *matrix) eql(b *matrix) bool\n```\n\n"
                    },
                    "children": null
                  }
                },
                {
                  "node": {
                    "pathID": "/std/math/big#matrix.String",
                    "documentation": {
                      "identifier": "matrix.String",
                      "newPage": false,
                      "searchKey": "big.matrix.String",
                      "tags": null
                    },
                    "label": {
                      "kind": "plaintext",
                      "value": "func (a *matrix) String() string"
                    },
                    "detail": {
                      "kind": "markdown",
                      "value": "```Go\nfunc (a *matrix) String() string\n```\n\n"
                    },
                    "children": null
                  }
                }
              ]
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#funZZ",
              "documentation": {
                "identifier": "funZZ",
                "newPage": false,
                "searchKey": "big.funZZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funZZ func(z *std/math/big.Int, x *std/math/big.Int, y *std/math/big.Int) *std/math/big.Int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funZZ func(z, x, y *Int) *Int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argZZ",
              "documentation": {
                "identifier": "argZZ",
                "newPage": false,
                "searchKey": "big.argZZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type argZZ struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype argZZ struct {\n\tz, x, y *Int\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#intShiftTest",
              "documentation": {
                "identifier": "intShiftTest",
                "newPage": false,
                "searchKey": "big.intShiftTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type intShiftTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype intShiftTest struct {\n\tin    string\n\tshift uint\n\tout   string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#bitFun",
              "documentation": {
                "identifier": "bitFun",
                "newPage": false,
                "searchKey": "big.bitFun",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type bitFun func(z *std/math/big.Int, x *std/math/big.Int, y *std/math/big.Int) *std/math/big.Int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype bitFun func(z, x, y *Int) *Int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#funNN",
              "documentation": {
                "identifier": "funNN",
                "newPage": false,
                "searchKey": "big.funNN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type funNN func(z std/math/big.nat, x std/math/big.nat, y std/math/big.nat) std/math/big.nat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype funNN func(z, x, y nat) nat\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#argNN",
              "documentation": {
                "identifier": "argNN",
                "newPage": false,
                "searchKey": "big.argNN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type argNN struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype argNN struct {\n\tz, x, y nat\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#shiftTest",
              "documentation": {
                "identifier": "shiftTest",
                "newPage": false,
                "searchKey": "big.shiftTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type shiftTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype shiftTest struct {\n\tin    nat\n\tshift uint\n\tout   nat\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#modWTest",
              "documentation": {
                "identifier": "modWTest",
                "newPage": false,
                "searchKey": "big.modWTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type modWTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype modWTest struct {\n\tin       string\n\tdividend string\n\tout      string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ratBinFun",
              "documentation": {
                "identifier": "ratBinFun",
                "newPage": false,
                "searchKey": "big.ratBinFun",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ratBinFun func(z *std/math/big.Rat, x *std/math/big.Rat, y *std/math/big.Rat) *std/math/big.Rat"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ratBinFun func(z, x, y *Rat) *Rat\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ratBinArg",
              "documentation": {
                "identifier": "ratBinArg",
                "newPage": false,
                "searchKey": "big.ratBinArg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type ratBinArg struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype ratBinArg struct {\n\tx, y, z string\n}\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#StringTest",
              "documentation": {
                "identifier": "StringTest",
                "newPage": false,
                "searchKey": "big.StringTest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "type StringTest struct"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\ntype StringTest struct {\n\tin, out string\n\tok      bool\n}\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    },
    {
      "node": {
        "pathID": "/std/math/big#func",
        "documentation": {
          "identifier": "func",
          "newPage": false,
          "searchKey": "",
          "tags": [
            "exported"
          ]
        },
        "label": {
          "kind": "plaintext",
          "value": "Functions"
        },
        "detail": {
          "kind": "plaintext",
          "value": ""
        },
        "children": [
          {
            "node": {
              "pathID": "/std/math/big#nlz",
              "documentation": {
                "identifier": "nlz",
                "newPage": false,
                "searchKey": "big.nlz",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func nlz(x Word) uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc nlz(x Word) uint\n```\n\nnlz returns the number of leading zeros in x. Wraps bits.LeadingZeros call for convenience. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#shr",
              "documentation": {
                "identifier": "shr",
                "newPage": false,
                "searchKey": "big.shr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func shr(x *decimal, s uint)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc shr(x *decimal, s uint)\n```\n\nshr implements x >> s, for s <= maxShift. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#appendZeros",
              "documentation": {
                "identifier": "appendZeros",
                "newPage": false,
                "searchKey": "big.appendZeros",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func appendZeros(buf []byte, n int) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc appendZeros(buf []byte, n int) []byte\n```\n\nappendZeros appends n 0 digits to buf and returns buf. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#shouldRoundUp",
              "documentation": {
                "identifier": "shouldRoundUp",
                "newPage": false,
                "searchKey": "big.shouldRoundUp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func shouldRoundUp(x *decimal, n int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc shouldRoundUp(x *decimal, n int) bool\n```\n\nshouldRoundUp reports if x should be rounded up if shortened to n digits. n must be a valid index for x.mant. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#trim",
              "documentation": {
                "identifier": "trim",
                "newPage": false,
                "searchKey": "big.trim",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func trim(x *decimal)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc trim(x *decimal)\n```\n\ntrim cuts off any trailing zeros from x's mantissa; they are meaningless for the value of x. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#fnorm",
              "documentation": {
                "identifier": "fnorm",
                "newPage": false,
                "searchKey": "big.fnorm",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fnorm(m nat) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fnorm(m nat) int64\n```\n\nfnorm normalizes mantissa m by shifting it to the left such that the msb of the most-significant word (msw) is 1. It returns the shift amount. It assumes that len(m) != 0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#msb32",
              "documentation": {
                "identifier": "msb32",
                "newPage": false,
                "searchKey": "big.msb32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func msb32(x nat) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc msb32(x nat) uint32\n```\n\nmsb32 returns the 32 most significant bits of x. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#msb64",
              "documentation": {
                "identifier": "msb64",
                "newPage": false,
                "searchKey": "big.msb64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func msb64(x nat) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc msb64(x nat) uint64\n```\n\nmsb64 returns the 64 most significant bits of x. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#validateBinaryOperands",
              "documentation": {
                "identifier": "validateBinaryOperands",
                "newPage": false,
                "searchKey": "big.validateBinaryOperands",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func validateBinaryOperands(x, y *Float)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc validateBinaryOperands(x, y *Float)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#umax32",
              "documentation": {
                "identifier": "umax32",
                "newPage": false,
                "searchKey": "big.umax32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func umax32(x, y uint32) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc umax32(x, y uint32) uint32\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#roundShortest",
              "documentation": {
                "identifier": "roundShortest",
                "newPage": false,
                "searchKey": "big.roundShortest",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func roundShortest(d *decimal, x *Float)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc roundShortest(d *decimal, x *Float)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#fmtE",
              "documentation": {
                "identifier": "fmtE",
                "newPage": false,
                "searchKey": "big.fmtE",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fmtE(buf []byte, fmt byte, prec int, d decimal) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fmtE(buf []byte, fmt byte, prec int, d decimal) []byte\n```\n\n%e: d.dddddedd \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#fmtF",
              "documentation": {
                "identifier": "fmtF",
                "newPage": false,
                "searchKey": "big.fmtF",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fmtF(buf []byte, prec int, d decimal) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fmtF(buf []byte, prec int, d decimal) []byte\n```\n\n%f: ddddddd.ddddd \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#min",
              "documentation": {
                "identifier": "min",
                "newPage": false,
                "searchKey": "big.min",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func min(x, y int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc min(x, y int) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#low32",
              "documentation": {
                "identifier": "low32",
                "newPage": false,
                "searchKey": "big.low32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func low32(x nat) uint32"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc low32(x nat) uint32\n```\n\nlow32 returns the least significant 32 bits of x. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#low64",
              "documentation": {
                "identifier": "low64",
                "newPage": false,
                "searchKey": "big.low64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func low64(x nat) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc low64(x nat) uint64\n```\n\nlow64 returns the least significant 64 bits of x. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#lehmerUpdate",
              "documentation": {
                "identifier": "lehmerUpdate",
                "newPage": false,
                "searchKey": "big.lehmerUpdate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func lehmerUpdate(A, B, q, r, s, t *Int, u0, u1, v0, v1 Word, even bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc lehmerUpdate(A, B, q, r, s, t *Int, u0, u1, v0, v1 Word, even bool)\n```\n\nlehmerUpdate updates the inputs A and B such that: \n\n```\nA = u0*A + v0*B\nB = u1*A + v1*B\n\n```\nwhere the signs of u0, u1, v0, v1 are given by even For even == true: u0, v1 >= 0 && u1, v0 <= 0 For even == false: u0, v1 <= 0 && u1, v0 >= 0 q, r, s, t are temporary variables to avoid allocations in the multiplication \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#euclidUpdate",
              "documentation": {
                "identifier": "euclidUpdate",
                "newPage": false,
                "searchKey": "big.euclidUpdate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func euclidUpdate(A, B, Ua, Ub, q, r, s, t *Int, extended bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc euclidUpdate(A, B, Ua, Ub, q, r, s, t *Int, extended bool)\n```\n\neuclidUpdate performs a single step of the Euclidean GCD algorithm if extended is true, it also updates the cosequence Ua, Ub \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#Jacobi",
              "documentation": {
                "identifier": "Jacobi",
                "newPage": false,
                "searchKey": "big.Jacobi",
                "tags": [
                  "exported"
                ]
              },
              "label": {
                "kind": "plaintext",
                "value": "func Jacobi(x, y *Int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc Jacobi(x, y *Int) int\n```\n\nJacobi returns the Jacobi symbol (x/y), either +1, -1, or 0. The y argument must be an odd integer. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#writeMultiple",
              "documentation": {
                "identifier": "writeMultiple",
                "newPage": false,
                "searchKey": "big.writeMultiple",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func writeMultiple(s fmt.State, text string, count int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc writeMultiple(s fmt.State, text string, count int)\n```\n\nwrite count copies of text to s \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#scanSign",
              "documentation": {
                "identifier": "scanSign",
                "newPage": false,
                "searchKey": "big.scanSign",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func scanSign(r io.ByteScanner) (neg bool, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc scanSign(r io.ByteScanner) (neg bool, err error)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#basicMul",
              "documentation": {
                "identifier": "basicMul",
                "newPage": false,
                "searchKey": "big.basicMul",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func basicMul(z, x, y nat)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc basicMul(z, x, y nat)\n```\n\nbasicMul multiplies x and y and leaves the result in z. The (non-normalized) result is placed in z[0 : len(x) + len(y)]. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#karatsubaAdd",
              "documentation": {
                "identifier": "karatsubaAdd",
                "newPage": false,
                "searchKey": "big.karatsubaAdd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func karatsubaAdd(z, x nat, n int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc karatsubaAdd(z, x nat, n int)\n```\n\nFast version of z[0:n+n>>1].add(z[0:n+n>>1], x[0:n]) w/o bounds checks. Factored out for readability - do not use outside karatsuba. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#karatsubaSub",
              "documentation": {
                "identifier": "karatsubaSub",
                "newPage": false,
                "searchKey": "big.karatsubaSub",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func karatsubaSub(z, x nat, n int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc karatsubaSub(z, x nat, n int)\n```\n\nLike karatsubaAdd, but does subtract. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#karatsuba",
              "documentation": {
                "identifier": "karatsuba",
                "newPage": false,
                "searchKey": "big.karatsuba",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func karatsuba(z, x, y nat)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc karatsuba(z, x, y nat)\n```\n\nkaratsuba multiplies x and y and leaves the result in z. Both x and y must have the same length n and n must be a power of 2. The result vector z must have len(z) >= 6*n. The (non-normalized) result is placed in z[0 : 2*n]. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#alias",
              "documentation": {
                "identifier": "alias",
                "newPage": false,
                "searchKey": "big.alias",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func alias(x, y nat) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc alias(x, y nat) bool\n```\n\nalias reports whether x and y share the same base array. Note: alias assumes that the capacity of underlying arrays \n\n```\nis never changed for nat values; i.e. that there are\nno 3-operand slice expressions in this code (or worse,\nreflect-based operations to the same effect).\n\n```\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#addAt",
              "documentation": {
                "identifier": "addAt",
                "newPage": false,
                "searchKey": "big.addAt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func addAt(z, x nat, i int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc addAt(z, x nat, i int)\n```\n\naddAt implements z += x<<(_W*i); z must be long enough. (we don't use nat.add because we need z to stay the same slice, and we don't need to normalize z after each addition) \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#max",
              "documentation": {
                "identifier": "max",
                "newPage": false,
                "searchKey": "big.max",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func max(x, y int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc max(x, y int) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#karatsubaLen",
              "documentation": {
                "identifier": "karatsubaLen",
                "newPage": false,
                "searchKey": "big.karatsubaLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func karatsubaLen(n, threshold int) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc karatsubaLen(n, threshold int) int\n```\n\nkaratsubaLen computes an approximation to the maximum k <= n such that k = p<<i for a number p <= threshold and an i >= 0. Thus, the result is the largest number that can be divided repeatedly by 2 before becoming about the value of threshold. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#basicSqr",
              "documentation": {
                "identifier": "basicSqr",
                "newPage": false,
                "searchKey": "big.basicSqr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func basicSqr(z, x nat)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc basicSqr(z, x nat)\n```\n\nbasicSqr sets z = x*x and is asymptotically faster than basicMul by about a factor of 2, but slower for small arguments due to overhead. Requirements: len(x) > 0, len(z) == 2*len(x) The (non-normalized) result is placed in z. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#karatsubaSqr",
              "documentation": {
                "identifier": "karatsubaSqr",
                "newPage": false,
                "searchKey": "big.karatsubaSqr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func karatsubaSqr(z, x nat)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc karatsubaSqr(z, x nat)\n```\n\nkaratsubaSqr squares x and leaves the result in z. len(x) must be a power of 2 and len(z) >= 6*len(x). The (non-normalized) result is placed in z[0 : 2*len(x)]. \n\nThe algorithm and the layout of z are the same as for karatsuba. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#putNat",
              "documentation": {
                "identifier": "putNat",
                "newPage": false,
                "searchKey": "big.putNat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func putNat(x *nat)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc putNat(x *nat)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#same",
              "documentation": {
                "identifier": "same",
                "newPage": false,
                "searchKey": "big.same",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func same(x, y nat) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc same(x, y nat) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#divisors",
              "documentation": {
                "identifier": "divisors",
                "newPage": false,
                "searchKey": "big.divisors",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func divisors(m int, b Word, ndigits int, bb Word) []divisor"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc divisors(m int, b Word, ndigits int, bb Word) []divisor\n```\n\nconstruct table of powers of bb*leafSize to use in subdivisions \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#greaterThan",
              "documentation": {
                "identifier": "greaterThan",
                "newPage": false,
                "searchKey": "big.greaterThan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func greaterThan(x1, x2, y1, y2 Word) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc greaterThan(x1, x2, y1, y2 Word) bool\n```\n\ngreaterThan reports whether the two digit numbers x1 x2 > y1 y2. TODO(rsc): In contradiction to most of this file, x1 is the high digit and x2 is the low digit. This should be fixed. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#quotToFloat32",
              "documentation": {
                "identifier": "quotToFloat32",
                "newPage": false,
                "searchKey": "big.quotToFloat32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func quotToFloat32(a, b nat) (f float32, exact bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc quotToFloat32(a, b nat) (f float32, exact bool)\n```\n\nquotToFloat32 returns the non-negative float32 value nearest to the quotient a/b, using round-to-even in halfway cases. It does not mutate its arguments. Preconditions: b is non-zero; a and b have no common factors. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#quotToFloat64",
              "documentation": {
                "identifier": "quotToFloat64",
                "newPage": false,
                "searchKey": "big.quotToFloat64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func quotToFloat64(a, b nat) (f float64, exact bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc quotToFloat64(a, b nat) (f float64, exact bool)\n```\n\nquotToFloat64 returns the non-negative float64 value nearest to the quotient a/b, using round-to-even in halfway cases. It does not mutate its arguments. Preconditions: b is non-zero; a and b have no common factors. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#ratTok",
              "documentation": {
                "identifier": "ratTok",
                "newPage": false,
                "searchKey": "big.ratTok",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func ratTok(ch rune) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc ratTok(ch rune) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#scanExponent",
              "documentation": {
                "identifier": "scanExponent",
                "newPage": false,
                "searchKey": "big.scanExponent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func scanExponent(r io.ByteScanner, base2ok, sepOk bool) (exp int64, base int, err error)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc scanExponent(r io.ByteScanner, base2ok, sepOk bool) (exp int64, base int, err error)\n```\n\nscanExponent scans the longest possible prefix of r representing a base 10 (`e', `E') or a base 2 (`p', `P') exponent, if any. It returns the exponent, the exponent base (10 or 2), or a read or syntax error, if any. \n\nIf sepOk is set, an underscore character `_' may appear between successive exponent digits; such underscores do not change the value of the exponent. Incorrect placement of underscores is reported as an error if there are no other errors. If sepOk is not set, underscores are not recognized and thus terminate scanning like any other character that is not a valid digit. \n\n```\nexponent = ( \"e\" | \"E\" | \"p\" | \"P\" ) [ sign ] digits .\nsign     = \"+\" | \"-\" .\ndigits   = digit { [ '_' ] digit } .\ndigit    = \"0\" ... \"9\" .\n\n```\nA base 2 exponent is only permitted if base2ok is set. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testFunVV",
              "documentation": {
                "identifier": "testFunVV",
                "newPage": false,
                "searchKey": "big.testFunVV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFunVV(t *testing.T, msg string, f funVV, a argVV)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFunVV(t *testing.T, msg string, f funVV, a argVV)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFunVV",
              "documentation": {
                "identifier": "TestFunVV",
                "newPage": false,
                "searchKey": "big.TestFunVV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFunVV(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFunVV(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#rndV",
              "documentation": {
                "identifier": "rndV",
                "newPage": false,
                "searchKey": "big.rndV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func rndV(n int) []Word"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc rndV(n int) []Word\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkAddVV",
              "documentation": {
                "identifier": "BenchmarkAddVV",
                "newPage": false,
                "searchKey": "big.BenchmarkAddVV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkAddVV(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkAddVV(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkSubVV",
              "documentation": {
                "identifier": "BenchmarkSubVV",
                "newPage": false,
                "searchKey": "big.BenchmarkSubVV",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkSubVV(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkSubVV(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testFunVW",
              "documentation": {
                "identifier": "testFunVW",
                "newPage": false,
                "searchKey": "big.testFunVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFunVW(t *testing.T, msg string, f funVW, a argVW)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFunVW(t *testing.T, msg string, f funVW, a argVW)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testFunVWext",
              "documentation": {
                "identifier": "testFunVWext",
                "newPage": false,
                "searchKey": "big.testFunVWext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFunVWext(t *testing.T, msg string, f funVW, f_g funVW, a argVW)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFunVWext(t *testing.T, msg string, f funVW, f_g funVW, a argVW)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFunVW",
              "documentation": {
                "identifier": "TestFunVW",
                "newPage": false,
                "searchKey": "big.TestFunVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFunVW(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFunVW(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#makeWordVec",
              "documentation": {
                "identifier": "makeWordVec",
                "newPage": false,
                "searchKey": "big.makeWordVec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func makeWordVec(e Word, n int) []Word"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc makeWordVec(e Word, n int) []Word\n```\n\nConstruct a vector comprising the same word, usually '0' or 'maximum uint' \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFunVWExt",
              "documentation": {
                "identifier": "TestFunVWExt",
                "newPage": false,
                "searchKey": "big.TestFunVWExt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFunVWExt(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFunVWExt(t *testing.T)\n```\n\nExtended testing to addVW and subVW using various kinds of input data. We utilize the results of addVW_g and subVW_g as golden reference to check correctness. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testShiftFunc",
              "documentation": {
                "identifier": "testShiftFunc",
                "newPage": false,
                "searchKey": "big.testShiftFunc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testShiftFunc(t *testing.T, f func(z, x []Word, s uint) Word, a argVU)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testShiftFunc(t *testing.T, f func(z, x []Word, s uint) Word, a argVU)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestShiftOverlap",
              "documentation": {
                "identifier": "TestShiftOverlap",
                "newPage": false,
                "searchKey": "big.TestShiftOverlap",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestShiftOverlap(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestShiftOverlap(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue31084",
              "documentation": {
                "identifier": "TestIssue31084",
                "newPage": false,
                "searchKey": "big.TestIssue31084",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue31084(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue31084(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue42838",
              "documentation": {
                "identifier": "TestIssue42838",
                "newPage": false,
                "searchKey": "big.TestIssue42838",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue42838(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue42838(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkAddVW",
              "documentation": {
                "identifier": "BenchmarkAddVW",
                "newPage": false,
                "searchKey": "big.BenchmarkAddVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkAddVW(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkAddVW(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkAddVWext",
              "documentation": {
                "identifier": "BenchmarkAddVWext",
                "newPage": false,
                "searchKey": "big.BenchmarkAddVWext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkAddVWext(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkAddVWext(b *testing.B)\n```\n\nBenchmarking addVW using vector of maximum uint to force carry flag set \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkSubVW",
              "documentation": {
                "identifier": "BenchmarkSubVW",
                "newPage": false,
                "searchKey": "big.BenchmarkSubVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkSubVW(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkSubVW(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkSubVWext",
              "documentation": {
                "identifier": "BenchmarkSubVWext",
                "newPage": false,
                "searchKey": "big.BenchmarkSubVWext",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkSubVWext(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkSubVWext(b *testing.B)\n```\n\nBenchmarking subVW using vector of zero to force carry flag set \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testFunVWW",
              "documentation": {
                "identifier": "testFunVWW",
                "newPage": false,
                "searchKey": "big.testFunVWW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFunVWW(t *testing.T, msg string, f funVWW, a argVWW)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFunVWW(t *testing.T, msg string, f funVWW, a argVWW)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testFunWVW",
              "documentation": {
                "identifier": "testFunWVW",
                "newPage": false,
                "searchKey": "big.testFunWVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFunWVW(t *testing.T, msg string, f funWVW, a argWVW)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFunWVW(t *testing.T, msg string, f funWVW, a argWVW)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFunVWW",
              "documentation": {
                "identifier": "TestFunVWW",
                "newPage": false,
                "searchKey": "big.TestFunVWW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFunVWW(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFunVWW(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestMulWW",
              "documentation": {
                "identifier": "TestMulWW",
                "newPage": false,
                "searchKey": "big.TestMulWW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMulWW(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMulWW(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestMulAddWWW",
              "documentation": {
                "identifier": "TestMulAddWWW",
                "newPage": false,
                "searchKey": "big.TestMulAddWWW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMulAddWWW(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMulAddWWW(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestDivWW",
              "documentation": {
                "identifier": "TestDivWW",
                "newPage": false,
                "searchKey": "big.TestDivWW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDivWW(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDivWW(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkMulAddVWW",
              "documentation": {
                "identifier": "BenchmarkMulAddVWW",
                "newPage": false,
                "searchKey": "big.BenchmarkMulAddVWW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkMulAddVWW(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkMulAddVWW(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkAddMulVVW",
              "documentation": {
                "identifier": "BenchmarkAddMulVVW",
                "newPage": false,
                "searchKey": "big.BenchmarkAddMulVVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkAddMulVVW(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkAddMulVVW(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkDivWVW",
              "documentation": {
                "identifier": "BenchmarkDivWVW",
                "newPage": false,
                "searchKey": "big.BenchmarkDivWVW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkDivWVW(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkDivWVW(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkNonZeroShifts",
              "documentation": {
                "identifier": "BenchmarkNonZeroShifts",
                "newPage": false,
                "searchKey": "big.BenchmarkNonZeroShifts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkNonZeroShifts(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkNonZeroShifts(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestMulBits",
              "documentation": {
                "identifier": "TestMulBits",
                "newPage": false,
                "searchKey": "big.TestMulBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMulBits(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMulBits(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestNormBits",
              "documentation": {
                "identifier": "TestNormBits",
                "newPage": false,
                "searchKey": "big.TestNormBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNormBits(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNormBits(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFromBits",
              "documentation": {
                "identifier": "TestFromBits",
                "newPage": false,
                "searchKey": "big.TestFromBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFromBits(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFromBits(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestCalibrate",
              "documentation": {
                "identifier": "TestCalibrate",
                "newPage": false,
                "searchKey": "big.TestCalibrate",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCalibrate(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCalibrate(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#karatsubaLoad",
              "documentation": {
                "identifier": "karatsubaLoad",
                "newPage": false,
                "searchKey": "big.karatsubaLoad",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func karatsubaLoad(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc karatsubaLoad(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#measureKaratsuba",
              "documentation": {
                "identifier": "measureKaratsuba",
                "newPage": false,
                "searchKey": "big.measureKaratsuba",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func measureKaratsuba(th int) time.Duration"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc measureKaratsuba(th int) time.Duration\n```\n\nmeasureKaratsuba returns the time to run a Karatsuba-relevant benchmark given Karatsuba threshold th. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#computeKaratsubaThresholds",
              "documentation": {
                "identifier": "computeKaratsubaThresholds",
                "newPage": false,
                "searchKey": "big.computeKaratsubaThresholds",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func computeKaratsubaThresholds()"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc computeKaratsubaThresholds()\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#measureSqr",
              "documentation": {
                "identifier": "measureSqr",
                "newPage": false,
                "searchKey": "big.measureSqr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func measureSqr(words, nruns int, mode string) time.Duration"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc measureSqr(words, nruns int, mode string) time.Duration\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#computeSqrThreshold",
              "documentation": {
                "identifier": "computeSqrThreshold",
                "newPage": false,
                "searchKey": "big.computeSqrThreshold",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func computeSqrThreshold(from, to, step, nruns int, lower, upper string) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc computeSqrThreshold(from, to, step, nruns int, lower, upper string) int\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestDecimalString",
              "documentation": {
                "identifier": "TestDecimalString",
                "newPage": false,
                "searchKey": "big.TestDecimalString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDecimalString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDecimalString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestDecimalInit",
              "documentation": {
                "identifier": "TestDecimalInit",
                "newPage": false,
                "searchKey": "big.TestDecimalInit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDecimalInit(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDecimalInit(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestDecimalRounding",
              "documentation": {
                "identifier": "TestDecimalRounding",
                "newPage": false,
                "searchKey": "big.TestDecimalRounding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDecimalRounding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDecimalRounding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkDecimalConversion",
              "documentation": {
                "identifier": "BenchmarkDecimalConversion",
                "newPage": false,
                "searchKey": "big.BenchmarkDecimalConversion",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkDecimalConversion(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkDecimalConversion(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkFloatString",
              "documentation": {
                "identifier": "BenchmarkFloatString",
                "newPage": false,
                "searchKey": "big.BenchmarkFloatString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkFloatString(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkFloatString(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatZeroValue",
              "documentation": {
                "identifier": "TestFloatZeroValue",
                "newPage": false,
                "searchKey": "big.TestFloatZeroValue",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatZeroValue(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatZeroValue(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSetPrec",
              "documentation": {
                "identifier": "TestFloatSetPrec",
                "newPage": false,
                "searchKey": "big.TestFloatSetPrec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSetPrec(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSetPrec(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatMinPrec",
              "documentation": {
                "identifier": "TestFloatMinPrec",
                "newPage": false,
                "searchKey": "big.TestFloatMinPrec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatMinPrec(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatMinPrec(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSign",
              "documentation": {
                "identifier": "TestFloatSign",
                "newPage": false,
                "searchKey": "big.TestFloatSign",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSign(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSign(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#alike",
              "documentation": {
                "identifier": "alike",
                "newPage": false,
                "searchKey": "big.alike",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func alike(x, y *Float) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc alike(x, y *Float) bool\n```\n\nalike(x, y) is like x.Cmp(y) == 0 but also considers the sign of 0 (0 != -0). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#alike32",
              "documentation": {
                "identifier": "alike32",
                "newPage": false,
                "searchKey": "big.alike32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func alike32(x, y float32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc alike32(x, y float32) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#alike64",
              "documentation": {
                "identifier": "alike64",
                "newPage": false,
                "searchKey": "big.alike64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func alike64(x, y float64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc alike64(x, y float64) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatMantExp",
              "documentation": {
                "identifier": "TestFloatMantExp",
                "newPage": false,
                "searchKey": "big.TestFloatMantExp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatMantExp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatMantExp(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatMantExpAliasing",
              "documentation": {
                "identifier": "TestFloatMantExpAliasing",
                "newPage": false,
                "searchKey": "big.TestFloatMantExpAliasing",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatMantExpAliasing(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatMantExpAliasing(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSetMantExp",
              "documentation": {
                "identifier": "TestFloatSetMantExp",
                "newPage": false,
                "searchKey": "big.TestFloatSetMantExp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSetMantExp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSetMantExp(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatPredicates",
              "documentation": {
                "identifier": "TestFloatPredicates",
                "newPage": false,
                "searchKey": "big.TestFloatPredicates",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatPredicates(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatPredicates(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatIsInt",
              "documentation": {
                "identifier": "TestFloatIsInt",
                "newPage": false,
                "searchKey": "big.TestFloatIsInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatIsInt(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatIsInt(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#fromBinary",
              "documentation": {
                "identifier": "fromBinary",
                "newPage": false,
                "searchKey": "big.fromBinary",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fromBinary(s string) int64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fromBinary(s string) int64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#toBinary",
              "documentation": {
                "identifier": "toBinary",
                "newPage": false,
                "searchKey": "big.toBinary",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func toBinary(x int64) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc toBinary(x int64) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testFloatRound",
              "documentation": {
                "identifier": "testFloatRound",
                "newPage": false,
                "searchKey": "big.testFloatRound",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFloatRound(t *testing.T, x, r int64, prec uint, mode RoundingMode)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFloatRound(t *testing.T, x, r int64, prec uint, mode RoundingMode)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatRound",
              "documentation": {
                "identifier": "TestFloatRound",
                "newPage": false,
                "searchKey": "big.TestFloatRound",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatRound(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatRound(t *testing.T)\n```\n\nTestFloatRound tests basic rounding. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatRound24",
              "documentation": {
                "identifier": "TestFloatRound24",
                "newPage": false,
                "searchKey": "big.TestFloatRound24",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatRound24(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatRound24(t *testing.T)\n```\n\nTestFloatRound24 tests that rounding a float64 to 24 bits matches IEEE-754 rounding to nearest when converting a float64 to a float32 (excluding denormal numbers). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSetUint64",
              "documentation": {
                "identifier": "TestFloatSetUint64",
                "newPage": false,
                "searchKey": "big.TestFloatSetUint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSetUint64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSetUint64(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSetInt64",
              "documentation": {
                "identifier": "TestFloatSetInt64",
                "newPage": false,
                "searchKey": "big.TestFloatSetInt64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSetInt64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSetInt64(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSetFloat64",
              "documentation": {
                "identifier": "TestFloatSetFloat64",
                "newPage": false,
                "searchKey": "big.TestFloatSetFloat64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSetFloat64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSetFloat64(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSetInt",
              "documentation": {
                "identifier": "TestFloatSetInt",
                "newPage": false,
                "searchKey": "big.TestFloatSetInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSetInt(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSetInt(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSetRat",
              "documentation": {
                "identifier": "TestFloatSetRat",
                "newPage": false,
                "searchKey": "big.TestFloatSetRat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSetRat(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSetRat(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSetInf",
              "documentation": {
                "identifier": "TestFloatSetInf",
                "newPage": false,
                "searchKey": "big.TestFloatSetInf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSetInf(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSetInf(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatUint64",
              "documentation": {
                "identifier": "TestFloatUint64",
                "newPage": false,
                "searchKey": "big.TestFloatUint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatUint64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatUint64(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatInt64",
              "documentation": {
                "identifier": "TestFloatInt64",
                "newPage": false,
                "searchKey": "big.TestFloatInt64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatInt64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatInt64(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatFloat32",
              "documentation": {
                "identifier": "TestFloatFloat32",
                "newPage": false,
                "searchKey": "big.TestFloatFloat32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatFloat32(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatFloat32(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatFloat64",
              "documentation": {
                "identifier": "TestFloatFloat64",
                "newPage": false,
                "searchKey": "big.TestFloatFloat64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatFloat64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatFloat64(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatInt",
              "documentation": {
                "identifier": "TestFloatInt",
                "newPage": false,
                "searchKey": "big.TestFloatInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatInt(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatInt(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatRat",
              "documentation": {
                "identifier": "TestFloatRat",
                "newPage": false,
                "searchKey": "big.TestFloatRat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatRat(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatRat(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatAbs",
              "documentation": {
                "identifier": "TestFloatAbs",
                "newPage": false,
                "searchKey": "big.TestFloatAbs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatAbs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatAbs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatNeg",
              "documentation": {
                "identifier": "TestFloatNeg",
                "newPage": false,
                "searchKey": "big.TestFloatNeg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatNeg(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatNeg(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatInc",
              "documentation": {
                "identifier": "TestFloatInc",
                "newPage": false,
                "searchKey": "big.TestFloatInc",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatInc(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatInc(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatAdd",
              "documentation": {
                "identifier": "TestFloatAdd",
                "newPage": false,
                "searchKey": "big.TestFloatAdd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatAdd(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatAdd(t *testing.T)\n```\n\nTestFloatAdd tests Float.Add/Sub by comparing the result of a \"manual\" addition/subtraction of arguments represented by Bits values with the respective Float addition/subtraction for a variety of precisions and rounding modes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatAddRoundZero",
              "documentation": {
                "identifier": "TestFloatAddRoundZero",
                "newPage": false,
                "searchKey": "big.TestFloatAddRoundZero",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatAddRoundZero(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatAddRoundZero(t *testing.T)\n```\n\nTestFloatAddRoundZero tests Float.Add/Sub rounding when the result is exactly zero. x + (-x) or x - x for non-zero x should be +0 in all cases except when the rounding mode is ToNegativeInf in which case it should be -0. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatAdd32",
              "documentation": {
                "identifier": "TestFloatAdd32",
                "newPage": false,
                "searchKey": "big.TestFloatAdd32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatAdd32(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatAdd32(t *testing.T)\n```\n\nTestFloatAdd32 tests that Float.Add/Sub of numbers with 24bit mantissa behaves like float32 addition/subtraction (excluding denormal numbers). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatAdd64",
              "documentation": {
                "identifier": "TestFloatAdd64",
                "newPage": false,
                "searchKey": "big.TestFloatAdd64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatAdd64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatAdd64(t *testing.T)\n```\n\nTestFloatAdd64 tests that Float.Add/Sub of numbers with 53bit mantissa behaves like float64 addition/subtraction. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue20490",
              "documentation": {
                "identifier": "TestIssue20490",
                "newPage": false,
                "searchKey": "big.TestIssue20490",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue20490(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue20490(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatMul",
              "documentation": {
                "identifier": "TestFloatMul",
                "newPage": false,
                "searchKey": "big.TestFloatMul",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatMul(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatMul(t *testing.T)\n```\n\nTestFloatMul tests Float.Mul/Quo by comparing the result of a \"manual\" multiplication/division of arguments represented by Bits values with the respective Float multiplication/division for a variety of precisions and rounding modes. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatMul64",
              "documentation": {
                "identifier": "TestFloatMul64",
                "newPage": false,
                "searchKey": "big.TestFloatMul64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatMul64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatMul64(t *testing.T)\n```\n\nTestFloatMul64 tests that Float.Mul/Quo of numbers with 53bit mantissa behaves like float64 multiplication/division. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue6866",
              "documentation": {
                "identifier": "TestIssue6866",
                "newPage": false,
                "searchKey": "big.TestIssue6866",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue6866(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue6866(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatQuo",
              "documentation": {
                "identifier": "TestFloatQuo",
                "newPage": false,
                "searchKey": "big.TestFloatQuo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatQuo(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatQuo(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatQuoSmoke",
              "documentation": {
                "identifier": "TestFloatQuoSmoke",
                "newPage": false,
                "searchKey": "big.TestFloatQuoSmoke",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatQuoSmoke(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatQuoSmoke(t *testing.T)\n```\n\nTestFloatQuoSmoke tests all divisions x/y for values x, y in the range [-n, +n]; it serves as a smoke test for basic correctness of division. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatArithmeticSpecialValues",
              "documentation": {
                "identifier": "TestFloatArithmeticSpecialValues",
                "newPage": false,
                "searchKey": "big.TestFloatArithmeticSpecialValues",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatArithmeticSpecialValues(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatArithmeticSpecialValues(t *testing.T)\n```\n\nTestFloatArithmeticSpecialValues tests that Float operations produce the correct results for combinations of zero (0), finite (1 and 2.71828), and infinite (Inf) operands. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatArithmeticOverflow",
              "documentation": {
                "identifier": "TestFloatArithmeticOverflow",
                "newPage": false,
                "searchKey": "big.TestFloatArithmeticOverflow",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatArithmeticOverflow(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatArithmeticOverflow(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatArithmeticRounding",
              "documentation": {
                "identifier": "TestFloatArithmeticRounding",
                "newPage": false,
                "searchKey": "big.TestFloatArithmeticRounding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatArithmeticRounding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatArithmeticRounding(t *testing.T)\n```\n\nFor rounding modes ToNegativeInf and ToPositiveInf, rounding is affected by the sign of the value to be rounded. Test that rounding happens after the sign of a result has been set. This test uses specific values that are known to fail if rounding is \"factored\" out before setting the result sign. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatCmpSpecialValues",
              "documentation": {
                "identifier": "TestFloatCmpSpecialValues",
                "newPage": false,
                "searchKey": "big.TestFloatCmpSpecialValues",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatCmpSpecialValues(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatCmpSpecialValues(t *testing.T)\n```\n\nTestFloatCmpSpecialValues tests that Cmp produces the correct results for combinations of zero (0), finite (1 and 2.71828), and infinite (Inf) operands. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkFloatAdd",
              "documentation": {
                "identifier": "BenchmarkFloatAdd",
                "newPage": false,
                "searchKey": "big.BenchmarkFloatAdd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkFloatAdd(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkFloatAdd(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkFloatSub",
              "documentation": {
                "identifier": "BenchmarkFloatSub",
                "newPage": false,
                "searchKey": "big.BenchmarkFloatSub",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkFloatSub(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkFloatSub(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSetFloat64String",
              "documentation": {
                "identifier": "TestFloatSetFloat64String",
                "newPage": false,
                "searchKey": "big.TestFloatSetFloat64String",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSetFloat64String(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSetFloat64String(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#fdiv",
              "documentation": {
                "identifier": "fdiv",
                "newPage": false,
                "searchKey": "big.fdiv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func fdiv(a, b float64) float64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc fdiv(a, b float64) float64\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloat64Text",
              "documentation": {
                "identifier": "TestFloat64Text",
                "newPage": false,
                "searchKey": "big.TestFloat64Text",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloat64Text(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloat64Text(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#actualPrec",
              "documentation": {
                "identifier": "actualPrec",
                "newPage": false,
                "searchKey": "big.actualPrec",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func actualPrec(x float64) uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc actualPrec(x float64) uint\n```\n\nactualPrec returns the number of actually used mantissa bits. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatText",
              "documentation": {
                "identifier": "TestFloatText",
                "newPage": false,
                "searchKey": "big.TestFloatText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatText(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatText(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatFormat",
              "documentation": {
                "identifier": "TestFloatFormat",
                "newPage": false,
                "searchKey": "big.TestFloatFormat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatFormat(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatFormat(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkParseFloatSmallExp",
              "documentation": {
                "identifier": "BenchmarkParseFloatSmallExp",
                "newPage": false,
                "searchKey": "big.BenchmarkParseFloatSmallExp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkParseFloatSmallExp(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkParseFloatSmallExp(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkParseFloatLargeExp",
              "documentation": {
                "identifier": "BenchmarkParseFloatLargeExp",
                "newPage": false,
                "searchKey": "big.BenchmarkParseFloatLargeExp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkParseFloatLargeExp(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkParseFloatLargeExp(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatScan",
              "documentation": {
                "identifier": "TestFloatScan",
                "newPage": false,
                "searchKey": "big.TestFloatScan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatScan(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatScan(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatGobEncoding",
              "documentation": {
                "identifier": "TestFloatGobEncoding",
                "newPage": false,
                "searchKey": "big.TestFloatGobEncoding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatGobEncoding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatGobEncoding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatCorruptGob",
              "documentation": {
                "identifier": "TestFloatCorruptGob",
                "newPage": false,
                "searchKey": "big.TestFloatCorruptGob",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatCorruptGob(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatCorruptGob(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatJSONEncoding",
              "documentation": {
                "identifier": "TestFloatJSONEncoding",
                "newPage": false,
                "searchKey": "big.TestFloatJSONEncoding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatJSONEncoding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatJSONEncoding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#runGCD",
              "documentation": {
                "identifier": "runGCD",
                "newPage": false,
                "searchKey": "big.runGCD",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runGCD(b *testing.B, aSize, bSize uint)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runGCD(b *testing.B, aSize, bSize uint)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#runGCDExt",
              "documentation": {
                "identifier": "runGCDExt",
                "newPage": false,
                "searchKey": "big.runGCDExt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runGCDExt(b *testing.B, aSize, bSize uint, calcXY bool)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runGCDExt(b *testing.B, aSize, bSize uint, calcXY bool)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD10x10",
              "documentation": {
                "identifier": "BenchmarkGCD10x10",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD10x10",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD10x10(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD10x10(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD10x100",
              "documentation": {
                "identifier": "BenchmarkGCD10x100",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD10x100",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD10x100(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD10x100(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD10x1000",
              "documentation": {
                "identifier": "BenchmarkGCD10x1000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD10x1000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD10x1000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD10x1000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD10x10000",
              "documentation": {
                "identifier": "BenchmarkGCD10x10000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD10x10000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD10x10000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD10x10000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD10x100000",
              "documentation": {
                "identifier": "BenchmarkGCD10x100000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD10x100000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD10x100000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD10x100000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD100x100",
              "documentation": {
                "identifier": "BenchmarkGCD100x100",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD100x100",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD100x100(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD100x100(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD100x1000",
              "documentation": {
                "identifier": "BenchmarkGCD100x1000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD100x1000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD100x1000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD100x1000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD100x10000",
              "documentation": {
                "identifier": "BenchmarkGCD100x10000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD100x10000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD100x10000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD100x10000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD100x100000",
              "documentation": {
                "identifier": "BenchmarkGCD100x100000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD100x100000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD100x100000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD100x100000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD1000x1000",
              "documentation": {
                "identifier": "BenchmarkGCD1000x1000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD1000x1000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD1000x1000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD1000x1000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD1000x10000",
              "documentation": {
                "identifier": "BenchmarkGCD1000x10000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD1000x10000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD1000x10000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD1000x10000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD1000x100000",
              "documentation": {
                "identifier": "BenchmarkGCD1000x100000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD1000x100000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD1000x100000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD1000x100000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD10000x10000",
              "documentation": {
                "identifier": "BenchmarkGCD10000x10000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD10000x10000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD10000x10000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD10000x10000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD10000x100000",
              "documentation": {
                "identifier": "BenchmarkGCD10000x100000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD10000x100000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD10000x100000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD10000x100000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkGCD100000x100000",
              "documentation": {
                "identifier": "BenchmarkGCD100000x100000",
                "newPage": false,
                "searchKey": "big.BenchmarkGCD100000x100000",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkGCD100000x100000(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkGCD100000x100000(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#doHilbert",
              "documentation": {
                "identifier": "doHilbert",
                "newPage": false,
                "searchKey": "big.doHilbert",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func doHilbert(t *testing.T, n int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc doHilbert(t *testing.T, n int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestHilbert",
              "documentation": {
                "identifier": "TestHilbert",
                "newPage": false,
                "searchKey": "big.TestHilbert",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestHilbert(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestHilbert(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkHilbert",
              "documentation": {
                "identifier": "BenchmarkHilbert",
                "newPage": false,
                "searchKey": "big.BenchmarkHilbert",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkHilbert(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkHilbert(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#isNormalized",
              "documentation": {
                "identifier": "isNormalized",
                "newPage": false,
                "searchKey": "big.isNormalized",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isNormalized(x *Int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isNormalized(x *Int) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestSignZ",
              "documentation": {
                "identifier": "TestSignZ",
                "newPage": false,
                "searchKey": "big.TestSignZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSignZ(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSignZ(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestSetZ",
              "documentation": {
                "identifier": "TestSetZ",
                "newPage": false,
                "searchKey": "big.TestSetZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSetZ(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSetZ(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestAbsZ",
              "documentation": {
                "identifier": "TestAbsZ",
                "newPage": false,
                "searchKey": "big.TestAbsZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAbsZ(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAbsZ(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testFunZZ",
              "documentation": {
                "identifier": "testFunZZ",
                "newPage": false,
                "searchKey": "big.testFunZZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFunZZ(t *testing.T, msg string, f funZZ, a argZZ)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFunZZ(t *testing.T, msg string, f funZZ, a argZZ)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestSumZZ",
              "documentation": {
                "identifier": "TestSumZZ",
                "newPage": false,
                "searchKey": "big.TestSumZZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSumZZ(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSumZZ(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestProdZZ",
              "documentation": {
                "identifier": "TestProdZZ",
                "newPage": false,
                "searchKey": "big.TestProdZZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestProdZZ(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestProdZZ(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#mulBytes",
              "documentation": {
                "identifier": "mulBytes",
                "newPage": false,
                "searchKey": "big.mulBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func mulBytes(x, y []byte) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc mulBytes(x, y []byte) []byte\n```\n\nmulBytes returns x*y via grade school multiplication. Both inputs and the result are assumed to be in big-endian representation (to match the semantics of Int.Bytes and Int.SetBytes). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#checkMul",
              "documentation": {
                "identifier": "checkMul",
                "newPage": false,
                "searchKey": "big.checkMul",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkMul(a, b []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkMul(a, b []byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestMul",
              "documentation": {
                "identifier": "TestMul",
                "newPage": false,
                "searchKey": "big.TestMul",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMul(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMul(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestMulRangeZ",
              "documentation": {
                "identifier": "TestMulRangeZ",
                "newPage": false,
                "searchKey": "big.TestMulRangeZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMulRangeZ(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMulRangeZ(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestBinomial",
              "documentation": {
                "identifier": "TestBinomial",
                "newPage": false,
                "searchKey": "big.TestBinomial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBinomial(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBinomial(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkBinomial",
              "documentation": {
                "identifier": "BenchmarkBinomial",
                "newPage": false,
                "searchKey": "big.BenchmarkBinomial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkBinomial(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkBinomial(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestDivisionSigns",
              "documentation": {
                "identifier": "TestDivisionSigns",
                "newPage": false,
                "searchKey": "big.TestDivisionSigns",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestDivisionSigns(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestDivisionSigns(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestBits",
              "documentation": {
                "identifier": "TestBits",
                "newPage": false,
                "searchKey": "big.TestBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBits(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBits(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#checkSetBytes",
              "documentation": {
                "identifier": "checkSetBytes",
                "newPage": false,
                "searchKey": "big.checkSetBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkSetBytes(b []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkSetBytes(b []byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestSetBytes",
              "documentation": {
                "identifier": "TestSetBytes",
                "newPage": false,
                "searchKey": "big.TestSetBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSetBytes(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSetBytes(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#checkBytes",
              "documentation": {
                "identifier": "checkBytes",
                "newPage": false,
                "searchKey": "big.checkBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkBytes(b []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkBytes(b []byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestBytes",
              "documentation": {
                "identifier": "TestBytes",
                "newPage": false,
                "searchKey": "big.TestBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBytes(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBytes(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#checkQuo",
              "documentation": {
                "identifier": "checkQuo",
                "newPage": false,
                "searchKey": "big.checkQuo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkQuo(x, y []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkQuo(x, y []byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestQuo",
              "documentation": {
                "identifier": "TestQuo",
                "newPage": false,
                "searchKey": "big.TestQuo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestQuo(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestQuo(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestQuoStepD6",
              "documentation": {
                "identifier": "TestQuoStepD6",
                "newPage": false,
                "searchKey": "big.TestQuoStepD6",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestQuoStepD6(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestQuoStepD6(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkQuoRem",
              "documentation": {
                "identifier": "BenchmarkQuoRem",
                "newPage": false,
                "searchKey": "big.BenchmarkQuoRem",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkQuoRem(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkQuoRem(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestBitLen",
              "documentation": {
                "identifier": "TestBitLen",
                "newPage": false,
                "searchKey": "big.TestBitLen",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBitLen(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBitLen(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestExp",
              "documentation": {
                "identifier": "TestExp",
                "newPage": false,
                "searchKey": "big.TestExp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExp(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkExp",
              "documentation": {
                "identifier": "BenchmarkExp",
                "newPage": false,
                "searchKey": "big.BenchmarkExp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkExp(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkExp(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkExp2",
              "documentation": {
                "identifier": "BenchmarkExp2",
                "newPage": false,
                "searchKey": "big.BenchmarkExp2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkExp2(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkExp2(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#checkGcd",
              "documentation": {
                "identifier": "checkGcd",
                "newPage": false,
                "searchKey": "big.checkGcd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkGcd(aBytes, bBytes []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkGcd(aBytes, bBytes []byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#checkLehmerGcd",
              "documentation": {
                "identifier": "checkLehmerGcd",
                "newPage": false,
                "searchKey": "big.checkLehmerGcd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkLehmerGcd(aBytes, bBytes []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkLehmerGcd(aBytes, bBytes []byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#checkLehmerExtGcd",
              "documentation": {
                "identifier": "checkLehmerExtGcd",
                "newPage": false,
                "searchKey": "big.checkLehmerExtGcd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkLehmerExtGcd(aBytes, bBytes []byte) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkLehmerExtGcd(aBytes, bBytes []byte) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testGcd",
              "documentation": {
                "identifier": "testGcd",
                "newPage": false,
                "searchKey": "big.testGcd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testGcd(t *testing.T, d, x, y, a, b *Int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testGcd(t *testing.T, d, x, y, a, b *Int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestGcd",
              "documentation": {
                "identifier": "TestGcd",
                "newPage": false,
                "searchKey": "big.TestGcd",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGcd(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGcd(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRsh",
              "documentation": {
                "identifier": "TestRsh",
                "newPage": false,
                "searchKey": "big.TestRsh",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRsh(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRsh(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRshSelf",
              "documentation": {
                "identifier": "TestRshSelf",
                "newPage": false,
                "searchKey": "big.TestRshSelf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRshSelf(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRshSelf(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestLsh",
              "documentation": {
                "identifier": "TestLsh",
                "newPage": false,
                "searchKey": "big.TestLsh",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLsh(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLsh(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestLshSelf",
              "documentation": {
                "identifier": "TestLshSelf",
                "newPage": false,
                "searchKey": "big.TestLshSelf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLshSelf(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLshSelf(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestLshRsh",
              "documentation": {
                "identifier": "TestLshRsh",
                "newPage": false,
                "searchKey": "big.TestLshRsh",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLshRsh(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLshRsh(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestCmpAbs",
              "documentation": {
                "identifier": "TestCmpAbs",
                "newPage": false,
                "searchKey": "big.TestCmpAbs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCmpAbs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCmpAbs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIntCmpSelf",
              "documentation": {
                "identifier": "TestIntCmpSelf",
                "newPage": false,
                "searchKey": "big.TestIntCmpSelf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIntCmpSelf(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIntCmpSelf(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestInt64",
              "documentation": {
                "identifier": "TestInt64",
                "newPage": false,
                "searchKey": "big.TestInt64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestInt64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestInt64(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestUint64",
              "documentation": {
                "identifier": "TestUint64",
                "newPage": false,
                "searchKey": "big.TestUint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestUint64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestUint64(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testBitFun",
              "documentation": {
                "identifier": "testBitFun",
                "newPage": false,
                "searchKey": "big.testBitFun",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testBitFun(t *testing.T, msg string, f bitFun, x, y *Int, exp string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testBitFun(t *testing.T, msg string, f bitFun, x, y *Int, exp string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testBitFunSelf",
              "documentation": {
                "identifier": "testBitFunSelf",
                "newPage": false,
                "searchKey": "big.testBitFunSelf",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testBitFunSelf(t *testing.T, msg string, f bitFun, x, y *Int, exp string)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testBitFunSelf(t *testing.T, msg string, f bitFun, x, y *Int, exp string)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#altBit",
              "documentation": {
                "identifier": "altBit",
                "newPage": false,
                "searchKey": "big.altBit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func altBit(x *Int, i int) uint"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc altBit(x *Int, i int) uint\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testBitset",
              "documentation": {
                "identifier": "testBitset",
                "newPage": false,
                "searchKey": "big.testBitset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testBitset(t *testing.T, x *Int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testBitset(t *testing.T, x *Int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestBitSet",
              "documentation": {
                "identifier": "TestBitSet",
                "newPage": false,
                "searchKey": "big.TestBitSet",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBitSet(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBitSet(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestTrailingZeroBits",
              "documentation": {
                "identifier": "TestTrailingZeroBits",
                "newPage": false,
                "searchKey": "big.TestTrailingZeroBits",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestTrailingZeroBits(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestTrailingZeroBits(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkBitset",
              "documentation": {
                "identifier": "BenchmarkBitset",
                "newPage": false,
                "searchKey": "big.BenchmarkBitset",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkBitset(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkBitset(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkBitsetNeg",
              "documentation": {
                "identifier": "BenchmarkBitsetNeg",
                "newPage": false,
                "searchKey": "big.BenchmarkBitsetNeg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkBitsetNeg(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkBitsetNeg(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkBitsetOrig",
              "documentation": {
                "identifier": "BenchmarkBitsetOrig",
                "newPage": false,
                "searchKey": "big.BenchmarkBitsetOrig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkBitsetOrig(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkBitsetOrig(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkBitsetNegOrig",
              "documentation": {
                "identifier": "BenchmarkBitsetNegOrig",
                "newPage": false,
                "searchKey": "big.BenchmarkBitsetNegOrig",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkBitsetNegOrig(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkBitsetNegOrig(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkModSqrt225_Tonelli",
              "documentation": {
                "identifier": "BenchmarkModSqrt225_Tonelli",
                "newPage": false,
                "searchKey": "big.BenchmarkModSqrt225_Tonelli",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkModSqrt225_Tonelli(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkModSqrt225_Tonelli(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkModSqrt225_3Mod4",
              "documentation": {
                "identifier": "BenchmarkModSqrt225_3Mod4",
                "newPage": false,
                "searchKey": "big.BenchmarkModSqrt225_3Mod4",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkModSqrt225_3Mod4(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkModSqrt225_3Mod4(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkModSqrt231_Tonelli",
              "documentation": {
                "identifier": "BenchmarkModSqrt231_Tonelli",
                "newPage": false,
                "searchKey": "big.BenchmarkModSqrt231_Tonelli",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkModSqrt231_Tonelli(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkModSqrt231_Tonelli(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkModSqrt231_5Mod8",
              "documentation": {
                "identifier": "BenchmarkModSqrt231_5Mod8",
                "newPage": false,
                "searchKey": "big.BenchmarkModSqrt231_5Mod8",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkModSqrt231_5Mod8(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkModSqrt231_5Mod8(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestBitwise",
              "documentation": {
                "identifier": "TestBitwise",
                "newPage": false,
                "searchKey": "big.TestBitwise",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBitwise(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBitwise(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestNot",
              "documentation": {
                "identifier": "TestNot",
                "newPage": false,
                "searchKey": "big.TestNot",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNot(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNot(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestModInverse",
              "documentation": {
                "identifier": "TestModInverse",
                "newPage": false,
                "searchKey": "big.TestModInverse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestModInverse(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestModInverse(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkModInverse",
              "documentation": {
                "identifier": "BenchmarkModInverse",
                "newPage": false,
                "searchKey": "big.BenchmarkModInverse",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkModInverse(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkModInverse(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testModSqrt",
              "documentation": {
                "identifier": "testModSqrt",
                "newPage": false,
                "searchKey": "big.testModSqrt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testModSqrt(t *testing.T, elt, mod, sq, sqrt *Int) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testModSqrt(t *testing.T, elt, mod, sq, sqrt *Int) bool\n```\n\ntestModSqrt is a helper for TestModSqrt, which checks that ModSqrt can compute a square-root of elt^2. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestModSqrt",
              "documentation": {
                "identifier": "TestModSqrt",
                "newPage": false,
                "searchKey": "big.TestModSqrt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestModSqrt(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestModSqrt(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestJacobi",
              "documentation": {
                "identifier": "TestJacobi",
                "newPage": false,
                "searchKey": "big.TestJacobi",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestJacobi(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestJacobi(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestJacobiPanic",
              "documentation": {
                "identifier": "TestJacobiPanic",
                "newPage": false,
                "searchKey": "big.TestJacobiPanic",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestJacobiPanic(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestJacobiPanic(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue2607",
              "documentation": {
                "identifier": "TestIssue2607",
                "newPage": false,
                "searchKey": "big.TestIssue2607",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue2607(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue2607(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestSqrt",
              "documentation": {
                "identifier": "TestSqrt",
                "newPage": false,
                "searchKey": "big.TestSqrt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSqrt(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSqrt(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue22830",
              "documentation": {
                "identifier": "TestIssue22830",
                "newPage": false,
                "searchKey": "big.TestIssue22830",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue22830(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue22830(t *testing.T)\n```\n\nWe can't test this together with the other Exp tests above because it requires a different receiver setup. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkSqrt",
              "documentation": {
                "identifier": "BenchmarkSqrt",
                "newPage": false,
                "searchKey": "big.BenchmarkSqrt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkSqrt(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkSqrt(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#benchmarkIntSqr",
              "documentation": {
                "identifier": "benchmarkIntSqr",
                "newPage": false,
                "searchKey": "big.benchmarkIntSqr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func benchmarkIntSqr(b *testing.B, nwords int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc benchmarkIntSqr(b *testing.B, nwords int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkIntSqr",
              "documentation": {
                "identifier": "BenchmarkIntSqr",
                "newPage": false,
                "searchKey": "big.BenchmarkIntSqr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkIntSqr(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkIntSqr(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#benchmarkDiv",
              "documentation": {
                "identifier": "benchmarkDiv",
                "newPage": false,
                "searchKey": "big.benchmarkDiv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func benchmarkDiv(b *testing.B, aSize, bSize int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc benchmarkDiv(b *testing.B, aSize, bSize int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkDiv",
              "documentation": {
                "identifier": "BenchmarkDiv",
                "newPage": false,
                "searchKey": "big.BenchmarkDiv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkDiv(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkDiv(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFillBytes",
              "documentation": {
                "identifier": "TestFillBytes",
                "newPage": false,
                "searchKey": "big.TestFillBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFillBytes(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFillBytes(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIntText",
              "documentation": {
                "identifier": "TestIntText",
                "newPage": false,
                "searchKey": "big.TestIntText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIntText(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIntText(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestAppendText",
              "documentation": {
                "identifier": "TestAppendText",
                "newPage": false,
                "searchKey": "big.TestAppendText",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestAppendText(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestAppendText(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#format",
              "documentation": {
                "identifier": "format",
                "newPage": false,
                "searchKey": "big.format",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func format(base int) string"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc format(base int) string\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestGetString",
              "documentation": {
                "identifier": "TestGetString",
                "newPage": false,
                "searchKey": "big.TestGetString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGetString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGetString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestSetString",
              "documentation": {
                "identifier": "TestSetString",
                "newPage": false,
                "searchKey": "big.TestSetString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSetString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSetString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFormat",
              "documentation": {
                "identifier": "TestFormat",
                "newPage": false,
                "searchKey": "big.TestFormat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFormat(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFormat(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestScan",
              "documentation": {
                "identifier": "TestScan",
                "newPage": false,
                "searchKey": "big.TestScan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestScan(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestScan(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIntGobEncoding",
              "documentation": {
                "identifier": "TestIntGobEncoding",
                "newPage": false,
                "searchKey": "big.TestIntGobEncoding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIntGobEncoding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIntGobEncoding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestGobEncodingNilIntInSlice",
              "documentation": {
                "identifier": "TestGobEncodingNilIntInSlice",
                "newPage": false,
                "searchKey": "big.TestGobEncodingNilIntInSlice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGobEncodingNilIntInSlice(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGobEncodingNilIntInSlice(t *testing.T)\n```\n\nSending a nil Int pointer (inside a slice) on a round trip through gob should yield a zero. TODO: top-level nils. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIntJSONEncoding",
              "documentation": {
                "identifier": "TestIntJSONEncoding",
                "newPage": false,
                "searchKey": "big.TestIntJSONEncoding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIntJSONEncoding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIntJSONEncoding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIntXMLEncoding",
              "documentation": {
                "identifier": "TestIntXMLEncoding",
                "newPage": false,
                "searchKey": "big.TestIntXMLEncoding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIntXMLEncoding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIntXMLEncoding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestLinkerGC",
              "documentation": {
                "identifier": "TestLinkerGC",
                "newPage": false,
                "searchKey": "big.TestLinkerGC",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLinkerGC(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLinkerGC(t *testing.T)\n```\n\nTests that the linker is able to remove references to Float, Rat, and Int if unused (notably, not used by init). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestCmp",
              "documentation": {
                "identifier": "TestCmp",
                "newPage": false,
                "searchKey": "big.TestCmp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestCmp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestCmp(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestSet",
              "documentation": {
                "identifier": "TestSet",
                "newPage": false,
                "searchKey": "big.TestSet",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSet(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSet(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testFunNN",
              "documentation": {
                "identifier": "testFunNN",
                "newPage": false,
                "searchKey": "big.testFunNN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testFunNN(t *testing.T, msg string, f funNN, a argNN)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testFunNN(t *testing.T, msg string, f funNN, a argNN)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFunNN",
              "documentation": {
                "identifier": "TestFunNN",
                "newPage": false,
                "searchKey": "big.TestFunNN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFunNN(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFunNN(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestMulRangeN",
              "documentation": {
                "identifier": "TestMulRangeN",
                "newPage": false,
                "searchKey": "big.TestMulRangeN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMulRangeN(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMulRangeN(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#allocBytes",
              "documentation": {
                "identifier": "allocBytes",
                "newPage": false,
                "searchKey": "big.allocBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func allocBytes(f func()) uint64"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc allocBytes(f func()) uint64\n```\n\nallocBytes returns the number of bytes allocated by invoking f. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestMulUnbalanced",
              "documentation": {
                "identifier": "TestMulUnbalanced",
                "newPage": false,
                "searchKey": "big.TestMulUnbalanced",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMulUnbalanced(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMulUnbalanced(t *testing.T)\n```\n\nTestMulUnbalanced tests that multiplying numbers of different lengths does not cause deep recursion and in turn allocate too much memory. Test case for issue 3807. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkMul",
              "documentation": {
                "identifier": "BenchmarkMul",
                "newPage": false,
                "searchKey": "big.BenchmarkMul",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkMul(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkMul(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#benchmarkNatMul",
              "documentation": {
                "identifier": "benchmarkNatMul",
                "newPage": false,
                "searchKey": "big.benchmarkNatMul",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func benchmarkNatMul(b *testing.B, nwords int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc benchmarkNatMul(b *testing.B, nwords int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkNatMul",
              "documentation": {
                "identifier": "BenchmarkNatMul",
                "newPage": false,
                "searchKey": "big.BenchmarkNatMul",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkNatMul(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkNatMul(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestNLZ",
              "documentation": {
                "identifier": "TestNLZ",
                "newPage": false,
                "searchKey": "big.TestNLZ",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNLZ(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNLZ(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestShiftLeft",
              "documentation": {
                "identifier": "TestShiftLeft",
                "newPage": false,
                "searchKey": "big.TestShiftLeft",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestShiftLeft(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestShiftLeft(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestShiftRight",
              "documentation": {
                "identifier": "TestShiftRight",
                "newPage": false,
                "searchKey": "big.TestShiftRight",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestShiftRight(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestShiftRight(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkZeroShifts",
              "documentation": {
                "identifier": "BenchmarkZeroShifts",
                "newPage": false,
                "searchKey": "big.BenchmarkZeroShifts",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkZeroShifts(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkZeroShifts(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#runModWTests",
              "documentation": {
                "identifier": "runModWTests",
                "newPage": false,
                "searchKey": "big.runModWTests",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func runModWTests(t *testing.T, tests []modWTest)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc runModWTests(t *testing.T, tests []modWTest)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestModW",
              "documentation": {
                "identifier": "TestModW",
                "newPage": false,
                "searchKey": "big.TestModW",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestModW(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestModW(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestMontgomery",
              "documentation": {
                "identifier": "TestMontgomery",
                "newPage": false,
                "searchKey": "big.TestMontgomery",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMontgomery(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMontgomery(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestExpNN",
              "documentation": {
                "identifier": "TestExpNN",
                "newPage": false,
                "searchKey": "big.TestExpNN",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestExpNN(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestExpNN(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkExp3Power",
              "documentation": {
                "identifier": "BenchmarkExp3Power",
                "newPage": false,
                "searchKey": "big.BenchmarkExp3Power",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkExp3Power(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkExp3Power(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFibo",
              "documentation": {
                "identifier": "TestFibo",
                "newPage": false,
                "searchKey": "big.TestFibo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFibo(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFibo(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkFibo",
              "documentation": {
                "identifier": "BenchmarkFibo",
                "newPage": false,
                "searchKey": "big.BenchmarkFibo",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkFibo(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkFibo(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestBit",
              "documentation": {
                "identifier": "TestBit",
                "newPage": false,
                "searchKey": "big.TestBit",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestBit(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestBit(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestSticky",
              "documentation": {
                "identifier": "TestSticky",
                "newPage": false,
                "searchKey": "big.TestSticky",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSticky(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSticky(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testSqr",
              "documentation": {
                "identifier": "testSqr",
                "newPage": false,
                "searchKey": "big.testSqr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testSqr(t *testing.T, x nat)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testSqr(t *testing.T, x nat)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestSqr",
              "documentation": {
                "identifier": "TestSqr",
                "newPage": false,
                "searchKey": "big.TestSqr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSqr(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSqr(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#benchmarkNatSqr",
              "documentation": {
                "identifier": "benchmarkNatSqr",
                "newPage": false,
                "searchKey": "big.benchmarkNatSqr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func benchmarkNatSqr(b *testing.B, nwords int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc benchmarkNatSqr(b *testing.B, nwords int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkNatSqr",
              "documentation": {
                "identifier": "BenchmarkNatSqr",
                "newPage": false,
                "searchKey": "big.BenchmarkNatSqr",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkNatSqr(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkNatSqr(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkNatSetBytes",
              "documentation": {
                "identifier": "BenchmarkNatSetBytes",
                "newPage": false,
                "searchKey": "big.BenchmarkNatSetBytes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkNatSetBytes(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkNatSetBytes(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestNatDiv",
              "documentation": {
                "identifier": "TestNatDiv",
                "newPage": false,
                "searchKey": "big.TestNatDiv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestNatDiv(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestNatDiv(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue37499",
              "documentation": {
                "identifier": "TestIssue37499",
                "newPage": false,
                "searchKey": "big.TestIssue37499",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue37499(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue37499(t *testing.T)\n```\n\nTestIssue37499 triggers the edge case of divBasic where the inaccurate estimate of the first word's quotient happens at the very beginning of the loop. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue42552",
              "documentation": {
                "identifier": "TestIssue42552",
                "newPage": false,
                "searchKey": "big.TestIssue42552",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue42552(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue42552(t *testing.T)\n```\n\nTestIssue42552 triggers an edge case of recursive division where the first division loop is never entered, and correcting the remainder takes exactly two iterations in the final loop. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestMaxBase",
              "documentation": {
                "identifier": "TestMaxBase",
                "newPage": false,
                "searchKey": "big.TestMaxBase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMaxBase(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMaxBase(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#log2",
              "documentation": {
                "identifier": "log2",
                "newPage": false,
                "searchKey": "big.log2",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func log2(x Word) int"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc log2(x Word) int\n```\n\nlog2 computes the integer binary logarithm of x. The result is the integer n for which 2^n <= x < 2^(n+1). If x == 0, the result is -1. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#itoa",
              "documentation": {
                "identifier": "itoa",
                "newPage": false,
                "searchKey": "big.itoa",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func itoa(x nat, base int) []byte"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc itoa(x nat, base int) []byte\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestString",
              "documentation": {
                "identifier": "TestString",
                "newPage": false,
                "searchKey": "big.TestString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestScanBase",
              "documentation": {
                "identifier": "TestScanBase",
                "newPage": false,
                "searchKey": "big.TestScanBase",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestScanBase(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestScanBase(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestScanPi",
              "documentation": {
                "identifier": "TestScanPi",
                "newPage": false,
                "searchKey": "big.TestScanPi",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestScanPi(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestScanPi(t *testing.T)\n```\n\nTest case for BenchmarkScanPi. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestScanPiParallel",
              "documentation": {
                "identifier": "TestScanPiParallel",
                "newPage": false,
                "searchKey": "big.TestScanPiParallel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestScanPiParallel(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestScanPiParallel(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkScanPi",
              "documentation": {
                "identifier": "BenchmarkScanPi",
                "newPage": false,
                "searchKey": "big.BenchmarkScanPi",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkScanPi(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkScanPi(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkStringPiParallel",
              "documentation": {
                "identifier": "BenchmarkStringPiParallel",
                "newPage": false,
                "searchKey": "big.BenchmarkStringPiParallel",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkStringPiParallel(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkStringPiParallel(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkScan",
              "documentation": {
                "identifier": "BenchmarkScan",
                "newPage": false,
                "searchKey": "big.BenchmarkScan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkScan(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkScan(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkString",
              "documentation": {
                "identifier": "BenchmarkString",
                "newPage": false,
                "searchKey": "big.BenchmarkString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkString(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkString(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkLeafSize",
              "documentation": {
                "identifier": "BenchmarkLeafSize",
                "newPage": false,
                "searchKey": "big.BenchmarkLeafSize",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkLeafSize(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkLeafSize(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#LeafSizeHelper",
              "documentation": {
                "identifier": "LeafSizeHelper",
                "newPage": false,
                "searchKey": "big.LeafSizeHelper",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func LeafSizeHelper(b *testing.B, base, size int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc LeafSizeHelper(b *testing.B, base, size int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#resetTable",
              "documentation": {
                "identifier": "resetTable",
                "newPage": false,
                "searchKey": "big.resetTable",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func resetTable(table []divisor)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc resetTable(table []divisor)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestStringPowers",
              "documentation": {
                "identifier": "TestStringPowers",
                "newPage": false,
                "searchKey": "big.TestStringPowers",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestStringPowers(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestStringPowers(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#cutSpace",
              "documentation": {
                "identifier": "cutSpace",
                "newPage": false,
                "searchKey": "big.cutSpace",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func cutSpace(r rune) rune"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc cutSpace(r rune) rune\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestProbablyPrime",
              "documentation": {
                "identifier": "TestProbablyPrime",
                "newPage": false,
                "searchKey": "big.TestProbablyPrime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestProbablyPrime(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestProbablyPrime(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkProbablyPrime",
              "documentation": {
                "identifier": "BenchmarkProbablyPrime",
                "newPage": false,
                "searchKey": "big.BenchmarkProbablyPrime",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkProbablyPrime(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkProbablyPrime(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestMillerRabinPseudoprimes",
              "documentation": {
                "identifier": "TestMillerRabinPseudoprimes",
                "newPage": false,
                "searchKey": "big.TestMillerRabinPseudoprimes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestMillerRabinPseudoprimes(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestMillerRabinPseudoprimes(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestLucasPseudoprimes",
              "documentation": {
                "identifier": "TestLucasPseudoprimes",
                "newPage": false,
                "searchKey": "big.TestLucasPseudoprimes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestLucasPseudoprimes(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestLucasPseudoprimes(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testPseudoprimes",
              "documentation": {
                "identifier": "testPseudoprimes",
                "newPage": false,
                "searchKey": "big.testPseudoprimes",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testPseudoprimes(t *testing.T, name string, cond func(nat) bool, want []int)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testPseudoprimes(t *testing.T, name string, cond func(nat) bool, want []int)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestZeroRat",
              "documentation": {
                "identifier": "TestZeroRat",
                "newPage": false,
                "searchKey": "big.TestZeroRat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestZeroRat(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestZeroRat(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatSign",
              "documentation": {
                "identifier": "TestRatSign",
                "newPage": false,
                "searchKey": "big.TestRatSign",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatSign(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatSign(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatCmp",
              "documentation": {
                "identifier": "TestRatCmp",
                "newPage": false,
                "searchKey": "big.TestRatCmp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatCmp(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatCmp(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIsInt",
              "documentation": {
                "identifier": "TestIsInt",
                "newPage": false,
                "searchKey": "big.TestIsInt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIsInt(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIsInt(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatAbs",
              "documentation": {
                "identifier": "TestRatAbs",
                "newPage": false,
                "searchKey": "big.TestRatAbs",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatAbs(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatAbs(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatNeg",
              "documentation": {
                "identifier": "TestRatNeg",
                "newPage": false,
                "searchKey": "big.TestRatNeg",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatNeg(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatNeg(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatInv",
              "documentation": {
                "identifier": "TestRatInv",
                "newPage": false,
                "searchKey": "big.TestRatInv",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatInv(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatInv(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#testRatBin",
              "documentation": {
                "identifier": "testRatBin",
                "newPage": false,
                "searchKey": "big.testRatBin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func testRatBin(t *testing.T, i int, name string, f ratBinFun, a ratBinArg)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc testRatBin(t *testing.T, i int, name string, f ratBinFun, a ratBinArg)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatBin",
              "documentation": {
                "identifier": "TestRatBin",
                "newPage": false,
                "searchKey": "big.TestRatBin",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatBin(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatBin(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue820",
              "documentation": {
                "identifier": "TestIssue820",
                "newPage": false,
                "searchKey": "big.TestIssue820",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue820(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue820(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatSetFrac64Rat",
              "documentation": {
                "identifier": "TestRatSetFrac64Rat",
                "newPage": false,
                "searchKey": "big.TestRatSetFrac64Rat",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatSetFrac64Rat(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatSetFrac64Rat(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue2379",
              "documentation": {
                "identifier": "TestIssue2379",
                "newPage": false,
                "searchKey": "big.TestIssue2379",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue2379(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue2379(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue3521",
              "documentation": {
                "identifier": "TestIssue3521",
                "newPage": false,
                "searchKey": "big.TestIssue3521",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue3521(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue3521(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloat32Distribution",
              "documentation": {
                "identifier": "TestFloat32Distribution",
                "newPage": false,
                "searchKey": "big.TestFloat32Distribution",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloat32Distribution(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloat32Distribution(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloat64Distribution",
              "documentation": {
                "identifier": "TestFloat64Distribution",
                "newPage": false,
                "searchKey": "big.TestFloat64Distribution",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloat64Distribution(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloat64Distribution(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestSetFloat64NonFinite",
              "documentation": {
                "identifier": "TestSetFloat64NonFinite",
                "newPage": false,
                "searchKey": "big.TestSetFloat64NonFinite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestSetFloat64NonFinite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestSetFloat64NonFinite(t *testing.T)\n```\n\nTestSetFloat64NonFinite checks that SetFloat64 of a non-finite value returns nil. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#checkNonLossyRoundtrip32",
              "documentation": {
                "identifier": "checkNonLossyRoundtrip32",
                "newPage": false,
                "searchKey": "big.checkNonLossyRoundtrip32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkNonLossyRoundtrip32(t *testing.T, f float32)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkNonLossyRoundtrip32(t *testing.T, f float32)\n```\n\ncheckNonLossyRoundtrip32 checks that a float->Rat->float roundtrip is non-lossy for finite f. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#checkNonLossyRoundtrip64",
              "documentation": {
                "identifier": "checkNonLossyRoundtrip64",
                "newPage": false,
                "searchKey": "big.checkNonLossyRoundtrip64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkNonLossyRoundtrip64(t *testing.T, f float64)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkNonLossyRoundtrip64(t *testing.T, f float64)\n```\n\ncheckNonLossyRoundtrip64 checks that a float->Rat->float roundtrip is non-lossy for finite f. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#checkIsBestApprox32",
              "documentation": {
                "identifier": "checkIsBestApprox32",
                "newPage": false,
                "searchKey": "big.checkIsBestApprox32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkIsBestApprox32(t *testing.T, f float32, r *Rat) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkIsBestApprox32(t *testing.T, f float32, r *Rat) bool\n```\n\ncheckIsBestApprox32 checks that f is the best possible float32 approximation of r. Returns true on success. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#checkIsBestApprox64",
              "documentation": {
                "identifier": "checkIsBestApprox64",
                "newPage": false,
                "searchKey": "big.checkIsBestApprox64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func checkIsBestApprox64(t *testing.T, f float64, r *Rat) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc checkIsBestApprox64(t *testing.T, f float64, r *Rat) bool\n```\n\ncheckIsBestApprox64 checks that f is the best possible float64 approximation of r. Returns true on success. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#isEven32",
              "documentation": {
                "identifier": "isEven32",
                "newPage": false,
                "searchKey": "big.isEven32",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isEven32(f float32) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isEven32(f float32) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#isEven64",
              "documentation": {
                "identifier": "isEven64",
                "newPage": false,
                "searchKey": "big.isEven64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isEven64(f float64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isEven64(f float64) bool\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIsFinite",
              "documentation": {
                "identifier": "TestIsFinite",
                "newPage": false,
                "searchKey": "big.TestIsFinite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIsFinite(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIsFinite(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatSetInt64",
              "documentation": {
                "identifier": "TestRatSetInt64",
                "newPage": false,
                "searchKey": "big.TestRatSetInt64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatSetInt64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatSetInt64(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatSetUint64",
              "documentation": {
                "identifier": "TestRatSetUint64",
                "newPage": false,
                "searchKey": "big.TestRatSetUint64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatSetUint64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatSetUint64(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkRatCmp",
              "documentation": {
                "identifier": "BenchmarkRatCmp",
                "newPage": false,
                "searchKey": "big.BenchmarkRatCmp",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkRatCmp(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkRatCmp(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue34919",
              "documentation": {
                "identifier": "TestIssue34919",
                "newPage": false,
                "searchKey": "big.TestIssue34919",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue34919(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue34919(t *testing.T)\n```\n\nTestIssue34919 verifies that a Rat's denominator is not modified when simply accessing the Rat value. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestScanExponent",
              "documentation": {
                "identifier": "TestScanExponent",
                "newPage": false,
                "searchKey": "big.TestScanExponent",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestScanExponent(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestScanExponent(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatSetString",
              "documentation": {
                "identifier": "TestRatSetString",
                "newPage": false,
                "searchKey": "big.TestRatSetString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatSetString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatSetString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatScan",
              "documentation": {
                "identifier": "TestRatScan",
                "newPage": false,
                "searchKey": "big.TestRatScan",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatScan(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatScan(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatString",
              "documentation": {
                "identifier": "TestFloatString",
                "newPage": false,
                "searchKey": "big.TestFloatString",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatString(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatString(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#isFinite",
              "documentation": {
                "identifier": "isFinite",
                "newPage": false,
                "searchKey": "big.isFinite",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func isFinite(f float64) bool"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc isFinite(f float64) bool\n```\n\nisFinite reports whether f represents a finite rational value. It is equivalent to !math.IsNan(f) && !math.IsInf(f, 0). \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloat32SpecialCases",
              "documentation": {
                "identifier": "TestFloat32SpecialCases",
                "newPage": false,
                "searchKey": "big.TestFloat32SpecialCases",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloat32SpecialCases(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloat32SpecialCases(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloat64SpecialCases",
              "documentation": {
                "identifier": "TestFloat64SpecialCases",
                "newPage": false,
                "searchKey": "big.TestFloat64SpecialCases",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloat64SpecialCases(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloat64SpecialCases(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue31184",
              "documentation": {
                "identifier": "TestIssue31184",
                "newPage": false,
                "searchKey": "big.TestIssue31184",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue31184(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue31184(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestIssue45910",
              "documentation": {
                "identifier": "TestIssue45910",
                "newPage": false,
                "searchKey": "big.TestIssue45910",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestIssue45910(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestIssue45910(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatGobEncoding",
              "documentation": {
                "identifier": "TestRatGobEncoding",
                "newPage": false,
                "searchKey": "big.TestRatGobEncoding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatGobEncoding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatGobEncoding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestGobEncodingNilRatInSlice",
              "documentation": {
                "identifier": "TestGobEncodingNilRatInSlice",
                "newPage": false,
                "searchKey": "big.TestGobEncodingNilRatInSlice",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestGobEncodingNilRatInSlice(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestGobEncodingNilRatInSlice(t *testing.T)\n```\n\nSending a nil Rat pointer (inside a slice) on a round trip through gob should yield a zero. TODO: top-level nils. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatJSONEncoding",
              "documentation": {
                "identifier": "TestRatJSONEncoding",
                "newPage": false,
                "searchKey": "big.TestRatJSONEncoding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatJSONEncoding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatJSONEncoding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestRatXMLEncoding",
              "documentation": {
                "identifier": "TestRatXMLEncoding",
                "newPage": false,
                "searchKey": "big.TestRatXMLEncoding",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestRatXMLEncoding(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestRatXMLEncoding(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSqrt64",
              "documentation": {
                "identifier": "TestFloatSqrt64",
                "newPage": false,
                "searchKey": "big.TestFloatSqrt64",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSqrt64(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSqrt64(t *testing.T)\n```\n\nTestFloatSqrt64 tests that Float.Sqrt of numbers with 53bit mantissa behaves like float math.Sqrt. \n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSqrt",
              "documentation": {
                "identifier": "TestFloatSqrt",
                "newPage": false,
                "searchKey": "big.TestFloatSqrt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSqrt(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSqrt(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#TestFloatSqrtSpecial",
              "documentation": {
                "identifier": "TestFloatSqrtSpecial",
                "newPage": false,
                "searchKey": "big.TestFloatSqrtSpecial",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func TestFloatSqrtSpecial(t *testing.T)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc TestFloatSqrtSpecial(t *testing.T)\n```\n\n"
              },
              "children": null
            }
          },
          {
            "node": {
              "pathID": "/std/math/big#BenchmarkFloatSqrt",
              "documentation": {
                "identifier": "BenchmarkFloatSqrt",
                "newPage": false,
                "searchKey": "big.BenchmarkFloatSqrt",
                "tags": null
              },
              "label": {
                "kind": "plaintext",
                "value": "func BenchmarkFloatSqrt(b *testing.B)"
              },
              "detail": {
                "kind": "markdown",
                "value": "```Go\nfunc BenchmarkFloatSqrt(b *testing.B)\n```\n\n"
              },
              "children": null
            }
          }
        ]
      }
    }
  ]
}
